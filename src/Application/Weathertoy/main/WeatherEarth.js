(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.WeatherEarth = {}));
}(this, (function (exports) { 'use strict';

    function Config() {

    }

    Config.showBackground = false;
    Config.font = '14px sans-serif';
    Config.outlineWidth = 4.0;
    Config.pixelSize = 6;
    Config.lineWidth = 8;
    Config.WeatherDataVersion = 1.0;
    Config.WeatherDataTemplateUrl = '../../OCserver/p/OC?method=nc&param={0}%3B{1}%3B{2}%3B{3}';
    Config.AxesFloorsRatio = [0.0, 0.1, 0.4, 0.7, 1.0];
    Config.AxesLineWidth = 2.0;
    Config.CreateTransferTextureFunction = undefined;

    Config.DetectiveLineOptions = {
        line: {
            _24小时警戒线: {
                positions: [[34, 127], [22, 127], [18, 119], [11, 119], [4.5, 113], [0, 105]],
                color: 'RGB(255.0, 255.0, 0.0)',
            },
            _48小时警戒线: {
                positions: [[34, 132], [15, 132], [0, 120], [0, 105]],
                color: 'RGB(0.0, 0.0, 255.0)',
            }
        },
        width: 2.0,
    };

    Config.init = function () {
        Config.pointColor = Cesium.Color.RED;
        Config.fillColor = Cesium.Color.WHITE;
        Config.outlineColor = Cesium.Color.BLACK;
        Config.backgroundColor = new Cesium.Color(0.165, 0.165, 0.165, 0.8);
    };

    function Directory(){

    }

    Directory.CesiumDir = '';

    function FrameListener(){

    }

    FrameListener.prototype.update = function(scene, time){
        
    };

    FrameListener.prototype.isDestroyed = function () {
        return false;
    };

    FrameListener.prototype.destroy = function () {
        return Cesium.destroyObject(this);
    };

    function FrameListenerManager(){
        this._frms = new Cesium.AssociativeArray();

    }

    FrameListenerManager.prototype.add = function (framelistener) {
        var id = Cesium.defined(framelistener.id) ? framelistener.id : framelistener.name;
        if (!Cesium.defined(id)) {
            framelistener.id = id = Cesium.createGuid();
        }  

        //var frm = this._frms.get(id);
        this._frms.set(id,framelistener);
    };


    FrameListenerManager.prototype.remove = function (id) {
        if (!Cesium.defined(id)) {
            return false;
        }
        
        var frm = this._frms.get(id);
        if (!Cesium.defined(frm)) {
            return false;
        }

        if (!this._frms.remove(id)) {
            return false;
        }

        return true;
    };

    FrameListenerManager.prototype.update = function(scene, time){
        var toRemoves = [];

        var i = 0;
        for(;i<this._frms.length;i++){
            var frm = this._frms._array[i];
            if(frm.isDestroyed()){
                toRemoves.push(frm);
            }
            else {
                frm.update(scene, time);
            }
        }

        i = 0;
        for(;i<toRemoves.length;i++){
            var frm = toRemoves[i];
            this.remove(frm.id);
        }
    };

    /*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    /* eslint-disable space-unary-ops */

    /* Public constants ==========================================================*/
    /* ===========================================================================*/


    //const Z_FILTERED          = 1;
    //const Z_HUFFMAN_ONLY      = 2;
    //const Z_RLE               = 3;
    const Z_FIXED$1               = 4;
    //const Z_DEFAULT_STRATEGY  = 0;

    /* Possible values of the data_type field (though see inflate()) */
    const Z_BINARY              = 0;
    const Z_TEXT                = 1;
    //const Z_ASCII             = 1; // = Z_TEXT
    const Z_UNKNOWN$1             = 2;

    /*============================================================================*/


    function zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

    // From zutil.h

    const STORED_BLOCK = 0;
    const STATIC_TREES = 1;
    const DYN_TREES    = 2;
    /* The three kinds of block type */

    const MIN_MATCH$1    = 3;
    const MAX_MATCH$1    = 258;
    /* The minimum and maximum match lengths */

    // From deflate.h
    /* ===========================================================================
     * Internal compression state.
     */

    const LENGTH_CODES$1  = 29;
    /* number of length codes, not counting the special END_BLOCK code */

    const LITERALS$1      = 256;
    /* number of literal bytes 0..255 */

    const L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;
    /* number of Literal or Length codes, including the END_BLOCK code */

    const D_CODES$1       = 30;
    /* number of distance codes */

    const BL_CODES$1      = 19;
    /* number of codes used to transfer the bit lengths */

    const HEAP_SIZE$1     = 2 * L_CODES$1 + 1;
    /* maximum heap size */

    const MAX_BITS$1      = 15;
    /* All codes must not exceed MAX_BITS bits */

    const Buf_size      = 16;
    /* size of bit buffer in bi_buf */


    /* ===========================================================================
     * Constants
     */

    const MAX_BL_BITS = 7;
    /* Bit length codes must not exceed MAX_BL_BITS bits */

    const END_BLOCK   = 256;
    /* end of block literal code */

    const REP_3_6     = 16;
    /* repeat previous bit length 3-6 times (2 bits of repeat count) */

    const REPZ_3_10   = 17;
    /* repeat a zero length 3-10 times  (3 bits of repeat count) */

    const REPZ_11_138 = 18;
    /* repeat a zero length 11-138 times  (7 bits of repeat count) */

    /* eslint-disable comma-spacing,array-bracket-spacing */
    const extra_lbits =   /* extra bits for each length code */
      new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

    const extra_dbits =   /* extra bits for each distance code */
      new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

    const extra_blbits =  /* extra bits for each bit length code */
      new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

    const bl_order =
      new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
    /* eslint-enable comma-spacing,array-bracket-spacing */

    /* The lengths of the bit length codes are sent in order of decreasing
     * probability, to avoid transmitting the lengths for unused bit length codes.
     */

    /* ===========================================================================
     * Local data. These are initialized only once.
     */

    // We pre-fill arrays with 0 to avoid uninitialized gaps

    const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

    // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
    const static_ltree  = new Array((L_CODES$1 + 2) * 2);
    zero$1(static_ltree);
    /* The static literal tree. Since the bit lengths are imposed, there is no
     * need for the L_CODES extra codes used during heap construction. However
     * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
     * below).
     */

    const static_dtree  = new Array(D_CODES$1 * 2);
    zero$1(static_dtree);
    /* The static distance tree. (Actually a trivial tree since all codes use
     * 5 bits.)
     */

    const _dist_code    = new Array(DIST_CODE_LEN);
    zero$1(_dist_code);
    /* Distance codes. The first 256 values correspond to the distances
     * 3 .. 258, the last 256 values correspond to the top 8 bits of
     * the 15 bit distances.
     */

    const _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
    zero$1(_length_code);
    /* length code for each normalized match length (0 == MIN_MATCH) */

    const base_length   = new Array(LENGTH_CODES$1);
    zero$1(base_length);
    /* First normalized length for each code (0 = MIN_MATCH) */

    const base_dist     = new Array(D_CODES$1);
    zero$1(base_dist);
    /* First normalized distance for each code (0 = distance of 1) */


    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

      this.static_tree  = static_tree;  /* static tree or NULL */
      this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
      this.extra_base   = extra_base;   /* base index for extra_bits */
      this.elems        = elems;        /* max number of elements in the tree */
      this.max_length   = max_length;   /* max bit length for the codes */

      // show if `static_tree` has data or dummy - needed for monomorphic objects
      this.has_stree    = static_tree && static_tree.length;
    }


    let static_l_desc;
    let static_d_desc;
    let static_bl_desc;


    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;     /* the dynamic tree */
      this.max_code = 0;            /* largest code with non zero frequency */
      this.stat_desc = stat_desc;   /* the corresponding static tree */
    }



    const d_code = (dist) => {

      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };


    /* ===========================================================================
     * Output a short LSB first on the stream.
     * IN assertion: there is enough room in pendingBuf.
     */
    const put_short = (s, w) => {
    //    put_byte(s, (uch)((w) & 0xff));
    //    put_byte(s, (uch)((ush)(w) >> 8));
      s.pending_buf[s.pending++] = (w) & 0xff;
      s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
    };


    /* ===========================================================================
     * Send a value on a given number of bits.
     * IN assertion: length <= 16 and value fits in length bits.
     */
    const send_bits = (s, value, length) => {

      if (s.bi_valid > (Buf_size - length)) {
        s.bi_buf |= (value << s.bi_valid) & 0xffff;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> (Buf_size - s.bi_valid);
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= (value << s.bi_valid) & 0xffff;
        s.bi_valid += length;
      }
    };


    const send_code = (s, c, tree) => {

      send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
    };


    /* ===========================================================================
     * Reverse the first len bits of a code, using straightforward code (a faster
     * method would use a table)
     * IN assertion: 1 <= len <= 15
     */
    const bi_reverse = (code, len) => {

      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };


    /* ===========================================================================
     * Flush the bit buffer, keeping at most 7 bits in it.
     */
    const bi_flush = (s) => {

      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;

      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 0xff;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    };


    /* ===========================================================================
     * Compute the optimal bit lengths for a tree and update the total bit length
     * for the current block.
     * IN assertion: the fields freq and dad are set, heap[heap_max] and
     *    above are the tree nodes sorted by increasing frequency.
     * OUT assertions: the field len is set to the optimal bit length, the
     *     array bl_count contains the frequencies for each bit length.
     *     The length opt_len is updated; static_len is also updated if stree is
     *     not null.
     */
    const gen_bitlen = (s, desc) =>
    //    deflate_state *s;
    //    tree_desc *desc;    /* the tree descriptor */
    {
      const tree            = desc.dyn_tree;
      const max_code        = desc.max_code;
      const stree           = desc.stat_desc.static_tree;
      const has_stree       = desc.stat_desc.has_stree;
      const extra           = desc.stat_desc.extra_bits;
      const base            = desc.stat_desc.extra_base;
      const max_length      = desc.stat_desc.max_length;
      let h;              /* heap index */
      let n, m;           /* iterate over the tree elements */
      let bits;           /* bit length */
      let xbits;          /* extra bits */
      let f;              /* frequency */
      let overflow = 0;   /* number of elements with bit length too large */

      for (bits = 0; bits <= MAX_BITS$1; bits++) {
        s.bl_count[bits] = 0;
      }

      /* In a first pass, compute the optimal bit lengths (which may
       * overflow in the case of the bit length tree).
       */
      tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

      for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1]/*.Len*/ = bits;
        /* We overwrite tree[n].Dad which is no longer needed */

        if (n > max_code) { continue; } /* not a leaf node */

        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2]/*.Freq*/;
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
        }
      }
      if (overflow === 0) { return; }

      // Trace((stderr,"\nbit length overflow\n"));
      /* This happens for example on obj2 and pic of the Calgary corpus */

      /* Find the first bit length which could increase: */
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) { bits--; }
        s.bl_count[bits]--;      /* move one leaf down the tree */
        s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
        s.bl_count[max_length]--;
        /* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */
        overflow -= 2;
      } while (overflow > 0);

      /* Now recompute all bit lengths, scanning in increasing frequency.
       * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
       * lengths instead of fixing only the wrong ones. This idea is taken
       * from 'ar' written by Haruhiko Okumura.)
       */
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) { continue; }
          if (tree[m * 2 + 1]/*.Len*/ !== bits) {
            // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
            s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
            tree[m * 2 + 1]/*.Len*/ = bits;
          }
          n--;
        }
      }
    };


    /* ===========================================================================
     * Generate the codes for a given tree and bit counts (which need not be
     * optimal).
     * IN assertion: the array bl_count contains the bit length statistics for
     * the given tree and the field len is set for all tree elements.
     * OUT assertion: the field code is set for all tree elements of non
     *     zero code length.
     */
    const gen_codes = (tree, max_code, bl_count) =>
    //    ct_data *tree;             /* the tree to decorate */
    //    int max_code;              /* largest code with non zero frequency */
    //    ushf *bl_count;            /* number of codes at each bit length */
    {
      const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */
      let code = 0;              /* running code value */
      let bits;                  /* bit index */
      let n;                     /* code index */

      /* The distribution counts are first used to generate the code values
       * without bit reversal.
       */
      for (bits = 1; bits <= MAX_BITS$1; bits++) {
        next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
      }
      /* Check that the bit counts in bl_count are consistent. The last code
       * must be all ones.
       */
      //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
      //        "inconsistent bit counts");
      //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

      for (n = 0;  n <= max_code; n++) {
        let len = tree[n * 2 + 1]/*.Len*/;
        if (len === 0) { continue; }
        /* Now reverse the bits */
        tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

        //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
        //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
      }
    };


    /* ===========================================================================
     * Initialize the various 'constant' tables.
     */
    const tr_static_init = () => {

      let n;        /* iterates over tree elements */
      let bits;     /* bit counter */
      let length;   /* length value */
      let code;     /* code value */
      let dist;     /* distance index */
      const bl_count = new Array(MAX_BITS$1 + 1);
      /* number of codes at each bit length for an optimal tree */

      // do check in _tr_init()
      //if (static_init_done) return;

      /* For some embedded targets, global variables are not initialized: */
    /*#ifdef NO_INIT_GLOBAL_POINTERS
      static_l_desc.static_tree = static_ltree;
      static_l_desc.extra_bits = extra_lbits;
      static_d_desc.static_tree = static_dtree;
      static_d_desc.extra_bits = extra_dbits;
      static_bl_desc.extra_bits = extra_blbits;
    #endif*/

      /* Initialize the mapping length (0..255) -> length code (0..28) */
      length = 0;
      for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < (1 << extra_lbits[code]); n++) {
          _length_code[length++] = code;
        }
      }
      //Assert (length == 256, "tr_static_init: length != 256");
      /* Note that the length 255 (match length 258) can be represented
       * in two different ways: code 284 + 5 bits or code 285, so we
       * overwrite length_code[255] to use the best encoding:
       */
      _length_code[length - 1] = code;

      /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < (1 << extra_dbits[code]); n++) {
          _dist_code[dist++] = code;
        }
      }
      //Assert (dist == 256, "tr_static_init: dist != 256");
      dist >>= 7; /* from now on, all distances are divided by 128 */
      for (; code < D_CODES$1; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      //Assert (dist == 256, "tr_static_init: 256+dist != 512");

      /* Construct the codes of the static literal tree */
      for (bits = 0; bits <= MAX_BITS$1; bits++) {
        bl_count[bits] = 0;
      }

      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1]/*.Len*/ = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1]/*.Len*/ = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1]/*.Len*/ = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1]/*.Len*/ = 8;
        n++;
        bl_count[8]++;
      }
      /* Codes 286 and 287 do not exist, but we must include them in the
       * tree construction to get a canonical Huffman tree (longest code
       * all ones)
       */
      gen_codes(static_ltree, L_CODES$1 + 1, bl_count);

      /* The static distance tree is trivial: */
      for (n = 0; n < D_CODES$1; n++) {
        static_dtree[n * 2 + 1]/*.Len*/ = 5;
        static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
      }

      // Now data ready and we can init static trees
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);

      //static_init_done = true;
    };


    /* ===========================================================================
     * Initialize a new block.
     */
    const init_block = (s) => {

      let n; /* iterates over tree elements */

      /* Initialize the trees. */
      for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
      for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
      for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

      s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    };


    /* ===========================================================================
     * Flush the bit buffer and align the output on a byte boundary
     */
    const bi_windup = (s) =>
    {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        //put_byte(s, (Byte)s->bi_buf);
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    };

    /* ===========================================================================
     * Copy a stored block, storing first the length and its
     * one's complement if requested.
     */
    const copy_block = (s, buf, len, header) =>
    //DeflateState *s;
    //charf    *buf;    /* the input data */
    //unsigned len;     /* its length */
    //int      header;  /* true if block header must be written */
    {
      bi_windup(s);        /* align on byte boundary */

      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
    //  while (len--) {
    //    put_byte(s, *buf++);
    //  }
      s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
      s.pending += len;
    };

    /* ===========================================================================
     * Compares to subtrees, using the tree depth as tie breaker when
     * the subtrees have equal frequency. This minimizes the worst case length.
     */
    const smaller = (tree, n, m, depth) => {

      const _n2 = n * 2;
      const _m2 = m * 2;
      return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
             (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
    };

    /* ===========================================================================
     * Restore the heap property by moving down the tree starting at node k,
     * exchanging a node with the smallest of its two sons if necessary, stopping
     * when the heap property is re-established (each father smaller than its
     * two sons).
     */
    const pqdownheap = (s, tree, k) =>
    //    deflate_state *s;
    //    ct_data *tree;  /* the tree to restore */
    //    int k;               /* node to move down */
    {
      const v = s.heap[k];
      let j = k << 1;  /* left son of k */
      while (j <= s.heap_len) {
        /* Set j to the smallest of the two sons: */
        if (j < s.heap_len &&
          smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        /* Exit if v is smaller than both sons */
        if (smaller(tree, v, s.heap[j], s.depth)) { break; }

        /* Exchange v with the smallest son */
        s.heap[k] = s.heap[j];
        k = j;

        /* And continue down the tree, setting j to the left son of k */
        j <<= 1;
      }
      s.heap[k] = v;
    };


    // inlined manually
    // const SMALLEST = 1;

    /* ===========================================================================
     * Send the block data compressed using the given Huffman trees
     */
    const compress_block = (s, ltree, dtree) =>
    //    deflate_state *s;
    //    const ct_data *ltree; /* literal tree */
    //    const ct_data *dtree; /* distance tree */
    {
      let dist;           /* distance of matched string */
      let lc;             /* match length or unmatched char (if dist == 0) */
      let lx = 0;         /* running index in l_buf */
      let code;           /* the code to send */
      let extra;          /* number of extra bits to send */

      if (s.last_lit !== 0) {
        do {
          dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
          lc = s.pending_buf[s.l_buf + lx];
          lx++;

          if (dist === 0) {
            send_code(s, lc, ltree); /* send a literal byte */
            //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
          } else {
            /* Here, lc is the match length - MIN_MATCH */
            code = _length_code[lc];
            send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);       /* send the extra length bits */
            }
            dist--; /* dist is now the match distance - 1 */
            code = d_code(dist);
            //Assert (code < D_CODES, "bad d_code");

            send_code(s, code, dtree);       /* send the distance code */
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);   /* send the extra distance bits */
            }
          } /* literal or match pair ? */

          /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
          //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
          //       "pendingBuf overflow");

        } while (lx < s.last_lit);
      }

      send_code(s, END_BLOCK, ltree);
    };


    /* ===========================================================================
     * Construct one Huffman tree and assigns the code bit strings and lengths.
     * Update the total bit length for the current block.
     * IN assertion: the field freq is set for all tree elements.
     * OUT assertions: the fields len and code are set to the optimal bit length
     *     and corresponding code. The length opt_len is updated; static_len is
     *     also updated if stree is not null. The field max_code is set.
     */
    const build_tree = (s, desc) =>
    //    deflate_state *s;
    //    tree_desc *desc; /* the tree descriptor */
    {
      const tree     = desc.dyn_tree;
      const stree    = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems    = desc.stat_desc.elems;
      let n, m;          /* iterate over heap elements */
      let max_code = -1; /* largest code with non zero frequency */
      let node;          /* new node being created */

      /* Construct the initial heap, with least frequent element in
       * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
       * heap[0] is not used.
       */
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE$1;

      for (n = 0; n < elems; n++) {
        if (tree[n * 2]/*.Freq*/ !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;

        } else {
          tree[n * 2 + 1]/*.Len*/ = 0;
        }
      }

      /* The pkzip format requires that at least one distance code exists,
       * and that at least one bit should be sent even if there is only one
       * possible code. So to avoid special checks later on we force at least
       * two codes of non zero frequency.
       */
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
        tree[node * 2]/*.Freq*/ = 1;
        s.depth[node] = 0;
        s.opt_len--;

        if (has_stree) {
          s.static_len -= stree[node * 2 + 1]/*.Len*/;
        }
        /* node is 0 or 1 so it does not have extra bits */
      }
      desc.max_code = max_code;

      /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
       * establish sub-heaps of increasing lengths:
       */
      for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

      /* Construct the Huffman tree by repeatedly combining the least two
       * frequent nodes.
       */
      node = elems;              /* next internal node of the tree */
      do {
        //pqremove(s, tree, n);  /* n = node of least frequency */
        /*** pqremove ***/
        n = s.heap[1/*SMALLEST*/];
        s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
        pqdownheap(s, tree, 1/*SMALLEST*/);
        /***/

        m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

        s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
        s.heap[--s.heap_max] = m;

        /* Create a new node father of n and m */
        tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

        /* and insert the new node in the heap */
        s.heap[1/*SMALLEST*/] = node++;
        pqdownheap(s, tree, 1/*SMALLEST*/);

      } while (s.heap_len >= 2);

      s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

      /* At this point, the fields freq and dad are set. We can now
       * generate the bit lengths.
       */
      gen_bitlen(s, desc);

      /* The field len is now set, we can generate the bit codes */
      gen_codes(tree, max_code, s.bl_count);
    };


    /* ===========================================================================
     * Scan a literal or distance tree to determine the frequencies of the codes
     * in the bit length tree.
     */
    const scan_tree = (s, tree, max_code) =>
    //    deflate_state *s;
    //    ct_data *tree;   /* the tree to be scanned */
    //    int max_code;    /* and its largest code of non zero frequency */
    {
      let n;                     /* iterates over all tree elements */
      let prevlen = -1;          /* last emitted length */
      let curlen;                /* length of current code */

      let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

      let count = 0;             /* repeat count of the current code */
      let max_count = 7;         /* max repeat count */
      let min_count = 4;         /* min repeat count */

      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

        if (++count < max_count && curlen === nextlen) {
          continue;

        } else if (count < min_count) {
          s.bl_tree[curlen * 2]/*.Freq*/ += count;

        } else if (curlen !== 0) {

          if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
          s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

        } else {
          s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
        }

        count = 0;
        prevlen = curlen;

        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;

        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;

        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };


    /* ===========================================================================
     * Send a literal or distance tree in compressed form, using the codes in
     * bl_tree.
     */
    const send_tree = (s, tree, max_code) =>
    //    deflate_state *s;
    //    ct_data *tree; /* the tree to be scanned */
    //    int max_code;       /* and its largest code of non zero frequency */
    {
      let n;                     /* iterates over all tree elements */
      let prevlen = -1;          /* last emitted length */
      let curlen;                /* length of current code */

      let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

      let count = 0;             /* repeat count of the current code */
      let max_count = 7;         /* max repeat count */
      let min_count = 4;         /* min repeat count */

      /* tree[max_code+1].Len = -1; */  /* guard already set */
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }

      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

        if (++count < max_count && curlen === nextlen) {
          continue;

        } else if (count < min_count) {
          do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          //Assert(count >= 3 && count <= 6, " 3_6?");
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);

        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);

        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }

        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;

        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;

        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };


    /* ===========================================================================
     * Construct the Huffman tree for the bit lengths and return the index in
     * bl_order of the last bit length code to send.
     */
    const build_bl_tree = (s) => {

      let max_blindex;  /* index of last bit length code of non zero freq */

      /* Determine the bit length frequencies for literal and distance trees */
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

      /* Build the bit length tree: */
      build_tree(s, s.bl_desc);
      /* opt_len now includes the length of the tree representations, except
       * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
       */

      /* Determine the number of bit length codes to send. The pkzip format
       * requires that at least 4 bit length codes be sent. (appnote.txt says
       * 3 but the actual value used is 4.)
       */
      for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
          break;
        }
      }
      /* Update opt_len to include the bit length tree and counts */
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
      //        s->opt_len, s->static_len));

      return max_blindex;
    };


    /* ===========================================================================
     * Send the header for a block using dynamic Huffman trees: the counts, the
     * lengths of the bit length codes, the literal tree and the distance tree.
     * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
     */
    const send_all_trees = (s, lcodes, dcodes, blcodes) =>
    //    deflate_state *s;
    //    int lcodes, dcodes, blcodes; /* number of codes for each tree */
    {
      let rank;                    /* index in bl_order */

      //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
      //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
      //        "too many codes");
      //Tracev((stderr, "\nbl counts: "));
      send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
      send_bits(s, dcodes - 1,   5);
      send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
      for (rank = 0; rank < blcodes; rank++) {
        //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
      }
      //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

      send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
      //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

      send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
      //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
    };


    /* ===========================================================================
     * Check if the data type is TEXT or BINARY, using the following algorithm:
     * - TEXT if the two conditions below are satisfied:
     *    a) There are no non-portable control characters belonging to the
     *       "black list" (0..6, 14..25, 28..31).
     *    b) There is at least one printable character belonging to the
     *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
     * - BINARY otherwise.
     * - The following partially-portable control characters form a
     *   "gray list" that is ignored in this detection algorithm:
     *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
     * IN assertion: the fields Freq of dyn_ltree are set.
     */
    const detect_data_type = (s) => {
      /* black_mask is the bit mask of black-listed bytes
       * set bits 0..6, 14..25, and 28..31
       * 0xf3ffc07f = binary 11110011111111111100000001111111
       */
      let black_mask = 0xf3ffc07f;
      let n;

      /* Check for non-textual ("black-listed") bytes. */
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
          return Z_BINARY;
        }
      }

      /* Check for textual ("white-listed") bytes. */
      if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
          s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS$1; n++) {
        if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
          return Z_TEXT;
        }
      }

      /* There are no "black-listed" or "white-listed" bytes:
       * this stream either is empty or has tolerated ("gray-listed") bytes only.
       */
      return Z_BINARY;
    };


    let static_init_done = false;

    /* ===========================================================================
     * Initialize the tree data structures for a new zlib stream.
     */
    const _tr_init$1 = (s) =>
    {

      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }

      s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

      s.bi_buf = 0;
      s.bi_valid = 0;

      /* Initialize the first block of the first file: */
      init_block(s);
    };


    /* ===========================================================================
     * Send a stored block
     */
    const _tr_stored_block$1 = (s, buf, stored_len, last) =>
    //DeflateState *s;
    //charf *buf;       /* input block */
    //ulg stored_len;   /* length of input block */
    //int last;         /* one if this is the last block for a file */
    {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
      copy_block(s, buf, stored_len, true); /* with header */
    };


    /* ===========================================================================
     * Send one empty static block to give enough lookahead for inflate.
     * This takes 10 bits, of which 7 may remain in the bit buffer.
     */
    const _tr_align$1 = (s) => {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    };


    /* ===========================================================================
     * Determine the best encoding for the current block: dynamic trees, static
     * trees or store, and output the encoded block to the zip file.
     */
    const _tr_flush_block$1 = (s, buf, stored_len, last) =>
    //DeflateState *s;
    //charf *buf;       /* input block, or NULL if too old */
    //ulg stored_len;   /* length of input block */
    //int last;         /* one if this is the last block for a file */
    {
      let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
      let max_blindex = 0;        /* index of last bit length code of non zero freq */

      /* Build the Huffman trees unless a stored block is forced */
      if (s.level > 0) {

        /* Check if the file is binary or text */
        if (s.strm.data_type === Z_UNKNOWN$1) {
          s.strm.data_type = detect_data_type(s);
        }

        /* Construct the literal and distance trees */
        build_tree(s, s.l_desc);
        // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
        //        s->static_len));

        build_tree(s, s.d_desc);
        // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
        //        s->static_len));
        /* At this point, opt_len and static_len are the total bit lengths of
         * the compressed block data, excluding the tree representations.
         */

        /* Build the bit length tree for the above two trees, and get the index
         * in bl_order of the last bit length code to send.
         */
        max_blindex = build_bl_tree(s);

        /* Determine the best encoding. Compute the block lengths in bytes. */
        opt_lenb = (s.opt_len + 3 + 7) >>> 3;
        static_lenb = (s.static_len + 3 + 7) >>> 3;

        // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
        //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
        //        s->last_lit));

        if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

      } else {
        // Assert(buf != (char*)0, "lost buf");
        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
      }

      if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
        /* 4: two words for the lengths */

        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
         * transform a block into a stored block.
         */
        _tr_stored_block$1(s, buf, stored_len, last);

      } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {

        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);

      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
      /* The above check is made mod 2^32, for files larger than 512 MB
       * and uLong implemented on 32 bits.
       */
      init_block(s);

      if (last) {
        bi_windup(s);
      }
      // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
      //       s->compressed_len-7*last));
    };

    /* ===========================================================================
     * Save the match info and tally the frequency counts. Return true if
     * the current block must be flushed.
     */
    const _tr_tally$1 = (s, dist, lc) =>
    //    deflate_state *s;
    //    unsigned dist;  /* distance of matched string */
    //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
    {
      //let out_length, in_length, dcode;

      s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

      s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
      s.last_lit++;

      if (dist === 0) {
        /* lc is the unmatched char */
        s.dyn_ltree[lc * 2]/*.Freq*/++;
      } else {
        s.matches++;
        /* Here, lc is the match length - MIN_MATCH */
        dist--;             /* dist = match distance - 1 */
        //Assert((ush)dist < (ush)MAX_DIST(s) &&
        //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
        //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

        s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;
        s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
      }

    // (!) This block is disabled in zlib defaults,
    // don't enable it for binary compatibility

    //#ifdef TRUNCATE_BLOCK
    //  /* Try to guess if it is profitable to stop the current block here */
    //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
    //    /* Compute an upper bound for the compressed length */
    //    out_length = s.last_lit*8;
    //    in_length = s.strstart - s.block_start;
    //
    //    for (dcode = 0; dcode < D_CODES; dcode++) {
    //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
    //    }
    //    out_length >>>= 3;
    //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
    //    //       s->last_lit, in_length, out_length,
    //    //       100L - out_length*100L/in_length));
    //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
    //      return true;
    //    }
    //  }
    //#endif

      return (s.last_lit === s.lit_bufsize - 1);
      /* We avoid equality with lit_bufsize because of wraparound at 64K
       * on 16 bit machines and because stored blocks are restricted to
       * 64K-1 bytes.
       */
    };

    var _tr_init_1  = _tr_init$1;
    var _tr_stored_block_1 = _tr_stored_block$1;
    var _tr_flush_block_1  = _tr_flush_block$1;
    var _tr_tally_1 = _tr_tally$1;
    var _tr_align_1 = _tr_align$1;

    var trees = {
    	_tr_init: _tr_init_1,
    	_tr_stored_block: _tr_stored_block_1,
    	_tr_flush_block: _tr_flush_block_1,
    	_tr_tally: _tr_tally_1,
    	_tr_align: _tr_align_1
    };

    // Note: adler32 takes 12% for level 0 and 2% for level 6.
    // It isn't worth it to make additional optimizations as in original.
    // Small size is preferable.

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    const adler32 = (adler, buf, len, pos) => {
      let s1 = (adler & 0xffff) |0,
          s2 = ((adler >>> 16) & 0xffff) |0,
          n = 0;

      while (len !== 0) {
        // Set limit ~ twice less than 5552, to keep
        // s2 in 31-bits, because we force signed ints.
        // in other case %= will fail.
        n = len > 2000 ? 2000 : len;
        len -= n;

        do {
          s1 = (s1 + buf[pos++]) |0;
          s2 = (s2 + s1) |0;
        } while (--n);

        s1 %= 65521;
        s2 %= 65521;
      }

      return (s1 | (s2 << 16)) |0;
    };


    var adler32_1 = adler32;

    // Note: we can't get significant speed boost here.
    // So write code to minimize size - no pregenerated tables
    // and array tools dependencies.

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    // Use ordinary array, since untyped makes no boost here
    const makeTable = () => {
      let c, table = [];

      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        table[n] = c;
      }

      return table;
    };

    // Create table on load. Just 255 signed longs. Not a problem.
    const crcTable = new Uint32Array(makeTable());


    const crc32 = (crc, buf, len, pos) => {
      const t = crcTable;
      const end = pos + len;

      crc ^= -1;

      for (let i = pos; i < end; i++) {
        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
      }

      return (crc ^ (-1)); // >>> 0;
    };


    var crc32_1 = crc32;

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    var messages = {
      2:      'need dictionary',     /* Z_NEED_DICT       2  */
      1:      'stream end',          /* Z_STREAM_END      1  */
      0:      '',                    /* Z_OK              0  */
      '-1':   'file error',          /* Z_ERRNO         (-1) */
      '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
      '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
      '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
      '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
      '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
    };

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    var constants$2 = {

      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH:         0,
      Z_PARTIAL_FLUSH:    1,
      Z_SYNC_FLUSH:       2,
      Z_FULL_FLUSH:       3,
      Z_FINISH:           4,
      Z_BLOCK:            5,
      Z_TREES:            6,

      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK:               0,
      Z_STREAM_END:       1,
      Z_NEED_DICT:        2,
      Z_ERRNO:           -1,
      Z_STREAM_ERROR:    -2,
      Z_DATA_ERROR:      -3,
      Z_MEM_ERROR:       -4,
      Z_BUF_ERROR:       -5,
      //Z_VERSION_ERROR: -6,

      /* compression levels */
      Z_NO_COMPRESSION:         0,
      Z_BEST_SPEED:             1,
      Z_BEST_COMPRESSION:       9,
      Z_DEFAULT_COMPRESSION:   -1,


      Z_FILTERED:               1,
      Z_HUFFMAN_ONLY:           2,
      Z_RLE:                    3,
      Z_FIXED:                  4,
      Z_DEFAULT_STRATEGY:       0,

      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY:                 0,
      Z_TEXT:                   1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN:                2,

      /* The deflate compression method */
      Z_DEFLATED:               8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;




    /* Public constants ==========================================================*/
    /* ===========================================================================*/

    const {
      Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,
      Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,
      Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
      Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
      Z_UNKNOWN,
      Z_DEFLATED: Z_DEFLATED$2
    } = constants$2;

    /*============================================================================*/


    const MAX_MEM_LEVEL = 9;
    /* Maximum value for memLevel in deflateInit2 */
    const MAX_WBITS$1 = 15;
    /* 32K LZ77 window */
    const DEF_MEM_LEVEL = 8;


    const LENGTH_CODES  = 29;
    /* number of length codes, not counting the special END_BLOCK code */
    const LITERALS      = 256;
    /* number of literal bytes 0..255 */
    const L_CODES       = LITERALS + 1 + LENGTH_CODES;
    /* number of Literal or Length codes, including the END_BLOCK code */
    const D_CODES       = 30;
    /* number of distance codes */
    const BL_CODES      = 19;
    /* number of codes used to transfer the bit lengths */
    const HEAP_SIZE     = 2 * L_CODES + 1;
    /* maximum heap size */
    const MAX_BITS  = 15;
    /* All codes must not exceed MAX_BITS bits */

    const MIN_MATCH = 3;
    const MAX_MATCH = 258;
    const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

    const PRESET_DICT = 0x20;

    const INIT_STATE = 42;
    const EXTRA_STATE = 69;
    const NAME_STATE = 73;
    const COMMENT_STATE = 91;
    const HCRC_STATE = 103;
    const BUSY_STATE = 113;
    const FINISH_STATE = 666;

    const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
    const BS_BLOCK_DONE     = 2; /* block flush performed */
    const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
    const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

    const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

    const err = (strm, errorCode) => {
      strm.msg = messages[errorCode];
      return errorCode;
    };

    const rank = (f) => {
      return ((f) << 1) - ((f) > 4 ? 9 : 0);
    };

    const zero = (buf) => {
      let len = buf.length; while (--len >= 0) { buf[len] = 0; }
    };


    /* eslint-disable new-cap */
    let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
    // This hash causes less collisions, https://github.com/nodeca/pako/issues/135
    // But breaks binary compatibility
    //let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
    let HASH = HASH_ZLIB;

    /* =========================================================================
     * Flush as much pending output as possible. All deflate() output goes
     * through this function so some applications may wish to modify it
     * to avoid allocating a large strm->output buffer and copying into it.
     * (See also read_buf()).
     */
    const flush_pending = (strm) => {
      const s = strm.state;

      //_tr_flush_bits(s);
      let len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) { return; }

      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    };


    const flush_block_only = (s, last) => {
      _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    };


    const put_byte = (s, b) => {
      s.pending_buf[s.pending++] = b;
    };


    /* =========================================================================
     * Put a short in the pending buffer. The 16-bit value is put in MSB order.
     * IN assertion: the stream state is correct and there is enough room in
     * pending_buf.
     */
    const putShortMSB = (s, b) => {

      //  put_byte(s, (Byte)(b >> 8));
    //  put_byte(s, (Byte)(b & 0xff));
      s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
      s.pending_buf[s.pending++] = b & 0xff;
    };


    /* ===========================================================================
     * Read a new buffer from the current input stream, update the adler32
     * and total number of bytes read.  All deflate() input goes through
     * this function so some applications may wish to modify it to avoid
     * allocating a large strm->input buffer and copying from it.
     * (See also flush_pending()).
     */
    const read_buf = (strm, buf, start, size) => {

      let len = strm.avail_in;

      if (len > size) { len = size; }
      if (len === 0) { return 0; }

      strm.avail_in -= len;

      // zmemcpy(buf, strm->next_in, len);
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32_1(strm.adler, buf, len, start);
      }

      else if (strm.state.wrap === 2) {
        strm.adler = crc32_1(strm.adler, buf, len, start);
      }

      strm.next_in += len;
      strm.total_in += len;

      return len;
    };


    /* ===========================================================================
     * Set match_start to the longest match starting at the given string and
     * return its length. Matches shorter or equal to prev_length are discarded,
     * in which case the result is equal to prev_length and match_start is
     * garbage.
     * IN assertions: cur_match is the head of the hash chain for the current
     *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
     * OUT assertion: the match length is not greater than s->lookahead.
     */
    const longest_match = (s, cur_match) => {

      let chain_length = s.max_chain_length;      /* max hash chain length */
      let scan = s.strstart; /* current string */
      let match;                       /* matched string */
      let len;                           /* length of current match */
      let best_len = s.prev_length;              /* best match length so far */
      let nice_match = s.nice_match;             /* stop if match long enough */
      const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
          s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

      const _win = s.window; // shortcut

      const wmask = s.w_mask;
      const prev  = s.prev;

      /* Stop when cur_match becomes <= limit. To simplify the code,
       * we prevent matches with the string of window index 0.
       */

      const strend = s.strstart + MAX_MATCH;
      let scan_end1  = _win[scan + best_len - 1];
      let scan_end   = _win[scan + best_len];

      /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
       * It is easy to get rid of this optimization if necessary.
       */
      // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

      /* Do not waste too much time if we already have a good match: */
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      /* Do not look for matches beyond the end of the input. This is necessary
       * to make deflate deterministic.
       */
      if (nice_match > s.lookahead) { nice_match = s.lookahead; }

      // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

      do {
        // Assert(cur_match < s->strstart, "no future");
        match = cur_match;

        /* Skip to next match if the match length cannot increase
         * or if the match length is less than 2.  Note that the checks below
         * for insufficient lookahead only occur occasionally for performance
         * reasons.  Therefore uninitialized memory will be accessed, and
         * conditional jumps will be made that depend on those values.
         * However the length of the match is limited to the lookahead, so
         * the output of deflate is not affected by the uninitialized values.
         */

        if (_win[match + best_len]     !== scan_end  ||
            _win[match + best_len - 1] !== scan_end1 ||
            _win[match]                !== _win[scan] ||
            _win[++match]              !== _win[scan + 1]) {
          continue;
        }

        /* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS >= 8.
         */
        scan += 2;
        match++;
        // Assert(*scan == *match, "match[2]?");

        /* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */
        do {
          /*jshint noempty:false*/
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                 _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                 _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                 _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                 scan < strend);

        // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;

        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1  = _win[scan + best_len - 1];
          scan_end   = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    };


    /* ===========================================================================
     * Fill the window when the lookahead becomes insufficient.
     * Updates strstart and lookahead.
     *
     * IN assertion: lookahead < MIN_LOOKAHEAD
     * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
     *    At least one byte has been read, or avail_in == 0; reads are
     *    performed for at least two bytes (required for the zip translate_eol
     *    option -- not supported here).
     */
    const fill_window = (s) => {

      const _w_size = s.w_size;
      let p, n, m, more, str;

      //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

      do {
        more = s.window_size - s.lookahead - s.strstart;

        // JS ints have 32 bit, block below not needed
        /* Deal with !@#$% 64K limit: */
        //if (sizeof(int) <= 2) {
        //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
        //        more = wsize;
        //
        //  } else if (more == (unsigned)(-1)) {
        //        /* Very unlikely, but possible on 16 bit machine if
        //         * strstart == 0 && lookahead == 1 (input done a byte at time)
        //         */
        //        more--;
        //    }
        //}


        /* If the window is almost full and there is insufficient lookahead,
         * move the upper half to the lower one to make room in the upper half.
         */
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

          s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          /* we now have strstart >= MAX_DIST */
          s.block_start -= _w_size;

          /* Slide the hash table (could be avoided with 32 bit values
           at the expense of memory usage). We slide even when level == 0
           to keep the hash table consistent if we switch back to level > 0
           later. (Using level 0 permanently is not an optimal usage of
           zlib, so we don't care about this pathological case.)
           */

          n = s.hash_size;
          p = n;

          do {
            m = s.head[--p];
            s.head[p] = (m >= _w_size ? m - _w_size : 0);
          } while (--n);

          n = _w_size;
          p = n;

          do {
            m = s.prev[--p];
            s.prev[p] = (m >= _w_size ? m - _w_size : 0);
            /* If n is not on any hash chain, prev[n] is garbage but
             * its value will never be used.
             */
          } while (--n);

          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }

        /* If there was no sliding:
         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
         *    more == window_size - lookahead - strstart
         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
         * => more >= window_size - 2*WSIZE + 2
         * In the BIG_MEM or MMAP case (not yet supported),
         *   window_size == input_size + MIN_LOOKAHEAD  &&
         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
         * Otherwise, window_size == 2*WSIZE so more >= 2.
         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
         */
        //Assert(more >= 2, "more < 2");
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;

        /* Initialize the hash value now that we have some input: */
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];

          /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
    //#if MIN_MATCH != 3
    //        Call update_hash() MIN_MATCH-3 more times
    //#endif
          while (s.insert) {
            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
         * but this is not important since only literal bytes will be emitted.
         */

      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

      /* If the WIN_INIT bytes after the end of the current data have never been
       * written, then zero those bytes in order to avoid memory check reports of
       * the use of uninitialized (or uninitialised as Julian writes) bytes by
       * the longest match routines.  Update the high water mark for the next
       * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
       * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
       */
    //  if (s.high_water < s.window_size) {
    //    const curr = s.strstart + s.lookahead;
    //    let init = 0;
    //
    //    if (s.high_water < curr) {
    //      /* Previous high water mark below current data -- zero WIN_INIT
    //       * bytes or up to end of window, whichever is less.
    //       */
    //      init = s.window_size - curr;
    //      if (init > WIN_INIT)
    //        init = WIN_INIT;
    //      zmemzero(s->window + curr, (unsigned)init);
    //      s->high_water = curr + init;
    //    }
    //    else if (s->high_water < (ulg)curr + WIN_INIT) {
    //      /* High water mark at or above current data, but below current data
    //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
    //       * to end of window, whichever is less.
    //       */
    //      init = (ulg)curr + WIN_INIT - s->high_water;
    //      if (init > s->window_size - s->high_water)
    //        init = s->window_size - s->high_water;
    //      zmemzero(s->window + s->high_water, (unsigned)init);
    //      s->high_water += init;
    //    }
    //  }
    //
    //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
    //    "not enough room for search");
    };

    /* ===========================================================================
     * Copy without compression as much as possible from the input stream, return
     * the current block state.
     * This function does not insert new strings in the dictionary since
     * uncompressible data is probably not useful. This function is used
     * only for the level=0 compression option.
     * NOTE: this function should be optimized to avoid extra copying from
     * window to pending_buf.
     */
    const deflate_stored = (s, flush) => {

      /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
       * to pending_buf_size, and each stored block has a 5 byte header:
       */
      let max_block_size = 0xffff;

      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }

      /* Copy as much as possible from input to output: */
      for (;;) {
        /* Fill the window as much as possible: */
        if (s.lookahead <= 1) {

          //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
          //  s->block_start >= (long)s->w_size, "slide too late");
    //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
    //        s.block_start >= s.w_size)) {
    //        throw  new Error("slide too late");
    //      }

          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }

          if (s.lookahead === 0) {
            break;
          }
          /* flush the current block */
        }
        //Assert(s->block_start >= 0L, "block gone");
    //    if (s.block_start < 0) throw new Error("block gone");

        s.strstart += s.lookahead;
        s.lookahead = 0;

        /* Emit a stored block if pending_buf will be full: */
        const max_start = s.block_start + max_block_size;

        if (s.strstart === 0 || s.strstart >= max_start) {
          /* strstart == 0 is possible when wraparound on 16-bit machine */
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/


        }
        /* Flush if we may have to slide, otherwise block_start may become
         * negative and the data will be gone:
         */
        if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }
      }

      s.insert = 0;

      if (flush === Z_FINISH$3) {
        /*** FLUSH_BLOCK(s, 1); ***/
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        /***/
        return BS_FINISH_DONE;
      }

      if (s.strstart > s.block_start) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

      return BS_NEED_MORE;
    };

    /* ===========================================================================
     * Compress as much as possible from the input stream, return the current
     * block state.
     * This function does not perform lazy evaluation of matches and inserts
     * new strings in the dictionary only for unmatched strings or for short
     * matches. It is used only for the fast compression options.
     */
    const deflate_fast = (s, flush) => {

      let hash_head;        /* head of the hash chain */
      let bflush;           /* set if current block must be flushed */

      for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break; /* flush the current block */
          }
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        hash_head = 0/*NIL*/;
        if (s.lookahead >= MIN_MATCH) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }

        /* Find the longest match, discarding those <= prev_length.
         * At this point we have always match_length < MIN_MATCH
         */
        if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
          /* To simplify the code, we prevent matches with the string
           * of window index 0 (in particular we have to avoid a match
           * of the string with itself at the start of the input file).
           */
          s.match_length = longest_match(s, hash_head);
          /* longest_match() sets match_start */
        }
        if (s.match_length >= MIN_MATCH) {
          // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

          /*** _tr_tally_dist(s, s.strstart - s.match_start,
                         s.match_length - MIN_MATCH, bflush); ***/
          bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

          s.lookahead -= s.match_length;

          /* Insert new strings in the hash table only if the match length
           * is not too large. This saves time but degrades compression.
           */
          if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
            s.match_length--; /* string at strstart already in table */
            do {
              s.strstart++;
              /*** INSERT_STRING(s, s.strstart, hash_head); ***/
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
              /***/
              /* strstart never exceeds WSIZE-MAX_MATCH, so there are
               * always MIN_MATCH bytes ahead.
               */
            } while (--s.match_length !== 0);
            s.strstart++;
          } else
          {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

    //#if MIN_MATCH != 3
    //                Call UPDATE_HASH() MIN_MATCH-3 more times
    //#endif
            /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
             * matter since it will be recomputed at next deflate call.
             */
          }
        } else {
          /* No match, output a literal byte */
          //Tracevv((stderr,"%c", s.window[s.strstart]));
          /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
          bflush = _tr_tally(s, 0, s.window[s.strstart]);

          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }
      }
      s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
      if (flush === Z_FINISH$3) {
        /*** FLUSH_BLOCK(s, 1); ***/
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        /***/
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }
      return BS_BLOCK_DONE;
    };

    /* ===========================================================================
     * Same as above, but achieves better compression. We use a lazy
     * evaluation for matches: a match is finally adopted only if there is
     * no better match at the next window position.
     */
    const deflate_slow = (s, flush) => {

      let hash_head;          /* head of hash chain */
      let bflush;              /* set if current block must be flushed */

      let max_insert;

      /* Process the input block. */
      for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) { break; } /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        hash_head = 0/*NIL*/;
        if (s.lookahead >= MIN_MATCH) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }

        /* Find the longest match, discarding those <= prev_length.
         */
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;

        if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
            s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
          /* To simplify the code, we prevent matches with the string
           * of window index 0 (in particular we have to avoid a match
           * of the string with itself at the start of the input file).
           */
          s.match_length = longest_match(s, hash_head);
          /* longest_match() sets match_start */

          if (s.match_length <= 5 &&
             (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

            /* If prev_match is also MIN_MATCH, match_start is garbage
             * but we will ignore the current match anyway.
             */
            s.match_length = MIN_MATCH - 1;
          }
        }
        /* If there was a match at the previous step and the current
         * match is not better, output the previous match:
         */
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          /* Do not insert strings in hash table beyond this. */

          //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

          /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                         s.prev_length - MIN_MATCH, bflush);***/
          bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          /* Insert in hash table all strings up to the end of the match.
           * strstart-1 and strstart are already inserted. If there is not
           * enough lookahead, the last two strings are not inserted in
           * the hash table.
           */
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              /*** INSERT_STRING(s, s.strstart, hash_head); ***/
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
              /***/
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;

          if (bflush) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
            /***/
          }

        } else if (s.match_available) {
          /* If there was no match at the previous position, output a
           * single literal. If there was a match but the current match
           * is longer, truncate the previous match to a single literal.
           */
          //Tracevv((stderr,"%c", s->window[s->strstart-1]));
          /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

          if (bflush) {
            /*** FLUSH_BLOCK_ONLY(s, 0) ***/
            flush_block_only(s, false);
            /***/
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          /* There is no previous match to compare with, wait for
           * the next step to decide.
           */
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      //Assert (flush != Z_NO_FLUSH, "no flush?");
      if (s.match_available) {
        //Tracevv((stderr,"%c", s->window[s->strstart-1]));
        /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH$3) {
        /*** FLUSH_BLOCK(s, 1); ***/
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        /***/
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

      return BS_BLOCK_DONE;
    };


    /* ===========================================================================
     * For Z_RLE, simply look for runs of bytes, generate matches only of distance
     * one.  Do not maintain a hash table.  (It will be regenerated if this run of
     * deflate switches away from Z_RLE.)
     */
    const deflate_rle = (s, flush) => {

      let bflush;            /* set if current block must be flushed */
      let prev;              /* byte at distance one to match */
      let scan, strend;      /* scan goes up to strend for length of run */

      const _win = s.window;

      for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the longest run, plus one for the unrolled loop.
         */
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) { break; } /* flush the current block */
        }

        /* See how many times the previous byte repeats */
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
              /*jshint noempty:false*/
            } while (prev === _win[++scan] && prev === _win[++scan] &&
                     prev === _win[++scan] && prev === _win[++scan] &&
                     prev === _win[++scan] && prev === _win[++scan] &&
                     prev === _win[++scan] && prev === _win[++scan] &&
                     scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
          //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
        }

        /* Emit match if have run of MIN_MATCH or longer, else emit literal */
        if (s.match_length >= MIN_MATCH) {
          //check_match(s, s.strstart, s.strstart - 1, s.match_length);

          /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
          bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          /* No match, output a literal byte */
          //Tracevv((stderr,"%c", s->window[s->strstart]));
          /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
          bflush = _tr_tally(s, 0, s.window[s.strstart]);

          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH$3) {
        /*** FLUSH_BLOCK(s, 1); ***/
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        /***/
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }
      return BS_BLOCK_DONE;
    };

    /* ===========================================================================
     * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
     * (It will be regenerated if this run of deflate switches away from Huffman.)
     */
    const deflate_huff = (s, flush) => {

      let bflush;             /* set if current block must be flushed */

      for (;;) {
        /* Make sure that we have a literal to write. */
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH$2) {
              return BS_NEED_MORE;
            }
            break;      /* flush the current block */
          }
        }

        /* Output a literal byte */
        s.match_length = 0;
        //Tracevv((stderr,"%c", s->window[s->strstart]));
        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH$3) {
        /*** FLUSH_BLOCK(s, 1); ***/
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        /***/
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }
      return BS_BLOCK_DONE;
    };

    /* Values for max_lazy_match, good_match and max_chain_length, depending on
     * the desired pack level (0..9). The values given below have been tuned to
     * exclude worst case performance for pathological files. Better values may be
     * found for specific files.
     */
    function Config$1(good_length, max_lazy, nice_length, max_chain, func) {

      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }

    const configuration_table = [
      /*      good lazy nice chain */
      new Config$1(0, 0, 0, 0, deflate_stored),          /* 0 store only */
      new Config$1(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
      new Config$1(4, 5, 16, 8, deflate_fast),           /* 2 */
      new Config$1(4, 6, 32, 32, deflate_fast),          /* 3 */

      new Config$1(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
      new Config$1(8, 16, 32, 32, deflate_slow),         /* 5 */
      new Config$1(8, 16, 128, 128, deflate_slow),       /* 6 */
      new Config$1(8, 32, 128, 256, deflate_slow),       /* 7 */
      new Config$1(32, 128, 258, 1024, deflate_slow),    /* 8 */
      new Config$1(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
    ];


    /* ===========================================================================
     * Initialize the "longest match" routines for a new zlib stream
     */
    const lm_init = (s) => {

      s.window_size = 2 * s.w_size;

      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);

      /* Set the default configuration parameters:
       */
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;

      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    };


    function DeflateState() {
      this.strm = null;            /* pointer back to this zlib stream */
      this.status = 0;            /* as the name implies */
      this.pending_buf = null;      /* output still pending */
      this.pending_buf_size = 0;  /* size of pending_buf */
      this.pending_out = 0;       /* next pending byte to output to the stream */
      this.pending = 0;           /* nb of bytes in the pending buffer */
      this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
      this.gzhead = null;         /* gzip header information to write */
      this.gzindex = 0;           /* where in extra, name, or comment */
      this.method = Z_DEFLATED$2; /* can only be DEFLATED */
      this.last_flush = -1;   /* value of flush param for previous deflate call */

      this.w_size = 0;  /* LZ77 window size (32K by default) */
      this.w_bits = 0;  /* log2(w_size)  (8..16) */
      this.w_mask = 0;  /* w_size - 1 */

      this.window = null;
      /* Sliding window. Input bytes are read into the second half of the window,
       * and move to the first half later to keep a dictionary of at least wSize
       * bytes. With this organization, matches are limited to a distance of
       * wSize-MAX_MATCH bytes, but this ensures that IO is always
       * performed with a length multiple of the block size.
       */

      this.window_size = 0;
      /* Actual size of window: 2*wSize, except when the user input buffer
       * is directly used as sliding window.
       */

      this.prev = null;
      /* Link to older string with same hash index. To limit the size of this
       * array to 64K, this link is maintained only for the last 32K strings.
       * An index in this array is thus a window index modulo 32K.
       */

      this.head = null;   /* Heads of the hash chains or NIL. */

      this.ins_h = 0;       /* hash index of string to be inserted */
      this.hash_size = 0;   /* number of elements in hash table */
      this.hash_bits = 0;   /* log2(hash_size) */
      this.hash_mask = 0;   /* hash_size-1 */

      this.hash_shift = 0;
      /* Number of bits by which ins_h must be shifted at each input
       * step. It must be such that after MIN_MATCH steps, the oldest
       * byte no longer takes part in the hash key, that is:
       *   hash_shift * MIN_MATCH >= hash_bits
       */

      this.block_start = 0;
      /* Window position at the beginning of the current output block. Gets
       * negative when the window is moved backwards.
       */

      this.match_length = 0;      /* length of best match */
      this.prev_match = 0;        /* previous match */
      this.match_available = 0;   /* set if previous match exists */
      this.strstart = 0;          /* start of string to insert */
      this.match_start = 0;       /* start of matching string */
      this.lookahead = 0;         /* number of valid bytes ahead in window */

      this.prev_length = 0;
      /* Length of the best match at previous step. Matches not greater than this
       * are discarded. This is used in the lazy match evaluation.
       */

      this.max_chain_length = 0;
      /* To speed up deflation, hash chains are never searched beyond this
       * length.  A higher limit improves compression ratio but degrades the
       * speed.
       */

      this.max_lazy_match = 0;
      /* Attempt to find a better match only when the current match is strictly
       * smaller than this value. This mechanism is used only for compression
       * levels >= 4.
       */
      // That's alias to max_lazy_match, don't use directly
      //this.max_insert_length = 0;
      /* Insert new strings in the hash table only if the match length is not
       * greater than this length. This saves time but degrades compression.
       * max_insert_length is used only for compression levels <= 3.
       */

      this.level = 0;     /* compression level (1..9) */
      this.strategy = 0;  /* favor or force Huffman coding*/

      this.good_match = 0;
      /* Use a faster search when the previous match is longer than this */

      this.nice_match = 0; /* Stop searching when current match exceeds this */

                  /* used by trees.c: */

      /* Didn't use ct_data typedef below to suppress compiler warning */

      // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
      // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
      // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

      // Use flat array of DOUBLE size, with interleaved fata,
      // because JS does not support effective
      this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);
      this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);
      this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);

      this.l_desc   = null;         /* desc. for literal tree */
      this.d_desc   = null;         /* desc. for distance tree */
      this.bl_desc  = null;         /* desc. for bit length tree */

      //ush bl_count[MAX_BITS+1];
      this.bl_count = new Uint16Array(MAX_BITS + 1);
      /* number of codes at each bit length for an optimal tree */

      //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
      this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
      zero(this.heap);

      this.heap_len = 0;               /* number of elements in the heap */
      this.heap_max = 0;               /* element of largest frequency */
      /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
       * The same heap array is used to build all trees.
       */

      this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
      zero(this.depth);
      /* Depth of each subtree used as tie breaker for trees of equal frequency
       */

      this.l_buf = 0;          /* buffer index for literals or lengths */

      this.lit_bufsize = 0;
      /* Size of match buffer for literals/lengths.  There are 4 reasons for
       * limiting lit_bufsize to 64K:
       *   - frequencies can be kept in 16 bit counters
       *   - if compression is not successful for the first block, all input
       *     data is still in the window so we can still emit a stored block even
       *     when input comes from standard input.  (This can also be done for
       *     all blocks if lit_bufsize is not greater than 32K.)
       *   - if compression is not successful for a file smaller than 64K, we can
       *     even emit a stored file instead of a stored block (saving 5 bytes).
       *     This is applicable only for zip (not gzip or zlib).
       *   - creating new Huffman trees less frequently may not provide fast
       *     adaptation to changes in the input data statistics. (Take for
       *     example a binary file with poorly compressible code followed by
       *     a highly compressible string table.) Smaller buffer sizes give
       *     fast adaptation but have of course the overhead of transmitting
       *     trees more frequently.
       *   - I can't count above 4
       */

      this.last_lit = 0;      /* running index in l_buf */

      this.d_buf = 0;
      /* Buffer index for distances. To simplify the code, d_buf and l_buf have
       * the same number of elements. To use different lengths, an extra flag
       * array would be necessary.
       */

      this.opt_len = 0;       /* bit length of current block with optimal trees */
      this.static_len = 0;    /* bit length of current block with static trees */
      this.matches = 0;       /* number of string matches in current block */
      this.insert = 0;        /* bytes at end of window left to insert */


      this.bi_buf = 0;
      /* Output buffer. bits are inserted starting at the bottom (least
       * significant bits).
       */
      this.bi_valid = 0;
      /* Number of valid bits in bi_buf.  All bits above the last valid bit
       * are always zero.
       */

      // Used for window memory init. We safely ignore it for JS. That makes
      // sense only for pointers and memory check tools.
      //this.high_water = 0;
      /* High water mark offset in window for initialized bytes -- bytes above
       * this are set to zero in order to avoid memory check warnings when
       * longest match routines access bytes past the input.  This is then
       * updated to the new high water mark.
       */
    }


    const deflateResetKeep = (strm) => {

      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR$2);
      }

      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;

      const s = strm.state;
      s.pending = 0;
      s.pending_out = 0;

      if (s.wrap < 0) {
        s.wrap = -s.wrap;
        /* was made negative by deflate(..., Z_FINISH); */
      }
      s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
      strm.adler = (s.wrap === 2) ?
        0  // crc32(0, Z_NULL, 0)
      :
        1; // adler32(0, Z_NULL, 0)
      s.last_flush = Z_NO_FLUSH$2;
      _tr_init(s);
      return Z_OK$3;
    };


    const deflateReset = (strm) => {

      const ret = deflateResetKeep(strm);
      if (ret === Z_OK$3) {
        lm_init(strm.state);
      }
      return ret;
    };


    const deflateSetHeader = (strm, head) => {

      if (!strm || !strm.state) { return Z_STREAM_ERROR$2; }
      if (strm.state.wrap !== 2) { return Z_STREAM_ERROR$2; }
      strm.state.gzhead = head;
      return Z_OK$3;
    };


    const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

      if (!strm) { // === Z_NULL
        return Z_STREAM_ERROR$2;
      }
      let wrap = 1;

      if (level === Z_DEFAULT_COMPRESSION$1) {
        level = 6;
      }

      if (windowBits < 0) { /* suppress zlib wrapper */
        wrap = 0;
        windowBits = -windowBits;
      }

      else if (windowBits > 15) {
        wrap = 2;           /* write gzip wrapper instead */
        windowBits -= 16;
      }


      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||
        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
        strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR$2);
      }


      if (windowBits === 8) {
        windowBits = 9;
      }
      /* until 256-byte window bug fixed */

      const s = new DeflateState();

      strm.state = s;
      s.strm = strm;

      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;

      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

      s.window = new Uint8Array(s.w_size * 2);
      s.head = new Uint16Array(s.hash_size);
      s.prev = new Uint16Array(s.w_size);

      // Don't need mem init magic for JS.
      //s.high_water = 0;  /* nothing written to s->window yet */

      s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

      s.pending_buf_size = s.lit_bufsize * 4;

      //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
      //s->pending_buf = (uchf *) overlay;
      s.pending_buf = new Uint8Array(s.pending_buf_size);

      // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
      //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
      s.d_buf = 1 * s.lit_bufsize;

      //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;

      s.level = level;
      s.strategy = strategy;
      s.method = method;

      return deflateReset(strm);
    };

    const deflateInit = (strm, level) => {

      return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
    };


    const deflate$2 = (strm, flush) => {

      let beg, val; // for gzip header write only

      if (!strm || !strm.state ||
        flush > Z_BLOCK$1 || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
      }

      const s = strm.state;

      if (!strm.output ||
          (!strm.input && strm.avail_in !== 0) ||
          (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {
        return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
      }

      s.strm = strm; /* just in case */
      const old_flush = s.last_flush;
      s.last_flush = flush;

      /* Write the header */
      if (s.status === INIT_STATE) {

        if (s.wrap === 2) { // GZIP header
          strm.adler = 0;  //crc32(0L, Z_NULL, 0);
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) { // s->gzhead == Z_NULL
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 :
                        (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                         4 : 0));
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          }
          else {
            put_byte(s, (s.gzhead.text ? 1 : 0) +
                        (s.gzhead.hcrc ? 2 : 0) +
                        (!s.gzhead.extra ? 0 : 4) +
                        (!s.gzhead.name ? 0 : 8) +
                        (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 0xff);
            put_byte(s, (s.gzhead.time >> 8) & 0xff);
            put_byte(s, (s.gzhead.time >> 16) & 0xff);
            put_byte(s, (s.gzhead.time >> 24) & 0xff);
            put_byte(s, s.level === 9 ? 2 :
                        (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                         4 : 0));
            put_byte(s, s.gzhead.os & 0xff);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 0xff);
              put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        }
        else // DEFLATE header
        {
          let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;
          let level_flags = -1;

          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= (level_flags << 6);
          if (s.strstart !== 0) { header |= PRESET_DICT; }
          header += 31 - (header % 31);

          s.status = BUSY_STATE;
          putShortMSB(s, header);

          /* Save the adler32 of the preset dictionary: */
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 0xffff);
          }
          strm.adler = 1; // adler32(0L, Z_NULL, 0);
        }
      }

    //#ifdef GZIP
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra/* != Z_NULL*/) {
          beg = s.pending;  /* start of bytes to update crc */

          while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        }
        else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name/* != Z_NULL*/) {
          beg = s.pending;  /* start of bytes to update crc */
          //int val;

          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            // JS specific: little magic to add zero terminator to end of string
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);

          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        }
        else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment/* != Z_NULL*/) {
          beg = s.pending;  /* start of bytes to update crc */
          //int val;

          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            // JS specific: little magic to add zero terminator to end of string
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);

          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        }
        else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 0xff);
            put_byte(s, (strm.adler >> 8) & 0xff);
            strm.adler = 0; //crc32(0L, Z_NULL, 0);
            s.status = BUSY_STATE;
          }
        }
        else {
          s.status = BUSY_STATE;
        }
      }
    //#endif

      /* Flush as much pending output as possible */
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          /* Since avail_out is 0, deflate will be called again with
           * more output space, but possibly with both pending and
           * avail_in equal to zero. There won't be anything to do,
           * but this is not an error situation so make sure we
           * return OK instead of BUF_ERROR at next call of deflate:
           */
          s.last_flush = -1;
          return Z_OK$3;
        }

        /* Make sure there is something to do and avoid duplicate consecutive
         * flushes. For repeated and useless calls with Z_FINISH, we keep
         * returning Z_STREAM_END instead of Z_BUF_ERROR.
         */
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
        flush !== Z_FINISH$3) {
        return err(strm, Z_BUF_ERROR$1);
      }

      /* User must not provide more input after the first FINISH: */
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR$1);
      }

      /* Start a new block or continue the current one.
       */
      if (strm.avail_in !== 0 || s.lookahead !== 0 ||
        (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {
        let bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
          (s.strategy === Z_RLE ? deflate_rle(s, flush) :
            configuration_table[s.level].func(s, flush));

        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            /* avoid BUF_ERROR next call, see above */
          }
          return Z_OK$3;
          /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
           * of deflate should use the same flush parameter to make sure
           * that the flush is complete. So we don't have to output an
           * empty block here, this will be done at next call. This also
           * ensures that for a very small output buffer, we emit at most
           * one empty block.
           */
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align(s);
          }
          else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */

            _tr_stored_block(s, 0, 0, false);
            /* For a full flush, this empty block will be recognized
             * as a special marker by inflate_sync().
             */
            if (flush === Z_FULL_FLUSH$1) {
              /*** CLEAR_HASH(s); ***/             /* forget history */
              zero(s.head); // Fill with NIL (= 0);

              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
            return Z_OK$3;
          }
        }
      }
      //Assert(strm->avail_out > 0, "bug2");
      //if (strm.avail_out <= 0) { throw new Error("bug2");}

      if (flush !== Z_FINISH$3) { return Z_OK$3; }
      if (s.wrap <= 0) { return Z_STREAM_END$3; }

      /* Write the trailer */
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        put_byte(s, (strm.adler >> 16) & 0xff);
        put_byte(s, (strm.adler >> 24) & 0xff);
        put_byte(s, strm.total_in & 0xff);
        put_byte(s, (strm.total_in >> 8) & 0xff);
        put_byte(s, (strm.total_in >> 16) & 0xff);
        put_byte(s, (strm.total_in >> 24) & 0xff);
      }
      else
      {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }

      flush_pending(strm);
      /* If avail_out is zero, the application will call deflate again
       * to flush the rest.
       */
      if (s.wrap > 0) { s.wrap = -s.wrap; }
      /* write the trailer only once! */
      return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
    };


    const deflateEnd = (strm) => {

      if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
        return Z_STREAM_ERROR$2;
      }

      const status = strm.state.status;
      if (status !== INIT_STATE &&
        status !== EXTRA_STATE &&
        status !== NAME_STATE &&
        status !== COMMENT_STATE &&
        status !== HCRC_STATE &&
        status !== BUSY_STATE &&
        status !== FINISH_STATE
      ) {
        return err(strm, Z_STREAM_ERROR$2);
      }

      strm.state = null;

      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
    };


    /* =========================================================================
     * Initializes the compression dictionary from the given byte
     * sequence without producing any compressed output.
     */
    const deflateSetDictionary = (strm, dictionary) => {

      let dictLength = dictionary.length;

      if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
        return Z_STREAM_ERROR$2;
      }

      const s = strm.state;
      const wrap = s.wrap;

      if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
        return Z_STREAM_ERROR$2;
      }

      /* when using zlib wrappers, compute Adler-32 for provided dictionary */
      if (wrap === 1) {
        /* adler32(strm->adler, dictionary, dictLength); */
        strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
      }

      s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

      /* if dictionary would fill window, just replace the history */
      if (dictLength >= s.w_size) {
        if (wrap === 0) {            /* already empty otherwise */
          /*** CLEAR_HASH(s); ***/
          zero(s.head); // Fill with NIL (= 0);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        /* use the tail */
        // dictionary = dictionary.slice(dictLength - s.w_size);
        let tmpDict = new Uint8Array(s.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      /* insert dictionary into window and hash */
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        let str = s.strstart;
        let n = s.lookahead - (MIN_MATCH - 1);
        do {
          /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

          s.prev[str & s.w_mask] = s.head[s.ins_h];

          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK$3;
    };


    var deflateInit_1 = deflateInit;
    var deflateInit2_1 = deflateInit2;
    var deflateReset_1 = deflateReset;
    var deflateResetKeep_1 = deflateResetKeep;
    var deflateSetHeader_1 = deflateSetHeader;
    var deflate_2$1 = deflate$2;
    var deflateEnd_1 = deflateEnd;
    var deflateSetDictionary_1 = deflateSetDictionary;
    var deflateInfo = 'pako deflate (from Nodeca project)';

    /* Not implemented
    module.exports.deflateBound = deflateBound;
    module.exports.deflateCopy = deflateCopy;
    module.exports.deflateParams = deflateParams;
    module.exports.deflatePending = deflatePending;
    module.exports.deflatePrime = deflatePrime;
    module.exports.deflateTune = deflateTune;
    */

    var deflate_1$2 = {
    	deflateInit: deflateInit_1,
    	deflateInit2: deflateInit2_1,
    	deflateReset: deflateReset_1,
    	deflateResetKeep: deflateResetKeep_1,
    	deflateSetHeader: deflateSetHeader_1,
    	deflate: deflate_2$1,
    	deflateEnd: deflateEnd_1,
    	deflateSetDictionary: deflateSetDictionary_1,
    	deflateInfo: deflateInfo
    };

    const _has = (obj, key) => {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };

    var assign = function (obj /*from1, from2, from3, ...*/) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source = sources.shift();
        if (!source) { continue; }

        if (typeof source !== 'object') {
          throw new TypeError(source + 'must be non-object');
        }

        for (const p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }

      return obj;
    };


    // Join array of chunks to single array.
    var flattenChunks = (chunks) => {
      // calculate data length
      let len = 0;

      for (let i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }

      // join chunks
      const result = new Uint8Array(len);

      for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
        let chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }

      return result;
    };

    var common = {
    	assign: assign,
    	flattenChunks: flattenChunks
    };

    // String encode/decode helpers


    // Quick check if we can use fast array to bin string conversion
    //
    // - apply(Array) can fail on Android 2.2
    // - apply(Uint8Array) can fail on iOS 5.1 Safari
    //
    let STR_APPLY_UIA_OK = true;

    try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


    // Table with utf8 lengths (calculated by first byte of sequence)
    // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
    // because max possible codepoint is 0x10ffff
    const _utf8len = new Uint8Array(256);
    for (let q = 0; q < 256; q++) {
      _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
    }
    _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


    // convert string to array (typed, when possible)
    var string2buf = (str) => {
      if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
      }

      let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

      // count binary size
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 0xfc00) === 0xdc00) {
            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
            m_pos++;
          }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
      }

      // allocate buffer
      buf = new Uint8Array(buf_len);

      // convert
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 0xfc00) === 0xdc00) {
            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
            m_pos++;
          }
        }
        if (c < 0x80) {
          /* one byte */
          buf[i++] = c;
        } else if (c < 0x800) {
          /* two bytes */
          buf[i++] = 0xC0 | (c >>> 6);
          buf[i++] = 0x80 | (c & 0x3f);
        } else if (c < 0x10000) {
          /* three bytes */
          buf[i++] = 0xE0 | (c >>> 12);
          buf[i++] = 0x80 | (c >>> 6 & 0x3f);
          buf[i++] = 0x80 | (c & 0x3f);
        } else {
          /* four bytes */
          buf[i++] = 0xf0 | (c >>> 18);
          buf[i++] = 0x80 | (c >>> 12 & 0x3f);
          buf[i++] = 0x80 | (c >>> 6 & 0x3f);
          buf[i++] = 0x80 | (c & 0x3f);
        }
      }

      return buf;
    };

    // Helper
    const buf2binstring = (buf, len) => {
      // On Chrome, the arguments in a function call that are allowed is `65534`.
      // If the length of the buffer is smaller than that, we can use this optimization,
      // otherwise we will take a slower path.
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
          return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
      }

      let result = '';
      for (let i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    };


    // convert array to string
    var buf2string = (buf, max) => {
      const len = max || buf.length;

      if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max));
      }

      let i, out;

      // Reserve max possible length (2 words per char)
      // NB: by unknown reasons, Array is significantly faster for
      //     String.fromCharCode.apply than Uint16Array.
      const utf16buf = new Array(len * 2);

      for (out = 0, i = 0; i < len;) {
        let c = buf[i++];
        // quick process ascii
        if (c < 0x80) { utf16buf[out++] = c; continue; }

        let c_len = _utf8len[c];
        // skip 5 & 6 byte codes
        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

        // apply mask on first byte
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        // join the rest
        while (c_len > 1 && i < len) {
          c = (c << 6) | (buf[i++] & 0x3f);
          c_len--;
        }

        // terminated by end of string?
        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

        if (c < 0x10000) {
          utf16buf[out++] = c;
        } else {
          c -= 0x10000;
          utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
          utf16buf[out++] = 0xdc00 | (c & 0x3ff);
        }
      }

      return buf2binstring(utf16buf, out);
    };


    // Calculate max possible position in utf8 buffer,
    // that will not break sequence. If that's not possible
    // - (very small limits) return max size as is.
    //
    // buf[] - utf8 bytes array
    // max   - length limit (mandatory);
    var utf8border = (buf, max) => {

      max = max || buf.length;
      if (max > buf.length) { max = buf.length; }

      // go back from last position, until start of sequence found
      let pos = max - 1;
      while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

      // Very small and broken sequence,
      // return max, because we should return something anyway.
      if (pos < 0) { return max; }

      // If we came to start of buffer - that means buffer is too small,
      // return max too.
      if (pos === 0) { return max; }

      return (pos + _utf8len[buf[pos]] > max) ? pos : max;
    };

    var strings = {
    	string2buf: string2buf,
    	buf2string: buf2string,
    	utf8border: utf8border
    };

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    function ZStream() {
      /* next input byte */
      this.input = null; // JS specific, because we have no pointers
      this.next_in = 0;
      /* number of bytes available at input */
      this.avail_in = 0;
      /* total number of input bytes read so far */
      this.total_in = 0;
      /* next output byte should be put there */
      this.output = null; // JS specific, because we have no pointers
      this.next_out = 0;
      /* remaining free space at output */
      this.avail_out = 0;
      /* total number of bytes output so far */
      this.total_out = 0;
      /* last error message, NULL if no error */
      this.msg = ''/*Z_NULL*/;
      /* not visible by applications */
      this.state = null;
      /* best guess about the data type: binary or text */
      this.data_type = 2/*Z_UNKNOWN*/;
      /* adler32 value of the uncompressed data */
      this.adler = 0;
    }

    var zstream = ZStream;

    const toString$1 = Object.prototype.toString;

    /* Public constants ==========================================================*/
    /* ===========================================================================*/

    const {
      Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,
      Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,
      Z_DEFAULT_COMPRESSION,
      Z_DEFAULT_STRATEGY,
      Z_DEFLATED: Z_DEFLATED$1
    } = constants$2;

    /* ===========================================================================*/


    /**
     * class Deflate
     *
     * Generic JS-style wrapper for zlib calls. If you don't need
     * streaming behaviour - use more simple functions: [[deflate]],
     * [[deflateRaw]] and [[gzip]].
     **/

    /* internal
     * Deflate.chunks -> Array
     *
     * Chunks of output data, if [[Deflate#onData]] not overridden.
     **/

    /**
     * Deflate.result -> Uint8Array
     *
     * Compressed result, generated by default [[Deflate#onData]]
     * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
     * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
     **/

    /**
     * Deflate.err -> Number
     *
     * Error code after deflate finished. 0 (Z_OK) on success.
     * You will not need it in real life, because deflate errors
     * are possible only on wrong options or bad `onData` / `onEnd`
     * custom handlers.
     **/

    /**
     * Deflate.msg -> String
     *
     * Error message, if [[Deflate.err]] != 0
     **/


    /**
     * new Deflate(options)
     * - options (Object): zlib deflate options.
     *
     * Creates new deflator instance with specified params. Throws exception
     * on bad params. Supported options:
     *
     * - `level`
     * - `windowBits`
     * - `memLevel`
     * - `strategy`
     * - `dictionary`
     *
     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
     * for more information on these.
     *
     * Additional options, for internal needs:
     *
     * - `chunkSize` - size of generated data chunks (16K by default)
     * - `raw` (Boolean) - do raw deflate
     * - `gzip` (Boolean) - create gzip wrapper
     * - `header` (Object) - custom header for gzip
     *   - `text` (Boolean) - true if compressed data believed to be text
     *   - `time` (Number) - modification time, unix timestamp
     *   - `os` (Number) - operation system code
     *   - `extra` (Array) - array of bytes with extra data (max 65536)
     *   - `name` (String) - file name (binary string)
     *   - `comment` (String) - comment (binary string)
     *   - `hcrc` (Boolean) - true if header crc should be added
     *
     * ##### Example:
     *
     * ```javascript
     * const pako = require('pako')
     *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
     *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
     *
     * const deflate = new pako.Deflate({ level: 3});
     *
     * deflate.push(chunk1, false);
     * deflate.push(chunk2, true);  // true -> last chunk
     *
     * if (deflate.err) { throw new Error(deflate.err); }
     *
     * console.log(deflate.result);
     * ```
     **/
    function Deflate$1(options) {
      this.options = common.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED$1,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY
      }, options || {});

      let opt = this.options;

      if (opt.raw && (opt.windowBits > 0)) {
        opt.windowBits = -opt.windowBits;
      }

      else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
        opt.windowBits += 16;
      }

      this.err    = 0;      // error code, if happens (0 = Z_OK)
      this.msg    = '';     // error message
      this.ended  = false;  // used to avoid multiple onEnd() calls
      this.chunks = [];     // chunks of compressed data

      this.strm = new zstream();
      this.strm.avail_out = 0;

      let status = deflate_1$2.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );

      if (status !== Z_OK$2) {
        throw new Error(messages[status]);
      }

      if (opt.header) {
        deflate_1$2.deflateSetHeader(this.strm, opt.header);
      }

      if (opt.dictionary) {
        let dict;
        // Convert data if needed
        if (typeof opt.dictionary === 'string') {
          // If we need to compress text, change encoding to utf8.
          dict = strings.string2buf(opt.dictionary);
        } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }

        status = deflate_1$2.deflateSetDictionary(this.strm, dict);

        if (status !== Z_OK$2) {
          throw new Error(messages[status]);
        }

        this._dict_set = true;
      }
    }

    /**
     * Deflate#push(data[, flush_mode]) -> Boolean
     * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
     *   converted to utf8 byte sequence.
     * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
     *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
     *
     * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
     * new compressed chunks. Returns `true` on success. The last data block must
     * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
     * buffers and call [[Deflate#onEnd]].
     *
     * On fail call [[Deflate#onEnd]] with error code and return false.
     *
     * ##### Example
     *
     * ```javascript
     * push(chunk, false); // push one of data chunks
     * ...
     * push(chunk, true);  // push last chunk
     * ```
     **/
    Deflate$1.prototype.push = function (data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;

      if (this.ended) { return false; }

      if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
      else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;

      // Convert data if needed
      if (typeof data === 'string') {
        // If we need to compress text, change encoding to utf8.
        strm.input = strings.string2buf(data);
      } else if (toString$1.call(data) === '[object ArrayBuffer]') {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }

      strm.next_in = 0;
      strm.avail_in = strm.input.length;

      for (;;) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }

        // Make sure avail_out > 6 to avoid repeating markers
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }

        status = deflate_1$2.deflate(strm, _flush_mode);

        // Ended => flush and finish
        if (status === Z_STREAM_END$2) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = deflate_1$2.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK$2;
        }

        // Flush if out buffer full
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }

        // Flush if requested and has data
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }

        if (strm.avail_in === 0) break;
      }

      return true;
    };


    /**
     * Deflate#onData(chunk) -> Void
     * - chunk (Uint8Array): output data.
     *
     * By default, stores data blocks in `chunks[]` property and glue
     * those in `onEnd`. Override this handler, if you need another behaviour.
     **/
    Deflate$1.prototype.onData = function (chunk) {
      this.chunks.push(chunk);
    };


    /**
     * Deflate#onEnd(status) -> Void
     * - status (Number): deflate status. 0 (Z_OK) on success,
     *   other if not.
     *
     * Called once after you tell deflate that the input stream is
     * complete (Z_FINISH). By default - join collected chunks,
     * free memory and fill `results` / `err` properties.
     **/
    Deflate$1.prototype.onEnd = function (status) {
      // On success - join
      if (status === Z_OK$2) {
        this.result = common.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };


    /**
     * deflate(data[, options]) -> Uint8Array
     * - data (Uint8Array|String): input data to compress.
     * - options (Object): zlib deflate options.
     *
     * Compress `data` with deflate algorithm and `options`.
     *
     * Supported options are:
     *
     * - level
     * - windowBits
     * - memLevel
     * - strategy
     * - dictionary
     *
     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
     * for more information on these.
     *
     * Sugar (options):
     *
     * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
     *   negative windowBits implicitly.
     *
     * ##### Example:
     *
     * ```javascript
     * const pako = require('pako')
     * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
     *
     * console.log(pako.deflate(data));
     * ```
     **/
    function deflate$1(input, options) {
      const deflator = new Deflate$1(options);

      deflator.push(input, true);

      // That will never happens, if you don't cheat with options :)
      if (deflator.err) { throw deflator.msg || messages[deflator.err]; }

      return deflator.result;
    }


    /**
     * deflateRaw(data[, options]) -> Uint8Array
     * - data (Uint8Array|String): input data to compress.
     * - options (Object): zlib deflate options.
     *
     * The same as [[deflate]], but creates raw data, without wrapper
     * (header and adler32 crc).
     **/
    function deflateRaw$1(input, options) {
      options = options || {};
      options.raw = true;
      return deflate$1(input, options);
    }


    /**
     * gzip(data[, options]) -> Uint8Array
     * - data (Uint8Array|String): input data to compress.
     * - options (Object): zlib deflate options.
     *
     * The same as [[deflate]], but create gzip wrapper instead of
     * deflate one.
     **/
    function gzip$1(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate$1(input, options);
    }


    var Deflate_1$1 = Deflate$1;
    var deflate_2 = deflate$1;
    var deflateRaw_1$1 = deflateRaw$1;
    var gzip_1$1 = gzip$1;
    var constants$1 = constants$2;

    var deflate_1$1 = {
    	Deflate: Deflate_1$1,
    	deflate: deflate_2,
    	deflateRaw: deflateRaw_1$1,
    	gzip: gzip_1$1,
    	constants: constants$1
    };

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    // See state defs from inflate.js
    const BAD$1 = 30;       /* got a data error -- remain here until reset */
    const TYPE$1 = 12;      /* i: waiting for type bits, including last-flag bit */

    /*
       Decode literal, length, and distance codes and write out the resulting
       literal and match bytes until either not enough input or output is
       available, an end-of-block is encountered, or a data error is encountered.
       When large enough input and output buffers are supplied to inflate(), for
       example, a 16K input buffer and a 64K output buffer, more than 95% of the
       inflate execution time is spent in this routine.

       Entry assumptions:

            state.mode === LEN
            strm.avail_in >= 6
            strm.avail_out >= 258
            start >= strm.avail_out
            state.bits < 8

       On return, state.mode is one of:

            LEN -- ran out of enough output space or enough available input
            TYPE -- reached end of block code, inflate() to interpret next block
            BAD -- error in block data

       Notes:

        - The maximum input bits used by a length/distance pair is 15 bits for the
          length code, 5 bits for the length extra, 15 bits for the distance code,
          and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
          Therefore if strm.avail_in >= 6, then there is enough input to avoid
          checking for available input while decoding.

        - The maximum bytes that a single length/distance pair can output is 258
          bytes, which is the maximum length that can be coded.  inflate_fast()
          requires strm.avail_out >= 258 for each loop to avoid checking for
          output space.
     */
    var inffast = function inflate_fast(strm, start) {
      let _in;                    /* local strm.input */
      let last;                   /* have enough input while in < last */
      let _out;                   /* local strm.output */
      let beg;                    /* inflate()'s initial strm.output */
      let end;                    /* while out < end, enough space available */
    //#ifdef INFLATE_STRICT
      let dmax;                   /* maximum distance from zlib header */
    //#endif
      let wsize;                  /* window size or zero if not using window */
      let whave;                  /* valid bytes in the window */
      let wnext;                  /* window write index */
      // Use `s_window` instead `window`, avoid conflict with instrumentation tools
      let s_window;               /* allocated sliding window, if wsize != 0 */
      let hold;                   /* local strm.hold */
      let bits;                   /* local strm.bits */
      let lcode;                  /* local strm.lencode */
      let dcode;                  /* local strm.distcode */
      let lmask;                  /* mask for first level of length codes */
      let dmask;                  /* mask for first level of distance codes */
      let here;                   /* retrieved table entry */
      let op;                     /* code bits, operation, extra bits, or */
                                  /*  window position, window bytes to copy */
      let len;                    /* match length, unused bytes */
      let dist;                   /* match distance */
      let from;                   /* where to copy match from */
      let from_source;


      let input, output; // JS specific, because we have no pointers

      /* copy state to local variables */
      const state = strm.state;
      //here = state.here;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
    //#ifdef INFLATE_STRICT
      dmax = state.dmax;
    //#endif
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;


      /* decode literals and length/distances until end-of-block or not enough
         input data or output space */

      top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }

        here = lcode[hold & lmask];

        dolen:
        for (;;) { // Goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;
          if (op === 0) {                          /* literal */
            //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
            //        "inflate:         literal '%c'\n" :
            //        "inflate:         literal 0x%02x\n", here.val));
            output[_out++] = here & 0xffff/*here.val*/;
          }
          else if (op & 16) {                     /* length base */
            len = here & 0xffff/*here.val*/;
            op &= 15;                           /* number of extra bits */
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & ((1 << op) - 1);
              hold >>>= op;
              bits -= op;
            }
            //Tracevv((stderr, "inflate:         length %u\n", len));
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];

            dodist:
            for (;;) { // goto emulation
              op = here >>> 24/*here.bits*/;
              hold >>>= op;
              bits -= op;
              op = (here >>> 16) & 0xff/*here.op*/;

              if (op & 16) {                      /* distance base */
                dist = here & 0xffff/*here.val*/;
                op &= 15;                       /* number of extra bits */
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                }
                dist += hold & ((1 << op) - 1);
    //#ifdef INFLATE_STRICT
                if (dist > dmax) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD$1;
                  break top;
                }
    //#endif
                hold >>>= op;
                bits -= op;
                //Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = _out - beg;                /* max distance in output */
                if (dist > op) {                /* see if copy from window */
                  op = dist - op;               /* distance back in window */
                  if (op > whave) {
                    if (state.sane) {
                      strm.msg = 'invalid distance too far back';
                      state.mode = BAD$1;
                      break top;
                    }

    // (!) This block is disabled in zlib defaults,
    // don't enable it for binary compatibility
    //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
    //                if (len <= op - whave) {
    //                  do {
    //                    output[_out++] = 0;
    //                  } while (--len);
    //                  continue top;
    //                }
    //                len -= op - whave;
    //                do {
    //                  output[_out++] = 0;
    //                } while (--op > whave);
    //                if (op === 0) {
    //                  from = _out - dist;
    //                  do {
    //                    output[_out++] = output[from++];
    //                  } while (--len);
    //                  continue top;
    //                }
    //#endif
                  }
                  from = 0; // window index
                  from_source = s_window;
                  if (wnext === 0) {           /* very common case */
                    from += wsize - op;
                    if (op < len) {         /* some from window */
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;  /* rest from output */
                      from_source = output;
                    }
                  }
                  else if (wnext < op) {      /* wrap around window */
                    from += wsize + wnext - op;
                    op -= wnext;
                    if (op < len) {         /* some from end of window */
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = 0;
                      if (wnext < len) {  /* some from start of window */
                        op = wnext;
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;      /* rest from output */
                        from_source = output;
                      }
                    }
                  }
                  else {                      /* contiguous in window */
                    from += wnext - op;
                    if (op < len) {         /* some from window */
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;  /* rest from output */
                      from_source = output;
                    }
                  }
                  while (len > 2) {
                    output[_out++] = from_source[from++];
                    output[_out++] = from_source[from++];
                    output[_out++] = from_source[from++];
                    len -= 3;
                  }
                  if (len) {
                    output[_out++] = from_source[from++];
                    if (len > 1) {
                      output[_out++] = from_source[from++];
                    }
                  }
                }
                else {
                  from = _out - dist;          /* copy direct from output */
                  do {                        /* minimum length is three */
                    output[_out++] = output[from++];
                    output[_out++] = output[from++];
                    output[_out++] = output[from++];
                    len -= 3;
                  } while (len > 2);
                  if (len) {
                    output[_out++] = output[from++];
                    if (len > 1) {
                      output[_out++] = output[from++];
                    }
                  }
                }
              }
              else if ((op & 64) === 0) {          /* 2nd level distance code */
                here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
                continue dodist;
              }
              else {
                strm.msg = 'invalid distance code';
                state.mode = BAD$1;
                break top;
              }

              break; // need to emulate goto via "continue"
            }
          }
          else if ((op & 64) === 0) {              /* 2nd level length code */
            here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dolen;
          }
          else if (op & 32) {                     /* end-of-block */
            //Tracevv((stderr, "inflate:         end of block\n"));
            state.mode = TYPE$1;
            break top;
          }
          else {
            strm.msg = 'invalid literal/length code';
            state.mode = BAD$1;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      } while (_in < last && _out < end);

      /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;

      /* update state and return */
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
      strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
      state.hold = hold;
      state.bits = bits;
      return;
    };

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    const MAXBITS = 15;
    const ENOUGH_LENS$1 = 852;
    const ENOUGH_DISTS$1 = 592;
    //const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

    const CODES$1 = 0;
    const LENS$1 = 1;
    const DISTS$1 = 2;

    const lbase = new Uint16Array([ /* Length codes 257..285 base */
      3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
      35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
    ]);

    const lext = new Uint8Array([ /* Length codes 257..285 extra */
      16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
      19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
    ]);

    const dbase = new Uint16Array([ /* Distance codes 0..29 base */
      1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
      257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
      8193, 12289, 16385, 24577, 0, 0
    ]);

    const dext = new Uint8Array([ /* Distance codes 0..29 extra */
      16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
      23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
      28, 28, 29, 29, 64, 64
    ]);

    const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
    {
      const bits = opts.bits;
          //here = opts.here; /* table entry for duplication */

      let len = 0;               /* a code's length in bits */
      let sym = 0;               /* index of code symbols */
      let min = 0, max = 0;          /* minimum and maximum code lengths */
      let root = 0;              /* number of index bits for root table */
      let curr = 0;              /* number of index bits for current table */
      let drop = 0;              /* code bits to drop for sub-table */
      let left = 0;                   /* number of prefix codes available */
      let used = 0;              /* code entries in table used */
      let huff = 0;              /* Huffman code */
      let incr;              /* for incrementing code, index */
      let fill;              /* index for replicating entries */
      let low;               /* low bits for current root entry */
      let mask;              /* mask for low root bits */
      let next;             /* next available space in table */
      let base = null;     /* base value table to use */
      let base_index = 0;
    //  let shoextra;    /* extra bits table to use */
      let end;                    /* use base and extra for symbol > end */
      const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
      const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
      let extra = null;
      let extra_index = 0;

      let here_bits, here_op, here_val;

      /*
       Process a set of code lengths to create a canonical Huffman code.  The
       code lengths are lens[0..codes-1].  Each length corresponds to the
       symbols 0..codes-1.  The Huffman code is generated by first sorting the
       symbols by length from short to long, and retaining the symbol order
       for codes with equal lengths.  Then the code starts with all zero bits
       for the first code of the shortest length, and the codes are integer
       increments for the same length, and zeros are appended as the length
       increases.  For the deflate format, these bits are stored backwards
       from their more natural integer increment ordering, and so when the
       decoding tables are built in the large loop below, the integer codes
       are incremented backwards.

       This routine assumes, but does not check, that all of the entries in
       lens[] are in the range 0..MAXBITS.  The caller must assure this.
       1..MAXBITS is interpreted as that code length.  zero means that that
       symbol does not occur in this code.

       The codes are sorted by computing a count of codes for each length,
       creating from that a table of starting indices for each length in the
       sorted table, and then entering the symbols in order in the sorted
       table.  The sorted table is work[], with that space being provided by
       the caller.

       The length counts are used for other purposes as well, i.e. finding
       the minimum and maximum length codes, determining if there are any
       codes at all, checking for a valid set of lengths, and looking ahead
       at length counts to determine sub-table sizes when building the
       decoding tables.
       */

      /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }

      /* bound code lengths, force root to be within code lengths */
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) { break; }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {                     /* no symbols to code at all */
        //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
        //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
        //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
        table[table_index++] = (1 << 24) | (64 << 16) | 0;


        //table.op[opts.table_index] = 64;
        //table.bits[opts.table_index] = 1;
        //table.val[opts.table_index++] = 0;
        table[table_index++] = (1 << 24) | (64 << 16) | 0;

        opts.bits = 1;
        return 0;     /* no symbols, but wait for decoding to report error */
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) { break; }
      }
      if (root < min) {
        root = min;
      }

      /* check for an over-subscribed or incomplete set of lengths */
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }        /* over-subscribed */
      }
      if (left > 0 && (type === CODES$1 || max !== 1)) {
        return -1;                      /* incomplete set */
      }

      /* generate offsets into symbol table for each length for sorting */
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }

      /* sort symbols by length, by symbol order within each length */
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }

      /*
       Create and fill in decoding tables.  In this loop, the table being
       filled is at next and has curr index bits.  The code being used is huff
       with length len.  That code is converted to an index by dropping drop
       bits off of the bottom.  For codes where len is less than drop + curr,
       those top drop + curr - len bits are incremented through all values to
       fill the table with replicated entries.

       root is the number of index bits for the root table.  When len exceeds
       root, sub-tables are created pointed to by the root entry with an index
       of the low root bits of huff.  This is saved in low to check for when a
       new sub-table should be started.  drop is zero when the root table is
       being filled, and drop is root when sub-tables are being filled.

       When a new sub-table is needed, it is necessary to look ahead in the
       code lengths to determine what size sub-table is needed.  The length
       counts are used for this, and so count[] is decremented as codes are
       entered in the tables.

       used keeps track of how many table entries have been allocated from the
       provided *table space.  It is checked for LENS and DIST tables against
       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
       the initial root table size constants.  See the comments in inftrees.h
       for more information.

       sym increments through all symbols, and the loop terminates when
       all codes of length max, i.e. all codes, have been processed.  This
       routine permits incomplete codes, so another loop after this one fills
       in the rest of the decoding tables with invalid code markers.
       */

      /* set up for code type */
      // poor man optimization - use if-else instead of switch,
      // to avoid deopts in old v8
      if (type === CODES$1) {
        base = extra = work;    /* dummy value--not used */
        end = 19;

      } else if (type === LENS$1) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;

      } else {                    /* DISTS */
        base = dbase;
        extra = dext;
        end = -1;
      }

      /* initialize opts for loop */
      huff = 0;                   /* starting code */
      sym = 0;                    /* starting code symbol */
      len = min;                  /* starting code length */
      next = table_index;              /* current table to fill in */
      curr = root;                /* current table index bits */
      drop = 0;                   /* current bits to drop from code for index */
      low = -1;                   /* trigger new sub-table when len > root */
      used = 1 << root;          /* use root table entries */
      mask = used - 1;            /* mask for comparing low */

      /* check available table space */
      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
        return 1;
      }

      /* process all codes and make table entries */
      for (;;) {
        /* create table entry */
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        }
        else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        }
        else {
          here_op = 32 + 64;         /* end of block */
          here_val = 0;
        }

        /* replicate for those indices with low len bits equal to huff */
        incr = 1 << (len - drop);
        fill = 1 << curr;
        min = fill;                 /* save offset to next table */
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
        } while (fill !== 0);

        /* backwards increment the len-bit code huff */
        incr = 1 << (len - 1);
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }

        /* go to next symbol, update count, len */
        sym++;
        if (--count[len] === 0) {
          if (len === max) { break; }
          len = lens[lens_index + work[sym]];
        }

        /* create new sub-table if needed */
        if (len > root && (huff & mask) !== low) {
          /* if first time, transition to sub-tables */
          if (drop === 0) {
            drop = root;
          }

          /* increment past last table */
          next += min;            /* here min is 1 << curr */

          /* determine length of next table */
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) { break; }
            curr++;
            left <<= 1;
          }

          /* check for enough space */
          used += 1 << curr;
          if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
            (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
            return 1;
          }

          /* point entry in root table to sub-table */
          low = huff & mask;
          /*table.op[low] = curr;
          table.bits[low] = root;
          table.val[low] = next - opts.table_index;*/
          table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
        }
      }

      /* fill in remaining table entry if code is incomplete (guaranteed to have
       at most one remaining entry, since if the code is incomplete, the
       maximum code length that was allowed to get this far is one bit) */
      if (huff !== 0) {
        //table.op[next + huff] = 64;            /* invalid code marker */
        //table.bits[next + huff] = len - drop;
        //table.val[next + huff] = 0;
        table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
      }

      /* set return parameters */
      //opts.table_index += used;
      opts.bits = root;
      return 0;
    };


    var inftrees = inflate_table;

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.






    const CODES = 0;
    const LENS = 1;
    const DISTS = 2;

    /* Public constants ==========================================================*/
    /* ===========================================================================*/

    const {
      Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,
      Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,
      Z_DEFLATED
    } = constants$2;


    /* STATES ====================================================================*/
    /* ===========================================================================*/


    const    HEAD = 1;       /* i: waiting for magic header */
    const    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
    const    TIME = 3;       /* i: waiting for modification time (gzip) */
    const    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
    const    EXLEN = 5;      /* i: waiting for extra length (gzip) */
    const    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
    const    NAME = 7;       /* i: waiting for end of file name (gzip) */
    const    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
    const    HCRC = 9;       /* i: waiting for header crc (gzip) */
    const    DICTID = 10;    /* i: waiting for dictionary check value */
    const    DICT = 11;      /* waiting for inflateSetDictionary() call */
    const        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
    const        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
    const        STORED = 14;    /* i: waiting for stored size (length and complement) */
    const        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
    const        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
    const        TABLE = 17;     /* i: waiting for dynamic block table lengths */
    const        LENLENS = 18;   /* i: waiting for code length code lengths */
    const        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
    const            LEN_ = 20;      /* i: same as LEN below, but only first time in */
    const            LEN = 21;       /* i: waiting for length/lit/eob code */
    const            LENEXT = 22;    /* i: waiting for length extra bits */
    const            DIST = 23;      /* i: waiting for distance code */
    const            DISTEXT = 24;   /* i: waiting for distance extra bits */
    const            MATCH = 25;     /* o: waiting for output space to copy string */
    const            LIT = 26;       /* o: waiting for output space to write literal */
    const    CHECK = 27;     /* i: waiting for 32-bit check value */
    const    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
    const    DONE = 29;      /* finished check, done -- remain here until reset */
    const    BAD = 30;       /* got a data error -- remain here until reset */
    const    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
    const    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

    /* ===========================================================================*/



    const ENOUGH_LENS = 852;
    const ENOUGH_DISTS = 592;
    //const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

    const MAX_WBITS = 15;
    /* 32K LZ77 window */
    const DEF_WBITS = MAX_WBITS;


    const zswap32 = (q) => {

      return  (((q >>> 24) & 0xff) +
              ((q >>> 8) & 0xff00) +
              ((q & 0xff00) << 8) +
              ((q & 0xff) << 24));
    };


    function InflateState() {
      this.mode = 0;             /* current inflate mode */
      this.last = false;          /* true if processing last block */
      this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
      this.havedict = false;      /* true if dictionary provided */
      this.flags = 0;             /* gzip header method and flags (0 if zlib) */
      this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
      this.check = 0;             /* protected copy of check value */
      this.total = 0;             /* protected copy of output count */
      // TODO: may be {}
      this.head = null;           /* where to save gzip header information */

      /* sliding window */
      this.wbits = 0;             /* log base 2 of requested window size */
      this.wsize = 0;             /* window size or zero if not using window */
      this.whave = 0;             /* valid bytes in the window */
      this.wnext = 0;             /* window write index */
      this.window = null;         /* allocated sliding window, if needed */

      /* bit accumulator */
      this.hold = 0;              /* input bit accumulator */
      this.bits = 0;              /* number of bits in "in" */

      /* for string and stored block copying */
      this.length = 0;            /* literal or length of data to copy */
      this.offset = 0;            /* distance back to copy string from */

      /* for table and code decoding */
      this.extra = 0;             /* extra bits needed */

      /* fixed and dynamic code tables */
      this.lencode = null;          /* starting table for length/literal codes */
      this.distcode = null;         /* starting table for distance codes */
      this.lenbits = 0;           /* index bits for lencode */
      this.distbits = 0;          /* index bits for distcode */

      /* dynamic table building */
      this.ncode = 0;             /* number of code length code lengths */
      this.nlen = 0;              /* number of length code lengths */
      this.ndist = 0;             /* number of distance code lengths */
      this.have = 0;              /* number of code lengths in lens[] */
      this.next = null;              /* next available space in codes[] */

      this.lens = new Uint16Array(320); /* temporary storage for code lengths */
      this.work = new Uint16Array(288); /* work area for code table building */

      /*
       because we don't have pointers in js, we use lencode and distcode directly
       as buffers so we don't need codes
      */
      //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
      this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
      this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
      this.sane = 0;                   /* if false, allow invalid distance too far */
      this.back = 0;                   /* bits back of last unprocessed length/lit */
      this.was = 0;                    /* initial length of match */
    }


    const inflateResetKeep = (strm) => {

      if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = ''; /*Z_NULL*/
      if (state.wrap) {       /* to support ill-conceived Java test suite */
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null/*Z_NULL*/;
      state.hold = 0;
      state.bits = 0;
      //state.lencode = state.distcode = state.next = state.codes;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

      state.sane = 1;
      state.back = -1;
      //Tracev((stderr, "inflate: reset\n"));
      return Z_OK$1;
    };


    const inflateReset = (strm) => {

      if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);

    };


    const inflateReset2 = (strm, windowBits) => {
      let wrap;

      /* get the state */
      if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
      const state = strm.state;

      /* extract wrap request from windowBits parameter */
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      }
      else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }

      /* set number of window bits, free window if different */
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR$1;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }

      /* update state and reset the rest of it */
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    };


    const inflateInit2 = (strm, windowBits) => {

      if (!strm) { return Z_STREAM_ERROR$1; }
      //strm.msg = Z_NULL;                 /* in case we return an error */

      const state = new InflateState();

      //if (state === Z_NULL) return Z_MEM_ERROR;
      //Tracev((stderr, "inflate: allocated\n"));
      strm.state = state;
      state.window = null/*Z_NULL*/;
      const ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK$1) {
        strm.state = null/*Z_NULL*/;
      }
      return ret;
    };


    const inflateInit = (strm) => {

      return inflateInit2(strm, DEF_WBITS);
    };


    /*
     Return state with length and distance decoding tables and index sizes set to
     fixed code decoding.  Normally this returns fixed tables from inffixed.h.
     If BUILDFIXED is defined, then instead this routine builds the tables the
     first time it's called, and returns those tables the first time and
     thereafter.  This reduces the size of the code by about 2K bytes, in
     exchange for a little execution time.  However, BUILDFIXED should not be
     used for threaded applications, since the rewriting of the tables and virgin
     may not be thread-safe.
     */
    let virgin = true;

    let lenfix, distfix; // We have no pointers in JS, so keep tables separate


    const fixedtables = (state) => {

      /* build fixed huffman tables if first call (may not be thread safe) */
      if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);

        /* literal/length table */
        let sym = 0;
        while (sym < 144) { state.lens[sym++] = 8; }
        while (sym < 256) { state.lens[sym++] = 9; }
        while (sym < 280) { state.lens[sym++] = 7; }
        while (sym < 288) { state.lens[sym++] = 8; }

        inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

        /* distance table */
        sym = 0;
        while (sym < 32) { state.lens[sym++] = 5; }

        inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

        /* do this just once */
        virgin = false;
      }

      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    };


    /*
     Update the window with the last wsize (normally 32K) bytes written before
     returning.  If window does not exist yet, create it.  This is only called
     when a window is already in use, or when output has been written during this
     inflate call, but the end of the deflate stream has not been reached yet.
     It is also called to create a window for dictionary data when a dictionary
     is loaded.

     Providing output buffers larger than 32K to inflate() should provide a speed
     advantage, since only the last 32K of output is copied to the sliding window
     upon return from inflate(), and since all distances after the first 32K of
     output will fall in the output data, making match copies simpler and faster.
     The advantage may be dependent on the size of the processor's data caches.
     */
    const updatewindow = (strm, src, end, copy) => {

      let dist;
      const state = strm.state;

      /* if it hasn't been done already, allocate space for the window */
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;

        state.window = new Uint8Array(state.wsize);
      }

      /* copy state->wsize or less output bytes into the circular window */
      if (copy >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      }
      else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        //zmemcpy(state->window + state->wnext, end - copy, dist);
        state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
        copy -= dist;
        if (copy) {
          //zmemcpy(state->window, end - copy, copy);
          state.window.set(src.subarray(end - copy, end), 0);
          state.wnext = copy;
          state.whave = state.wsize;
        }
        else {
          state.wnext += dist;
          if (state.wnext === state.wsize) { state.wnext = 0; }
          if (state.whave < state.wsize) { state.whave += dist; }
        }
      }
      return 0;
    };


    const inflate$2 = (strm, flush) => {

      let state;
      let input, output;          // input/output buffers
      let next;                   /* next input INDEX */
      let put;                    /* next output INDEX */
      let have, left;             /* available input and output */
      let hold;                   /* bit buffer */
      let bits;                   /* bits in bit buffer */
      let _in, _out;              /* save starting available input and output */
      let copy;                   /* number of stored or match bytes to copy */
      let from;                   /* where to copy match bytes from */
      let from_source;
      let here = 0;               /* current decoding table entry */
      let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
      //let last;                   /* parent table entry */
      let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
      let len;                    /* length to copy for repeats, bits to drop */
      let ret;                    /* return code */
      const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
      let opts;

      let n; // temporary variable for NEED_BITS

      const order = /* permutation of code lengths */
        new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


      if (!strm || !strm.state || !strm.output ||
          (!strm.input && strm.avail_in !== 0)) {
        return Z_STREAM_ERROR$1;
      }

      state = strm.state;
      if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


      //--- LOAD() ---
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      //---

      _in = have;
      _out = left;
      ret = Z_OK$1;

      inf_leave: // goto emulation
      for (;;) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            //=== NEEDBITS(16);
            while (bits < 16) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
              state.check = 0/*crc32(0L, Z_NULL, 0)*/;
              //=== CRC2(state.check, hold);
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32_1(state.check, hbuf, 2, 0);
              //===//

              //=== INITBITS();
              hold = 0;
              bits = 0;
              //===//
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;           /* expect zlib header */
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) ||   /* check if zlib header allowed */
              (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
              strm.msg = 'incorrect header check';
              state.mode = BAD;
              break;
            }
            if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
              strm.msg = 'unknown compression method';
              state.mode = BAD;
              break;
            }
            //--- DROPBITS(4) ---//
            hold >>>= 4;
            bits -= 4;
            //---//
            len = (hold & 0x0f)/*BITS(4)*/ + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            }
            else if (len > state.wbits) {
              strm.msg = 'invalid window size';
              state.mode = BAD;
              break;
            }

            // !!! pako patch. Force use `options.windowBits` if passed.
            // Required to always use max window size by default.
            state.dmax = 1 << state.wbits;
            //state.dmax = 1 << len;

            //Tracev((stderr, "inflate:   zlib header ok\n"));
            strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
            state.mode = hold & 0x200 ? DICTID : TYPE;
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            break;
          case FLAGS:
            //=== NEEDBITS(16); */
            while (bits < 16) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.flags = hold;
            if ((state.flags & 0xff) !== Z_DEFLATED) {
              strm.msg = 'unknown compression method';
              state.mode = BAD;
              break;
            }
            if (state.flags & 0xe000) {
              strm.msg = 'unknown header flags set';
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = ((hold >> 8) & 1);
            }
            if (state.flags & 0x0200) {
              //=== CRC2(state.check, hold);
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32_1(state.check, hbuf, 2, 0);
              //===//
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = TIME;
            /* falls through */
          case TIME:
            //=== NEEDBITS(32); */
            while (bits < 32) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 0x0200) {
              //=== CRC4(state.check, hold)
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              hbuf[2] = (hold >>> 16) & 0xff;
              hbuf[3] = (hold >>> 24) & 0xff;
              state.check = crc32_1(state.check, hbuf, 4, 0);
              //===
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = OS;
            /* falls through */
          case OS:
            //=== NEEDBITS(16); */
            while (bits < 16) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            if (state.head) {
              state.head.xflags = (hold & 0xff);
              state.head.os = (hold >> 8);
            }
            if (state.flags & 0x0200) {
              //=== CRC2(state.check, hold);
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32_1(state.check, hbuf, 2, 0);
              //===//
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = EXLEN;
            /* falls through */
          case EXLEN:
            if (state.flags & 0x0400) {
              //=== NEEDBITS(16); */
              while (bits < 16) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 0x0200) {
                //=== CRC2(state.check, hold);
                hbuf[0] = hold & 0xff;
                hbuf[1] = (hold >>> 8) & 0xff;
                state.check = crc32_1(state.check, hbuf, 2, 0);
                //===//
              }
              //=== INITBITS();
              hold = 0;
              bits = 0;
              //===//
            }
            else if (state.head) {
              state.head.extra = null/*Z_NULL*/;
            }
            state.mode = EXTRA;
            /* falls through */
          case EXTRA:
            if (state.flags & 0x0400) {
              copy = state.length;
              if (copy > have) { copy = have; }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    // Use untyped array for more convenient processing later
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(
                    input.subarray(
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      next + copy
                    ),
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                  //zmemcpy(state.head.extra + len, next,
                  //        len + copy > state.head.extra_max ?
                  //        state.head.extra_max - len : copy);
                }
                if (state.flags & 0x0200) {
                  state.check = crc32_1(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) { break inf_leave; }
            }
            state.length = 0;
            state.mode = NAME;
            /* falls through */
          case NAME:
            if (state.flags & 0x0800) {
              if (have === 0) { break inf_leave; }
              copy = 0;
              do {
                // TODO: 2 or 1 bytes?
                len = input[next + copy++];
                /* use constant limit because in js we should not preallocate memory */
                if (state.head && len &&
                    (state.length < 65536 /*state.head.name_max*/)) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);

              if (state.flags & 0x0200) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) { break inf_leave; }
            }
            else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
            /* falls through */
          case COMMENT:
            if (state.flags & 0x1000) {
              if (have === 0) { break inf_leave; }
              copy = 0;
              do {
                len = input[next + copy++];
                /* use constant limit because in js we should not preallocate memory */
                if (state.head && len &&
                    (state.length < 65536 /*state.head.comm_max*/)) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 0x0200) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) { break inf_leave; }
            }
            else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
            /* falls through */
          case HCRC:
            if (state.flags & 0x0200) {
              //=== NEEDBITS(16); */
              while (bits < 16) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              if (hold !== (state.check & 0xffff)) {
                strm.msg = 'header crc mismatch';
                state.mode = BAD;
                break;
              }
              //=== INITBITS();
              hold = 0;
              bits = 0;
              //===//
            }
            if (state.head) {
              state.head.hcrc = ((state.flags >> 9) & 1);
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            //=== NEEDBITS(32); */
            while (bits < 32) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            strm.adler = state.check = zswap32(hold);
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = DICT;
            /* falls through */
          case DICT:
            if (state.havedict === 0) {
              //--- RESTORE() ---
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              //---
              return Z_NEED_DICT$1;
            }
            strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
            state.mode = TYPE;
            /* falls through */
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
            /* falls through */
          case TYPEDO:
            if (state.last) {
              //--- BYTEBITS() ---//
              hold >>>= bits & 7;
              bits -= bits & 7;
              //---//
              state.mode = CHECK;
              break;
            }
            //=== NEEDBITS(3); */
            while (bits < 3) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.last = (hold & 0x01)/*BITS(1)*/;
            //--- DROPBITS(1) ---//
            hold >>>= 1;
            bits -= 1;
            //---//

            switch ((hold & 0x03)/*BITS(2)*/) {
              case 0:                             /* stored block */
                //Tracev((stderr, "inflate:     stored block%s\n",
                //        state.last ? " (last)" : ""));
                state.mode = STORED;
                break;
              case 1:                             /* fixed block */
                fixedtables(state);
                //Tracev((stderr, "inflate:     fixed codes block%s\n",
                //        state.last ? " (last)" : ""));
                state.mode = LEN_;             /* decode codes */
                if (flush === Z_TREES) {
                  //--- DROPBITS(2) ---//
                  hold >>>= 2;
                  bits -= 2;
                  //---//
                  break inf_leave;
                }
                break;
              case 2:                             /* dynamic block */
                //Tracev((stderr, "inflate:     dynamic codes block%s\n",
                //        state.last ? " (last)" : ""));
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = 'invalid block type';
                state.mode = BAD;
            }
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
            break;
          case STORED:
            //--- BYTEBITS() ---// /* go to byte boundary */
            hold >>>= bits & 7;
            bits -= bits & 7;
            //---//
            //=== NEEDBITS(32); */
            while (bits < 32) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
              strm.msg = 'invalid stored block lengths';
              state.mode = BAD;
              break;
            }
            state.length = hold & 0xffff;
            //Tracev((stderr, "inflate:       stored length %u\n",
            //        state.length));
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = COPY_;
            if (flush === Z_TREES) { break inf_leave; }
            /* falls through */
          case COPY_:
            state.mode = COPY;
            /* falls through */
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) { copy = have; }
              if (copy > left) { copy = left; }
              if (copy === 0) { break inf_leave; }
              //--- zmemcpy(put, next, copy); ---
              output.set(input.subarray(next, next + copy), put);
              //---//
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            //Tracev((stderr, "inflate:       stored end\n"));
            state.mode = TYPE;
            break;
          case TABLE:
            //=== NEEDBITS(14); */
            while (bits < 14) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
            //--- DROPBITS(5) ---//
            hold >>>= 5;
            bits -= 5;
            //---//
            state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
            //--- DROPBITS(5) ---//
            hold >>>= 5;
            bits -= 5;
            //---//
            state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
            //--- DROPBITS(4) ---//
            hold >>>= 4;
            bits -= 4;
            //---//
    //#ifndef PKZIP_BUG_WORKAROUND
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = 'too many length or distance symbols';
              state.mode = BAD;
              break;
            }
    //#endif
            //Tracev((stderr, "inflate:       table sizes ok\n"));
            state.have = 0;
            state.mode = LENLENS;
            /* falls through */
          case LENLENS:
            while (state.have < state.ncode) {
              //=== NEEDBITS(3);
              while (bits < 3) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            // We have separate tables & no pointers. 2 commented lines below not needed.
            //state.next = state.codes;
            //state.lencode = state.next;
            // Switch to use dynamic table
            state.lencode = state.lendyn;
            state.lenbits = 7;

            opts = { bits: state.lenbits };
            ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;

            if (ret) {
              strm.msg = 'invalid code lengths set';
              state.mode = BAD;
              break;
            }
            //Tracev((stderr, "inflate:       code lengths ok\n"));
            state.have = 0;
            state.mode = CODELENS;
            /* falls through */
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (;;) {
                here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;

                if ((here_bits) <= bits) { break; }
                //--- PULLBYTE() ---//
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
                //---//
              }
              if (here_val < 16) {
                //--- DROPBITS(here.bits) ---//
                hold >>>= here_bits;
                bits -= here_bits;
                //---//
                state.lens[state.have++] = here_val;
              }
              else {
                if (here_val === 16) {
                  //=== NEEDBITS(here.bits + 2);
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) { break inf_leave; }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  //===//
                  //--- DROPBITS(here.bits) ---//
                  hold >>>= here_bits;
                  bits -= here_bits;
                  //---//
                  if (state.have === 0) {
                    strm.msg = 'invalid bit length repeat';
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 0x03);//BITS(2);
                  //--- DROPBITS(2) ---//
                  hold >>>= 2;
                  bits -= 2;
                  //---//
                }
                else if (here_val === 17) {
                  //=== NEEDBITS(here.bits + 3);
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) { break inf_leave; }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  //===//
                  //--- DROPBITS(here.bits) ---//
                  hold >>>= here_bits;
                  bits -= here_bits;
                  //---//
                  len = 0;
                  copy = 3 + (hold & 0x07);//BITS(3);
                  //--- DROPBITS(3) ---//
                  hold >>>= 3;
                  bits -= 3;
                  //---//
                }
                else {
                  //=== NEEDBITS(here.bits + 7);
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) { break inf_leave; }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  //===//
                  //--- DROPBITS(here.bits) ---//
                  hold >>>= here_bits;
                  bits -= here_bits;
                  //---//
                  len = 0;
                  copy = 11 + (hold & 0x7f);//BITS(7);
                  //--- DROPBITS(7) ---//
                  hold >>>= 7;
                  bits -= 7;
                  //---//
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = 'invalid bit length repeat';
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }

            /* handle error breaks in while */
            if (state.mode === BAD) { break; }

            /* check for end-of-block code (better have one) */
            if (state.lens[256] === 0) {
              strm.msg = 'invalid code -- missing end-of-block';
              state.mode = BAD;
              break;
            }

            /* build code tables -- note: do not change the lenbits or distbits
               values here (9 and 6) without reading the comments in inftrees.h
               concerning the ENOUGH constants, which depend on those values */
            state.lenbits = 9;

            opts = { bits: state.lenbits };
            ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            // We have separate tables & no pointers. 2 commented lines below not needed.
            // state.next_index = opts.table_index;
            state.lenbits = opts.bits;
            // state.lencode = state.next;

            if (ret) {
              strm.msg = 'invalid literal/lengths set';
              state.mode = BAD;
              break;
            }

            state.distbits = 6;
            //state.distcode.copy(state.codes);
            // Switch to use dynamic table
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            // We have separate tables & no pointers. 2 commented lines below not needed.
            // state.next_index = opts.table_index;
            state.distbits = opts.bits;
            // state.distcode = state.next;

            if (ret) {
              strm.msg = 'invalid distances set';
              state.mode = BAD;
              break;
            }
            //Tracev((stderr, 'inflate:       codes ok\n'));
            state.mode = LEN_;
            if (flush === Z_TREES) { break inf_leave; }
            /* falls through */
          case LEN_:
            state.mode = LEN;
            /* falls through */
          case LEN:
            if (have >= 6 && left >= 258) {
              //--- RESTORE() ---
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              //---
              inffast(strm, _out);
              //--- LOAD() ---
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              //---

              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (;;) {
              here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;

              if (here_bits <= bits) { break; }
              //--- PULLBYTE() ---//
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
              //---//
            }
            if (here_op && (here_op & 0xf0) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;;) {
                here = state.lencode[last_val +
                        ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;

                if ((last_bits + here_bits) <= bits) { break; }
                //--- PULLBYTE() ---//
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
                //---//
              }
              //--- DROPBITS(last.bits) ---//
              hold >>>= last_bits;
              bits -= last_bits;
              //---//
              state.back += last_bits;
            }
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
              //        "inflate:         literal '%c'\n" :
              //        "inflate:         literal 0x%02x\n", here.val));
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              //Tracevv((stderr, "inflate:         end of block\n"));
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = 'invalid literal/length code';
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
            /* falls through */
          case LENEXT:
            if (state.extra) {
              //=== NEEDBITS(state.extra);
              n = state.extra;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
              //--- DROPBITS(state.extra) ---//
              hold >>>= state.extra;
              bits -= state.extra;
              //---//
              state.back += state.extra;
            }
            //Tracevv((stderr, "inflate:         length %u\n", state.length));
            state.was = state.length;
            state.mode = DIST;
            /* falls through */
          case DIST:
            for (;;) {
              here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;

              if ((here_bits) <= bits) { break; }
              //--- PULLBYTE() ---//
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
              //---//
            }
            if ((here_op & 0xf0) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;;) {
                here = state.distcode[last_val +
                        ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;

                if ((last_bits + here_bits) <= bits) { break; }
                //--- PULLBYTE() ---//
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
                //---//
              }
              //--- DROPBITS(last.bits) ---//
              hold >>>= last_bits;
              bits -= last_bits;
              //---//
              state.back += last_bits;
            }
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = 'invalid distance code';
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = (here_op) & 15;
            state.mode = DISTEXT;
            /* falls through */
          case DISTEXT:
            if (state.extra) {
              //=== NEEDBITS(state.extra);
              n = state.extra;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
              //--- DROPBITS(state.extra) ---//
              hold >>>= state.extra;
              bits -= state.extra;
              //---//
              state.back += state.extra;
            }
    //#ifdef INFLATE_STRICT
            if (state.offset > state.dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
    //#endif
            //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
            state.mode = MATCH;
            /* falls through */
          case MATCH:
            if (left === 0) { break inf_leave; }
            copy = _out - left;
            if (state.offset > copy) {         /* copy from window */
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break;
                }
    // (!) This block is disabled in zlib defaults,
    // don't enable it for binary compatibility
    //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
    //          Trace((stderr, "inflate.c too far\n"));
    //          copy -= state.whave;
    //          if (copy > state.length) { copy = state.length; }
    //          if (copy > left) { copy = left; }
    //          left -= copy;
    //          state.length -= copy;
    //          do {
    //            output[put++] = 0;
    //          } while (--copy);
    //          if (state.length === 0) { state.mode = LEN; }
    //          break;
    //#endif
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              }
              else {
                from = state.wnext - copy;
              }
              if (copy > state.length) { copy = state.length; }
              from_source = state.window;
            }
            else {                              /* copy from output */
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) { copy = left; }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) { state.mode = LEN; }
            break;
          case LIT:
            if (left === 0) { break inf_leave; }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              //=== NEEDBITS(32);
              while (bits < 32) {
                if (have === 0) { break inf_leave; }
                have--;
                // Use '|' instead of '+' to make sure that result is signed
                hold |= input[next++] << bits;
                bits += 8;
              }
              //===//
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check =
                    /*UPDATE(state.check, put - _out, _out);*/
                    (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

              }
              _out = left;
              // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = 'incorrect data check';
                state.mode = BAD;
                break;
              }
              //=== INITBITS();
              hold = 0;
              bits = 0;
              //===//
              //Tracev((stderr, "inflate:   check matches trailer\n"));
            }
            state.mode = LENGTH;
            /* falls through */
          case LENGTH:
            if (state.wrap && state.flags) {
              //=== NEEDBITS(32);
              while (bits < 32) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              if (hold !== (state.total & 0xffffffff)) {
                strm.msg = 'incorrect length check';
                state.mode = BAD;
                break;
              }
              //=== INITBITS();
              hold = 0;
              bits = 0;
              //===//
              //Tracev((stderr, "inflate:   length matches trailer\n"));
            }
            state.mode = DONE;
            /* falls through */
          case DONE:
            ret = Z_STREAM_END$1;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR$1;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR$1;
          case SYNC:
            /* falls through */
          default:
            return Z_STREAM_ERROR$1;
        }
      }

      // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

      /*
         Return from inflate(), updating the total counts and the check value.
         If there was no progress during the inflate() call, return a buffer
         error.  Call updatewindow() to create and/or update the window state.
         Note: a memory error from inflate() is non-recoverable.
       */

      //--- RESTORE() ---
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      //---

      if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                          (state.mode < CHECK || flush !== Z_FINISH$1))) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
          (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) +
                        (state.mode === TYPE ? 128 : 0) +
                        (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    };


    const inflateEnd = (strm) => {

      if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
        return Z_STREAM_ERROR$1;
      }

      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK$1;
    };


    const inflateGetHeader = (strm, head) => {

      /* check state */
      if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
      const state = strm.state;
      if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

      /* save header structure */
      state.head = head;
      head.done = false;
      return Z_OK$1;
    };


    const inflateSetDictionary = (strm, dictionary) => {
      const dictLength = dictionary.length;

      let state;
      let dictid;
      let ret;

      /* check state */
      if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR$1; }
      state = strm.state;

      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR$1;
      }

      /* check for correct dictionary identifier */
      if (state.mode === DICT) {
        dictid = 1; /* adler32(0, null, 0)*/
        /* dictid = adler32(dictid, dictionary, dictLength); */
        dictid = adler32_1(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR$1;
        }
      }
      /* copy dictionary to window using updatewindow(), which will amend the
       existing dictionary if appropriate */
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR$1;
      }
      state.havedict = 1;
      // Tracev((stderr, "inflate:   dictionary set\n"));
      return Z_OK$1;
    };


    var inflateReset_1 = inflateReset;
    var inflateReset2_1 = inflateReset2;
    var inflateResetKeep_1 = inflateResetKeep;
    var inflateInit_1 = inflateInit;
    var inflateInit2_1 = inflateInit2;
    var inflate_2$1 = inflate$2;
    var inflateEnd_1 = inflateEnd;
    var inflateGetHeader_1 = inflateGetHeader;
    var inflateSetDictionary_1 = inflateSetDictionary;
    var inflateInfo = 'pako inflate (from Nodeca project)';

    /* Not implemented
    module.exports.inflateCopy = inflateCopy;
    module.exports.inflateGetDictionary = inflateGetDictionary;
    module.exports.inflateMark = inflateMark;
    module.exports.inflatePrime = inflatePrime;
    module.exports.inflateSync = inflateSync;
    module.exports.inflateSyncPoint = inflateSyncPoint;
    module.exports.inflateUndermine = inflateUndermine;
    */

    var inflate_1$2 = {
    	inflateReset: inflateReset_1,
    	inflateReset2: inflateReset2_1,
    	inflateResetKeep: inflateResetKeep_1,
    	inflateInit: inflateInit_1,
    	inflateInit2: inflateInit2_1,
    	inflate: inflate_2$1,
    	inflateEnd: inflateEnd_1,
    	inflateGetHeader: inflateGetHeader_1,
    	inflateSetDictionary: inflateSetDictionary_1,
    	inflateInfo: inflateInfo
    };

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    function GZheader() {
      /* true if compressed data believed to be text */
      this.text       = 0;
      /* modification time */
      this.time       = 0;
      /* extra flags (not used when writing a gzip file) */
      this.xflags     = 0;
      /* operating system */
      this.os         = 0;
      /* pointer to extra field or Z_NULL if none */
      this.extra      = null;
      /* extra field length (valid if extra != Z_NULL) */
      this.extra_len  = 0; // Actually, we don't need it in JS,
                           // but leave for few code modifications

      //
      // Setup limits is not necessary because in js we should not preallocate memory
      // for inflate use constant limit in 65536 bytes
      //

      /* space at extra (only when reading header) */
      // this.extra_max  = 0;
      /* pointer to zero-terminated file name or Z_NULL */
      this.name       = '';
      /* space at name (only when reading header) */
      // this.name_max   = 0;
      /* pointer to zero-terminated comment or Z_NULL */
      this.comment    = '';
      /* space at comment (only when reading header) */
      // this.comm_max   = 0;
      /* true if there was or will be a header crc */
      this.hcrc       = 0;
      /* true when done reading gzip header (not used when writing a gzip file) */
      this.done       = false;
    }

    var gzheader = GZheader;

    const toString = Object.prototype.toString;

    /* Public constants ==========================================================*/
    /* ===========================================================================*/

    const {
      Z_NO_FLUSH, Z_FINISH,
      Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
    } = constants$2;

    /* ===========================================================================*/


    /**
     * class Inflate
     *
     * Generic JS-style wrapper for zlib calls. If you don't need
     * streaming behaviour - use more simple functions: [[inflate]]
     * and [[inflateRaw]].
     **/

    /* internal
     * inflate.chunks -> Array
     *
     * Chunks of output data, if [[Inflate#onData]] not overridden.
     **/

    /**
     * Inflate.result -> Uint8Array|String
     *
     * Uncompressed result, generated by default [[Inflate#onData]]
     * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
     * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
     **/

    /**
     * Inflate.err -> Number
     *
     * Error code after inflate finished. 0 (Z_OK) on success.
     * Should be checked if broken data possible.
     **/

    /**
     * Inflate.msg -> String
     *
     * Error message, if [[Inflate.err]] != 0
     **/


    /**
     * new Inflate(options)
     * - options (Object): zlib inflate options.
     *
     * Creates new inflator instance with specified params. Throws exception
     * on bad params. Supported options:
     *
     * - `windowBits`
     * - `dictionary`
     *
     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
     * for more information on these.
     *
     * Additional options, for internal needs:
     *
     * - `chunkSize` - size of generated data chunks (16K by default)
     * - `raw` (Boolean) - do raw inflate
     * - `to` (String) - if equal to 'string', then result will be converted
     *   from utf8 to utf16 (javascript) string. When string output requested,
     *   chunk length can differ from `chunkSize`, depending on content.
     *
     * By default, when no options set, autodetect deflate/gzip data format via
     * wrapper header.
     *
     * ##### Example:
     *
     * ```javascript
     * const pako = require('pako')
     * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
     * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
     *
     * const inflate = new pako.Inflate({ level: 3});
     *
     * inflate.push(chunk1, false);
     * inflate.push(chunk2, true);  // true -> last chunk
     *
     * if (inflate.err) { throw new Error(inflate.err); }
     *
     * console.log(inflate.result);
     * ```
     **/
    function Inflate$1(options) {
      this.options = common.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ''
      }, options || {});

      const opt = this.options;

      // Force window size for `raw` data, if not set directly,
      // because we have no header for autodetect.
      if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) { opt.windowBits = -15; }
      }

      // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
      if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
          !(options && options.windowBits)) {
        opt.windowBits += 32;
      }

      // Gzip header has no info about windows size, we can do autodetect only
      // for deflate. So, if window size not set, force it to max when gzip possible
      if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
        // bit 3 (16) -> gzipped data
        // bit 4 (32) -> autodetect gzip/deflate
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }

      this.err    = 0;      // error code, if happens (0 = Z_OK)
      this.msg    = '';     // error message
      this.ended  = false;  // used to avoid multiple onEnd() calls
      this.chunks = [];     // chunks of compressed data

      this.strm   = new zstream();
      this.strm.avail_out = 0;

      let status  = inflate_1$2.inflateInit2(
        this.strm,
        opt.windowBits
      );

      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }

      this.header = new gzheader();

      inflate_1$2.inflateGetHeader(this.strm, this.header);

      // Setup dictionary
      if (opt.dictionary) {
        // Convert data if needed
        if (typeof opt.dictionary === 'string') {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) { //In raw mode we need to set the dictionary early
          status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== Z_OK) {
            throw new Error(messages[status]);
          }
        }
      }
    }

    /**
     * Inflate#push(data[, flush_mode]) -> Boolean
     * - data (Uint8Array|ArrayBuffer): input data
     * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
     *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
     *   `true` means Z_FINISH.
     *
     * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
     * new output chunks. Returns `true` on success. If end of stream detected,
     * [[Inflate#onEnd]] will be called.
     *
     * `flush_mode` is not needed for normal operation, because end of stream
     * detected automatically. You may try to use it for advanced things, but
     * this functionality was not tested.
     *
     * On fail call [[Inflate#onEnd]] with error code and return false.
     *
     * ##### Example
     *
     * ```javascript
     * push(chunk, false); // push one of data chunks
     * ...
     * push(chunk, true);  // push last chunk
     * ```
     **/
    Inflate$1.prototype.push = function (data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;

      if (this.ended) return false;

      if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
      else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

      // Convert data if needed
      if (toString.call(data) === '[object ArrayBuffer]') {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }

      strm.next_in = 0;
      strm.avail_in = strm.input.length;

      for (;;) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }

        status = inflate_1$2.inflate(strm, _flush_mode);

        if (status === Z_NEED_DICT && dictionary) {
          status = inflate_1$2.inflateSetDictionary(strm, dictionary);

          if (status === Z_OK) {
            status = inflate_1$2.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR) {
            // Replace code with more verbose
            status = Z_NEED_DICT;
          }
        }

        // Skip snyc markers if more data follows and not raw mode
        while (strm.avail_in > 0 &&
               status === Z_STREAM_END &&
               strm.state.wrap > 0 &&
               data[strm.next_in] !== 0)
        {
          inflate_1$2.inflateReset(strm);
          status = inflate_1$2.inflate(strm, _flush_mode);
        }

        switch (status) {
          case Z_STREAM_ERROR:
          case Z_DATA_ERROR:
          case Z_NEED_DICT:
          case Z_MEM_ERROR:
            this.onEnd(status);
            this.ended = true;
            return false;
        }

        // Remember real `avail_out` value, because we may patch out buffer content
        // to align utf8 strings boundaries.
        last_avail_out = strm.avail_out;

        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END) {

            if (this.options.to === 'string') {

              let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings.buf2string(strm.output, next_out_utf8);

              // move tail & realign counters
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

              this.onData(utf8str);

            } else {
              this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
            }
          }
        }

        // Must repeat iteration if out buffer is full
        if (status === Z_OK && last_avail_out === 0) continue;

        // Finalize if end of stream reached.
        if (status === Z_STREAM_END) {
          status = inflate_1$2.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }

        if (strm.avail_in === 0) break;
      }

      return true;
    };


    /**
     * Inflate#onData(chunk) -> Void
     * - chunk (Uint8Array|String): output data. When string output requested,
     *   each chunk will be string.
     *
     * By default, stores data blocks in `chunks[]` property and glue
     * those in `onEnd`. Override this handler, if you need another behaviour.
     **/
    Inflate$1.prototype.onData = function (chunk) {
      this.chunks.push(chunk);
    };


    /**
     * Inflate#onEnd(status) -> Void
     * - status (Number): inflate status. 0 (Z_OK) on success,
     *   other if not.
     *
     * Called either after you tell inflate that the input stream is
     * complete (Z_FINISH). By default - join collected chunks,
     * free memory and fill `results` / `err` properties.
     **/
    Inflate$1.prototype.onEnd = function (status) {
      // On success - join
      if (status === Z_OK) {
        if (this.options.to === 'string') {
          this.result = this.chunks.join('');
        } else {
          this.result = common.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };


    /**
     * inflate(data[, options]) -> Uint8Array|String
     * - data (Uint8Array): input data to decompress.
     * - options (Object): zlib inflate options.
     *
     * Decompress `data` with inflate/ungzip and `options`. Autodetect
     * format via wrapper header by default. That's why we don't provide
     * separate `ungzip` method.
     *
     * Supported options are:
     *
     * - windowBits
     *
     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
     * for more information.
     *
     * Sugar (options):
     *
     * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
     *   negative windowBits implicitly.
     * - `to` (String) - if equal to 'string', then result will be converted
     *   from utf8 to utf16 (javascript) string. When string output requested,
     *   chunk length can differ from `chunkSize`, depending on content.
     *
     *
     * ##### Example:
     *
     * ```javascript
     * const pako = require('pako');
     * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
     * let output;
     *
     * try {
     *   output = pako.inflate(input);
     * } catch (err) {
     *   console.log(err);
     * }
     * ```
     **/
    function inflate$1(input, options) {
      const inflator = new Inflate$1(options);

      inflator.push(input);

      // That will never happens, if you don't cheat with options :)
      if (inflator.err) throw inflator.msg || messages[inflator.err];

      return inflator.result;
    }


    /**
     * inflateRaw(data[, options]) -> Uint8Array|String
     * - data (Uint8Array): input data to decompress.
     * - options (Object): zlib inflate options.
     *
     * The same as [[inflate]], but creates raw data, without wrapper
     * (header and adler32 crc).
     **/
    function inflateRaw$1(input, options) {
      options = options || {};
      options.raw = true;
      return inflate$1(input, options);
    }


    /**
     * ungzip(data[, options]) -> Uint8Array|String
     * - data (Uint8Array): input data to decompress.
     * - options (Object): zlib inflate options.
     *
     * Just shortcut to [[inflate]], because it autodetects format
     * by header.content. Done for convenience.
     **/


    var Inflate_1$1 = Inflate$1;
    var inflate_2 = inflate$1;
    var inflateRaw_1$1 = inflateRaw$1;
    var ungzip$1 = inflate$1;
    var constants = constants$2;

    var inflate_1$1 = {
    	Inflate: Inflate_1$1,
    	inflate: inflate_2,
    	inflateRaw: inflateRaw_1$1,
    	ungzip: ungzip$1,
    	constants: constants
    };

    const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;

    const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;



    var Deflate_1 = Deflate;
    var deflate_1 = deflate;
    var deflateRaw_1 = deflateRaw;
    var gzip_1 = gzip;
    var Inflate_1 = Inflate;
    var inflate_1 = inflate;
    var inflateRaw_1 = inflateRaw;
    var ungzip_1 = ungzip;
    var constants_1 = constants$2;

    var pako = {
    	Deflate: Deflate_1,
    	deflate: deflate_1,
    	deflateRaw: deflateRaw_1,
    	gzip: gzip_1,
    	Inflate: Inflate_1,
    	inflate: inflate_1,
    	inflateRaw: inflateRaw_1,
    	ungzip: ungzip_1,
    	constants: constants_1
    };

    function GeoTerrainProvider(options) {
        options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
        if (!Cesium.defined(options.urls)) {
            throw new Cesium.DeveloperError('options.urls is required.');
        }
    	//dem数据类型，是int还是float。默认为int。
    	this._dataType = Cesium.defaultValue(options.dataType, GeoTerrainProvider.INT);

        this._urls = options.urls;
        this._urls_length = this._urls.length;
        this._url_i = 0;
        this._url_step = 0;
        this._maxTerrainLevel = options.maxTerrainLevel-1;
        //if (this._url.length > 0 && this._url[this._url.length - 1] !== '/') {
        //    this._url += '/';
        //}

        this._errorEvent = new Cesium.Event();
        this._ready = false;
        this._readyPromise = Cesium.when.defer();

        this._proxy = options.proxy;

        this._terrainDataStructure = {
                heightScale : 1.0 / 1000.0,
                heightOffset : -1000.0,
                elementsPerHeight : 3,
                stride : 4,
                elementMultiplier : 256.0,
                isBigEndian : true
            };

        var credit = options.credit;
        if (typeof credit === 'string') {
            credit = new Cesium.Credit(credit);
        }
        this._credit = credit;

        this._tilingScheme = undefined;
        this._rectangles = [];

        var ellipsoid = Cesium.defaultValue(options.ellipsoid, Cesium.Ellipsoid.WGS84);
    	this._tilingScheme = new Cesium.GeographicTilingScheme({ ellipsoid : ellipsoid });
        this._heightmapWidth = 64;//parseInt(tileFormat.getAttribute('width'), 10);
        this._heightmapHeight = 64;//parseInt(tileFormat.getAttribute('height'), 10);
        this._levelZeroMaximumGeometricError = Cesium.TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(ellipsoid, Math.min(this._heightmapWidth, this._heightmapHeight), this._tilingScheme.getNumberOfXTilesAtLevel(0));
        this._ready = true;
        this._readyPromise.resolve(true);
        this._name = options.name;
        this._opacity = options.opacity;
        this._maxExtent = options.maxExtent;
        this._topLevel = options.topLevel;
        this._bottomLevel = options.bottomLevel;
    }
    Object.defineProperties(GeoTerrainProvider.prototype, {
    	/**
    	    * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
    	    * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
    	    * are passed an instance of {@link TileProviderError}.
    	    * @memberof GeoTerrainProvider.prototype
    	    * @type {Event}
    	    */
    	errorEvent : {
    	    get : function() {
    	        return this._errorEvent;
    	    }
    	},
    	
    	/**
    	    * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
    	    * the source of the terrain.  This function should not be called before {@link GeoTerrainProvider#ready} returns true.
    	    * @memberof GeoTerrainProvider.prototype
    	    * @type {Credit}
    	    */
    	credit : {
    	    get : function() {
    	        return this._credit;
    	    }
    	},
    	
    	/**
    	    * Gets the tiling scheme used by this provider.  This function should
    	    * not be called before {@link GeoTerrainProvider#ready} returns true.
    	    * @memberof GeoTerrainProvider.prototype
    	    * @type {GeographicTilingScheme}
    	    */
    	tilingScheme : {
    	    get : function() {
    	        if (!this.ready) {
    	            throw new Cesium.DeveloperError('requestTileGeometry must not be called before ready returns true.');
    	        }
    	
    	        return this._tilingScheme;
    	    }
    	},
    	
    	/**
    	    * Gets a value indicating whether or not the provider is ready for use.
    	    * @memberof GeoTerrainProvider.prototype
    	    * @type {Boolean}
    	    */
    	ready : {
    	    get : function() {
    	        return this._ready;
    	    }
    	},
    	
    	/**
    	    * Gets a promise that resolves to true when the provider is ready for use.
    	    * @memberof GeoTerrainProvider.prototype
    	    * @type {Promise.<Boolean>}
    	    * @readonly
    	    */
    	readyPromise : {
    	    get : function() {
    	        return this._readyPromise.promise;
    	    }
    	},
    	
    	/**
    	    * Gets a value indicating whether or not the provider includes a water mask.  The water mask
    	    * indicates which areas of the globe are water rather than land, so they can be rendered
    	    * as a reflective surface with animated waves.  This function should not be
    	    * called before {@link GeoTerrainProvider#ready} returns true.
    	    * @memberof GeoTerrainProvider.prototype
    	    * @type {Boolean}
    	    */
    	hasWaterMask : {
    	    get : function() {
    	        return false;
    	    }
    	},
    	
    	/**
    	    * Gets a value indicating whether or not the requested tiles include vertex normals.
    	    * This function should not be called before {@link GeoTerrainProvider#ready} returns true.
    	    * @memberof GeoTerrainProvider.prototype
    	    * @type {Boolean}
    	    */
    	hasVertexNormals : {
    	    get : function() {
    	        return false;
    	    }
    	}
    });
    	
    	//zhangli,获取瓦片url
    GeoTerrainProvider.prototype.requestTileGeometry = function (x, y, level, request){
    	    //console.log("requestTileGeometry  x: %d;   y: %d ;   level: %d", x, y, level);
    	    if (!this.ready) {
    	        throw new Cesium.DeveloperError('requestTileGeometry must not be called before ready returns true.');
    	    }
    		 
    	    //urls个数大于1时
    		if(this._urls_length > 1){
    		 	//urlToUse = this._urls[0];
    		    //一个链接连续发8个请求，然后换下个链接
    		    if (this._url_step < 1) {
    		        this._url_step++;
    		    }
    		    else {
    		        this._url_step = 0;
    		        this._url_i++;
    		        if (this._url_i >= this._urls_length) {
    		            this._url_i = 0;
    		        }
    		    }
    		}
    	    var urlToUse = this._urls[this._url_i];
    	     
    	    var yTiles = this._tilingScheme.getNumberOfYTilesAtLevel(level);
    	    //var url = urlToUse + level + '/' + x + '/' + (yTiles - y - 1) + '.tif?cesium=true';
    	    if (level < 25 && level >= 2)//level === 2 ||level === 6 ||level === this._maxTerrainLevel || ((level>6)&&(level<this._maxTerrainLevel)&&((level-6)%3===0)))
    	    {
    		    var paramSplit = urlToUse.indexOf('?') === -1 ? '?' : '&';
    	        var url = urlToUse + paramSplit + 'x=' + x + '&y=' + y + '&l=' + (level + 1);//
    	        //console.log(url);
    	         
    	        //如果有代理，则加上代理地址
    	        var proxy = this._proxy;
    	        if (Cesium.defined(proxy)) {
    	            url = proxy.getURL(url);
    	        }
    	        //console.log("proxy url:" + url);
    	         
                var promise = loadZlibTerrain(url, request, this._dataType, this._heightmapWidth, this._heightmapHeight);

                if (!Cesium.defined(promise)) {
    	            return undefined;
    	        }
    			 
    	        var that = this;
                return Cesium.when(promise, function (vhBuffer){
    	            if (Cesium.defined(vhBuffer)) {
    	                var hmt = new Cesium.HeightmapTerrainData({
    	                    buffer: vhBuffer,
    	                    width: that._heightmapWidth,
    	                    height: that._heightmapHeight,
    	                    childTileMask: getChildMask(that, x, y, level),
    	                    structure: that._terrainDataStructure
    	                });
    	                hmt._skirtHeight = 6000;
    	                return hmt;
    	            }
    	            else {
    	                return undefined;
    	            }
    	        });
    	    }
    	    else 
    	        if (level < 2) {
    	            var vStructure = this._terrainDataStructure;
    	            return new Cesium.HeightmapTerrainData({
    	                buffer: this.getvHeightBuffer(),
                        width: this._heightmapWidth,
                        height: this._heightmapHeight,
                        childTileMask: getChildMask(this, x, y, level),
    	                structure: vStructure
    	            });
    	        }
    	        else {
    	            return undefined;
    	        }
    	};
    	 
    /**
    	* Gets the maximum geometric error allowed in a tile at a given level.
    	*
    	* @param {Number} level The tile level for which to get the maximum geometric error.
    	* @returns {Number} The maximum geometric error.
    	*/
    GeoTerrainProvider.prototype.getLevelMaximumGeometricError = function(level){
    	if (!this.ready) {
    	    throw new Cesium.DeveloperError('requestTileGeometry must not be called before ready returns true.');
    	}
    	return this._levelZeroMaximumGeometricError / (1 << level);
    };
    /**
    	* Determines whether data for a tile is available to be loaded.
    	*
    	* @param {Number} x The X coordinate of the tile for which to request geometry.
    	* @param {Number} y The Y coordinate of the tile for which to request geometry.
    	* @param {Number} level The level of the tile for which to request geometry.
    	* @returns {Boolean} Undefined if not supported, otherwise true or false.
    	*/
    GeoTerrainProvider.prototype.getTileDataAvailable = function(x, y, level){
    	if (level < 25) {
    	    return true;
    	}
    	return undefined;
    };
    	
    GeoTerrainProvider.prototype.getvHeightBuffer = function(){
    	var vHeightBuffer = this._vHeightBuffer;
    	if (!Cesium.defined(vHeightBuffer)) {
    	    vHeightBuffer = new Uint8ClampedArray(this._heightmapWidth * this._heightmapHeight * 4);
    	    for (var i = 0; i < this._heightmapWidth * this._heightmapHeight * 4;) {
    	        vHeightBuffer[i++] = 15;
    	        vHeightBuffer[i++] = 66;
    	        vHeightBuffer[i++] = 64;
    	        vHeightBuffer[i++] = 255;
    	    }
    		this._vHeightBuffer = vHeightBuffer;
    	}
    	return vHeightBuffer;
    };
    	
    //转换buffer数据
    function transformBuffer(zlibData, dataType, width, height) {
        if (!Cesium.defined(zlibData))
            return new Uint8Array(width * height * 4);
    	//this._dataType是int还是float，控制方法交给用户
    	//int时  DataSize=2；
    	//float时  DataSize=4；
        var DataSize = dataType === GeoTerrainProvider.INT ? 2 : 4;
    	var dZlib = zlibData;
    	if (dZlib.length === 150 * 150 * DataSize) {
    	    
    	    //创建四字节数组
    	    var height_buffer = new ArrayBuffer(DataSize);
    	    //创建DateView
    	    var height_view = new DataView(height_buffer);
    	        
            var myW = width;
            var myH = height;
    	    var myBuffer = new Uint8Array(myW * myH * 4);
    	        
    	    var i_height;
    	    var NN, NN_R;
    	    var jj_n, ii_n;
    	    for (var jj = 0; jj < myH; jj++) {
    	        for (var ii = 0; ii < myW; ii++) {
    	            jj_n = parseInt((149 * jj) / (myH - 1));
    	            ii_n = parseInt((149 * ii) / (myW - 1));
    	                
    	            //如果是float型使用dataview帮忙解析
    	            if (DataSize === 4) {
    	                NN = DataSize * (jj_n * 150 + ii_n);
    	                height_view.setInt8(0, dZlib[NN]);
    	                height_view.setInt8(1, dZlib[NN + 1]);
    	                height_view.setInt8(2, dZlib[NN + 2]);
    	                height_view.setInt8(3, dZlib[NN + 3]);
    	                i_height = height_view.getFloat32(0, true);
    	                    
    	            }
    	            else //int型也可以使用dataview解析，以后可以改掉
    	            {
    	                //NN = DataSize * (jj * 150 + ii);
    	                NN = DataSize * (jj_n * 150 + ii_n);
    	                i_height = dZlib[NN] + (dZlib[NN + 1] * 256);
    	            }
    	                
    	            //定个范围，在地球上高程应都在-1000——10000之间
    	            if (i_height > 10000 || i_height < -2000) {
    	                i_height = 0;
    	            }
    	            /*
    	                NN = 2 * (jj_n * 150 + ii_n);
    	                //NN = 2 * (jj * 150 + ii);
    	                i_height = dZlib[NN] + (dZlib[NN + 1] * 256);
    	                if (i_height > 10000 || i_height < 0) {
    	                i_height = 0;
    	                }
    	                */
    	            //数据结果整理成Cesium内部形式
    	            NN_R = (jj * myW + ii) * 4;
    	            //Cesium内部就是这么表示的
    	            var i_height_new = (i_height + 1000) / 0.001;
    	            myBuffer[NN_R] = i_height_new / (256 * 256);
    	            myBuffer[NN_R + 1] = (i_height_new - myBuffer[NN_R] * 256 * 256) / 256;
    	            myBuffer[NN_R + 2] = i_height_new - myBuffer[NN_R] * 256 * 256 - myBuffer[NN_R + 1] * 256;
    	            myBuffer[NN_R + 3] = 255;
    	        }
    	    }
    	    return myBuffer;
    	}
    	else {
    		return null;
    	}
    }	
    function loadZlibTerrain(url, request, dataType, width, height) {
    	request.url = url;
        request.requestFunction = function() {
            var deferred = Cesium.when.defer();
            var resource = Cesium.Resource.createIfNeeded(url);
            resource.fetchArrayBuffer().then(function (array) {
                var zBuffer = new Uint8Array(array);
                var dZlib = decZlibBuffer(zBuffer);
                if (Cesium.defined(dZlib)) {
                    var heightValue = transformBuffer(dZlib, dataType, width, height);
                    deferred.resolve(heightValue);
                } else {
                    deferred.reject(undefined);
                }
            });
            return deferred.promise;
        };
        return Cesium.RequestScheduler.request(request);
    }
    	
    //解压数据
    function decZlibBuffer(zBuffer) {
    	if (zBuffer.length < 1000) {
    	    return undefined;
    	}
        try {
            return pako.inflate(zBuffer);
            // var inflate = new Zlib.Inflate(zBuffer);
            // if (Cesium.defined(inflate)) {
            //     return inflate.decompress();
            // }
            // else {
            //     return undefined;
            // }
        }
        catch (ex) {
            return undefined;
        }

    }
    	 
    function getChildMask(provider, x, y, level){
    	var rectangleScratch = new Cesium.Rectangle();
    	var tilingScheme = provider._tilingScheme;
    	var rectangles = provider._rectangles;
    	var parentRectangle = tilingScheme.tileXYToRectangle(x, y, level);
    	    
    	var childMask = 0;
    	    
    	for (var i = 0; i < rectangles.length && childMask !== 15; ++i) {
    	    var rectangle = rectangles[i];
    	    if (rectangle.maxLevel <= level) {
    	        continue;
    	    }
    	        
    	    var testRectangle = rectangle.rectangle;
    	        
    	    var intersection = Cesium.Rectangle.intersection(testRectangle, parentRectangle, rectangleScratch);
    	    if (Cesium.defined(intersection)) {
    	        // Parent tile is inside this rectangle, so at least one child is, too.
    	        if (isTileInRectangle(tilingScheme, testRectangle, x * 2, y * 2, level + 1)) {
    	            childMask |= 4; // northwest
    	        }
    	        if (isTileInRectangle(tilingScheme, testRectangle, x * 2 + 1, y * 2, level + 1)) {
    	            childMask |= 8; // northeast
    	        }
    	        if (isTileInRectangle(tilingScheme, testRectangle, x * 2, y * 2 + 1, level + 1)) {
    	            childMask |= 1; // southwest
    	        }
    	        if (isTileInRectangle(tilingScheme, testRectangle, x * 2 + 1, y * 2 + 1, level + 1)) {
    	            childMask |= 2; // southeast
    	        }
    	    }
    	}
    	return childMask;
    }
    	
    function isTileInRectangle(tilingScheme, rectangle, x, y, level) {
    	var rectangleScratch = new Cesium.Rectangle();
    	var tileRectangle = tilingScheme.tileXYToRectangle(x, y, level);
    	return Cesium.defined(Cesium.Rectangle.intersection(tileRectangle, rectangle, rectangleScratch));
    }
    	
    GeoTerrainProvider.INT = "int";
    GeoTerrainProvider.FLOAT = "float";

    var PERSPECTIVE = 0;
    var ORTHOGRAPHIC = 1;

    var scratchInverseMatrix;

    var scratchXDirection;
    var scratchYDirection;
    var scratchZDirection;
    var scratchNegativeX;
    var scratchNegativeY;
    var scratchNegativeZ;
    var frustumSplits;
    var frustumCornersNDC;
    var scratchFrustumCorners;

    function SimpleDrawFrustum(options) {
      scratchInverseMatrix = new Cesium.Matrix4();
      scratchXDirection = new Cesium.Cartesian3();
      scratchYDirection = new Cesium.Cartesian3();
      scratchZDirection = new Cesium.Cartesian3();
      scratchNegativeX = new Cesium.Cartesian3();
      scratchNegativeY = new Cesium.Cartesian3();
      scratchNegativeZ = new Cesium.Cartesian3();
      frustumSplits = new Array(3);
      frustumCornersNDC = new Array(4);
      frustumCornersNDC[0] = new Cesium.Cartesian4(-1.0, -1.0, 1.0, 1.0);
      frustumCornersNDC[1] = new Cesium.Cartesian4(1.0, -1.0, 1.0, 1.0);
      frustumCornersNDC[2] = new Cesium.Cartesian4(1.0, 1.0, 1.0, 1.0);
      frustumCornersNDC[3] = new Cesium.Cartesian4(-1.0, 1.0, 1.0, 1.0);
      scratchFrustumCorners = new Array(4);
      for (var i = 0; i < 4; ++i) {
        scratchFrustumCorners[i] = new Cesium.Cartesian4();
      }

      Cesium.Check.typeOf.object("options", options);
      Cesium.Check.typeOf.object("options.frustum", options.frustum);
      Cesium.Check.typeOf.object("options.origin", options.origin);
      Cesium.Check.typeOf.object("options.orientation", options.orientation);
      //>>includeEnd('debug');

      var frustum = options.frustum;
      var orientation = options.orientation;
      var origin = options.origin;

      // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by
      // creating multiple FrustumGeometrys. This way the near plane of one frustum doesn't overlap
      // the far plane of another.
      var drawNearPlane = Cesium.defaultValue(options._drawNearPlane, true);

      var frustumType;
      var frustumPackedLength;
      if (frustum instanceof Cesium.PerspectiveFrustum) {
        frustumType = PERSPECTIVE;
        frustumPackedLength = Cesium.PerspectiveFrustum.packedLength;
      } else if (frustum instanceof Cesium.OrthographicFrustum) {
        frustumType = ORTHOGRAPHIC;
        frustumPackedLength = Cesium.OrthographicFrustum.packedLength;
      }

      this._frustumType = frustumType;
      this._frustum = frustum.clone();
      this._origin = Cesium.Cartesian3.clone(origin);
      this._orientation = Cesium.Quaternion.clone(orientation);
      this._drawNearPlane = drawNearPlane;
      this._vertexFormat = Cesium.VertexFormat;

      this.packedLength =
        2 +
        frustumPackedLength +
        Cesium.Cartesian3.packedLength +
        Cesium.Quaternion.packedLength +
        Cesium.VertexFormat.packedLength;
    }

    SimpleDrawFrustum.pack = function (value, array, startingIndex) {
      Cesium.Check.typeOf.object("value", value);
      Cesium.Check.Cesium.defined("array", array);

      startingIndex = Cesium.defaultValue(startingIndex, 0);

      var frustumType = value._frustumType;
      var frustum = value._frustum;

      array[startingIndex++] = frustumType;

      if (frustumType === PERSPECTIVE) {
        Cesium.PerspectiveFrustum.pack(frustum, array, startingIndex);
        startingIndex += Cesium.PerspectiveFrustum.packedLength;
      } else {
        Cesium.OrthographicFrustum.pack(frustum, array, startingIndex);
        startingIndex += Cesium.OrthographicFrustum.packedLength;
      }

      Cesium.Cartesian3.pack(value._origin, array, startingIndex);
      startingIndex += Cesium.Cartesian3.packedLength;
      Cesium.Quaternion.pack(value._orientation, array, startingIndex);
      startingIndex += Cesium.Quaternion.packedLength;
      Cesium.VertexFormat.pack(value._vertexFormat, array, startingIndex);
      startingIndex += Cesium.VertexFormat.packedLength;
      array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;

      return array;
    };


    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {SimpleDrawFrustum} [result] The object into which to store the result.
     */
    SimpleDrawFrustum.unpack = function (array, startingIndex, result) {
      
      var scratchPackPerspective = new Cesium.PerspectiveFrustum();
      var scratchPackOrthographic = new Cesium.OrthographicFrustum();
      var scratchPackQuaternion = new Cesium.Quaternion();
      var scratchPackorigin = new Cesium.Cartesian3();
      var scratchVertexFormat = new Cesium.VertexFormat();


      startingIndex = Cesium.defaultValue(startingIndex, 0);

      var frustumType = array[startingIndex++];

      var frustum;
      if (frustumType === PERSPECTIVE) {
        frustum = Cesium.PerspectiveFrustum.unpack(
          array,
          startingIndex,
          scratchPackPerspective
        );
        startingIndex += Cesium.PerspectiveFrustum.packedLength;
      } else {
        frustum = Cesium.OrthographicFrustum.unpack(
          array,
          startingIndex,
          scratchPackOrthographic
        );
        startingIndex += Cesium.OrthographicFrustum.packedLength;
      }

      var origin = Cesium.Cartesian3.unpack(array, startingIndex, scratchPackorigin);
      startingIndex += Cesium.Cartesian3.packedLength;
      var orientation = Cesium.Quaternion.unpack(
        array,
        startingIndex,
        scratchPackQuaternion
      );
      startingIndex += Cesium.Quaternion.packedLength;
      var VertexFormat = Cesium.VertexFormat.unpack(
        array,
        startingIndex,
        scratchVertexFormat
      );
      startingIndex += Cesium.VertexFormat.packedLength;
      var drawNearPlane = array[startingIndex] === 1.0;

      if (!Cesium.defined(result)) {
        return new SimpleDrawFrustum({
          frustum: frustum,
          origin: origin,
          orientation: orientation,
          VertexFormat: Cesium.VertexFormat,
          _drawNearPlane: drawNearPlane,
        });
      }

      var frustumResult =
        frustumType === result._frustumType ? result._frustum : undefined;
      result._frustum = frustum.clone(frustumResult);

      result._frustumType = frustumType;
      result._origin = Cesium.Cartesian3.clone(origin, result._origin);
      result._orientation = Cesium.Quaternion.clone(orientation, result._orientation);
      result._vertexFormat = Cesium.VertexFormat.clone(Cesium.VertexFormat, result._vertexFormat);
      result._drawNearPlane = drawNearPlane;

      return result;
    };

    function getAttributes(
      offset,
      normals,
      tangents,
      bitangents,
      st,
      normal,
      tangent,
      bitangent
    ) {
      var stOffset = (offset / 3) * 2;

      for (var i = 0; i < 4; ++i) {
        if (Cesium.defined(normals)) {
          normals[offset] = normal.x;
          normals[offset + 1] = normal.y;
          normals[offset + 2] = normal.z;
        }
        if (Cesium.defined(tangents)) {
          tangents[offset] = tangent.x;
          tangents[offset + 1] = tangent.y;
          tangents[offset + 2] = tangent.z;
        }
        if (Cesium.defined(bitangents)) {
          bitangents[offset] = bitangent.x;
          bitangents[offset + 1] = bitangent.y;
          bitangents[offset + 2] = bitangent.z;
        }
        offset += 3;
      }

      st[stOffset] = 0.0;
      st[stOffset + 1] = 0.0;
      st[stOffset + 2] = 1.0;
      st[stOffset + 3] = 0.0;
      st[stOffset + 4] = 1.0;
      st[stOffset + 5] = 1.0;
      st[stOffset + 6] = 0.0;
      st[stOffset + 7] = 1.0;
    }

    SimpleDrawFrustum.computeNearFarPlanes = function (
      origin,
      orientation,
      frustumType,
      frustum,
      positions,
      xDirection,
      yDirection,
      zDirection
    ) {
      var scratchRotationMatrix = new Cesium.Matrix3();
      var rotationMatrix = Cesium.Matrix3.fromQuaternion(
        orientation,
        scratchRotationMatrix
      );
      var x = Cesium.defaultValue(xDirection, scratchXDirection);
      var y = Cesium.defaultValue(yDirection, scratchYDirection);
      var z = Cesium.defaultValue(zDirection, scratchZDirection);

      x = Cesium.Matrix3.getColumn(rotationMatrix, 0, x);
      y = Cesium.Matrix3.getColumn(rotationMatrix, 1, y);
      z = Cesium.Matrix3.getColumn(rotationMatrix, 2, z);

      Cesium.Cartesian3.normalize(x, x);
      Cesium.Cartesian3.normalize(y, y);
      Cesium.Cartesian3.normalize(z, z);

      Cesium.Cartesian3.negate(x, x);

      var scratchViewMatrix = new Cesium.Matrix4();
      var view = Cesium.Matrix4.computeView(origin, z, y, x, scratchViewMatrix);

      var inverseView;
      var inverseViewProjection;
      if (frustumType === PERSPECTIVE) {
        var projection = frustum.projectionMatrix;
        var viewProjection = Cesium.Matrix4.multiply(
          projection,
          view,
          scratchInverseMatrix
        );
        inverseViewProjection = Cesium.Matrix4.inverse(
          viewProjection,
          scratchInverseMatrix
        );
      } else {
        inverseView = Cesium.Matrix4.inverseTransformation(view, scratchInverseMatrix);
      }

      if (Cesium.defined(inverseViewProjection)) {
        frustumSplits[0] = frustum.near;
        frustumSplits[1] = frustum.far;
      } else {
        frustumSplits[0] = 0.0;
        frustumSplits[1] = frustum.near;
        frustumSplits[2] = frustum.far;
      }

      for (var i = 0; i < 2; ++i) {
        for (var j = 0; j < 4; ++j) {
          var corner = Cesium.Cartesian4.clone(
            frustumCornersNDC[j],
            scratchFrustumCorners[j]
          );

          if (!Cesium.defined(inverseViewProjection)) {
            if (Cesium.defined(frustum._offCenterFrustum)) {
              frustum = frustum._offCenterFrustum;
            }

            var near = frustumSplits[i];
            var far = frustumSplits[i + 1];

            corner.x =
              (corner.x * (frustum.right - frustum.left) +
                frustum.left +
                frustum.right) *
              0.5;
            corner.y =
              (corner.y * (frustum.top - frustum.bottom) +
                frustum.bottom +
                frustum.top) *
              0.5;
            corner.z = (corner.z * (near - far) - near - far) * 0.5;
            corner.w = 1.0;

            Cesium.Matrix4.multiplyByVector(inverseView, corner, corner);
          } else {
            corner = Cesium.Matrix4.multiplyByVector(
              inverseViewProjection,
              corner,
              corner
            );

            // Reverse perspective divide
            var w = 1.0 / corner.w;
            Cesium.Cartesian3.multiplyByScalar(corner, w, corner);

            Cesium.Cartesian3.subtract(corner, origin, corner);
            Cesium.Cartesian3.normalize(corner, corner);

            var fac = Cesium.Cartesian3.dot(z, corner);
            Cesium.Cartesian3.multiplyByScalar(corner, frustumSplits[i] / fac, corner);
            Cesium.Cartesian3.add(corner, origin, corner);
          }

          positions[12 * i + j * 3] = corner.x;
          positions[12 * i + j * 3 + 1] = corner.y;
          positions[12 * i + j * 3 + 2] = corner.z;
        }
      }
    };

    SimpleDrawFrustum.createGeometry = function (simpleDrawFrustum) {
      var frustumType = simpleDrawFrustum._frustumType;
      var frustum = simpleDrawFrustum._frustum;
      var origin = simpleDrawFrustum._origin;
      var orientation = simpleDrawFrustum._orientation;
      var drawNearPlane = simpleDrawFrustum._drawNearPlane;
      var VertexFormat = simpleDrawFrustum._vertexFormat;

      var numberOfPlanes = drawNearPlane ? 1 : 5;
      var positions = new Float64Array(3 * 4 * 6);
      SimpleDrawFrustum.computeNearFarPlanes(
        origin,
        orientation,
        frustumType,
        frustum,
        positions
      );

      // -x plane
      var offset = 3 * 4 * 2;
      positions[offset] = positions[3 * 4];
      positions[offset + 1] = positions[3 * 4 + 1];
      positions[offset + 2] = positions[3 * 4 + 2];
      positions[offset + 3] = positions[0];
      positions[offset + 4] = positions[1];
      positions[offset + 5] = positions[2];
      positions[offset + 6] = positions[3 * 3];
      positions[offset + 7] = positions[3 * 3 + 1];
      positions[offset + 8] = positions[3 * 3 + 2];
      positions[offset + 9] = positions[3 * 7];
      positions[offset + 10] = positions[3 * 7 + 1];
      positions[offset + 11] = positions[3 * 7 + 2];
      positions = positions.subarray(0, 12);

      var attributes = new Cesium.GeometryAttributes({
        position: new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.DOUBLE,
          componentsPerAttribute: 3,
          values: positions,
        }),
      });

    //   if (
    //     Cesium.defined(VertexFormat.normal) ||
    //     Cesium.defined(VertexFormat.tangent) ||
    //     Cesium.defined(VertexFormat.bitangent) ||
    //     Cesium.defined(VertexFormat.st)
    //   ) 
      {
        var normals = new Float32Array(3 * 4 * numberOfPlanes);
        var tangents = new Float32Array(3 * 4 * numberOfPlanes);
        var bitangents = new Float32Array(3 * 4 * numberOfPlanes);
        var st = new Float32Array(2 * 4 * numberOfPlanes);

        var x = scratchXDirection;
        var y = scratchYDirection;
        var z = scratchZDirection;

        var negativeZ = Cesium.Cartesian3.negate(z, scratchNegativeZ);

        offset = 0;
        getAttributes(offset, normals, tangents, bitangents, st, negativeZ, x, y); // near
        offset += 3 * 4;

        // if (Cesium.defined(st)) 
        {
          attributes.st = new Cesium.GeometryAttribute({
            componentDatatype: Cesium.ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: st,
          });
        }
      }

      var indices = new Uint16Array(6 * numberOfPlanes);
      for (var i = 0; i < numberOfPlanes; ++i) {
        var indexOffset = i * 6;
        var index = i * 4;

        indices[indexOffset] = index;
        indices[indexOffset + 1] = index + 1;
        indices[indexOffset + 2] = index + 2;
        indices[indexOffset + 3] = index;
        indices[indexOffset + 4] = index + 2;
        indices[indexOffset + 5] = index + 3;
      }

      return new Cesium.Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: Cesium.PrimitiveType.TRIANGLES,
        boundingSphere: Cesium.BoundingSphere.fromVertices(positions),
      });
    };

    function styleInject(css, ref) {
      if ( ref === void 0 ) ref = {};
      var insertAt = ref.insertAt;

      if (!css || typeof document === 'undefined') { return; }

      var head = document.head || document.getElementsByTagName('head')[0];
      var style = document.createElement('style');
      style.type = 'text/css';

      if (insertAt === 'top') {
        if (head.firstChild) {
          head.insertBefore(style, head.firstChild);
        } else {
          head.appendChild(style);
        }
      } else {
        head.appendChild(style);
      }

      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(document.createTextNode(css));
      }
    }

    var css_248z = ".twipsy {\r\n    display: block;\r\n    position: absolute;\r\n    top: 0;\r\n    visibility: visible;\r\n    max-width: 200px;\r\n    min-width: 100px;\r\n    padding: 5px;\r\n    font-size: 11px;\r\n    z-index: 1000;\r\n    opacity: 0.8;\r\n    -khtml-opacity: 0.8;\r\n    -moz-opacity: 0.8;\r\n    filter: alpha(opacity=80);\r\n    pointer-events: none;\r\n}\r\n\r\n.twipsy.top .twipsy-arrow { \r\n    bottom: 0; \r\n    left: 50%; \r\n    margin-left: -5px; \r\n    border-left: 5px solid transparent; \r\n    border-right: 5px solid transparent; \r\n    border-top: 5px solid #000000; \r\n} \r\n.twipsy.left .twipsy-arrow {\r\n    top: 50%;\r\n    right: 0;\r\n    margin-top: -5px;\r\n    border-top: 5px solid transparent;\r\n    border-bottom: 5px solid transparent;\r\n    border-left: 5px solid #000000;\r\n}\r\n.twipsy.bottom .twipsy-arrow { \r\n    top: 0; \r\n    left: 50%; \r\n    margin-left: -5px; \r\n    border-left: 5px solid transparent; \r\n    border-right: 5px solid transparent; \r\n    border-bottom: 5px solid #000000; \r\n} \r\n.twipsy.right .twipsy-arrow {\r\n    top: 50%;\r\n    left: 0;\r\n    margin-top: -5px;\r\n    border-top: 5px solid transparent;\r\n    border-bottom: 5px solid transparent;\r\n    border-right: 5px solid #000000;\r\n}\r\n.twipsy-inner {\r\n    padding: 3px 8px;\r\n    background-color: #000000;\r\n    color: white;\r\n    text-align: center;\r\n    max-width: 200px;\r\n    text-decoration: none;\r\n    -webkit-border-radius: 4px;\r\n    -moz-border-radius: 4px;\r\n    border-radius: 4px;\r\n}\r\n.twipsy-arrow {\r\n    position: absolute;\r\n    width: 0;\r\n    height: 0;\r\n}\r\n";
    styleInject(css_248z);

    var Tooltip = function (options) {
        this._visible = false;
        if (!Cesium.defined(options)) {
            options = {};
        }
        this.align = Cesium.defaultValue(options.align, 'right');
        if (!Cesium.defined(options.container)) {
            options = {};
        }
    };

    Object.defineProperties(Tooltip.prototype, {
        target: {
            get: function () {
                return this._target;
            },
        },
        content: {
            set: function (value) {
                if (Cesium.defined(this._target)) {
                    this._target.lastElementChild.innerHTML = value;
                }
            }
        },
        visible: {
            get: function () {
                return this._visible;
            },
            set: function (value) {
                if (Cesium.defined(this._target) && this._visible !== value) {
                    this._visible = value;
                    this._target.style.display = value ? 'block' : 'none';
                }
            }
        },
    });


    Tooltip.prototype.createGraph = function (container, earthPin) {
        this._target = Tooltip.createWrapNode(this.align);
        if (Cesium.defined(container)) {
            container.appendChild(this._target);
        }
        if (Cesium.defined(earthPin)) {
            this.content = earthPin.content;
        }
        return this._target;
    };

    Tooltip.createWrapNode = function (align) {
        var div = document.createElement('DIV');
        div.className = "twipsy " + align;

        var arrow = document.createElement('DIV');
        arrow.className = "twipsy-arrow";
        div.appendChild(arrow);

        var title = document.createElement('DIV');
        title.className = "twipsy-inner";
        div.appendChild(title);

        div.style.display = 'none';

        return div;
    };

    Tooltip.prototype.showAt = function (position, message) {
        if (message) {
            this.content = message;
        }
        if (position) {
            this.visible = true;
            var left;
            var top;
            if (this.align === 'bottom') {
                left = position.x - this.target.clientWidth * 0.5;
                top = position.y;
            } else if (this.align === 'top') {
                left = position.x - this.target.clientWidth * 0.5;
                top = position.y - this.target.clientHeight;
            } else if (this.align === 'left') {
                left = position.x - this.target.clientWidth - 10;
                top = position.y - this.target.clientHeight * 0.5;
            } else {
                left = position.x + 10;
                top = position.y - this.target.clientHeight * 0.5;
            }

            this.target.style.left = left + "px";
            this.target.style.top = top + "px";
        }
    };

    Tooltip.prototype.isDestroyed = function () {
        return false;
    };

    Tooltip.prototype.destroy = function () {
        if (Cesium.defined(this._target)) {
            this._target.remove();
        }
        return Cesium.destroyObject(this);
    };

    function EditablePoint(){
        this._collection = new Cesium.PointPrimitiveCollection();
        this._postionChangedEvent = new Cesium.Event();
        this._removeEventSubscription = this._postionChangedEvent.addEventListener(
            EditablePoint.prototype._onPostionChanged,
            this
        );

        this._height = 0.0;
        this._scaleHeight = 0.0;
        this._scaleIndex = -1;
        this._tip = undefined;
        this._tooltip = undefined;
    }

    Object.defineProperties(EditablePoint.prototype, {
        position: {
            set: function (value) {
                if(!Cesium.defined(this._point)){
                    this._point = this._collection.add(
                        {
                            color : Cesium.Color.WHITE,
                            outlineWidth : 1.0,
                            outlineColor: Cesium.Color.BLACK,
                            pixelSize : 4,
                            id: this,
                            disableDepthTestDistance: Number.POSITIVE_INFINITY
                        }
                    );
                }
                this._point.position = value;
            },
        },
        heightPointPosition: {
            set: function (value) {
                if(!Cesium.defined(this._pointHeight)){
                    this._pointHeight = this._collection.add(
                        {
                            color : Cesium.Color.WHITE,
                            outlineWidth : 1.0,
                            outlineColor: Cesium.Color.BLACK,
                            pixelSize : 4,
                            id: this,
                            disableDepthTestDistance: Number.POSITIVE_INFINITY
                        }
                    );

                    this._scaleIndex = this._pointHeight._index;
                }
                this._pointHeight.position = value;
            },
            get: function(){
                return this._pointHeight.position;
            }
        },
        extent: {
            set: function (value) {
               this._extent = value;
            },
        },
        height: {
            get: function () {
               return this._height;
            },
            set: function (value) {
               this._height = value;
            },
        },
        tip: {
            get: function () {
               return this._tip;
            },
            set: function (value) {
               this._tip = value;
            },
        },
        scaleHeight: {
            get: function () {
               return this._scaleHeight;
            },
            set: function (value) {
               if(this._scaleHeight !== value){
                    this._scaleHeight = value;
                    this.updateHeightScale();
               }
            },
        },
        ratioHeight: {
            get: function () {
               return this.scaleHeight * this.height;
            }
        },
    });

    EditablePoint.prototype.getTip = function (container) {
        if(!Cesium.defined(this._tooltip)){
            this._tooltip = new Tooltip();
            this._tooltip.createGraph(container);
        }
        return this._tooltip;
    };

    EditablePoint.prototype.isHeightPoint = function (primitive) {
        return this._scaleIndex === primitive._index;
    };

    EditablePoint.prototype._onPostionChanged = function (
        entity,
        propertyName,
        newValue,
        oldValue
    ) {
        if(propertyName === 'onPostionChanged' && Cesium.defined(this.onPostionChanged)){
            this.onPostionChanged(
                entity,
                propertyName,
                newValue,
                oldValue
            );
        }else if(propertyName === 'onHeightChanged' && Cesium.defined(this.onHeightChanged)){
            this.onHeightChanged(
                entity,
                propertyName,
                newValue,
                oldValue
            );
        }
    };
        
    EditablePoint.prototype.updateHeightScale = function () {
        if(!Cesium.defined(this._pointHeight)){
            return;
        }
        
        var cartographic = Cesium.Cartographic.fromCartesian(this.heightPointPosition);
        cartographic.height = this._scaleHeight * this.height;
        this.heightPointPosition = Cesium.Cartesian3.fromRadians(cartographic.longitude,cartographic.latitude,cartographic.height);
        this._postionChangedEvent.raiseEvent(this, "onHeightChanged",cartographic.height,'');
    };

    EditablePoint.prototype.updateCartesian = function (cartesian) {
        if(!Cesium.defined(this._point)){
            return;
        }

        if(Cesium.defined(this._extent)){
            var cartographic = Cesium.Cartographic.fromCartesian(cartesian);
            if(cartographic.longitude < this._extent.west ||
                cartographic.longitude > this._extent.east ||
                cartographic.latitude < this._extent.south ||
                cartographic.latitude > this._extent.north){
                    return;
            }
        }
        this._point.position = cartesian;
        this._postionChangedEvent.raiseEvent(this, "onPostionChanged",cartesian,'');
    };

    EditablePoint.prototype.onHighlight = function (index) {
        if(Cesium.defined(index) && index < this._collection.length){
            this._collection.get(index).color = Cesium.Color.AQUA;
        }
        else {
            var i = 0;
            for(;i<this._collection.length;i++){
                this._collection.get(i).color = Cesium.Color.AQUA;
            }
        }
    };

    EditablePoint.prototype.offHighlight = function () {
        var i = 0;
        for(;i<this._collection.length;i++){
            this._collection.get(i).color = Cesium.Color.WHITE;
        }
    };

    EditablePoint.prototype.update = function (frameState) {
        this._collection.update(frameState);
    };

    EditablePoint.prototype.destroy = function () {
        this._removeEventSubscription();
        this._collection = this._collection && this._collection.destroy();
        this._tooltip = this._tooltip && this._tooltip.destroy();
        return Cesium.destroyObject(this);
    };

    function WeatherVolumeWallAxisGeometry(options) {
      options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

      var wallPositions = options.positions;
      var maximumHeights = options.maximumHeights;
      var minimumHeights = options.minimumHeights;


      var granularity = Cesium.defaultValue(
        options.granularity,
        Cesium.Math.RADIANS_PER_DEGREE
      );
      var ellipsoid = Cesium.defaultValue(options.ellipsoid, Cesium.Ellipsoid.WGS84);
      this._positions = wallPositions;
      this._floors = options.floors;
      this._split = Cesium.defaultValue(options.split, true);
      this._minimumHeights = minimumHeights;
      this._maximumHeights = maximumHeights;
      this._granularity = granularity;
      this._ellipsoid = Cesium.Ellipsoid.clone(ellipsoid);
    }

    var generateArcOptionsScratch = {
      positions: undefined,
      height: undefined,
      granularity: undefined,
      ellipsoid: undefined,
    };

    WeatherVolumeWallAxisGeometry.computePositions = function (
      ellipsoid,
      wallPositions,
      floors,
      granularity
    ) {
      var length = wallPositions.length;
      var numCorners = length - 2;

      var minDistance = Cesium.Math.chordLength(
        granularity,
        ellipsoid.maximumRadius
      );

      var widthLength = wallPositions.length;

      var heightArray = [];
      
      // eslint-disable-next-line block-scoped-var
      for(var i=0;i<floors.length;i++){
        var height = floors[i];
        var heights = new Array(widthLength);
        for(var j=0;j<widthLength;j++){
          heights[j] = height;
        }
        heightArray.push(heights);
      }

      var generateArcOptions = generateArcOptionsScratch;
      generateArcOptions.minDistance = minDistance;
      generateArcOptions.ellipsoid = ellipsoid;
      generateArcOptions.positions = wallPositions;

      var floorPositions = [];

      // eslint-disable-next-line no-redeclare
      for(var i=0;i<heightArray.length;i++){
          generateArcOptions.height = heightArray[i];
          var floorPos = new Float64Array(
            Cesium.PolylinePipeline.generateArc(generateArcOptions)
          );
          floorPositions.push(floorPos);
      }

      return {
        floorPositions: floorPositions,
        numCorners: numCorners,
      };
    };

    WeatherVolumeWallAxisGeometry.createGeometry = function (wallGeometry) {
      var scratchCartesian3Position1 = new Cesium.Cartesian3();
      var scratchCartesian3Position2 = new Cesium.Cartesian3();

      var wallPositions = wallGeometry._positions;
      var granularity = wallGeometry._granularity;
      var ellipsoid = wallGeometry._ellipsoid;
      var floors = wallGeometry._floors;
      var split = wallGeometry._split;

      var pos = this.computePositions(
        ellipsoid,
        wallPositions,
        floors,
        granularity
      );

      if (!Cesium.defined(pos)) {
        return;
      }

      var floorNum = pos.floorPositions.length;
      var length = pos.floorPositions[0].length;
      var size = length * floorNum;
      var positions = new Float64Array(size);
      var positionIndex = 0;

      length /= 3;
      for(var f = 0;f<floorNum;f++){
        var fositions = pos.floorPositions[f];
        for (var i = 0; i < length; ++i) {
          var i3 = i * 3;
          var position = Cesium.Cartesian3.fromArray(
            fositions,
            i3,
            scratchCartesian3Position1
          );
          positions[positionIndex++] = position.x;
          positions[positionIndex++] = position.y;
          positions[positionIndex++] = position.z;
        }
      }

      var attributes = new Cesium.GeometryAttributes({
        position: new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.DOUBLE,
          componentsPerAttribute: 3,
          values: positions,
        }),
      });

      var numVertices = size / 3;

      size = 2 * (floorNum * (length - 1) + (floorNum - 1) * (split ? 5 : 2));

      var indices = Cesium.IndexDatatype.createTypedArray(numVertices, size);

      // | |   |   |   |
      var h1 = Math.floor(length * 0.1);
      var h3 = Math.floor(length * 0.3);
      var h7 = Math.floor(length * 0.7);

      if (split) {
        var fositions = pos.floorPositions[0];
        var p0 = Cesium.Cartesian3.fromArray(fositions, 0, new Cesium.Cartesian3());
        wallGeometry.p1 = Cesium.Cartesian3.fromArray(fositions, h1 * 3, new Cesium.Cartesian3());
        wallGeometry.p3 = Cesium.Cartesian3.fromArray(fositions, h3 * 3, new Cesium.Cartesian3());
        wallGeometry.p7 = Cesium.Cartesian3.fromArray(fositions, h7 * 3, new Cesium.Cartesian3());
      }

      var edgeIndex = 0;
      for (var f = 0; f < floorNum; f++) {

        // -----------
        // -----------
        for (var i = 0; i < length - 1; i += 1) {
          var LL = f * length + i;
          var LR = LL + 1;
          var pl = Cesium.Cartesian3.fromArray(
            positions,
            LL * 3, 
            scratchCartesian3Position1
          );
          var pr = Cesium.Cartesian3.fromArray(
            positions,
            LR * 3,
            scratchCartesian3Position2
          );
          if (Cesium.Cartesian3.equalsEpsilon(pl, pr, Cesium.Math.EPSILON10)) {
            continue;
          }
          indices[edgeIndex++] = LL;
          indices[edgeIndex++] = LR;
        }



        if (f < floorNum - 1) {
          LL = f * length;
          LR = (f + 1) * length;

          indices[edgeIndex++] = LL;
          indices[edgeIndex++] = LR;
          indices[edgeIndex++] = LL + (length - 1);
          indices[edgeIndex++] = LR + (length - 1);

          if (split)
          {
            indices[edgeIndex++] = LL + h1;
            indices[edgeIndex++] = LR + h1;
            indices[edgeIndex++] = LL + h3;
            indices[edgeIndex++] = LR + h3;
            indices[edgeIndex++] = LL + h7;
            indices[edgeIndex++] = LR + h7;
          }
        }
      }

      return new Cesium.Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: Cesium.PrimitiveType.LINES,
        boundingSphere: new Cesium.BoundingSphere.fromVertices(positions),
      });
    };

    //This file is automatically rebuilt by the WeatherEarth build process.
    var VolumeWallMaterial = "czm_material czm_getMaterial(czm_materialInput materialInput) {\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
    vec2 startST = vec2(calcMatrix[0][0],calcMatrix[0][1]); \n\
    vec2 endST = vec2(calcMatrix[0][2],calcMatrix[0][3]); \n\
    float length = materialInput.st.x; \n\
    vec3 texcoord = vec3(0.0,0.0,materialInput.st.y); \n\
    texcoord.xy = startST + (endST - startST) * length; \n\
    float scaler = u_attribute[0][0];\n\
    float offset = u_attribute[0][1];\n\
    bool usePhongLight = u_attribute[0][3] > 0.0;\n\
    float summationX = calcMatrix[1][0]; \n\
    float summationY = calcMatrix[1][1]; \n\
    vec4 color = texture3D(baseTexture,texcoord);\n\
    float v = czm_unpackVolume(color,scaler,offset);\n\
    if(summationY == 1.0){\n\
        for(float i=0.01;i<=1.0;i+=0.01){\n\
            color = texture3D(baseTexture, vec3(texcoord.x,i,texcoord.z));\n\
            float v2 = czm_unpackVolume(color,scaler,offset); \n\
            if(v2>v)v=v2;\n\
        }\n\
    }\n\
    else if(summationX == 1.0){\n\
        for(float i=0.01;i<=1.0;i+=0.01){\n\
            color = texture3D(baseTexture, vec3(i,texcoord.y,texcoord.z));\n\
            float v2 = czm_unpackVolume(color,scaler,offset); \n\
            if(v2>v)v=v2;\n\
        }\n\
    }\n\
    color = v_transfer(v,0.0,!usePhongLight,color);\n\
    float filtrationmin = clipMatrix[3][2];\n\
    float filtrationmax = clipMatrix[3][3];\n\
    if(v > filtrationmax || v < filtrationmin)\n\
    {\n\
        color.a = 0.0;\n\
    }\n\
    material.diffuse = color.rgb;\n\
    material.alpha = color.a > 0.0 ? 1.0 : 0.0;\n\
    material.specular = 0.0; // Specular mountain tops\n\
    material.shininess = 0.0; // Sharpen highlight\n\
    if(material.alpha == 0.0)discard;\n\
    return material;\n\
}\n\
";

    /**
     * @private
     */
    var WeatherVolumeLibrary = {};

    WeatherVolumeLibrary.computeVolume = function (attrMatrix) {
      var EarthRadius = 6378137.0;
      var meterWidth = attrMatrix[0];
      var meterHeight = attrMatrix[1];
      var position = new Cesium.Cartesian3(attrMatrix[4],attrMatrix[5],attrMatrix[6]);

      var degreeHeight = meterHeight * 180.0 / EarthRadius / Cesium.Math.PI;
      var bottomLatInRad = Cesium.Math.toRadians(position.y - 0.5 * degreeHeight);
      var degreeWidth = meterWidth * 180.0 / EarthRadius / Cesium.Math.PI / Math.cos(bottomLatInRad);
      attrMatrix[3] = degreeWidth;
      attrMatrix[7] = degreeHeight;

      attrMatrix[8]  = position.x - degreeWidth * 0.5;     //w
      attrMatrix[9]  = position.y - degreeHeight * 0.5;    //s
      attrMatrix[10] = position.x + degreeWidth * 0.5;     //e
      attrMatrix[11] = position.y + degreeHeight * 0.5;    //n

      var toplatInRad = Cesium.Math.toRadians(position.y + 0.5 * degreeHeight);
      var topMeterWidth = Math.cos(toplatInRad) * EarthRadius * Cesium.Math.PI * (degreeWidth / 180.0);
      attrMatrix[12] = topMeterWidth;    
    };

    WeatherVolumeLibrary.computeWallPosition = function (p1, p2 , granularityFactor) {
      var dx = (p1.x > p2.x) ? p1.x - p2.x : p2.x - p1.x;
      var dy = (p1.y > p2.y) ? p1.y - p2.y : p2.y - p1.y;
      var granularity = Cesium.Math.RADIANS_PER_DEGREE * granularityFactor;
      var width = Math.ceil(dx / granularity) + 1;
      var height = Math.ceil(dy / granularity) + 1;

      var stamp = width > height ? width : height;
      var granularityX = (p2.x - p1.x) / (stamp - 1);
      var granularityY = (p2.y - p1.y) / (stamp - 1);
      var granYCos = granularityY;
      var granXCos = granularityX;

      var size = stamp * 2;
      var pos = new Float64Array(size);
      for (var i = 0; i < size; i += 2) {
        pos[i] = p1.x + (i / 2) * granXCos;
        pos[i + 1] = p1.y + (i / 2) * granYCos;
      }

      return Cesium.Cartesian3.fromRadiansArray(pos);
    };

    WeatherVolumeLibrary.create3DTexture = function (context, source) {
      var sampler = new Cesium.Sampler({
        wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
        wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
        wrapR: Cesium.TextureWrap.CLAMP_TO_EDGE,
        minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
        magnificationFilter: Cesium.TextureMagnificationFilter.LINEAR
      });

      return new Cesium.Texture({
        context: context,
        source: source,
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE,
        sampler: sampler
      });
    };

    WeatherVolumeLibrary.createTransferTexture2 = function (context,valueAndColorRamp, size, min,
      minificationFilter,
      magnificationFilter) {
      var sampler = new Cesium.Sampler({
        wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
        wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
        minificationFilter: Cesium.defaultValue(minificationFilter,Cesium.TextureMinificationFilter.NEAREST),
        magnificationFilter: Cesium.defaultValue(magnificationFilter,Cesium.TextureMagnificationFilter.NEAREST)
      });
      var pixelNum = size > 4096 ? 4096 : size;
      var tfSource = new Uint8Array(pixelNum * 2 * 4);
      for (var i = 0; i < pixelNum; i++) {
        var rampSt = 0;
        var rampEd = 0;
        var idx = valueAndColorRamp.ValueRamp.length - 1;
        for (var j = 0; j < valueAndColorRamp.ValueRamp.length - 1; j++) {
          if ((i / pixelNum) < (valueAndColorRamp.ValueRamp[j] - min) / size) {
            idx = j;
            rampEd = valueAndColorRamp.ValueRamp[j] - min;
            if (j > 0) {
              rampSt = valueAndColorRamp.ValueRamp[j - 1] - min;
            }
            break;
          }
        }

        var pixels = valueAndColorRamp.ColorRamp[idx];

        idx = i * 4;
        tfSource[idx] = rampSt;
        tfSource[idx + 1] = rampEd;
        tfSource[idx + 2] = 0;
        tfSource[idx + 3] = 0;

        //
        tfSource[idx] = pixels[0];
        tfSource[idx + 1] = pixels[1];
        tfSource[idx + 2] = pixels[2];
        tfSource[idx + 3] = pixels[3];

        idx += pixelNum * 4;
        tfSource[idx] = pixels[0];
        tfSource[idx + 1] = pixels[1];
        tfSource[idx + 2] = pixels[2];
        tfSource[idx + 3] = pixels[3];
      }

      return new Cesium.Texture({
        context: context,
        source: { width: pixelNum, height: 2, arrayBufferView: tfSource },
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE,
        sampler: sampler
      });
    };

    WeatherVolumeLibrary.createTransferTexture = function (context,valueAndColorRamp, size, min,
      minificationFilter,
      magnificationFilter) {
      var sampler = new Cesium.Sampler({
        wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
        wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
        minificationFilter: Cesium.defaultValue(minificationFilter,Cesium.TextureMinificationFilter.NEAREST),
        magnificationFilter: Cesium.defaultValue(magnificationFilter,Cesium.TextureMagnificationFilter.NEAREST)
      });
      var tfSource = new Uint8Array(size * 2 * 4);
      for (var i = 0; i < size; i++) {
        var rampSt = 0;
        var rampEd = 0;
        var idx = valueAndColorRamp.ValueRamp.length - 1;
        for (var j = 0; j < valueAndColorRamp.ValueRamp.length; j++) {
          if (i < valueAndColorRamp.ValueRamp[j] - min) {
            idx = j;
            rampEd = valueAndColorRamp.ValueRamp[j] - min;
            if (j > 0) {
              rampSt = valueAndColorRamp.ValueRamp[j - 1] - min;
            }
            break;
          }
        }
        var pixels = valueAndColorRamp.ColorRamp[idx];
        idx = i * 4;
        tfSource[idx] = rampSt;
        tfSource[idx + 1] = rampEd;
        tfSource[idx + 2] = 0;
        tfSource[idx + 3] = 0;

        idx += size * 4;
        tfSource[idx] = pixels[0];
        tfSource[idx + 1] = pixels[1];
        tfSource[idx + 2] = pixels[2];
        tfSource[idx + 3] = pixels[3];
      }

      return new Cesium.Texture({
        context: context,
        source: { width: size, height: 2, arrayBufferView: tfSource },
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE,
        sampler: sampler
      });
    };

    function WeatherVolumeWall(volume) {
      var depth = volume._meter.depth;
      this._floors = [];
      for (let i = 0; i < Config.AxesFloorsRatio.length; i++) {
        this._floors.push(
          Math.ceil(Config.AxesFloorsRatio[i] * depth * 0.001) * 1000.0
        );
      }

      this._LabelDistanceDisplayFator = 4;
      this._scene = volume._scene;
      this._show = true;
      this._appearance = new Cesium.MaterialAppearance({
        renderState: {
          depthTest: { enabled: true },
          depthMask: true,
          blending: Cesium.BlendingState.ALPHA_BLEND,
          cull: {
            enabled: false,
            face: Cesium.CullFace.FRONT,
          },
        },
        translucent: true,
      });

      this._calcMatrix = new Cesium.Matrix4(
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0
      );
      var that = this;

      var _uniforms = {
        baseTexture: volume._texture,
        clipMatrix: volume._clipMatrix,
        statisticMatrix: volume._statisticMatrix,
        u_attribute: volume._attributeMatrix,
        calcMatrix: that._calcMatrix,
      };

      if (Cesium.defined(volume._textureTF)) {
        _uniforms.tfTexture = volume._textureTF;
      }

      this._appearance.material = new Cesium.Material({
        translucent: false,
        fabric: {
          uniforms: _uniforms,
          source: volume.transFunction + VolumeWallMaterial,
        },
      });

      this._leftLabel = undefined;
      this._rightLabel = undefined;
      this._bottomLabel = undefined;
      this._options = undefined;
      this._splitWidth = false;
      this._rectangle = volume.rectangle;
      this.computePosition = function (positions, granularityFactor) {
        var p1 = new Cesium.Cartesian2(positions[0], positions[1]);
        var p2 = new Cesium.Cartesian2(positions[2], positions[3]);

        //startXY
        this._calcMatrix[0] = (p1.x - this._rectangle.west) / this._rectangle.width;
        this._calcMatrix[1] =
          (p1.y - this._rectangle.south) / this._rectangle.height;
        //endXY
        this._calcMatrix[2] = (p2.x - this._rectangle.west) / this._rectangle.width;
        this._calcMatrix[3] =
          (p2.y - this._rectangle.south) / this._rectangle.height;
        return WeatherVolumeLibrary.computeWallPosition(p1, p2, granularityFactor);
      };
    }

    WeatherVolumeWall.prototype.isDestroyed = function () {
      return false;
    };

    WeatherVolumeWall.prototype.destroy = function () {
      this._wall = this._wall && this._wall.destroy();
      this._wallOutline = this._wallOutline && this._wallOutline.destroy();
      this._leftLabel = this._leftLabel && this._leftLabel.destroy();
      this._rightLabel = this._rightLabel && this._rightLabel.destroy();
      this._bottomLabel = this._bottomLabel && this._bottomLabel.destroy();
      return Cesium.destroyObject(this);
    };

    WeatherVolumeWall.prototype.equals = function (options) {
      if (!Cesium.defined(this._options)) {
        return false;
      }
      if (
        (this._options.showGrid && !Cesium.defined(this._labels)) ||
        this._options.showGrid !== options.showGrid
      )
        return false;

      if (
        this._options.height === options.height &&
        this._options.granularityFactor === options.granularityFactor &&
        this._options.positions.length === options.positions.length
      ) {
        for (var i = 0; i < options.positions.length; i++) {
          if (this._options.positions[i] !== options.positions[i]) return false;
        }
        return true;
      }
      return false;
    };

    WeatherVolumeWall.prototype.update = function (frameState) {
      if (this._dirty) {
        this._dirty = false;
        this.rebuild();
      }
      if (this._show && Cesium.defined(this._wall)) {
        this._wall.update(frameState);
        var showGrid = this.options.showGrid;
        if (showGrid && Cesium.defined(this._wallOutline)) {
          this._wallOutline.update(frameState);
          if (Cesium.defined(this._leftLabel)) {
            this._leftLabel.update(frameState);
          }
          if (Cesium.defined(this._rightLabel)) {
            this._rightLabel.update(frameState);
          }
        }
      }
    };

    WeatherVolumeWall.prototype.rebuild = function () {
      this._wall = this._wall && this._wall.destroy();

      var height = this._options.height;
      var granularityFactor = this._options.granularityFactor;
      var pos = this.computePosition(
        this._options.positions,
        granularityFactor,
        this._rectangle
      );

      var wallGeometry = Cesium.WallGeometry.createGeometry(
        Cesium.WallGeometry.fromConstantHeights({
          positions: pos,
          minimumHeight: 0.0,
          maximumHeight: height,
          granularity: Cesium.Math.RADIANS_PER_DEGREE * granularityFactor,
        })
      );

      this._wall = new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({ geometry: wallGeometry }),
        asynchronous: false,
      });
      this._wall.appearance = this._appearance;
      this._wall.show = this._show;
      this.buildGrid(pos);
    };

    WeatherVolumeWall.prototype.buildLineCollection = function (pos, floors, granularityFactor) {
      this._wallOutline = new Cesium.PolylineCollection();
      const floorPositions = WeatherVolumeWallAxisGeometry.computePositions(
        Cesium.Ellipsoid.WGS84,
        pos,
        floors,
        Cesium.Math.RADIANS_PER_DEGREE * granularityFactor
      );

      const st = [];
      const ed = [];
      
      var floorNum = floorPositions.floorPositions.length;
      var length = floorPositions.floorPositions[0].length / 3;
      for (let f = 0; f < floorNum; f++) {
        var fositions = floorPositions.floorPositions[f];
        var linepos = [];
        for (let i = 0; i < length; ++i) {
          var i3 = i * 3;
          var position = Cesium.Cartesian3.fromArray(
            fositions,
            i3,
            new Cesium.Cartesian3()
          );
          linepos.push(position);
          if( i=== 0) {
            st.push(position);
          } else if ( i === length - 1){
            ed.push(position);
          }
        }
        this._wallOutline.add({
          positions: linepos,
          width: Config.AxesLineWidth,
        });
      }
      this._wallOutline.add({
        positions: st,
        width: Config.AxesLineWidth,
      });  
      this._wallOutline.add({
        positions: ed,
        width: Config.AxesLineWidth,
      });
    };

    WeatherVolumeWall.prototype.buildGridGeometry = function (
      pos,
      floors,
      granularityFactor
    ) {
      var volumeWallAxisGeometry = new WeatherVolumeWallAxisGeometry({
        positions: pos,
        floors: floors,
        split: this._splitWidth,
        granularity: Cesium.Math.RADIANS_PER_DEGREE * granularityFactor,
      });

      var wallOutlineGeometry = WeatherVolumeWallAxisGeometry.createGeometry(
        volumeWallAxisGeometry
      );

      this._wallOutline = new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry: wallOutlineGeometry,
          attributes: {
            color: Cesium.ColorGeometryInstanceAttribute.fromColor(
              new Cesium.Color(1.0, 1.0, 1.0, 1.0)
            ),
          },
        }),
        asynchronous: false,
      });

      if (!Cesium.defined(this._lineAppearance)) {
        this._lineAppearance = new Cesium.PerInstanceColorAppearance({
          flat: true,
          translucent: false,
          renderState: {
            lineWidth: Math.min(2.0, this._scene.maximumAliasedLineWidth),
          },
        });
      }

      this._wallOutline.appearance = this._lineAppearance;
    };

    WeatherVolumeWall.prototype.buildLabel = function (pos) {
      var distance =
        Cesium.Cartesian3.distance(pos[0], pos[pos.length - 1]) *
        this._LabelDistanceDisplayFator;
      var sacleCartesian = new Cesium.Cartesian3(1.0, 1.0, this._options.scaleZ);

      if (!Cesium.defined(this._leftLabel)) {
        this._leftLabel = this.createLabel(distance, Cesium.HorizontalOrigin.RIGHT);
      }

      var positionLeft = Cesium.Cartesian3.fromRadians(
        this._options.positions[0],
        this._options.positions[1]
      );
      var m1 = Cesium.Transforms.eastNorthUpToFixedFrame(positionLeft);
      this._leftLabel.modelMatrix = Cesium.Matrix4.multiplyByScale(
        m1,
        sacleCartesian,
        this._leftLabel.modelMatrix
      );

      if (!Cesium.defined(this._rightLabel)) {
        this._rightLabel = this.createLabel(distance, Cesium.HorizontalOrigin.LEFT);
      }

      var positionRight = Cesium.Cartesian3.fromRadians(
        this._options.positions[2],
        this._options.positions[3]
      );
      var m2 = Cesium.Transforms.eastNorthUpToFixedFrame(positionRight);
      this._rightLabel.modelMatrix = Cesium.Matrix4.multiplyByScale(
        m2,
        sacleCartesian,
        this._rightLabel.modelMatrix
      );
    };

    WeatherVolumeWall.prototype.buildGrid = function (pos) {
      this._wallOutline = this._wallOutline && this._wallOutline.destroy();
      if (this._options.showGrid) {
        var granularityFactor = this._options.granularityFactor;

        var floors = [];
        for (var i = 0; i < this._floors.length; i++) {
          floors.push(this._floors[i] * this._options.scaleZ);
        }

        this.buildLineCollection(pos, floors, granularityFactor);
        // this.buildGridGeometry(pos, floors, granularityFactor);
        this.buildLabel(pos);
      }
    };

    WeatherVolumeWall.prototype.createLabel = function (
      distanceDisplay,
      horizontalOrigin
    ) {
      var labels = new Cesium.LabelCollection();
      for (var i = 1; i < this._floors.length; i++) {
        var text = (this._floors[i] * 0.001).toFixed(0) + "km";
        labels.add({
          position: new Cesium.Cartesian3(0.0, 0.0, this._floors[i]),
          font: Config.font,
          disableDepthTestDistance: Number.POSITIVE_INFINITY,
          text: text,
          showBackground: Config.showBackground,
          backgroundColor: Config.backgroundColor,
          fillColor: Config.fillColor,
          outlineColor: Config.outlineColor,
          outlineWidth: Config.outlineWidth,
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          distanceDisplayCondition: new Cesium.DistanceDisplayCondition(
            0,
            distanceDisplay
          ),
          horizontalOrigin: horizontalOrigin,
        });
      }

      return labels;
    };

    Object.defineProperties(WeatherVolumeWall.prototype, {
      show: {
        get: function () {
          if (Cesium.defined(this._wall)) return this._wall.show;
          return this._show;
        },
        set: function (value) {
          if (value !== this._show) {
            this._show = value;
            if (Cesium.defined(this._wall)) {
              this._wall.show = value;
            }
          }
          //this.options.showGrid = value;
        },
      },
      options: {
        get: function () {
          return this._options;
        },
        set: function (value) {
          if (!Cesium.defined(this._wall) || !this.equals(value)) {
            this._options = value;
            this._dirty = true;
          }
        },
      },
      summationX: {
        get: function () {
          return this._calcMatrix[4] === 1.0;
        },
        set: function (value) {
          this._calcMatrix[4] = value ? 1.0 : 0.0;
        },
      },
      summationY: {
        get: function () {
          return this._calcMatrix[5] === 1.0;
        },
        set: function (value) {
          this._calcMatrix[5] = value ? 1.0 : 0.0;
        },
      },
    });

    function WeatherLengthWay(volume, positions, extraOptions) {
        if(!Cesium.defined(extraOptions)){
            extraOptions = {};
        }

        this._id = Cesium.defaultValue(extraOptions.id,Cesium.createGuid());

        this._volume = volume;
        var h = volume._meter.depth * volume.scaleZ;
        this._options = {
            positions: [],
            height: h,
            scaleZ: volume.scaleZ,
            granularityFactor: volume._granularityFactor,
            showGrid: Cesium.defaultValue(extraOptions.showGrid,true)
        };

        this._rectangle = volume.rectangle;
        this._contentChangedEvent = new Cesium.Event();
        this._removeEventSubscription = this._contentChangedEvent.addEventListener(
            WeatherLengthWay.prototype._onContentChanged,
            this
        );
        this._volumeWall = new WeatherVolumeWall(volume);

        var hasEdit = Cesium.defaultValue(extraOptions.EditablePoint,true);
        // if(hasEdit){
        //     this._editablePoint = new EditablePoint();
        //     this._editablePoint.extent = volume.rectangle;
        //     this._editablePoint.height = h;
        //     this._computeScaleHeight = 0.0;
        
        //     var that = this;
        //     this._editablePoint.onPostionChanged = function (
        //         entity,
        //         propertyName,
        //         newValue,
        //         oldValue
        //     ) {
        //         var cartographic = Cesium.Cartographic.fromCartesian(newValue);
        //         that._options.positions[2] = cartographic.longitude;
        //         that._options.positions[3] = cartographic.latitude;
        //         that._dirty = true;
        //     };
        
        //     this._editablePoint.onHeightChanged = function (
        //         entity,
        //         propertyName,
        //         newValue,
        //         oldValue
        //     ) {
        //         that._computeScaleHeight = newValue / h;
        //         entity.tip = Math.floor(newValue / volume.scaleZ) + 'm';
        //         that.createCompute();
        //     };
        // }
    }
    WeatherLengthWay.prototype._onContentChanged = function (
        entity,
        propertyName,
        newValue,
        oldValue
    ) {
        if (propertyName == 'onUpdate') {
            if(Cesium.defined(this.onUpdate))
                this.onUpdate(entity,propertyName,newValue,oldValue);
        }else if (propertyName == 'onDestroy') {
            if(Cesium.defined(this.onDestroy))
                this.onDestroy(entity,propertyName,newValue,oldValue);
        }
    };

    WeatherLengthWay.prototype.isDestroyed = function () {
        return false;
    };

    WeatherLengthWay.prototype.destroy = function () {
        this._contentChangedEvent.raiseEvent(this, "onDestroy",'','');
        this._removeEventSubscription();
        this._volumeWall = this._volumeWall && this._volumeWall.destroy();
        this._editablePoint = this._editablePoint && this._editablePoint.destroy();
        this._computeEngine = this._computeEngine && this._computeEngine.destroy();
        return Cesium.destroyObject(this);
    };

    Object.defineProperties(WeatherLengthWay.prototype, {
        length: {
            get: function () {
                if(this._options.positions.length != 4){
                    return 0;
                }
                var satrt = Cesium.Cartographic.fromRadians(this._options.positions[0], this._options.positions[1]);
                var end = Cesium.Cartographic.fromRadians(this._options.positions[2], this._options.positions[3]);
                var geodesic = new Cesium.EllipsoidGeodesic();
                geodesic.setEndPoints(satrt, end);
                return geodesic.surfaceDistance;
            },
        },
        positions: {
            get: function () {
                return this._options.positions;
            },
            set: function (value) {
                if(value.length === 4){
                    var west = this._rectangle.west;
                    var south = this._rectangle.south;
                    var east = this._rectangle.east;
                    var north = this._rectangle.north;
                    
                    var p1 = new Cesium.Cartesian2(value[0],value[1]);
                    var p2 = new Cesium.Cartesian2(value[2],value[3]);

                    if(p1.x >= west && p1.x <= east &&
                        p1.y >= south && p1.y <= north){
                        if(p2.x <= west){
                            var ratio = (west - p2.x)/(p1.x - p2.x);
                            var dir = Cesium.Cartesian2.subtract(p1,p2,new Cesium.Cartesian2()); 
                            var length = Cesium.Cartesian2.magnitude(dir);
                            dir = Cesium.Cartesian2.normalize(dir,new Cesium.Cartesian2());
                            dir = Cesium.Cartesian2.multiplyByScalar(dir,ratio * length,new Cesium.Cartesian2());
                            p2 = Cesium.Cartesian2.add(p2,dir,new Cesium.Cartesian2());
                        }
                        else if(p2.x >= east){
                            var ratio = (p2.x - east)/(p2.x - p1.x);
                            var dir = Cesium.Cartesian2.subtract(p1,p2,new Cesium.Cartesian2()); 
                            var length = Cesium.Cartesian2.magnitude(dir);
                            dir = Cesium.Cartesian2.normalize(dir,new Cesium.Cartesian2());
                            dir = Cesium.Cartesian2.multiplyByScalar(dir,ratio * length,new Cesium.Cartesian2());
                            p2 = Cesium.Cartesian2.add(p2,dir,new Cesium.Cartesian2());
                        }
                        if(p2.y <= south){
                            var ratio = (south - p2.y)/(p1.y - p2.y);
                            var dir = Cesium.Cartesian2.subtract(p1,p2,new Cesium.Cartesian2()); 
                            var length = Cesium.Cartesian2.magnitude(dir);
                            dir = Cesium.Cartesian2.normalize(dir,new Cesium.Cartesian2());
                            dir = Cesium.Cartesian2.multiplyByScalar(dir,ratio * length,new Cesium.Cartesian2());
                            p2 = Cesium.Cartesian2.add(p2,dir,new Cesium.Cartesian2());
                        }
                        else if(p2.y >= north){
                            var ratio = (p2.y - north)/(p2.y - p1.y);
                            var dir = Cesium.Cartesian2.subtract(p1,p2,new Cesium.Cartesian2()); 
                            var length = Cesium.Cartesian2.magnitude(dir);
                            dir = Cesium.Cartesian2.normalize(dir,new Cesium.Cartesian2());
                            dir = Cesium.Cartesian2.multiplyByScalar(dir,ratio * length,new Cesium.Cartesian2());
                            p2 = Cesium.Cartesian2.add(p2,dir,new Cesium.Cartesian2());
                        }

                        this._options.positions = [p1.x,p1.y,p2.x,p2.y];
                        this._dirty = true;
                    }
                }
            },
        },
        showGrid: {
            get: function () {
                return this._showGrid;
            },
            set: function (value) {
                if (this._options.showGrid != value) {
                    this._options.showGrid = value;
                    this._dirty = true;
                }
            }
        },
        id: {
            get: function () {
                return this._id;
            }
        },
    });

    WeatherLengthWay.calculateRotate = function (angle,positions) {
        var pos = Cesium.defined(positions) ? positions : this.positions;
        if(pos.length !==  4){
            return undefined;
        }
        var pos1 = new Cesium.Cartesian3(pos[0],pos[1],0.0);
        var pos2 = new Cesium.Cartesian3(pos[2],pos[3],0.0);
        var dir = Cesium.Cartesian3.subtract(pos2,pos1,new Cesium.Cartesian3());
        var m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(angle));
        var rotated = Cesium.Matrix3.multiplyByVector(m, dir, new Cesium.Cartesian3());
        return [pos1.x, pos1.y, pos1.x + rotated.x, pos1.y + rotated.y];
    };

    WeatherLengthWay.prototype.rotate = function (angle,positions) {
        this.positions = WeatherLengthWay.calculateRotate(angle,positions);
        this._dirty = Cesium.defined(this.positions);
    };

    WeatherLengthWay.prototype.update = function (frameState) {
        if (Cesium.defined(this._volume) && !this._volume.isDestroyed()) {
            var dirty = this._dirty;
            if (this._dirty) {
                this._dirty = false;
                this._volumeWall.options = this._options;
                this._volumeWall._dirty = dirty;    
                if(Cesium.defined(this._editablePoint)){
                    this._editablePoint.position = Cesium.Cartesian3.fromRadians(this._options.positions[2],this._options.positions[3]);
                    var h = this._volume._meter.depth * this._volume.scaleZ;
                    this._editablePoint.heightPointPosition = Cesium.Cartesian3.fromRadians(this._options.positions[0],this._options.positions[1],this._computeScaleHeight * h);
                }
            }

            this._volumeWall.update(frameState);

            if(Cesium.defined(this._editablePoint)){
                this._editablePoint.update(frameState);
            }

            if(dirty){
                this._contentChangedEvent.raiseEvent(this, "onUpdate",'','');
            }
        }
    };

    function addRadarScanPostStage(viewer, cartographicCenter, radius, scanColor, duration) {
        var ScanSegmentShader =
            "uniform sampler2D colorTexture;" +
            "uniform sampler2D depthTexture;" +
            "varying vec2 v_textureCoordinates;" +
            "uniform vec4 u_scanCenterEC;" +
            "uniform vec3 u_scanPlaneNormalEC;" +
            "uniform vec3 u_scanLineNormalEC;" +
            "uniform float u_radius;" +
            "uniform vec4 u_scanColor;" +
            "bool isPointOnLineRight(in vec3 ptOnLine, in vec3 lineNormal, in vec3 testPt)" +
            "{" +
            "vec3 v01 = testPt - ptOnLine;" +
            "normalize(v01);" +
            "vec3 temp = cross(v01, lineNormal);" +
            "float d = dot(temp, u_scanPlaneNormalEC);" +
            "return d > 0.5;" +
            "}" +
            "vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point)" +
            "{" +
            "vec3 v01 = point -planeOrigin;" +
            "float d = dot(planeNormal, v01) ;" +
            "return (point - planeNormal * d);" +
            "}" +
            "void main()" +
            "{" +
            "gl_FragColor = texture2D(colorTexture, v_textureCoordinates);" +
            "float logDepthOrDepth = czm_unpackDepth(texture2D(depthTexture, v_textureCoordinates));" +
            "vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);" +
            "vec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC.xyz, u_scanCenterEC.xyz, eyeCoordinate.xyz/eyeCoordinate.w);" +
            "float dis = length(prjOnPlane.xyz - u_scanCenterEC.xyz);" +
            "float twou_radius = u_radius * 2.0;" +
            "if(dis < u_radius)" +
            "{" +
            "float f0 = 1.0 -abs(u_radius - dis) / u_radius;" +
            "f0 = pow(f0, 64.0);" +
            "vec3 lineEndPt = vec3(u_scanCenterEC.xyz) + u_scanLineNormalEC * u_radius;" +
            "float f = 0.0;" +
            "if(isPointOnLineRight(u_scanCenterEC.xyz, u_scanLineNormalEC.xyz, prjOnPlane.xyz))" +
            "{" +
            "float dis1= length(prjOnPlane.xyz - lineEndPt);" +
            "f = abs(twou_radius -dis1) / twou_radius;" +
            "f = pow(f, 3.0);" +
            "}" +
            "gl_FragColor = mix(gl_FragColor, u_scanColor, f + f0);" +
            "}" +
            "}";

        var _Cartesian3Center = Cesium.Cartographic.toCartesian(cartographicCenter);
        var _Cartesian4Center = new Cesium.Cartesian4(_Cartesian3Center.x, _Cartesian3Center.y, _Cartesian3Center.z, 1);
        var _CartographicCenter1 = new Cesium.Cartographic(cartographicCenter.longitude, cartographicCenter.latitude, cartographicCenter.height + 500);
        var _Cartesian3Center1 = Cesium.Cartographic.toCartesian(_CartographicCenter1);
        var _Cartesian4Center1 = new Cesium.Cartesian4(_Cartesian3Center1.x, _Cartesian3Center1.y, _Cartesian3Center1.z, 1);
        var _CartographicCenter2 = new Cesium.Cartographic(cartographicCenter.longitude + 0.001, cartographicCenter.latitude, cartographicCenter.height);
        var _Cartesian3Center2 = Cesium.Cartographic.toCartesian(_CartographicCenter2);
        var _Cartesian4Center2 = new Cesium.Cartesian4(_Cartesian3Center2.x, _Cartesian3Center2.y, _Cartesian3Center2.z, 1);
        var _RotateQ = new Cesium.Quaternion();
        var _RotateM = new Cesium.Matrix3();
        var _time = (new Date()).getTime();
        var _scratchCartesian4Center = new Cesium.Cartesian4();
        var _scratchCartesian4Center1 = new Cesium.Cartesian4();
        var _scratchCartesian4Center2 = new Cesium.Cartesian4();
        var _scratchCartesian3Normal = new Cesium.Cartesian3();
        var _scratchCartesian3Normal1 = new Cesium.Cartesian3();
        var ScanPostStage = new Cesium.PostProcessStage({
            fragmentShader: ScanSegmentShader,
            uniforms: {
                u_scanCenterEC: function () {
                    return Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center);
                },
                u_scanPlaneNormalEC: function () {
                    var temp = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center);
                    var temp1 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center1, _scratchCartesian4Center1);
                    _scratchCartesian3Normal.x = temp1.x - temp.x;
                    _scratchCartesian3Normal.y = temp1.y - temp.y;
                    _scratchCartesian3Normal.z = temp1.z - temp.z;
                    Cesium.Cartesian3.normalize(_scratchCartesian3Normal, _scratchCartesian3Normal);
                    return _scratchCartesian3Normal;

                },
                u_radius: radius,
                u_scanLineNormalEC: function () {
                    var temp = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center);
                    var temp1 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center1, _scratchCartesian4Center1);
                    var temp2 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center2, _scratchCartesian4Center2);
                    _scratchCartesian3Normal.x = temp1.x - temp.x;
                    _scratchCartesian3Normal.y = temp1.y - temp.y;
                    _scratchCartesian3Normal.z = temp1.z - temp.z;
                    Cesium.Cartesian3.normalize(_scratchCartesian3Normal, _scratchCartesian3Normal);
                    _scratchCartesian3Normal1.x = temp2.x - temp.x;
                    _scratchCartesian3Normal1.y = temp2.y - temp.y;
                    _scratchCartesian3Normal1.z = temp2.z - temp.z;
                    var tempTime = (((new Date()).getTime() - _time) % duration) / duration;
                    Cesium.Quaternion.fromAxisAngle(_scratchCartesian3Normal, tempTime * Cesium.Math.PI * 2, _RotateQ);
                    Cesium.Matrix3.fromQuaternion(_RotateQ, _RotateM);
                    Cesium.Matrix3.multiplyByVector(_RotateM, _scratchCartesian3Normal1, _scratchCartesian3Normal1);
                    Cesium.Cartesian3.normalize(_scratchCartesian3Normal1, _scratchCartesian3Normal1);
                    return _scratchCartesian3Normal1;
                },
                u_scanColor: scanColor
            }
        });
        viewer.scene.postProcessStages.add(ScanPostStage);
        return (ScanPostStage);

    }

    WeatherLengthWay.prototype.createCompute = function () {
        if(!Cesium.defined(this._computeCommand)){
            var context = this._volume._scene.context;
            this._computeEngine = new Cesium.ComputeEngine(context);
            var outputTexture = new Cesium.Texture({
                context: context,
                width: 1,
                height: 1,
                PixelFormat: Cesium.PixelFormat.RGBA
            });

            var framebuffer = new Cesium.Framebuffer({
                context: context,
                colorTextures: [outputTexture],
                destroyAttachments: false
            });

            var readState = {
                framebuffer: framebuffer,
                x: 0,
                y: 0,
                width: 1,
                height: 1
            };

            var fs = "precision highp sampler3D;\n\
        uniform sampler3D baseTexture;\n\
        uniform mat4 calcMatrix;\n\
        uniform mat4 u_attribute;\n\
        uniform mat4 clipPlane;\n\
        uniform float z;\n\
        void main()\n\
            {\n\
    vec2 startST = vec2(calcMatrix[0][0],calcMatrix[0][1]);\n\
    vec2 endST = vec2(calcMatrix[0][2],calcMatrix[0][3]); \n\
    float length = 0.0; \n\
    vec3 texcoord = vec3(0.0,0.0,z);\n\
    texcoord.xy = startST + (endST - startST) * length; \n\
    float scaler = u_attribute[0][0];\n\
    float offset = u_attribute[0][1];\n\
    float filtrationmin = clipPlane[3][2];\n\
    float filtrationmax = clipPlane[3][3];\n\
    vec4 color = vec4(0.0);\n\
    float v = 0.0;\n\
    float average = 0.0;\n\
    float count = 1.0;\n\
    for(float i=0.0;i<1.01;i+=0.01){\n\
        texcoord.xy = startST + (endST - startST) * i; \n\
        vec4 color2 = texture3D(baseTexture,texcoord);\n\
        float v2 = czm_unpackVolume(color2,scaler,offset);\n\
        if(v2 > filtrationmax || v2 < filtrationmin)\n\
        {\n\
            v2 = 0.0;\n\
        }\n\
        average += v2;\n\
        if(v2 > v) v = v2;\n\
        count += 1.0;\n\
    }\n\
    color = czm_packDepth((v - offset) / scaler);\n\
    color.zw = czm_packDepth((average / count - offset) / scaler).xy;\n\
    gl_FragColor = color;\n\
    }\n\
            ";
            var that = this;
            var computeCommand = new Cesium.ComputeCommand({
                fragmentShaderSource: fs,
                outputTexture : outputTexture,
                uniformMap : {
                    baseTexture : function() {
                        return that._volume._texture;
                    },
                    calcMatrix: function () {
                        return that._volumeWall._calcMatrix;
                    },
                    clipPlane: function () {
                        return that._volume._clipMatrix;
                    },
                    u_attribute: function () {
                        return that._volume._attributeMatrix;
                    },
                    z: function () {
                        return that._computeScaleHeight;
                    },
                },
                persists : false,
                postExecute : function() {
                    var pixel = context.readPixels(readState);
                    var maxP = [pixel[0],pixel[1],0,0];
                    var averP = [pixel[2],pixel[3],0,0];
                    var maxValue = that._volume.computeReal(maxP);
                    var averValue = that._volume.computeReal(averP);
                    that._editablePoint.tip = that._editablePoint.tip + ' 最大值' + maxValue.toFixed(1)+ ' 均值' + averValue.toFixed(1);
                }
            });
            this._computeCommand = computeCommand;
        }   

        this._computeCommand.execute(this._computeEngine);
    };

    WeatherLengthWay.prototype.scan = function (viewer, color, duration) {
        var positions = this.positions;
        var startCartographicCenter = new Cesium.Cartographic(positions[0], positions[1], 0);
        var endCartographicCenter = new Cesium.Cartographic(positions[2], positions[3], 0);
        // 计算两点表面距离
        var geodesic = new Cesium.EllipsoidGeodesic();
        geodesic.setEndPoints(startCartographicCenter, endCartographicCenter);
        var distance = geodesic.surfaceDistance;
        viewer.scene.globe.depthTestAgainstTerrain = true;
        this.scanPostStage = addRadarScanPostStage(viewer, startCartographicCenter, distance, color, duration);
    };

    //This file is automatically rebuilt by the WeatherEarth build process.
    var VolumeSurfaceMaterial = "czm_material czm_getMaterial(czm_materialInput materialInput){\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
    vec4 color;\n\
    vec2 st = materialInput.st;\n\
    st.x = st.x * calcMatrix[0][3] + calcMatrix[1][1];\n\
    st.y = st.y * calcMatrix[1][0] + calcMatrix[1][2];\n\
    float spliceZ = calcMatrix[0][2]; \n\
    color = texture3D(baseTexture, vec3(st,spliceZ));\n\
    float scaler = u_attribute[0][0]; \n\
    float offset = u_attribute[0][1]; \n\
    bool usePhongLight = u_attribute[0][3] > 0.0; \n\
    float v = czm_unpackVolume(color,scaler,offset);\n\
    float summationZ = calcMatrix[0][1] + calcMatrix[1][3]; \n\
    for(float i=0.1;i<=1.0 && summationZ >= 1.0;i+=0.01)\n\
    {\n\
        color = texture3D(baseTexture, vec3(st,i));\n\
        float v2 = czm_unpackVolume(color,scaler,offset);\n\
        if(v2>v)\n\
            v=v2;\n\
    }\n\
    color = v_transfer(v,0.0,!usePhongLight,color);\n\
    float filtrationmin = clipMatrix[3][2];\n\
    float filtrationmax = clipMatrix[3][3];\n\
    if(v > filtrationmax || v < filtrationmin)\n\
    {\n\
        color.a = 0.0;\n\
    }\n\
    float alpha = calcMatrix[0][0]; \n\
    material.alpha = color.a > 0.0 ? alpha : 0.0;\n\
    material.diffuse = color.rgb;\n\
    material.specular = 0.0; // Specular mountain tops\n\
    material.shininess = 0.0; // Sharpen highlight\n\
    if(material.alpha == 0.0)discard;\n\
    return material;\n\
}\n\
";

    var scratchRight;
    var scratchRotation;
    var scratchOrientation;
    var scratchPerspective;
    var scratchPerspectiveOffCenter;
    var scratchOrthographic;
    var scratchOrthographicOffCenter;

    var scratchColor;
    var scratchSplits = [1.0, 100000.0];
    function SimpleDrawPrimitive(options) {
        scratchRight = new Cesium.Cartesian3();
        scratchRotation = new Cesium.Matrix3();
        scratchOrientation = new Cesium.Quaternion();
        scratchPerspective = new Cesium.PerspectiveFrustum();
        scratchPerspectiveOffCenter = new Cesium.PerspectiveOffCenterFrustum();
        scratchOrthographic = new Cesium.OrthographicFrustum();
        scratchOrthographicOffCenter = new Cesium.OrthographicOffCenterFrustum();
        scratchColor = new Cesium.Color();

        options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

        if (!Cesium.defined(options.camera)) {
          throw new Cesium.DeveloperError("options.camera is required.");
        }
      
        this._camera = options.camera;
        this._frustumSplits = options.frustumSplits;
        this._color = Cesium.defaultValue(options.color, Cesium.Color.CYAN);
        this.show = Cesium.defaultValue(options.show, true);
      
        this.id = options.id;
        this._id = undefined;
      
        this._planesPrimitives = [];

        this._material = new Cesium.Material({
            translucent: Cesium.defaultValue(options.translucent,false),
            fabric: {
                uniforms: {
                    image: Directory.CesiumDir + "/Assets/Images/cesium_credit.png",
                    },
                source: "    czm_material czm_getMaterial(czm_materialInput materialInput) {\n" +
                "    czm_material material = czm_getDefaultMaterial(materialInput); \n" +
                "    vec4 color = texture2D(image, materialInput.st); \n" +
                "    material.alpha = color.a; \n" +
                "    material.diffuse = color.rgb; \n" +
                "    material.specular = 0.0; \n" + // Specular mountain tops
                "    material.shininess = 0.0; \n" + // Sharpen highlight    
                "    if(material.alpha == 0.0)discard;\n" +
                "    return material; \n" +
                "} \n",
            },
        });

        this._appearance = new Cesium.MaterialAppearance({
            renderState: {
                depthTest: { enabled: true },
                depthMask: true,
                blending: Cesium.BlendingState.ALPHA_BLEND,
                cull: {
                enabled: false,
                face: Cesium.CullFace.FRONT
                }
            },
            flat: true,
            translucent: Cesium.defaultValue(options.translucent, false),
            material: this._material,
        });
    }
    SimpleDrawPrimitive.prototype.bindVolume = function (scene,weatherVolume,volumeSlice) {
        var _uniforms = {
            clipMatrix: weatherVolume.inner._clipMatrix,
            u_attribute: weatherVolume.inner._attributeMatrix
          };

        var isLengthWay = volumeSlice instanceof WeatherLengthWay;

        if(isLengthWay){
            _uniforms.calcMatrix = volumeSlice._volumeWall._calcMatrix;
        }else {
            _uniforms.calcMatrix = volumeSlice._surfs[0]._calcMatrix;
            volumeSlice._surfs[0]._calcMatrix[7] = 1.0;
        }
        
        var mFabric = isLengthWay ? VolumeWallMaterial : VolumeSurfaceMaterial;

        _uniforms.baseTexture = WeatherVolumeLibrary.create3DTexture(scene.context,weatherVolume.inner._source);
        _uniforms.tfTexture = WeatherVolumeLibrary.createTransferTexture(scene.context,weatherVolume._ValueAndColorRamp, weatherVolume.inner.transferRange, weatherVolume.inner._attributeMatrix[1]);
        
        if(Cesium.defined(weatherVolume.inner._texture)){
            _uniforms.baseTexture.sampler = weatherVolume.inner._texture.sampler;
        }

        this._material = this._material && this._material.destroy();

        this._material = new Cesium.Material({
            translucent: false,
            fabric: {
                uniforms: _uniforms,
                source: weatherVolume._TransFunction + mFabric,
            },
          });

          this._appearance = new Cesium.MaterialAppearance({
            renderState: {
                depthTest: { enabled: true },
                depthMask: true,
                blending: Cesium.BlendingState.ALPHA_BLEND,
                cull: {
                enabled: false,
                face: Cesium.CullFace.FRONT
                }
            },
            flat: true,
            translucent: false,
            material: this._material,
        });
    };

    SimpleDrawPrimitive.prototype.update = function (frameState) {
        if (!this.show) {
            return;
        }

        var planesPrimitives = this._planesPrimitives;
        var i;
        var length;

        if (planesPrimitives.length === 0) {
            var camera = this._camera;
            var cameraFrustum = camera.frustum;
            var frustum;
            if (cameraFrustum instanceof Cesium.PerspectiveFrustum) {
            frustum = scratchPerspective;
            } else if (cameraFrustum instanceof Cesium.PerspectiveOffCenterFrustum) {
            frustum = scratchPerspectiveOffCenter;
            } else if (cameraFrustum instanceof Cesium.OrthographicFrustum) {
            frustum = scratchOrthographic;
            } else {
            frustum = scratchOrthographicOffCenter;
            }
            frustum = cameraFrustum.clone(frustum);

            var numFrustums;
            var frustumSplits = this._frustumSplits;
            if (!Cesium.defined(frustumSplits) || frustumSplits.length <= 1) {
            // Use near and far planes if no splits created
            frustumSplits = scratchSplits;
            frustumSplits[0] = this._camera.frustum.near + 0.1;
            frustumSplits[1] = this._camera.frustum.far;
            numFrustums = 1;
            } else {
            numFrustums = frustumSplits.length - 1;
            }

            var position = camera.positionWC;
            var direction = camera.directionWC;
            var up = camera.upWC;
            var right = camera.rightWC;
            right = Cesium.Cartesian3.negate(right, scratchRight);

            var rotation = scratchRotation;
            Cesium.Matrix3.setColumn(rotation, 0, right, rotation);
            Cesium.Matrix3.setColumn(rotation, 1, up, rotation);
            Cesium.Matrix3.setColumn(rotation, 2, direction, rotation);

            var orientation = Cesium.Quaternion.fromRotationMatrix(
            rotation,
            scratchOrientation
            );

            planesPrimitives.length = numFrustums;

            for (i = 0; i < numFrustums; ++i) {
            frustum.near = frustumSplits[i];
            frustum.far = frustumSplits[i + 1];

            planesPrimitives[i] = new Cesium.Primitive({
                geometryInstances: new Cesium.GeometryInstance({
                geometry: new SimpleDrawFrustum({
                    origin: position,
                    orientation: orientation,
                    frustum: frustum,
                    _drawNearPlane: i === 0,
                }),
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(
                    Cesium.Color.fromAlpha(this._color, 0.1, scratchColor)
                    ),
                },
                id: this.id,
                pickPrimitive: this,
                }),
                appearance: this._appearance,
                asynchronous: false,
            });

            
            }
        }

        length = planesPrimitives.length;
        for (i = 0; i < length; ++i) {
            planesPrimitives[i].update(frameState);
        }
    };

    SimpleDrawPrimitive.prototype.isDestroyed = function () {
        return false;
    };

    SimpleDrawPrimitive.prototype.destroy = function () {
        var length = this._planesPrimitives.length;
        for (var i = 0; i < length; ++i) {
          this._planesPrimitives[i] =
            this._planesPrimitives[i] && this._planesPrimitives[i].destroy();
        }
        
        this._material = this._material && this._material.destroy();

        return Cesium.destroyObject(this);
    };  

    Object.defineProperties(SimpleDrawPrimitive.prototype, {
        appearance: {
            get: function () {
                return this._appearance;
            },
            set: function (value) {
                this._material = this._material && this._material.destroy();
                this._appearance = value;
            }
        },
    });

    function TimeSampleArray(urls, parseTime) {
      var property = new Cesium.SampledProperty(Number);

      var i = 0;
      for (; i < urls.length; i++) {
        var name = urls[i];
        var t = typeof parseTime === 'array' ? parseTime[i] : parseTime(name);
        property.addSample(t, i);
        if (i === 0) {
          this._start = t;
        } else if (i === urls.length - 1) {
          this._end = t;
        }
      }

      this._urls = urls;
      this._sampleProperty = property;
    }

    TimeSampleArray.prototype.getIndex = function (time) {
      return Math.floor(this.sampleProperty.getValue(time));
    };

    TimeSampleArray.prototype.getUrl = function (index) {
      return this._urls[index];
    };

    Object.defineProperties(TimeSampleArray.prototype, {
      start: {
        get: function () {
          return this._start;
        },
      },
      end: {
        get: function () {
          return this._end;
        },
      },
      sampleProperty: {
        get: function () {
          return this._sampleProperty;
        },
      },
    });

    function TimeSystem(we) {
      this._we = we;
      this._playing = false;
    }

    Object.defineProperties(TimeSystem.prototype, {
      timeSampleArray: {
        get: function () {
          return this._timeSampleArray;
        },
        set: function (value) {
          this._timeSampleArray = value;
        },
      },
      playing: {
        get: function () {
          return this._playing;
        },
        set: function (value) {
          this._playing = value;
        },
      },
    });

    TimeSystem.prototype.addTimeArray = function (urls, parseTime) {
      this._timeSampleArray = new TimeSampleArray(urls, parseTime);
    };

    TimeSystem.prototype.setRange = function (start,stop) {
      var viewer = this._we.viewer;
      viewer.clock.startTime = start.clone();
      viewer.clock.stopTime = stop.clone();
      viewer.clock.currentTime = start.clone();
      viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP; //Loop at the end
      viewer.clock.clockStep = Cesium.ClockStep.TICK_DEPENDENT;
      viewer.timeline.zoomTo(start, stop);
      //this.playing = true;
    };

    TimeSystem.prototype.update = function (frameState) {
      // if (!this.playing && !frameState.passes.render) {
      //   return;
      // }

      // if (Cesium.defined(this.timeSampleArray)) {
      //   var viewer = this._we.viewer;
      //   var time = frameState.time;
      //   var index = this.timeSampleArray.getIndex(time);
      //   var url = this.timeSampleArray.getUrl(index);
      //   if (Cesium.defined(url)) {
      //       viewer.clock.shouldAnimate = this._we.layerManager.updateTime(index, url);
      //       this._we.layerManager.updateTime(index, url);
      //   }
      // }
    };

    function Util(){

    }

    Util.getFullscreenPoints = function () {
    	var fullscreenQuad = new Cesium.Geometry({
    		attributes: new Cesium.GeometryAttributes({
    			position: new Cesium.GeometryAttribute({
    				componentDatatype: Cesium.ComponentDatatype.FLOAT,
    				componentsPerAttribute: 3,
    				//  v3----v2
    				//  |     |
    				//  |     |
    				//  v0----v1
    				values: new Float32Array([
    					-1, -1, 0, // v0
    					1, -1, 0, // v1
    					1, 1, 0, // v2
    					-1, 1, 0, // v3
    					0, 0, 0, // v4
    				])
    			}),
    			st: new Cesium.GeometryAttribute({
    				componentDatatype: Cesium.ComponentDatatype.FLOAT,
    				componentsPerAttribute: 2,
    				values: new Float32Array([
    					0, 0,
    					1, 0,
    					1, 1,
    					0, 1,
    					0.5, 0.5,
    				])
    			})
    		})
    	});
    	return fullscreenQuad;
    };

    Util.getFullscreenQuad = function () {
    	var fullscreenQuad = new Cesium.Geometry({
    		attributes: new Cesium.GeometryAttributes({
    			position: new Cesium.GeometryAttribute({
    				componentDatatype: Cesium.ComponentDatatype.FLOAT,
    				componentsPerAttribute: 3,
    				//  v3----v2
    				//  |     |
    				//  |     |
    				//  v0----v1
    				values: new Float32Array([
    					-1, -1, 0, // v0
    					1, -1, 0, // v1
    					1, 1, 0, // v2
    					-1, 1, 0, // v3
    				])
    			}),
    			st: new Cesium.GeometryAttribute({
    				componentDatatype: Cesium.ComponentDatatype.FLOAT,
    				componentsPerAttribute: 2,
    				values: new Float32Array([
    					0, 0,
    					1, 0,
    					1, 1,
    					0, 1,
    				])
    			})
    		}),
    		indices: new Uint32Array([3, 2, 0, 0, 2, 1])
    	});
    	return fullscreenQuad;
    };

    Util.formatUrl = function (templateUrl, options) {
        var url;
    	url = templateUrl + '';
    	url = url.replace('{0}', options.name);
    	url = url.replace('{1}', options.varname);
    	url = url.replace('{2}', Cesium.defaultValue(options.ext,'nc'));
    	return url;
    };

    Util.createTexture = function (options, typedArray) {
    	if (Cesium.defined(typedArray)) {
    		// typed array needs to be passed as source option, this is required by Cesium.Texture
    		var source = {};
    		source.arrayBufferView = typedArray;
    		options.source = source;
    	}

    	var texture = new Cesium.Texture(options);
    	return texture;
    };

    Util.createFramebuffer = function (context, colorTexture, depthTexture) {
    	var framebuffer = new Cesium.Framebuffer({
    		context: context,
    		colorTextures: [colorTexture],
    		depthTexture: depthTexture
    	});
    	return framebuffer;
    };

    Util.createRawRenderState = function (options) {
    	var translucent = true;
    	var closed = false;
    	var existing = {
    		viewport: options.viewport,
    		depthTest: options.depthTest,
    		depthMask: options.depthMask,
    		blending: options.blending
    	};

    	var rawRenderState = Cesium.Appearance.getDefaultRenderState(translucent, closed, existing);
    	return rawRenderState;
    };

    Util.viewRectangleToLonLatRange = function (viewRectangle) {
    	var range = {};

    	var postiveWest = Cesium.Math.mod(viewRectangle.west, Cesium.Math.TWO_PI);
    	var postiveEast = Cesium.Math.mod(viewRectangle.east, Cesium.Math.TWO_PI);
    	var width = viewRectangle.width;

    	var longitudeMin;
    	var longitudeMax;
    	if (width > Cesium.Math.THREE_PI_OVER_TWO) {
    		longitudeMin = 0.0;
    		longitudeMax = Cesium.Math.TWO_PI;
    	} else {
    		if (postiveEast - postiveWest < width) {
    			longitudeMin = postiveWest;
    			longitudeMax = postiveWest + width;
    		} else {
    			longitudeMin = postiveWest;
    			longitudeMax = postiveEast;
    		}
    	}

    	range.lon = {
    		min: Cesium.Math.toDegrees(longitudeMin),
    		max: Cesium.Math.toDegrees(longitudeMax)
    	};

    	var south = viewRectangle.south;
    	var north = viewRectangle.north;
    	var height = viewRectangle.height;

    	var extendHeight = height > Cesium.Math.PI / 12 ? height / 2 : 0;
    	var extendedSouth = Cesium.Math.clampToLatitudeRange(south - extendHeight);
    	var extendedNorth = Cesium.Math.clampToLatitudeRange(north + extendHeight);

    	// extend the bound in high latitude area to make sure it can cover all the visible area
    	if (extendedSouth < -Cesium.Math.PI_OVER_THREE) {
    		extendedSouth = -Cesium.Math.PI_OVER_TWO;
    	}
    	if (extendedNorth > Cesium.Math.PI_OVER_THREE) {
    		extendedNorth = Cesium.Math.PI_OVER_TWO;
    	}

    	range.lat = {
    		min: Cesium.Math.toDegrees(extendedSouth),
    		max: Cesium.Math.toDegrees(extendedNorth)
    	};

    	return range;
    };

    Util.Cartographic2String = function (cartographic) {
    	return Cesium.Math.toDegrees(cartographic.longitude) + ',' + Cesium.Math.toDegrees(cartographic.latitude);
    };
    	
    function scaleCanvas (canvas, width, height) {
    	var w = canvas.width,
    		h = canvas.height;
    	if (width == undefined) {
    		width = w;
    	}
    	if (height == undefined) {
    		height = h;
    	}

    	var retCanvas = document.createElement('canvas');
    	var retCtx = retCanvas.getContext('2d');
    	retCanvas.width = width;
    	retCanvas.height = height;
    	retCtx.drawImage(canvas, 0, 0, w, h, 0, 0, width, height);
    	return retCanvas;
    }

    function getDataURL (canvas, type, width, height) {
    	canvas = scaleCanvas(canvas, width, height);
    	return canvas.toDataURL(type);
    }

    function saveFile (strData) {
    	document.location.href = strData;
    }

    function genImage(strData) {
    	var img = document.createElement('img');
    	img.src = strData;
    	return img;
    }

    function fixType (type) {
    	type = type.toLowerCase().replace(/jpg/i, 'jpeg');
    	var r = type.match(/png|jpeg|bmp|gif/)[0];
    	return 'image/' + r;
    }

    function encodeData (data) {
    	if (!window.btoa) { throw 'btoa undefined' }
    	var str = '';
    	if (typeof data == 'string') {
    		str = data;
    	} else {
    		for (var i = 0; i < data.length; i ++) {
    			str += String.fromCharCode(data[i]);
    		}
    	}

    	return btoa(str);
    }

    function getImageData (canvas) {
    	var w = canvas.width,
    		h = canvas.height;
    	return canvas.getContext('2d').getImageData(0, 0, w, h);
    }

    function makeURI (strData, type) {
    	return 'data:' + type + ';base64,' + strData;
    }

    /**
     * create bitmap image
     * 按照规则生成图片响应头和响应体
     */
     Util.genBitmapImage = function (oData) {

    	//
    	// BITMAPFILEHEADER: http://msdn.microsoft.com/en-us/library/windows/desktop/dd183374(v=vs.85).aspx
    	// BITMAPINFOHEADER: http://msdn.microsoft.com/en-us/library/dd183376.aspx
    	//

    	var biWidth  = oData.width;
    	var biHeight	= oData.height;
    	var biSizeImage = biWidth * biHeight * 3;
    	var bfSize  = biSizeImage + 54; // total header size = 54 bytes

    	//
    	//  typedef struct tagBITMAPFILEHEADER {
    	//  	WORD bfType;
    	//  	DWORD bfSize;
    	//  	WORD bfReserved1;
    	//  	WORD bfReserved2;
    	//  	DWORD bfOffBits;
    	//  } BITMAPFILEHEADER;
    	//
    	var BITMAPFILEHEADER = [
    		// WORD bfType -- The file type signature; must be "BM"
    		0x42, 0x4D,
    		// DWORD bfSize -- The size, in bytes, of the bitmap file
    		bfSize & 0xff, bfSize >> 8 & 0xff, bfSize >> 16 & 0xff, bfSize >> 24 & 0xff,
    		// WORD bfReserved1 -- Reserved; must be zero
    		0, 0,
    		// WORD bfReserved2 -- Reserved; must be zero
    		0, 0,
    		// DWORD bfOffBits -- The offset, in bytes, from the beginning of the BITMAPFILEHEADER structure to the bitmap bits.
    		54, 0, 0, 0
    	];

    	//
    	//  typedef struct tagBITMAPINFOHEADER {
    	//  	DWORD biSize;
    	//  	LONG  biWidth;
    	//  	LONG  biHeight;
    	//  	WORD  biPlanes;
    	//  	WORD  biBitCount;
    	//  	DWORD biCompression;
    	//  	DWORD biSizeImage;
    	//  	LONG  biXPelsPerMeter;
    	//  	LONG  biYPelsPerMeter;
    	//  	DWORD biClrUsed;
    	//  	DWORD biClrImportant;
    	//  } BITMAPINFOHEADER, *PBITMAPINFOHEADER;
    	//
    	var BITMAPINFOHEADER = [
    		// DWORD biSize -- The number of bytes required by the structure
    		40, 0, 0, 0,
    		// LONG biWidth -- The width of the bitmap, in pixels
    		biWidth & 0xff, biWidth >> 8 & 0xff, biWidth >> 16 & 0xff, biWidth >> 24 & 0xff,
    		// LONG biHeight -- The height of the bitmap, in pixels
    		biHeight & 0xff, biHeight >> 8  & 0xff, biHeight >> 16 & 0xff, biHeight >> 24 & 0xff,
    		// WORD biPlanes -- The number of planes for the target device. This value must be set to 1
    		1, 0,
    		// WORD biBitCount -- The number of bits-per-pixel, 24 bits-per-pixel -- the bitmap
    		// has a maximum of 2^24 colors (16777216, Truecolor)
    		24, 0,
    		// DWORD biCompression -- The type of compression, BI_RGB (code 0) -- uncompressed
    		0, 0, 0, 0,
    		// DWORD biSizeImage -- The size, in bytes, of the image. This may be set to zero for BI_RGB bitmaps
    		biSizeImage & 0xff, biSizeImage >> 8 & 0xff, biSizeImage >> 16 & 0xff, biSizeImage >> 24 & 0xff,
    		// LONG biXPelsPerMeter, unused
    		0,0,0,0,
    		// LONG biYPelsPerMeter, unused
    		0,0,0,0,
    		// DWORD biClrUsed, the number of color indexes of palette, unused
    		0,0,0,0,
    		// DWORD biClrImportant, unused
    		0,0,0,0
    	];

    	var iPadding = (4 - ((biWidth * 3) % 4)) % 4;

    	var aImgData = oData.data;

    	var strPixelData = '';
    	var biWidth4 = biWidth<<2;
    	var y = biHeight;
    	var fromCharCode = String.fromCharCode;

    	do {
    		var iOffsetY = biWidth4*(y-1);
    		var strPixelRow = '';
    		for (var x = 0; x < biWidth; x++) {
    			var iOffsetX = x<<2;
    			strPixelRow += fromCharCode(aImgData[iOffsetY+iOffsetX+2]) +
    						   fromCharCode(aImgData[iOffsetY+iOffsetX+1]) +
    						   fromCharCode(aImgData[iOffsetY+iOffsetX]);
    		}

    		for (var c = 0; c < iPadding; c++) {
    			strPixelRow += String.fromCharCode(0);
    		}

    		strPixelData += strPixelRow;
    	} while (--y);

    	var strEncoded = encodeData(BITMAPFILEHEADER.concat(BITMAPINFOHEADER)) + encodeData(strPixelData);

    	return strEncoded;
    };

    /**
     * saveAsImage
     * @param canvasElement
     * @param {String} image type
     * @param {Number} [optional] png width
     * @param {Number} [optional] png height
     */
     Util.saveAsImage = function (canvas, width, height, type) {
    	var downloadMime = 'image/octet-stream';
    	if (typeof canvas == "string") { canvas = document.getElementById(canvas); }
    	if (type == undefined) { type = 'png'; }
    	type = fixType(type);
    	if (/bmp/.test(type)) {
    		var data = getImageData(scaleCanvas(canvas, width, height));
    		var strData = genBitmapImage(data);
    		saveFile(makeURI(strData, downloadMime));
    	} else {
    		var strData = getDataURL(canvas, type, width, height);
    		saveFile(strData.replace(type, downloadMime));
    	}
    };

    Util.convertToImage = function (canvas, width, height, type) {
    	if (typeof canvas == "string") { canvas = document.getElementById(canvas); }
    	if (type == undefined) { type = 'png'; }
    	type = fixType(type);

    	if (/bmp/.test(type)) {
    		var data = getImageData(scaleCanvas(canvas, width, height));
    		var strData = genBitmapImage(data);
    		return genImage(makeURI(strData, 'image/bmp'));
    	} else {
    		var strData = getDataURL(canvas, type, width, height);
    		return genImage(strData);
    	}
    };

    Util.createRadarTexture = function (context,radius,ffx) {
    	var imageWidth = radius * 2;
    	var imageHeight = radius * 2;
    	var lineWidth = ffx < 3 ? 4:6;
    	var fontSize = ffx < 3 ? 18:24;

    	var c = document.createElement("canvas");
    	c.width = imageWidth;
    	c.height = imageHeight;
    	var ctx = c.getContext("2d");
    	ctx.lineWidth = lineWidth;
    	ctx.strokeStyle = '#FFFFFF';
    	ctx.fillStyle = '#FFFFFF';
      
    	var centerX = imageWidth * 0.5;
    	var centerY = imageHeight * 0.5;
    	
    	ctx.beginPath();
    	ctx.moveTo(centerX, lineWidth);
    	ctx.lineTo(centerX, imageHeight - lineWidth);
    	ctx.moveTo(lineWidth, centerY);
    	ctx.lineTo(imageWidth - lineWidth, centerY);
    	ctx.arc(centerX, centerY, radius - lineWidth, 0, 2 * Math.PI);
    	ctx.stroke();
      
    	var r = 0;
    	var r_text = 0;
    	for(var i=0;i<7;i++){
    	  ctx.beginPath();
    	  r += (i<5?50:100) * ffx;
    	  r_text += (i<5?50:100);
    	  ctx.arc(centerX, centerY, r, 0, 2 * Math.PI);
    	  ctx.stroke();
    	  ctx.font= (i<5? (fontSize + "px serif"):(fontSize * 2.0 + "px serif"));
    	  ctx.lineWidth = (i<5?lineWidth:lineWidth*2);
    	  
    	  ctx.translate(centerX, centerX);
    	  for(var j=0;j<4;j++){
    		ctx.strokeStyle = '#000000';
    		ctx.strokeText(r_text + 'KM',0,r - lineWidth);
    		ctx.fillText(r_text + 'KM',0,r - lineWidth);
    		ctx.strokeStyle = '#FFFFFF';
    		ctx.rotate(Math.PI/2);
    	  }
    	  ctx.translate(-centerX, -centerX);
    	}

        var sampler = new Cesium.Sampler({
            wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
            wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
            minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
            magnificationFilter: Cesium.TextureMagnificationFilter.LINEAR
        });

        var texture = new Cesium.Texture({
            context: context,
            source: c,
            sampler: sampler,
        });

    	return texture;
    };

    ViewPoint.PRECISION_LONLAT = 6;
    ViewPoint.PRECISION_HEIGHT = ViewPoint.PRECISION_LONLAT / 2;
    ViewPoint.PRECISION_ANGLE = ViewPoint.PRECISION_LONLAT / 3;

    function ViewPoint(options){
        if(!Cesium.defined(options)){
            options = {};
        }
        this._position = new Cesium.Cartographic;
        this._position.longitude = Cesium.defaultValue(options.longitude,0.0);
        this._position.latitude = Cesium.defaultValue(options.latitude,0.0);
        this._position.height = Cesium.defaultValue(options.height,0.0);
        this.heading = Cesium.defaultValue(options.heading,0.0);
        this.pitch = Cesium.defaultValue(options.pitch,-0.5 * Cesium.Math.PI);
        this.roll = Cesium.defaultValue(options.roll,0.0);
    }

    ViewPoint.clone = function (viewpoint, result) {
        if (!Cesium.defined(viewpoint)) {
          return undefined;
        }
        if (!Cesium.defined(result)) {
            result = new ViewPoint();
        }
        result._position = Cesium.Cartographic.clone(viewpoint._position,result._position);
        result.heading = viewpoint.heading;
        result.pitch = viewpoint.pitch;
        result.roll = viewpoint.roll;
        return result;
      };

    ViewPoint.fromCamera = function (camera, result) {
        if (!Cesium.defined(result)) {
            result = new ViewPoint();
        }

        Cesium.Cartographic.clone(camera.positionCartographic,result._position);
        result.roll = camera.roll;
        result.heading = camera.heading;
        result.pitch = camera.pitch;

        return result;
    };

    ViewPoint.prototype.fromDegrees = function (x, y, z,roll,heading,pitch) {
        Cesium.Cartographic.fromDegrees(x, y, z,this._position);
        this.roll = Cesium.Math.toRadians(roll);
        this.heading = Cesium.Math.toRadians(heading);
        this.pitch = Cesium.Math.toRadians(pitch);
    };

    Object.defineProperties(ViewPoint.prototype, {
        cartesion3: {
            get: function () {
                return Cesium.Cartesian3.fromRadians(this._position.longitude, this._position.latitude, this._position.height);
            },
            set: function (value) {
                var cartographic = Cesium.Cartographic.fromCartesian(value);
                this._position.longitude = Cesium.Math.toDegrees(cartographic.longitude);
                this._position.latitude = Cesium.Math.toDegrees(cartographic.latitude);
                this._position.height = cartographic.height;
            }
        },
        cartographic: {
            get: function () {
                return this._position;
            },
            set: function (value) {
                this._position = value;
            }
        },
        height: {
            get: function () {
                return this._position.height;
            },
            set: function (value) {
                this._position.height = value;
            }
        },
        longitudeD: {
            get: function () {
                return Cesium.Math.toDegrees(this._position.longitude);
            },
            set: function (value) {
                this._position.longitude = Cesium.Math.toRadians(value);
            }
        },
        longitude: {
            get: function () {
                return this._position.longitude;
            },
            set: function (value) {
                this._position.longitude = value;
            }
        },
        latitude: {
            get: function () {
                return this._position.latitude;
            },
            set: function (value) {
                this._position.latitude = value;
            }
        },
        latitudeD: {
            get: function () {
                return Cesium.Math.toDegrees(this._position.latitude);
            },
            set: function (value) {
                this._position.latitude = Cesium.Math.toRadians(value);
            }
        },
        position: {
            get: function () {
                return this._position;
            }
        },
        headingD: {
            get: function () {
                return Cesium.Math.toDegrees(this.heading);
            },
            set: function (value) {
                this.heading = Cesium.Math.toRadians(value);
            }
        },
        rollD: {
            get: function () {
                return Cesium.Math.toDegrees(this.roll);
            },
            set: function (value) {
                this.roll = Cesium.Math.toRadians(value);
            }
        },
        pitchD: {
            get: function () {
                return Cesium.Math.toDegrees(this.pitch);
            },
            set: function (value) {
                this.pitch = Cesium.Math.toRadians(value);
            }
        },
    });

    ViewPoint.prototype.toJSON = function (d) {
        var info = "{longitude:" + (d ?this.longitudeD:this.longitude)
            + ",latitude:" + (d ?this.latitudeD:this.latitude)
            + ",height:" + this._position.height
            + ",heading:" + (d ?this.headingD:this.heading)
            + ",pitch:" + (d ?this.pitchD:this.pitch)
            + ",roll:" + (d ?this.rollD:this.roll)
            + "}";

        return info;
    };

    var EarthPin = function (options) {
      var id = options.id;
      if (!Cesium.defined(id)) {
        id = Cesium.createGuid();
      }
      this._id = id;
      this._position = options.position;
      this._target = Cesium.defaultValue(options.target, undefined);
      this._pinGraphy = Cesium.defaultValue(options.graphy, undefined);
      this._content = options.content;
      this.pinCollection = undefined;
      this._dirty = false;
      this._appended = false;
      this._offsetWidth = 0;
      this._offsetHeight = 0;
    };

    Object.defineProperties(EarthPin.prototype, {
      id: {
        get: function () {
          return this._id;
        },
      },
      content: {
        get: function () {
          return this._content;
        },
        set: function (value) {
          this._dirty = value !== this.content;
          this._content = value;
        }
      },
      position: {
        get: function () {
          return this._position;
        },
        set: function (value) {
          this._position = value;
        }
      },
      target: {
        get: function () {
          return this._target;
        },
      },
    });

    EarthPin.prototype.destroy = function () {
      if (Cesium.defined(this._target)) {
        this._target.remove();
      }
      this.pinCollection.remove(this);
      return Cesium.destroyObject(this);
    };


    EarthPin.prototype.update = function (mgr, time) {
      if (!this._appended) {
        this._appended = true;
        if (Cesium.defined(this._pinGraphy)) {
          this._target = this._pinGraphy.createGraph(mgr.viewer.container, this);
        } else {
          mgr.viewer.container.appendChild(this._target);
        }

        this._offsetWidth = this._target.offsetWidth;
        this._offsetHeight = this._target.offsetHeight;
      }

      if (this._dirty && Cesium.defined(this._pinGraphy) && Cesium.defined(this.content)) {
        this._dirty = false;
        this._pinGraphy.content = this.content;
      }

      var target = this._target;
      var position = Cesium.SceneTransforms.wgs84ToWindowCoordinates(mgr.viewer.scene, this._position);
      if (position) {
        if (Cesium.defined(this._pinGraphy) && Cesium.defined(this._pinGraphy.showAt)) {
          this._pinGraphy.showAt(position);
          return;
        }
        var x = position.x - this._offsetWidth / 2;
        var y = position.y - this._offsetHeight - 15;
        var v = position.x > 0 && position.y > 0 && position.x < mgr.viewer.container.clientWidth && position.y < mgr.viewer.container.clientHeight;
        if (v && target.style.display !== 'block') {
          target.style.display = v ? 'block' : 'none';
        } else if (!v && target.style.display !== 'none') {
          target.style.display = v ? 'block' : 'none';
        }
        if (v) {
          target.style.left = x + 'px';
          target.style.top = y + 'px'; // 垂直偏移距离。
          this._offsetWidth = target.offsetWidth;
          this._offsetHeight = target.offsetHeight;
        }
      }
    };

    var pinOptionsScratch = {
      id: undefined,
    };

    var EarthPinCollection = function (we) {
      this._viewer = we.viewer;
      this._pins = new Cesium.AssociativeArray();
      this._removedPins = new Cesium.AssociativeArray();
      this._firing = false;
      this._refire = false;
      this._tooltip = undefined;
      var that = this;
      this._preUpdateRemoveListener = this._viewer.scene.preUpdate.addEventListener(
        function (scene, time) {
          that.update(that, time);
        }
      );
    };

    Object.defineProperties(EarthPinCollection.prototype, {
      viewer: {
        get: function () {
          return this._viewer;
        },
      },
    });

    EarthPinCollection.prototype.showTooltip = function (cartographic, message) {
      this._tooltip = this._tooltip && this._tooltip.destroy();
      this._tooltip = new Tooltip(this._viewer.container);
      this._tooltip.showAt(cartographic, message);
    };

    EarthPinCollection.prototype.hideTooltip = function () {
      this._tooltip = this._tooltip && this._tooltip.destroy();
    };

    EarthPinCollection.prototype.add = function (pin) {
      if (!Cesium.defined(pin)) {
        throw new Cesium.DeveloperError("entity is required.");
      }

      if (!(pin instanceof EarthPin)) {
        pin = new EarthPin(pin);
      }

      var id = pin.id;
      var pins = this._pins;
      if (pins.contains(id)) {
        throw new Cesium.RuntimeError(
          "An pin with id " + id + " already exists in this collection."
        );
      }
      pin.pinCollection = this;
      pins.set(id, pin);

      return pin;
    };

    EarthPinCollection.prototype.getById = function (id) {
      if (!Cesium.defined(id)) {
        throw new Cesium.DeveloperError("id is required.");
      }

      return this._pins.get(id);
    };

    EarthPinCollection.prototype.getOrCreatePin = function (id) {
      if (!Cesium.defined(id)) {
        throw new Cesium.DeveloperError("id is required.");
      }

      var pin = this._pins.get(id);
      if (!Cesium.defined(pin)) {
        pinOptionsScratch.id = id;
        pin = new EarthPin(pinOptionsScratch);
        this.add(pin);
      }
      return pin;
    };

    EarthPinCollection.prototype.remove = function (pin) {
      if (!Cesium.defined(pin)) {
        return false;
      }

      if (typeof pin === 'string') {
        return this.removeById(pin);
      }

      if (!Cesium.defined(pin.id)) {
        return false;
      }

      if (!this._pins.remove(pin.id)) {
        return false;
      }

      pin.destroy();
      return true;
    };

    EarthPinCollection.prototype.removeById = function (id) {
      if (!Cesium.defined(id)) {
        return false;
      }

      var pin = this.getById(id);
      if (!Cesium.defined(pin)) {
        return false;
      }

      if (!this._pins.remove(id)) {
        return false;
      }

      pin.destroy();
      return true;
    };

    EarthPinCollection.prototype.removeAll = function () {
      var pins = this._pins;
      var pinsLength = pins.length;
      var array = pins.values;

      for (var i = 0; i < pinsLength; i++) {
        var existingItem = array[i];
        existingItem.destory();
      }

      pins.removeAll();
    };

    EarthPinCollection.prototype.destroy = function () {
      this._preUpdateRemoveListener();
    };

    EarthPinCollection.prototype.update = function (mgr, time) {
      var pins = this._pins.values;
      var pinsLength = pins.length;
      for (var i = 0; i < pinsLength; i++) {
        var pin = pins[i];
        pin.update(mgr, time);
      }
    };

    //This file is automatically rebuilt by the WeatherEarth build process.
    var VolumeBoxVS = "attribute vec3 position3DHigh; \n\
attribute vec3 position3DLow;\n\
attribute float batchId; \n\
varying vec3 v_positionEC;\n\
varying vec4 vertexPos;\n\
varying vec4 cameraPos;\n\
void main()\n\
{\n\
    vec4 p = czm_computePosition();\n\
    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n\
    vec3 pos = position3DHigh + position3DLow;\n\
    vertexPos = vec4(pos.xyz, 1.0);\n\
    cameraPos = czm_inverseModelView * vec4(0,0,0,1);\n\
    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n\
}\n\
";

    //This file is automatically rebuilt by the WeatherEarth build process.
    var VolumeBoxFS = "precision highp sampler3D;\n\
varying vec3 v_positionEC;\n\
varying vec4 vertexPos;\n\
varying vec4 cameraPos;\n\
#ifdef INCLUDE_IN_JS\n\
varying vec4 v_pickColor;\n\
uniform float AlphaFuncValue;\n\
uniform float TransparencyValue;\n\
uniform mat4 texgen;\n\
uniform mat4 statisticMatrix;\n\
uniform mat4 clipMatrix;\n\
uniform mat4 u_attribute;\n\
uniform sampler3D baseTexture;\n\
#endif\n\
\n\
\n\
void v_trans(inout vec4 color,vec3 texcoord)\n\
{\n\
    bool usePhongLight = u_attribute[0][3] > 0.0;\n\
    vec3 normalEC = -vec3(0,0,1);\n\
    float scaler = u_attribute[0][0];\n\
    float offset = u_attribute[0][1];\n\
    float value = czm_unpackVolume(color,scaler,offset);\n\
    vec4 realColor = v_transfer(value,texcoord.z,usePhongLight,color);\n\
\n\
    float filterCustom = u_attribute[3][2];\n\
    if(filterCustom < 1.0)\n\
    {\n\
        float filtrationmin = clipMatrix[3][2];\n\
        float filtrationmax = clipMatrix[3][3];\n\
        if(value > filtrationmax || value < filtrationmin)\n\
        {\n\
            realColor.a = 0.0;\n\
        }\n\
    }\n\
\n\
    float circle_clip_r = u_attribute[3][1];\n\
    if(circle_clip_r > 0.0)\n\
    {\n\
        float circle_clip_x = u_attribute[2][3];\n\
        float circle_clip_y = u_attribute[3][0];\n\
        vec2 toCenter = vec2(texcoord.x,texcoord.y) - vec2(circle_clip_x,circle_clip_y);\n\
        if(length(toCenter) < circle_clip_r){\n\
            realColor.a = 0.0;\n\
        }\n\
    }\n\
\n\
    float resolution = 7.0 + u_attribute[1][2];\n\
    float normalSampleDistance = 1.0/pow(2.0,resolution);\n\
    if(usePhongLight && texcoord.x > normalSampleDistance && texcoord.y > normalSampleDistance\n\
        && texcoord.x < 1.0 - normalSampleDistance && texcoord.y < 1.0 - normalSampleDistance && texcoord.z < 1.0 - normalSampleDistance)\n\
    {\n\
        //vec2 color_normal = (color.zw - vec2(0.5,0.5)) * 2.0;\n\
        normalEC = czm_octDecode(color.zw * 255.0);\n\
    }\n\
    color = realColor;\n\
    if(usePhongLight && realColor.a > 0.0)\n\
    {\n\
        vec3 positionToEyeEC = -v_positionEC;\n\
        czm_material material;\n\
        material.diffuse = realColor.rgb;\n\
        material.specular = 0.0;\n\
        material.shininess = 0.0;\n\
        material.normal = -normalize(normalEC);\n\
        material.emission = vec3(0.1);\n\
        material.alpha = realColor.a;\n\
        color = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n\
    }\n\
}\n\
bool inside_clip(vec3 texcoord)\n\
{\n\
    float clip_minx = clipMatrix[0][0];\n\
    float clip_maxx = clipMatrix[0][1];\n\
    float clip_miny = clipMatrix[0][2];\n\
    float clip_maxy = clipMatrix[0][3];\n\
    float clip_maxz = clipMatrix[1][0];\n\
    if(texcoord.x > clip_maxx || texcoord.x < clip_minx\n\
    ||texcoord.y > clip_maxy || texcoord.y < clip_miny\n\
    ||texcoord.z > clip_maxz)\n\
    return false;\n\
    return true;\n\
}\n\
vec3 st_region(in vec3 texcoord)\n\
{\n\
    vec3 st = texcoord;\n\
    float st_x = u_attribute[1][3];\n\
    float st_y = u_attribute[2][0];\n\
    float st_width = u_attribute[2][1];\n\
    float st_height = u_attribute[2][2];\n\
    st.x = st_x + texcoord.x * st_width;\n\
    st.y = st_y + texcoord.y * st_height;\n\
    return st;\n\
}\n\
void main(){\n\
    vec4 t0 = vertexPos * texgen;\n\
    vec4 te = cameraPos * texgen;\n\
    if (te.x>=0.0 && te.x<=1.0 &&\n\
    te.y>=0.0 && te.y<=1.0 &&\n\
    te.z>=0.0 && te.z<=1.0)\n\
    {\n\
    }\n\
    else\n\
    {\n\
        if (te.x<0.0)\n\
        {\n\
            float r = -te.x / (t0.x-te.x);\n\
            te = te + (t0-te)*r;\n\
        }\n\
        if (te.x>1.0)\n\
        {\n\
            float r = (1.0-te.x) / (t0.x-te.x);\n\
            te = te + (t0-te)*r;\n\
        }\n\
        if (te.y<0.0)\n\
        {\n\
            float r = -te.y / (t0.y-te.y);\n\
            te = te + (t0-te)*r;\n\
        }\n\
        if (te.y>1.0)\n\
        {\n\
            float r = (1.0-te.y) / (t0.y-te.y);\n\
            te = te + (t0-te)*r;\n\
        }\n\
        if (te.z<0.0)\n\
        {\n\
            float r = -te.z / (t0.z-te.z);\n\
            te = te + (t0-te)*r;\n\
        }\n\
        if (te.z>1.0)\n\
        {\n\
            float r = (1.0-te.z) / (t0.z-te.z);\n\
            te = te + (t0-te)*r;\n\
        }\n\
    }\n\
    float resolution = 7.0 + u_attribute[1][2];\n\
    vec3 texcoord = t0.xyz;\n\
    float num_iterations = pow(2.0,resolution);\n\
    vec3 deltaTexCoord=(te-t0).xyz/(num_iterations-1.0);\n\
    gl_FragColor = texture3D(baseTexture,texcoord);\n\
    vec4 fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\
    while(num_iterations-- > 0.0)\n\
    {\n\
        vec3 st = st_region(texcoord);\n\
        vec4 color = texture3D(baseTexture,st);\n\
        v_trans(color,texcoord);\n\
        if(!inside_clip(texcoord))\n\
        {\n\
            color.a = 0.0;\n\
        }\n\
        float r = color.a * TransparencyValue;\n\
        if (r>AlphaFuncValue)\n\
        {\n\
            fragColor.xyz = fragColor.xyz*(1.0-r)+color.xyz*r;\n\
            fragColor.w += r;\n\
        } \n\
        if (fragColor.w<color.w)\n\
        {\n\
            fragColor = color;\n\
        }\n\
        texcoord += deltaTexCoord;\n\
    }\n\
    fragColor.w *= TransparencyValue;\n\
    if (fragColor.w>1.0) fragColor.w = 1.0;\n\
    if (fragColor.w<AlphaFuncValue) discard;\n\
    gl_FragColor = fragColor;\n\
    return;\n\
}\n\
";

    function WeatherVolumeBox(volume) {
      var _uniforms = {
        baseTexture: volume._texture,
        clipMatrix: volume._clipMatrix,
        texgen: volume._texgen,
        tfTexture: volume._textureTF,
        u_attribute: volume._attributeMatrix,
        statisticMatrix: volume._statisticMatrix,
        AlphaFuncValue: volume._alphaFuncValue,
        TransparencyValue: volume._transparencyValue,
      };

      var fs = VolumeBoxFS;

      if (Cesium.defined(volume._transFunction)) {
        fs = "#define HasTransfuction;\n" + volume._transFunction + "\n" + fs;
      }

      var i = 0;
      Object.keys(_uniforms).forEach(function (element) {
        var re = new RegExp(element + "\\b", "g");
        fs = fs.replace(re, element + "_" + i++);
      });

      var halfWidth = volume._meter.width * 0.5;
      var halfHeight = volume._meter.height * 0.5;
      var depth = volume._meter.depth;

      this._boxGeometry = Cesium.BoxGeometry.createGeometry(
        new Cesium.BoxGeometry({
          maximum: new Cesium.Cartesian3(halfWidth, halfHeight, depth),
          minimum: new Cesium.Cartesian3(-halfWidth, -halfHeight, 0.0),
          vertexFormat: Cesium.VertexFormat.POSITION_AND_NORMAL,
        })
      );
    /*
      var positions = new Float32Array(6 * 4 * 3);

      var min = new Cesium.Cartesian3(0, 0, 0);
      var max = new Cesium.Cartesian3(1, 1, 1);
        
        // +z face
        positions[0] = min.x;
        positions[1] = min.y;
        positions[2] = max.z;
        positions[3] = max.x;
        positions[4] = min.y;
        positions[5] = max.z;
        positions[6] = max.x;
        positions[7] = max.y;
        positions[8] = max.z;
        positions[9] = min.x;
        positions[10] = max.y;
        positions[11] = max.z;

        // -z face
        positions[12] = min.x;
        positions[13] = min.y;
        positions[14] = min.z;
        positions[15] = max.x;
        positions[16] = min.y;
        positions[17] = min.z;
        positions[18] = max.x;
        positions[19] = max.y;
        positions[20] = min.z;
        positions[21] = min.x;
        positions[22] = max.y;
        positions[23] = min.z;

        // +x face
        positions[24] = max.x;
        positions[25] = min.y;
        positions[26] = min.z;
        positions[27] = max.x;
        positions[28] = max.y;
        positions[29] = min.z;
        positions[30] = max.x;
        positions[31] = max.y;
        positions[32] = max.z;
        positions[33] = max.x;
        positions[34] = min.y;
        positions[35] = max.z;

        // -x face
        positions[36] = min.x;
        positions[37] = min.y;
        positions[38] = min.z;
        positions[39] = min.x;
        positions[40] = max.y;
        positions[41] = min.z;
        positions[42] = min.x;
        positions[43] = max.y;
        positions[44] = max.z;
        positions[45] = min.x;
        positions[46] = min.y;
        positions[47] = max.z;

        // +y face
        positions[48] = min.x;
        positions[49] = max.y;
        positions[50] = min.z;
        positions[51] = max.x;
        positions[52] = max.y;
        positions[53] = min.z;
        positions[54] = max.x;
        positions[55] = max.y;
        positions[56] = max.z;
        positions[57] = min.x;
        positions[58] = max.y;
        positions[59] = max.z;

        // -y face
        positions[60] = min.x;
        positions[61] = min.y;
        positions[62] = min.z;
        positions[63] = max.x;
        positions[64] = min.y;
        positions[65] = min.z;
        positions[66] = max.x;
        positions[67] = min.y;
        positions[68] = max.z;
        positions[69] = min.x;
        positions[70] = min.y;
        positions[71] = max.z;

      this._boxGeometry.attributes.color = new Cesium.GeometryAttribute({
        componentDatatype: Cesium.ComponentDatatype.FLOAT,
        componentsPerAttribute: 3,
        values: positions,
      });
    */
      this._id = volume;
      this._modelMatrix = volume._modelmatrix;
      //this._box.modelMatrix = volume._modelmatrix;
      this._appearance = new Cesium.MaterialAppearance({
        renderState: {
          depthTest: { enabled: true },
          depthMask: true,
          blending: Cesium.BlendingState.ALPHA_BLEND,
          cull: {
            enabled: true,
            face: Cesium.CullFace.FRONT,
          },
        },
        translucent: false,
        vertexShaderSource: VolumeBoxVS,
        fragmentShaderSource: fs,
        material: new Cesium.Material({
          translucent: true,
          fabric: {
            uniforms: _uniforms,
          },
        }),
      });
    }

    WeatherVolumeBox.prototype.isDestroyed = function () {
      return false;
    };

    WeatherVolumeBox.prototype.destroy = function () {
      this._box = this._box && this._box.destroy();
    };

    WeatherVolumeBox.prototype.updateMatrix = function (matrix) {
      if(Cesium.defined(this._box)){
        this._box.modelMatrix = matrix;
      }
    };

    WeatherVolumeBox.prototype.createBox = function () {
      this._box = new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry: this._boxGeometry,
          modelMatrix: this._modelMatrix,
        }),
        asynchronous: false,
      });
      this._box.modelMatrix1 = this._modelMatrix;
      this._box.id = this._id;
      this._box.appearance = this._appearance;
    };

    WeatherVolumeBox.prototype.update = function (frameState) {
      if (!Cesium.defined(this._box)) {
        this.createBox();
      }
      this._box.update(frameState);
    };

    /**
     * @private
     */
    var WeatherVolumeConeGeometryLibrary = {};

    /**
     * @private
     */
    WeatherVolumeConeGeometryLibrary.computePositions = function (
      length,
      topRadius,
      bottomRadius,
      slices,
      fill
    ) {
      var topZ = length;
      var bottomZ = 0.0;

      var twoSlice = slices + slices;
      var size = fill ? 2 * twoSlice : twoSlice;
      var positions = new Float64Array(size * 3);
      var i;
      var index = 0;
      var tbIndex = 0;
      var bottomOffset = fill ? twoSlice * 3 : 0;
      var topOffset = fill ? (twoSlice + slices) * 3 : slices * 3;

      for (i = 0; i < slices; i++) {
        var angle = (i / slices) * Cesium.Math.TWO_PI;
        var x = Math.cos(angle);
        var y = Math.sin(angle);
        var bottomX = x * bottomRadius;
        var bottomY = y * bottomRadius;
        var topX = x * topRadius;
        var topY = y * topRadius;

        positions[tbIndex + bottomOffset] = bottomX;
        positions[tbIndex + bottomOffset + 1] = bottomY;
        positions[tbIndex + bottomOffset + 2] = bottomZ;

        positions[tbIndex + topOffset] = topX;
        positions[tbIndex + topOffset + 1] = topY;
        positions[tbIndex + topOffset + 2] = topZ;
        tbIndex += 3;
        if (fill) {
          positions[index++] = bottomX;
          positions[index++] = bottomY;
          positions[index++] = bottomZ;
          positions[index++] = topX;
          positions[index++] = topY;
          positions[index++] = topZ;
        }
      }

      return positions;
    };

    var radiusScratch;
    var normalScratch;
    var bitangentScratch;
    var tangentScratch;
    var positionScratch;

    /**
     * A description of a cylinder.
     *
     * @alias WeatherVolumeConeGeometry
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {Number} options.length The length of the cylinder.
     * @param {Number} options.topRadius The radius of the top of the cylinder.
     * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.
     * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.
     * @param {Cesium.VertexFormat} [options.vertexFormat=Cesium.VertexFormat.DEFAULT] The vertex attributes to be computed.
     *
     * @exception {Cesium.DeveloperError} options.slices must be greater than or equal to 3.
     *
     * @see WeatherVolumeConeGeometry.createGeometry
     *
     * @example
     * // create cylinder geometry
     * var cylinder = new Cesium.WeatherVolumeConeGeometry({
     *     length: 200000,
     *     topRadius: 80000,
     *     bottomRadius: 200000,
     * });
     * var geometry = Cesium.WeatherVolumeConeGeometry.createGeometry(cylinder);
     */


     
    function WeatherVolumeConeGeometry(options) {
      radiusScratch = new Cesium.Cartesian2();
      normalScratch = new Cesium.Cartesian3();
      bitangentScratch = new Cesium.Cartesian3();
      tangentScratch = new Cesium.Cartesian3();
      positionScratch = new Cesium.Cartesian3();

      options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

      var length = options.length;
      var topRadius = options.topRadius;
      var bottomRadius = options.bottomRadius;
      var vertexFormat = Cesium.defaultValue(options.vertexFormat, Cesium.VertexFormat.DEFAULT);
      var slices = Cesium.defaultValue(options.slices, 128);


      this._length = length;
      this._topRadius = topRadius;
      this._bottomRadius = bottomRadius;
      this._vertexFormat = Cesium.VertexFormat.clone(vertexFormat);
      this._slices = slices;
      this._offsetAttribute = options.offsetAttribute;
      this._workerName = "createVolumeConeGeometry";
    }

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {WeatherVolumeConeGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
     *
     * @returns {Number[]} The array that was packed into
     */
    WeatherVolumeConeGeometry.pack = function (value, array, startingIndex) {

      startingIndex = Cesium.defaultValue(startingIndex, 0);

      Cesium.VertexFormat.pack(value._vertexFormat, array, startingIndex);
      startingIndex += Cesium.VertexFormat.packedLength + 5;

      array[startingIndex++] = value._length;
      array[startingIndex++] = value._topRadius;
      array[startingIndex++] = value._bottomRadius;
      array[startingIndex++] = value._slices;
      array[startingIndex] = Cesium.defaultValue(value._offsetAttribute, -1);

      return array;
    };

    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {WeatherVolumeConeGeometry} [result] The object into which to store the result.
     * @returns {WeatherVolumeConeGeometry} The modified result parameter or a new WeatherVolumeConeGeometry instance if one was not provided.
     */
    WeatherVolumeConeGeometry.unpack = function (array, startingIndex, result) {

      
      var scratchVertexFormat = new Cesium.VertexFormat();
      var scratchOptions = {
        vertexFormat: scratchVertexFormat,
        length: undefined,
        topRadius: undefined,
        bottomRadius: undefined,
        slices: undefined,
        offsetAttribute: undefined,
      };


      startingIndex = Cesium.defaultValue(startingIndex, 0);

      var vertexFormat = Cesium.VertexFormat.unpack(
        array,
        startingIndex,
        scratchVertexFormat
      );
      startingIndex += Cesium.VertexFormat.packedLength;

      var length = array[startingIndex++];
      var topRadius = array[startingIndex++];
      var bottomRadius = array[startingIndex++];
      var slices = array[startingIndex++];
      var offsetAttribute = array[startingIndex];

      if (!Cesium.defined(result)) {
        scratchOptions.length = length;
        scratchOptions.topRadius = topRadius;
        scratchOptions.bottomRadius = bottomRadius;
        scratchOptions.slices = slices;
        scratchOptions.offsetAttribute =
          offsetAttribute === -1 ? undefined : offsetAttribute;
        return new WeatherVolumeConeGeometry(scratchOptions);
      }

      result._vertexFormat = Cesium.VertexFormat.clone(vertexFormat, result._vertexFormat);
      result._length = length;
      result._topRadius = topRadius;
      result._bottomRadius = bottomRadius;
      result._slices = slices;
      result._offsetAttribute =
        offsetAttribute === -1 ? undefined : offsetAttribute;

      return result;
    };

    /**
     * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.
     *
     * @param {WeatherVolumeConeGeometry} WeatherVolumeConeGeometry A description of the cylinder.
     * @returns {Cesium.Geometry|undefined} The computed vertices and indices.
     */
    WeatherVolumeConeGeometry.createGeometry = function (WeatherVolumeConeGeometry) {
      var length = WeatherVolumeConeGeometry._length;
      var topRadius = WeatherVolumeConeGeometry._topRadius;
      var bottomRadius = WeatherVolumeConeGeometry._bottomRadius;
      var vertexFormat = WeatherVolumeConeGeometry._vertexFormat;
      var slices = WeatherVolumeConeGeometry._slices;

      if (
        length <= 0 ||
        topRadius < 0 ||
        bottomRadius < 0 ||
        (topRadius === 0 && bottomRadius === 0)
      ) {
        return;
      }

      var twoSlices = slices + slices;
      var numVertices = twoSlices + twoSlices;

      var positions = WeatherVolumeConeGeometryLibrary.computePositions(
        length,
        topRadius,
        bottomRadius,
        slices,
        true
      );

      var st = vertexFormat.st ? new Float32Array(numVertices * 2) : undefined;
      var normals = vertexFormat.normal
        ? new Float32Array(numVertices * 3)
        : undefined;
      var tangents = vertexFormat.tangent
        ? new Float32Array(numVertices * 3)
        : undefined;
      var bitangents = vertexFormat.bitangent
        ? new Float32Array(numVertices * 3)
        : undefined;

      var i;
      var computeNormal =
        vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent;

      if (computeNormal) {
        var computeTangent = vertexFormat.tangent || vertexFormat.bitangent;

        var normalIndex = 0;
        var tangentIndex = 0;
        var bitangentIndex = 0;

        var theta = Math.atan2(bottomRadius - topRadius, length);
        var normal = normalScratch;
        normal.z = Math.sin(theta);
        var normalScale = Math.cos(theta);
        var tangent = tangentScratch;
        var bitangent = bitangentScratch;

        for (i = 0; i < slices; i++) {
          var angle = (i / slices) * Cesium.Math.TWO_PI;
          var x = normalScale * Math.cos(angle);
          var y = normalScale * Math.sin(angle);
          if (computeNormal) {
            normal.x = x;
            normal.y = y;

            if (computeTangent) {
              tangent = Cesium.Cartesian3.normalize(
                Cesium.Cartesian3.cross(Cesium.Cartesian3.UNIT_Z, normal, tangent),
                tangent
              );
            }

            if (vertexFormat.normal) {
              normals[normalIndex++] = normal.x;
              normals[normalIndex++] = normal.y;
              normals[normalIndex++] = normal.z;
              normals[normalIndex++] = normal.x;
              normals[normalIndex++] = normal.y;
              normals[normalIndex++] = normal.z;
            }

            if (vertexFormat.tangent) {
              tangents[tangentIndex++] = tangent.x;
              tangents[tangentIndex++] = tangent.y;
              tangents[tangentIndex++] = tangent.z;
              tangents[tangentIndex++] = tangent.x;
              tangents[tangentIndex++] = tangent.y;
              tangents[tangentIndex++] = tangent.z;
            }

            if (vertexFormat.bitangent) {
              bitangent = Cesium.Cartesian3.normalize(
                Cesium.Cartesian3.cross(normal, tangent, bitangent),
                bitangent
              );
              bitangents[bitangentIndex++] = bitangent.x;
              bitangents[bitangentIndex++] = bitangent.y;
              bitangents[bitangentIndex++] = bitangent.z;
              bitangents[bitangentIndex++] = bitangent.x;
              bitangents[bitangentIndex++] = bitangent.y;
              bitangents[bitangentIndex++] = bitangent.z;
            }
          }
        }

        for (i = 0; i < slices; i++) {
          if (vertexFormat.normal) {
            normals[normalIndex++] = 0;
            normals[normalIndex++] = 0;
            normals[normalIndex++] = -1;
          }
          if (vertexFormat.tangent) {
            tangents[tangentIndex++] = 1;
            tangents[tangentIndex++] = 0;
            tangents[tangentIndex++] = 0;
          }
          if (vertexFormat.bitangent) {
            bitangents[bitangentIndex++] = 0;
            bitangents[bitangentIndex++] = -1;
            bitangents[bitangentIndex++] = 0;
          }
        }

        for (i = 0; i < slices; i++) {
          if (vertexFormat.normal) {
            normals[normalIndex++] = 0;
            normals[normalIndex++] = 0;
            normals[normalIndex++] = 1;
          }
          if (vertexFormat.tangent) {
            tangents[tangentIndex++] = 1;
            tangents[tangentIndex++] = 0;
            tangents[tangentIndex++] = 0;
          }
          if (vertexFormat.bitangent) {
            bitangents[bitangentIndex++] = 0;
            bitangents[bitangentIndex++] = 1;
            bitangents[bitangentIndex++] = 0;
          }
        }
      }

      var numIndices = 12 * slices - 12;
      var indices = Cesium.IndexDatatype.createTypedArray(numVertices, numIndices);
      var index = 0;
      var j = 0;
      for (i = 0; i < slices - 1; i++) {
        indices[index++] = j;
        indices[index++] = j + 2;
        indices[index++] = j + 3;

        indices[index++] = j;
        indices[index++] = j + 3;
        indices[index++] = j + 1;

        j += 2;
      }

      indices[index++] = twoSlices - 2;
      indices[index++] = 0;
      indices[index++] = 1;
      indices[index++] = twoSlices - 2;
      indices[index++] = 1;
      indices[index++] = twoSlices - 1;

      //for (i = 1; i < slices - 1; i++) {
      //  indices[index++] = twoSlices + i + 1;
      //  indices[index++] = twoSlices + i;
      //  indices[index++] = twoSlices;
      //}

      //for (i = 1; i < slices - 1; i++) {
      //  indices[index++] = threeSlices;
      //  indices[index++] = threeSlices + i;
      //  indices[index++] = threeSlices + i + 1;
      //}

      var textureCoordIndex = 0;
      if (vertexFormat.st) {
        var rad = Math.max(topRadius, bottomRadius);
        for (i = 0; i < numVertices; i++) {
          var position = Cesium.Cartesian3.fromArray(positions, i * 3, positionScratch);
          st[textureCoordIndex++] = (position.x + rad) / (2.0 * rad);
          st[textureCoordIndex++] = (position.y + rad) / (2.0 * rad);
        }
      }

      var attributes = new Cesium.GeometryAttributes();
      if (vertexFormat.position) {
        attributes.position = new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.DOUBLE,
          componentsPerAttribute: 3,
          values: positions,
        });
      }

      if (vertexFormat.normal) {
        attributes.normal = new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.FLOAT,
          componentsPerAttribute: 3,
          values: normals,
        });
      }

      if (vertexFormat.tangent) {
        attributes.tangent = new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.FLOAT,
          componentsPerAttribute: 3,
          values: tangents,
        });
      }

      if (vertexFormat.bitangent) {
        attributes.bitangent = new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.FLOAT,
          componentsPerAttribute: 3,
          values: bitangents,
        });
      }

      if (vertexFormat.st) {
        attributes.st = new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.FLOAT,
          componentsPerAttribute: 2,
          values: st,
        });
      }

      radiusScratch.x = length * 0.5;
      radiusScratch.y = Math.max(bottomRadius, topRadius);

      var boundingSphere = new Cesium.BoundingSphere(
        Cesium.Cartesian3.ZERO,
        Cesium.Cartesian2.magnitude(radiusScratch)
      );

      if (Cesium.defined(WeatherVolumeConeGeometry._offsetAttribute)) {
        length = positions.length;
        var applyOffset = new Uint8Array(length / 3);
        var offsetValue =
          WeatherVolumeConeGeometry._offsetAttribute === Cesium.GeometryOffsetAttribute.NONE
            ? 0
            : 1;
        Cesium.arrayFill(applyOffset, offsetValue);
        attributes.applyOffset = new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.UNSIGNED_BYTE,
          componentsPerAttribute: 1,
          values: applyOffset,
        });
      }

      return new Cesium.Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: Cesium.PrimitiveType.TRIANGLES,
        boundingSphere: boundingSphere,
        offsetAttribute: WeatherVolumeConeGeometry._offsetAttribute,
      });
    };

    var unitVolumeConeGeometry;

    /**
     * Returns the geometric representation of a unit cylinder, including its vertices, indices, and a bounding sphere.
     * @returns {Cesium.Geometry} The computed vertices and indices.
     *
     * @private
     */
    WeatherVolumeConeGeometry.getUnitCylinder = function () {
      if (!Cesium.defined(unitVolumeConeGeometry)) {
        unitVolumeConeGeometry = WeatherVolumeConeGeometry.createGeometry(
          new WeatherVolumeConeGeometry({
            topRadius: 1.0,
            bottomRadius: 1.0,
            length: 1.0,
            vertexFormat: Cesium.VertexFormat.POSITION_ONLY,
          })
        );
      }
      return unitVolumeConeGeometry;
    };

    //This file is automatically rebuilt by the WeatherEarth build process.
    var VolumeConeVS = "attribute vec3 position3DHigh;\n\
attribute vec3 position3DLow;\n\
attribute vec3 normal;\n\
attribute vec2 st;\n\
attribute float batchId;\n\
uniform mat4 calcMatrix_0;\n\
varying vec3 v_positionEC;\n\
varying vec3 v_normalEC;\n\
varying vec2 v_st;\n\
varying float v_batchId;\n\
void main()\n\
{\n\
    vec3 p3DHigh = position3DHigh;\n\
    vec3 vertex = position3DHigh + position3DLow;\n\
    vec2 dir = vertex.xy;\n\
    dir = normalize(dir);\n\
    float scaleOffsetZ = (batchId + 1.0) * calcMatrix_0[0][1];\n\
    p3DHigh.z += scaleOffsetZ;\n\
    vec4 p = czm_translateRelativeToEye(p3DHigh,position3DLow);\n\
    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n\
    v_normalEC = czm_normal * normal;\n\
    v_st = st;\n\
    v_batchId = batchId;\n\
    float currentLevel = calcMatrix_0[1][0];\n\
    float scanMode = calcMatrix_0[1][3];\n\
    if(scanMode != 0.0 && v_batchId >= currentLevel)return;\n\
    vec2 circleST = st - vec2(0.5,0.5);\n\
    circleST = normalize(circleST);\n\
    float angle = czm_angleBetween(vec3(0, 1, 0), vec3(circleST.xy,0)); \n\
    if(circleST.x<0.0)angle=czm_twoPi-angle; \n\
    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n\
}\n\
";

    //This file is automatically rebuilt by the WeatherEarth build process.
    var VolumeConeMaterial = "varying float v_batchId;\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput); \n\
    vec2 st = materialInput.st; \n\
    float angleDegree = calcMatrix[0][2]; \n\
    float level = calcMatrix[0][3];  \n\
    vec4 color = texture3D(baseTexture, vec3(st,v_batchId/level)); \n\
    float scaler = u_attribute[0][0];  \n\
    float offset = u_attribute[0][1];  \n\
    float v = czm_unpackVolume(color,scaler,offset); \n\
    color = v_transfer(v,0.0,false,color); \n\
    float filtrationmin = clipPlane[3][2];\n\
    float filtrationmax = clipPlane[3][3];\n\
    if(v > filtrationmax || v < filtrationmin)\n\
    {\n\
       color.a = 0.0;\n\
    }\n\
    float alpha = calcMatrix[0][0];  \n\
    material.alpha = color.a > 0.0 ? alpha : 0.0; \n\
    material.diffuse = color.rgb * (0.9 + 0.1 * v_batchId/level); \n\
    material.specular = 0.0;  // Specular mountain tops\n\
    material.shininess = 0.0;  // Sharpen highlight\n\
    material.emission = vec3(0.0); \n\
    if(material.alpha == 0.0)discard;\n\
    return material; \n\
}\n\
";

    //This file is automatically rebuilt by the WeatherEarth build process.
    var VolumeConeScanVS = "attribute vec3 position3DHigh;\n\
attribute vec3 position3DLow;\n\
attribute vec3 normal;\n\
attribute vec2 st;\n\
attribute float batchId;\n\
uniform mat4 calcMatrix_0;\n\
varying vec3 v_positionEC;\n\
varying vec3 v_normalEC;\n\
varying vec2 v_st;\n\
varying float v_batchId;\n\
void main()\n\
{\n\
    vec3 p3DHigh = position3DHigh;\n\
    vec3 vertex = position3DHigh + position3DLow;\n\
    vec3 dir = normalize(vertex);\n\
    float radius = length(vertex.xy);\n\
    float scaleOffsetZ = tan(calcMatrix_0[1][1] / czm_degreesPerRadian) * radius;\n\
    p3DHigh.z = scaleOffsetZ * calcMatrix_0[1][2];\n\
    vec4 p = czm_translateRelativeToEye(p3DHigh,position3DLow);\n\
    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n\
    v_normalEC = czm_normal * vec3(0,0,1);\n\
    v_st = st;\n\
    v_batchId = batchId;\n\
    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n\
}\n\
";

    //This file is automatically rebuilt by the WeatherEarth build process.
    var VolumeConeScanMaterial = "varying float v_batchId;\n\
czm_material czm_getMaterial(czm_materialInput materialInput)\n\
{\n\
    czm_material material = czm_getDefaultMaterial(materialInput);\n\
    vec2 st = materialInput.st;\n\
    vec2 circleST = st - vec2(0.5,0.5);\n\
    float currentAngle = calcMatrix[0][2];\n\
    float stAngle = currentAngle;\n\
    float edAngle = currentAngle + 10.0 * 0.9836 / czm_degreesPerRadian;\n\
    circleST = normalize(circleST);\n\
    float angle = czm_angleBetween(vec3(0,1,0),vec3(circleST,0));\n\
    if(circleST.x<0.0)angle=czm_twoPi-angle;\n\
    if(angle > edAngle)discard;\n\
    float alpha = (angle - stAngle) / (edAngle - stAngle); \n\
    float level = calcMatrix[0][3]; \n\
    float currentLevel = calcMatrix[1][0]; \n\
    vec4 color = texture3D(baseTexture, vec3(st,currentLevel/level));\n\
    float scaler = u_attribute[0][0]; \n\
    float offset = u_attribute[0][1]; \n\
    float v = czm_unpackVolume(color,scaler,offset);\n\
    color = v_transfer(v,0.0,false,color);\n\
    float filtrationmin = clipPlane[3][2];\n\
    float filtrationmax = clipPlane[3][3];\n\
    if(v > filtrationmax || v < filtrationmin)\n\
    {\n\
       color.a = 0.0;\n\
    }\n\
    if(angle < stAngle)\n\
    {\n\
       alpha = 1.0;\n\
       if(color.a == 0.0)discard;\n\
    }\n\
    material.alpha = color.a > 0.0 ? alpha : alpha * 0.333;\n\
    material.diffuse = color.a == 0.0 ? vec3(1,1,1) : color.rgb;\n\
    return material;\n\
} \n\
";

    function WeatherVolumeCone(volume) {
      this._angles = [0.5];
      this._scene = volume._scene;
      this._volume = volume;
      var cartesion = Cesium.Cartesian3.fromDegrees(volume.position.x, volume.position.y, volume.position.z);
      this._modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(cartesion);

      this._radius = this._volume._meter.width * 0.5;

      this._calcMatrix = new Cesium.Matrix4(1.0/*alpha*/, 0.0/*currentLevel*/, 0.0, 0.0,
        0.0/*offsetZ*/, 0.0/*currentAngle*/, 0.0, 0.0,
        0.0/*angle*/, 1.0/*volumeScaleZ*/, 0.0, 0.0,
        0.0/*levels*/, 0.0/*scanMode*/, 0.0, 0.0);

      var that = this;
      var _uniforms = {
        calcMatrix: that._calcMatrix,
        baseTexture: volume._texture,
        clipPlane: volume._clipMatrix,
        tfTexture: volume._textureTF,
        u_attribute: volume._attributeMatrix,
      };

      this._appearance = new Cesium.MaterialAppearance({
        renderState: {
          depthTest: { enabled: true },
          depthMask: true,
          blending: Cesium.BlendingState.ALPHA_BLEND,
          cull: {
            enabled: false,
            face: Cesium.CullFace.FRONT
          }
        },
        translucent: false,
        vertexShaderSource: VolumeConeVS,
        material: new Cesium.Material({
          translucent: false,
          fabric: {
            uniforms: _uniforms,
            source: volume.transFunction + VolumeConeMaterial,
          },
        }),
      });

      this._scanAppearance = new Cesium.MaterialAppearance({
        renderState: {
          depthTest: { enabled: true },
          depthMask: true,
          blending: Cesium.BlendingState.ALPHA_BLEND,
          cull: {
            enabled: false,
            face: Cesium.CullFace.FRONT
          }
        },
        translucent: false,
        vertexShaderSource: VolumeConeScanVS,
        material: new Cesium.Material({
          translucent: false,
          fabric: {
            uniforms: _uniforms,
            source: volume.transFunction + VolumeConeScanMaterial,
          },
        }),
      });

      this.create();
    }

    WeatherVolumeCone.prototype.destroy = function () {
      this._cone = this._cone && this._cone.destroy();
      this._scanCone = this._scanCone && this._scanCone.destroy();
      this._boundSpere = this._boundSpere && this._boundSpere.destroy();
    };

    WeatherVolumeCone.prototype.create = function () {
      if (!Cesium.defined(this._cone)) {
        var instances = [];
        var levels = this._volume._source.depth;
        if (levels == 9) {
          this._angles = [0.5, 1.5, 2.4, 3.4, 4.3, 6.0, 9.9, 14.6, 19.5];
        }

        this._calcMatrix[3] = levels;

        var i = 0;
        for (; i < this._angles.length; i++) {
          var angle = Cesium.Math.toRadians(this._angles[i]);
          var length = Math.sin(angle) * this._radius;
          var radius = Math.cos(angle) * this._radius;
          var geometry = WeatherVolumeConeGeometry.createGeometry(
            new WeatherVolumeConeGeometry({
              length: length,
              topRadius: radius,
              bottomRadius: 1,
              slices: 128,
              vertexFormat: Cesium.VertexFormat.POSITION_NORMAL_AND_ST
            }));
          instances.push(new Cesium.GeometryInstance({
            geometry: geometry,
          }));
        }
       
        this._cone = new Cesium.Primitive({
          geometryInstances: instances , asynchronous: false,
        });

        this._cone.modelMatrix = this._modelMatrix;
        this._cone.appearance = this._appearance;
      }

      //this.createScanCone();
      this.createBoundSpere();
    };

    WeatherVolumeCone.prototype.createScanCone = function () {
      this._lastUpdateTime = undefined;
      this._calcMatrix[7] = 1.0;
      this._scanCone = this._scanCone && this._scanCone.destroy();
      var attributes = { color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.GAINSBORO) };

      var length = 1.0;
      var radius = this._radius;
      var geometry = WeatherVolumeConeGeometry.createGeometry(
        new WeatherVolumeConeGeometry({
          length: length,
          topRadius: radius,
          bottomRadius: 1,
          slices: 128,
          vertexFormat: Cesium.VertexFormat.POSITION_NORMAL_AND_ST
        }));

      this._scanCone = new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry: geometry,
          attributes: attributes,
        }), asynchronous: false
      });
      this._scanCone.modelMatrix = this._modelMatrix;
      this._scanCone.appearance = this._scanAppearance;
    };

    WeatherVolumeCone.prototype.createBoundSpere = function () {
      this._boundSpere = this._boundSpere && this._boundSpere.destroy();

      var radius = this._radius;
      var attributes = {
        color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.WHITE),
      };

      var ellipsoid = new Cesium.EllipsoidOutlineGeometry({
        radii: new Cesium.Cartesian3(radius, radius, radius * this._volume.scaleZ),
        minimumCone: Cesium.Math.toRadians(90.0 - this._angles[this._angles.length - 1]),
        maximumCone: Cesium.Math.PI_OVER_TWO,
        stackPartitions: 60,
        slicePartitions: 20
      });
      var geometry = Cesium.EllipsoidOutlineGeometry.createGeometry(ellipsoid);

      this._boundSpere = new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry: geometry,
          attributes: attributes,
        }), asynchronous: false
      });
      this._boundSpere.modelMatrix = this._modelMatrix;
      this._boundSpere.appearance = new Cesium.PerInstanceColorAppearance({
        flat: true,
        translucent: true
      });
      this._boundSpere.show = this._volume.showGrid;
    };

    WeatherVolumeCone.prototype.update = function (frameState) {
      if (frameState.passes.render && Cesium.defined(this._scanCone)) {
        if (!Cesium.defined(this._lastUpdateTime)) {
          this._lastUpdateTime = (new Date()).getTime();
          this._currentLevel = 0;
        }
        var speedX = 8.0;
        var duration = 36000.0 / speedX;
        var elapseTime = (new Date()).getTime() - this._lastUpdateTime;
        var TWO_PI = Math.PI * 2;
        this._calcMatrix[2] = elapseTime % duration / duration * TWO_PI;
        this._currentLevel = Math.floor(elapseTime / duration % this._calcMatrix[3]);
        this._calcMatrix[4] = this._currentLevel;
        this._calcMatrix[5] = this._angles[this._currentLevel];
      }

      if (Cesium.defined(this._cone)) {
        this._cone.update(frameState);
      }
      if (Cesium.defined(this._scanCone)) {
        this._scanCone.update(frameState);
      }
      if (Cesium.defined(this._boundSpere)) {
        this._boundSpere.update(frameState);
      }
    };

    WeatherVolumeCone.prototype.onDirty = function (volume) {
      this._calcMatrix[6] = volume.scaleZ;
      var cartesion = Cesium.Cartesian3.fromDegrees(volume.position.x, volume.position.y, volume.position.z);
      if (Cesium.defined(this._cone)) {
        var modelmatrix = Cesium.Transforms.eastNorthUpToFixedFrame(cartesion);
        //Cesium.Matrix4.multiplyByTranslation(modelmatrix, { x: 0.0, y: 0.0, z: this._offset.z }, modelmatrix);
        Cesium.Matrix4.multiplyByScale(modelmatrix, { x: 1.0, y: 1.0, z: volume.scaleZ }, modelmatrix);
        this._cone.modelMatrix = modelmatrix;
        if (volume.scaleZ > 1.0) ;
        else {
          this._calcMatrix[1] = 0.0;
        }
      }
      if (Cesium.defined(this._boundSpere)) {
        var modelmatrix = Cesium.Transforms.eastNorthUpToFixedFrame(cartesion);
        Cesium.Matrix4.multiplyByScale(modelmatrix, { x: 1.0, y: 1.0, z: Cesium.Math.clamp(volume.scaleZ * 0.3, 1.0, volume.scaleZ) }, modelmatrix);
        this._boundSpere.modelMatrix = modelmatrix;
        this._boundSpere.show = volume.showGrid;
      }
    };

    Object.defineProperties(WeatherVolumeCone.prototype, {
      scanMode: {
        get: function () {
          return this._calcMatrix[7] == 1.0;
        },
        set: function (value) {
          if (value) {
            if (!Cesium.defined(this._scanCone)) {
              this.createScanCone();
            }
          } else {
            this._scanCone = this._scanCone && this._scanCone.destroy();
          }
          this._calcMatrix[7] = value ? 1.0 : 0.0;
        }
      },
    });

    function WeatherVolumeSurface(volume,options) {
      this._scene = volume._scene;
      this._show = true;
      this._granularityFactor = volume.granularityFactor;
      this._appearance = new Cesium.MaterialAppearance({
        renderState: {
          depthTest: { enabled: true },
          depthMask: true,
          blending: Cesium.BlendingState.ALPHA_BLEND,
          cull: {
            enabled: false,
            face: Cesium.CullFace.FRONT
          }
        },
        translucent: Cesium.defaultValue(options.translucent, false),
      });
      this._calcMatrix = new Cesium.Matrix4(
        1.0/*alpha*/,      0.0/*scaleY*/, 0.0, 0.0,
        0.0/*summationZ*/, 0.0/*offsetX*/, 0.0, 0.0,
        0.0/*spliceZ*/,    0.0/*offsetY*/, 0.0, 0.0,
        0.0/*scaleX*/,     0.0/*forceSummationZ*/, 0.0, 0.0);
      this._onDem = false;
      var that = this;

      var _uniforms = {
        baseTexture: volume._texture,
        clipMatrix: volume._clipMatrix,
        u_attribute: volume._attributeMatrix,
        statisticMatrix: volume._statisticMatrix,
        calcMatrix: that._calcMatrix,
      };

      if (Cesium.defined(volume._textureTF)) {
        _uniforms.tfTexture = volume._textureTF;
      }

      this._appearance.material = new Cesium.Material({
        translucent: Cesium.defaultValue(options.translucent, false),
        fabric: {uniforms : _uniforms,
          source: volume.transFunction + VolumeSurfaceMaterial,
        },
      });
      var fullRectangle = volume.rectangle;
      this.rectangle = options.rectangle;

      var fw = fullRectangle.width;
      var fh = fullRectangle.height;
      var scaleX = this.rectangle.width / fw;
      var scaleY = this.rectangle.height / fh;
      var offsetX = (this.rectangle.west - fullRectangle.west) / fw;
      var offsetY = (this.rectangle.south - fullRectangle.south) / fh;

      this._calcMatrix[3] = scaleX;
      this._calcMatrix[4] = scaleY;
      this._calcMatrix[5] = offsetX;
      this._calcMatrix[6] = offsetY;

      this._height = 0.0;

      this._depth = volume.meter.depth;
      this._scaleZ = volume.scaleZ;
      this._dirty = true;
    }

    WeatherVolumeSurface.prototype.isDestroyed = function () {
      return false;
    };

    WeatherVolumeSurface.prototype.destroy = function () {
      this._surface = this._surface && this._surface.destroy();
      return Cesium.destroyObject(this);
    };

    WeatherVolumeSurface.prototype.rebuild = function () {
      this._surface = this._surface && this._surface.destroy();

      var height = this._height;
      this._calcMatrix[2] = height / (this._depth * this._scaleZ);
      var granularityFactor = this._granularityFactor;
      var rectangleInstance = new Cesium.GeometryInstance({
        geometry: new Cesium.RectangleGeometry({ rectangle: this.rectangle, granularity: Cesium.Math.RADIANS_PER_DEGREE * granularityFactor, height: height })
      });

      if (this._onDem && height <= 0.0)
        this._surface = new Cesium.GroundPrimitive({ geometryInstances: rectangleInstance, asynchronous: false });
      else
        this._surface = new Cesium.Primitive({ geometryInstances: rectangleInstance, asynchronous: false });
      this._surface.appearance = this._appearance;
      this._surface.show = this._show;
      this._surface.id = this;
    };

    WeatherVolumeSurface.prototype.update = function (frameState) {
      if (this._dirty) {
        this._dirty = false;
        this.rebuild();
      }
      if (Cesium.defined(this._surface)) {
        this._surface.update(frameState);
      }
    };

    Object.defineProperties(WeatherVolumeSurface.prototype, {
      show: {
        get: function () {
          if (Cesium.defined(this._surface))
            return this._surface.show;
          else
            return this._show;
        },
        set: function (value) {
          if (value != this._show) {
            this._show = value;
            if (Cesium.defined(this._surface)) {
              this._surface.show = value;
            }
          }
        }
      },
      height: {
        get: function () {
          return this._height;
        },
        set: function (value) {
          if (value != this._height || !Cesium.defined(this._surface)) {
            this._height = value;
            this._dirty = true;
            //this.rebuild();
          }
        }
      },
      scaleZ: {
        get: function () {
          return this._scaleZ;
        },
        set: function (value) {
          if (value != this._scaleZ || !Cesium.defined(this._surface)) {
            this._scaleZ = value;
          }
        }
      },
      granularityFactor: {
        get: function () {
          return this._granularityFactor;
        },
        set: function (value) {
          if (value != this._granularityFactor) {
            this._granularityFactor = value;
            this._dirty = true;
            //this.rebuild();
          }
        }
      },
      alpha: {
        get: function () {
          return this._calcMatrix[0];
        },
        set: function (value) {
          this._calcMatrix[0] = value;
        }
      },
      onDem: {
        get: function () {
          return this._onDem;
        },
        set: function (value) {
          if (!this._onDem == value) {
            this._onDem = value;
            this._dirty = true;
          }
        }
      },
      summationZ: {
        get: function () {
          return this._calcMatrix[1] == 1.0;
        },
        set: function (value) {
          this._calcMatrix[1] = value ? 1.0 : 0.0;
        }
      }
    });

    function WeatherLengthWayXYZ(innerVolume){
        this._x = new WeatherVolumeWall(innerVolume);
        this._y = new WeatherVolumeWall(innerVolume);
        this._z = new WeatherVolumeSurface(innerVolume, { rectangle: innerVolume.rectangle});
        this.updateOptions(innerVolume);
        this._dirty = true;
    }
    Object.defineProperties(WeatherLengthWayXYZ.prototype, {
      dirty: {
        get: function () {
            return this._dirty;
        },
        set: function (value) {
            this._dirty = value;
        },
      },
    });

    WeatherLengthWayXYZ.prototype.updateOptions = function (innerVolume) {
        if (Cesium.defined(this._z)) {
          this._z.alpha = innerVolume.SlicePlaneZAlpha;
        }

        // if(!innerVolume._dirty && !this.dirty){
        //   return;
        // }

        var rectangle = innerVolume.rectangle;
        var w = rectangle.west;
        var e = rectangle.east;
        var n = rectangle.north;
        var s = rectangle.south;
        var x = w + rectangle.width * innerVolume.SlicePlaneX;
        var y = s + rectangle.height * innerVolume.SlicePlaneY;
        var h = innerVolume._meter.depth * innerVolume.scaleZ;
        if (Cesium.defined(this._z)) {
          var height = innerVolume.SlicePlaneZ * innerVolume._meter.depth * innerVolume.scaleZ;
          this._z.summationZ = innerVolume.summationInEdge && (innerVolume.SlicePlaneZ == 0.0);
          this._z.onDem = innerVolume.onDemWhenHeightZero;
          this._z.scaleZ = innerVolume.scaleZ;
          this._z.height = height;
          this._z.show = innerVolume.SlicePlaneZ_Visible;
        }
        if (Cesium.defined(this._x)) {
          this._x.summationX = innerVolume.summationInEdge && (innerVolume.SlicePlaneX == 0.0 || innerVolume.SlicePlaneX == 1.0);
          this._x.options = {
            positions: [x, s, x, n],
            height: h,
            scaleZ: innerVolume.scaleZ,
            granularityFactor: innerVolume._granularityFactor,
            showGrid: innerVolume._showGrid
          };
          this._x.show = innerVolume.SlicePlaneX_Visible;
        }
      
        if (Cesium.defined(this._y)) {
          this._y.summationY = innerVolume.summationInEdge && (innerVolume.SlicePlaneY == 0.0 || innerVolume.SlicePlaneY == 1.0);
          this._y.options = {
            positions: [w, y, e, y],
            height: h,
            scaleZ: innerVolume.scaleZ,
            granularityFactor: innerVolume._granularityFactor,
            showGrid: innerVolume._showGrid
          };
          this._y.show = innerVolume.SlicePlaneY_Visible;
        }
    };

    WeatherLengthWayXYZ.prototype.update = function (frameState) {
        if (Cesium.defined(this._x)) {
            this._x.update(frameState);
        }
        if (Cesium.defined(this._y)) {
            this._y.update(frameState);
        }
        if (Cesium.defined(this._z)) {
            this._z.update(frameState);
        }
    };

    WeatherLengthWayXYZ.prototype.isDestroyed = function () {
        return false;
    };

    WeatherLengthWayXYZ.prototype.destroy = function () {
        this._x = this._x && this._x.destroy();
        this._y = this._y && this._y.destroy();
        this._z = this._z && this._z.destroy();
        return Cesium.destroyObject(this);
    };

    function WeatherVolumeAxesWall(options) {
      this._floors = options.floors;
      var scaleZ = options.scaleZ;

      var split = Cesium.defaultValue(options.split, false);

      var floors = [];
      for (var i = 0; i < this._floors.length; i++) {
        floors.push(this._floors[i] * scaleZ);
      }

      var positions = WeatherVolumeLibrary.computeWallPosition(
        options.st,
        options.ed,
        Cesium.Math.RADIANS_PER_DEGREE
      );

      var volumeWallAxisGeometry = new WeatherVolumeWallAxisGeometry({
        positions: positions,
        floors: floors,
        granularity: Cesium.Math.RADIANS_PER_DEGREE,
        split: split,
      });

      var wallOutlineGeometry = WeatherVolumeWallAxisGeometry.createGeometry(
        volumeWallAxisGeometry
      );

      if (split) {
        this.splitPositions = [
          volumeWallAxisGeometry.p1,
          volumeWallAxisGeometry.p3,
          volumeWallAxisGeometry.p7,
        ];
      }

      this._wallOutline = new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry: wallOutlineGeometry,
          attributes: {
            color: Cesium.ColorGeometryInstanceAttribute.fromColor(
              new Cesium.Color(1.0, 1.0, 1.0, 1.0)
            ),
          },
        }),
        asynchronous: false,
      });

      this._wallOutline.appearance = new Cesium.PerInstanceColorAppearance({
        flat: true,
        translucent: false,
        renderState: {
          lineWidth: 1.0,
        },
      });

      this._polylines = new Cesium.PolylineCollection();
    }

    WeatherVolumeAxesWall.prototype.isDestroyed = function () {
      return false;
    };

    WeatherVolumeAxesWall.prototype.destroy = function () {
      if (Cesium.defined(this._wallOutline)) {
        this._wallOutline.destroy();
      }
      return Cesium.destroyObject(this);
    };

    WeatherVolumeAxesWall.prototype.update = function (frameState) {
      if (frameState.passes.render && Cesium.defined(this._wallOutline)) {
        this._wallOutline.update(frameState);
      }

      if (frameState.passes.render) {
        this._polylines.update(frameState);
      }
    };

    function WeatherVolumeAxes(options) {
      this._scaleZ = 1.0;
      this._offsetZ = Cesium.defaultValue(options.offsetZ,0.0);
      this._LabelDistanceDisplayFator = 3;
      this._rectangle = options.rectangle;
      this._floors = options.floors;
      this._split = Cesium.defaultValue(options.split,true);
      this._dirty = false;
    }
    Object.defineProperties(WeatherVolumeAxes.prototype, {
      scaleZ: {
          get: function () {
              return this._scaleZ;
          },
          set: function (value) {
              if(this._scaleZ !== value){
                this._scaleZ = value;
                this._dirty = true;
              }
          }
      },
    });

    WeatherVolumeAxes.prototype.isDestroyed = function () {
      return false;
    };

    WeatherVolumeAxes.prototype.destroy = function () {
        this._axesX = this._axesX && this._axesX.destroy();
        this._axesY = this._axesY && this._axesY.destroy();
        this._labelsX = this._labelsX && this._labelsX.destroy();
        this._labelsY = this._labelsY && this._labelsY.destroy();
        this._labelsZ = this._labelsZ && this._labelsZ.destroy();
        return Cesium.destroyObject(this);
    };

    WeatherVolumeAxes.prototype.update = function (frameState) {
      if(this._dirty || !Cesium.defined(this._axesX) || !Cesium.defined(this._axesX)){
        this._dirty = false;
        this.rebuild();
      }

      this._axesX.update(frameState);
      this._axesY.update(frameState);
      this._labelsX.update(frameState);
      this._labelsY.update(frameState);
      this._labelsZ.update(frameState);
    };

    WeatherVolumeAxes.prototype.rebuild = function () {
      var split = this._split;

      var west = this._rectangle.west;
      var south = this._rectangle.south;
      var east = this._rectangle.east;
      var north = this._rectangle.north;
      
      var floors = this._floors;
      var scaleZ = this.scaleZ;
      var offsetZ = this._offsetZ;

      this._axesX = this._axesX && this._axesX.destroy();
      this._axesY = this._axesY && this._axesY.destroy();

      this._axesX = new WeatherVolumeAxesWall({
        st:new Cesium.Cartesian2(west,south),
        ed:new Cesium.Cartesian2(east,south),
        rectangle: this._rectangle,
        floors: floors,
        scaleZ: scaleZ,
        split: split,
      });

      this._axesY = new WeatherVolumeAxesWall({
        st:new Cesium.Cartesian2(west,south),
        ed:new Cesium.Cartesian2(west,north),
        rectangle: this._rectangle,
        floors: floors,
        scaleZ: scaleZ,
        split: split,
      });

      var center = Cesium.Cartesian3.fromRadians(west, south);

      if (!Cesium.defined(this._labelsZ)) {
        var labels = new Cesium.LabelCollection();
        var font = '14px sans-serif';
        var pos = Cesium.Cartesian3.fromRadiansArray([west, south, east, south]);
        var distance = Cesium.Cartesian3.distance(pos[0], pos[pos.length - 1]);
        for (var i = 1; i < floors.length; i++) {
          var text = ((floors[i] + offsetZ) * 0.001).toFixed(2) + 'km';
          labels.add({
            position: new Cesium.Cartesian3(0.0, 0.0, floors[i]),
            font: font,
            disableDepthTestDistance: Number.POSITIVE_INFINITY,
            text: text,
            fillColor: Cesium.Color.WHITE,
            outlineColor: Cesium.Color.BLACK,
            outlineWidth: 2.0,
            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
            distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, distance * this._LabelDistanceDisplayFator * i * scaleZ),
            horizontalOrigin: Cesium.HorizontalOrigin.RIGHT,
          }); 
        }

        if(split){
          this._labelsX = new Cesium.LabelCollection();
          this._labelsY = new Cesium.LabelCollection();
          
          for (var i = 0; i < 3; i++) {
            var CartographicX = Cesium.Cartographic.fromCartesian(this._axesX.splitPositions[i]);
            var textX = Cesium.Math.toDegrees(CartographicX.longitude).toFixed(1);
            this._labelsX.add({
              position: this._axesX.splitPositions[i],
              font: font,
              disableDepthTestDistance: Number.POSITIVE_INFINITY,
              text: textX,
              fillColor: Cesium.Color.WHITE,
              outlineColor: Cesium.Color.BLACK,
              outlineWidth: 2.0,
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, distance * this._LabelDistanceDisplayFator * scaleZ),
              horizontalOrigin: Cesium.HorizontalOrigin.RIGHT,
            }); 

            var CartographicY = Cesium.Cartographic.fromCartesian(this._axesY.splitPositions[i]);
            var textY = Cesium.Math.toDegrees(CartographicY.latitude).toFixed(1);
            this._labelsY.add({
              position: this._axesY.splitPositions[i],
              font: font,
              disableDepthTestDistance: Number.POSITIVE_INFINITY,
              text: textY,
              fillColor: Cesium.Color.WHITE,
              outlineColor: Cesium.Color.BLACK,
              outlineWidth: 2.0,
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, distance * this._LabelDistanceDisplayFator * scaleZ),
              horizontalOrigin: Cesium.HorizontalOrigin.RIGHT,
            }); 
          }
        }


        this._labelsZ = labels;
      }
      this._labelsZ.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);
      Cesium.Matrix4.multiplyByScale(this._labelsZ.modelMatrix, { x: 1.0, y: 1.0, z: scaleZ }, this._labelsZ.modelMatrix);
    };

    function WeatherVolumeHierarchy(volume,rectangle) {
        this._scene = volume._scene;  
        this._LabelDistanceDisplayFator = 10;
        this._surfs = [];
        this._floors = [];
        this._scaleZ = volume.scaleZ * 10.0;
        var depth = volume.meter.depth + volume.offsetZ;

        var i = 0;
        for(;i<volume._source.depth;i++){
            var surface = new WeatherVolumeSurface(volume,{rectangle:rectangle,translucent:false});
            this._surfs[i] = surface;
            this._floors[i] = Math.floor((i / volume._source.depth * depth) * 0.1) * 10.0;
        }
        this._sourceDepth = volume._source.depth;
        this._meterDepth = volume.meter.depth;
        this._offsetZ = volume.offsetZ;
        
        this._rectangle = rectangle;
        this.rebuild();

        this._contentChangedEvent = new Cesium.Event();
        this._removeEventSubscription = this._contentChangedEvent.addEventListener(
            WeatherVolumeHierarchy.prototype._onContentChanged,
            this
        );
    }
    Object.defineProperties(WeatherVolumeHierarchy.prototype, {
        scaleZ: {
            get: function () {
                return this._scaleZ;
            },
            set: function (value) {
                if(value != this._scaleZ){
                    this._scaleZ = value;
                    this.rebuild();
                }
            }
        },
    });

    WeatherVolumeHierarchy.prototype._onContentChanged = function (
        entity,
        propertyName,
        newValue,
        oldValue
    ) {
        if (propertyName == 'onUpdate') {
            if(Cesium.defined(this.onUpdate))
                this.onUpdate(entity,propertyName,newValue,oldValue);
        }else if (propertyName == 'onDestroy') {
            if(Cesium.defined(this.onDestroy))
                this.onDestroy(entity,propertyName,newValue,oldValue);
        }
    };

    WeatherVolumeHierarchy.prototype.destroy = function () {
        var i = 0;
        for(;i<this._surfs.length;i++){
            this._surfs[i].destroy();
        }
        this._surfs = [];
        this._contentChangedEvent.raiseEvent(this, "onDestroy",'','');
        this._removeEventSubscription();
        return Cesium.destroyObject(this);
    };

    WeatherVolumeHierarchy.prototype.update = function (frameState) {
        var i = 0;
        for(;i<this._surfs.length;i++){
            this._surfs[i].update(frameState);
        }
        if(Cesium.defined(this._axes)){
            this._axes.update(frameState);
        }
    };

    WeatherVolumeHierarchy.prototype.rebuild = function () {
        var i = 0;
        for(;i<this._surfs.length;i++){
            var height = i / this._sourceDepth * this._meterDepth * this.scaleZ;
            this._surfs[i].scaleZ = this.scaleZ;
            this._surfs[i].height = height;
        }

        if(!Cesium.defined(this._axes)){
            this._axes = new WeatherVolumeAxes({
                    rectangle:this._rectangle,
                    floors:this._floors,
                    offsetZ:this._offsetZ
                });
        }
        
        this._axes.scaleZ = this.scaleZ;
    };

    function WeatherVolumeClipHandler(volume){
        this._volume = volume;
        this._handler1 = undefined;
        this._handler2 = undefined;
        this._handler3 = undefined;
        this._scene = volume._scene;
        this._radius = Math.floor(volume.meter.width * 0.015);
        this._show = true;
        this._dirty = true;
        this.create();
        this.start();
    }

    Object.defineProperties(WeatherVolumeClipHandler.prototype, {
        show: {
          get: function () {
            return this._show;
          },
          set: function (value) {
              this._show = value;
          }
        },
        dirty: {
            get: function () {
              return this._dirty;
            },
            set: function (value) {
                this._dirty = value;
            }
          }
    });

    WeatherVolumeClipHandler._origionalColor = new Uint8Array([0,255,255,255]);
    WeatherVolumeClipHandler._highlightColor = new Uint8Array([255, 255, 255, 255]);
    WeatherVolumeClipHandler._clipPlaneMinX = 'clipPlaneMinX';
    WeatherVolumeClipHandler._clipPlaneMaxX = 'clipPlaneMaxX';
    WeatherVolumeClipHandler._clipPlaneMinY = 'clipPlaneMinY';
    WeatherVolumeClipHandler._clipPlaneMaxY = 'clipPlaneMaxY';
    WeatherVolumeClipHandler._clipPlaneMaxZ = 'clipPlaneMaxZ';

    WeatherVolumeClipHandler.prototype.destroy = function () {
        this._handler1 = this._handler1 && this._handler1.destroy();
        this._handler2 = this._handler2 && this._handler2.destroy();
        this._handler3 = this._handler3 && this._handler3.destroy();
        this._primitive1 = this._primitive1 && this._primitive1.destroy();
        this._primitive2 = this._primitive2 && this._primitive2.destroy();
        this._primitive3 = this._primitive3 && this._primitive3.destroy();
        this._primitive4 = this._primitive4 && this._primitive4.destroy();
        this._primitive5 = this._primitive5 && this._primitive5.destroy();
    };

    WeatherVolumeClipHandler.prototype.updateMatrix = function () {
        if(Cesium.defined(this._primitive1)){
            var volume = this._volume;

            var clipPlaneMinX = volume.clipPlaneMinX;
            var clipPlaneMaxX = volume.clipPlaneMaxX;
            var clipPlaneMinY = volume.clipPlaneMinY;
            var clipPlaneMaxY = volume.clipPlaneMaxY;
            var clipPlaneMinZ = 0.0;
            var clipPlaneMaxZ = volume.clipPlaneMaxZ;

            var minXOffset = (clipPlaneMinX - 0.5) * volume._meter.width;
            var maxXOffset = (clipPlaneMaxX - 0.5) * volume._meter.width;
            var minYOffset = (clipPlaneMinY - 0.5) * volume._meter.height;
            var maxYOffset = (clipPlaneMaxY - 0.5) * volume._meter.height;

            var maxZOffset = clipPlaneMaxZ * volume._scale.z * volume._meter.depth;

            var xOffset = (0.5 * (clipPlaneMaxX + clipPlaneMinX) - 0.5) * volume._meter.width;
            var yOffset = (0.5 * (clipPlaneMaxY + clipPlaneMinY) - 0.5) * volume._meter.height;
            var zOffset = (0.5 * (clipPlaneMaxZ + clipPlaneMinZ)) * volume._scale.z * volume._meter.depth;

            var m0 = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(volume.position.x, volume.position.y, volume.position.z));
            var m1 = Cesium.Matrix4.fromTranslation(new Cesium.Cartesian3(minXOffset, yOffset, zOffset));
            var m2 = Cesium.Matrix4.fromTranslation(new Cesium.Cartesian3(maxXOffset, yOffset, zOffset));
            var m3 = Cesium.Matrix4.fromTranslation(new Cesium.Cartesian3(xOffset, minYOffset, zOffset));
            var m4 = Cesium.Matrix4.fromTranslation(new Cesium.Cartesian3(xOffset, maxYOffset, zOffset));
            var m5 = Cesium.Matrix4.fromTranslation(new Cesium.Cartesian3(xOffset, yOffset, maxZOffset));
            Cesium.Matrix4.multiply(m0,m1,m1);
            Cesium.Matrix4.multiply(m0,m2,m2);
            Cesium.Matrix4.multiply(m0,m3,m3);
            Cesium.Matrix4.multiply(m0,m4,m4);
            Cesium.Matrix4.multiply(m0,m5,m5);

            var scaleW = clipPlaneMaxX - clipPlaneMinX;
            var scaleH = clipPlaneMaxY - clipPlaneMinY;
            
            var mw = Cesium.Matrix4.fromUniformScale(Cesium.Math.clamp(scaleW,0.5,1.0));
            var mh = Cesium.Matrix4.fromUniformScale(Cesium.Math.clamp(scaleH,0.5,1.0));
            Cesium.Matrix4.multiply(m1,mh,m1);
            Cesium.Matrix4.multiply(m2,mh,m2);
            Cesium.Matrix4.multiply(m3,mw,m3);
            Cesium.Matrix4.multiply(m4,mw,m4);
            Cesium.Matrix4.multiply(m5,scaleW > scaleH ? mw :mh,m5);

            this._primitive1.modelMatrix = m1;
            this._primitive2.modelMatrix = m2;
            this._primitive3.modelMatrix = m3;
            this._primitive4.modelMatrix = m4;
            this._primitive5.modelMatrix = m5;
        }
    };


    WeatherVolumeClipHandler.prototype.create = function () {
      if (!Cesium.defined(this._primitive1)) {
            var r = this._radius;
            var geometry = Cesium.EllipsoidGeometry.createGeometry(
                    new Cesium.EllipsoidGeometry({
                        radii : new Cesium.Cartesian3(r, r, r),
                        vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL
                        }));
            var attributes = {color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)};

            var instance1 = new Cesium.GeometryInstance({geometry : geometry, id : WeatherVolumeClipHandler._clipPlaneMinX, attributes : attributes});
            var instance2 = new Cesium.GeometryInstance({geometry : geometry, id : WeatherVolumeClipHandler._clipPlaneMaxX, attributes : attributes});
            var instance3 = new Cesium.GeometryInstance({geometry : geometry, id : WeatherVolumeClipHandler._clipPlaneMinY, attributes : attributes});
            var instance4 = new Cesium.GeometryInstance({geometry : geometry, id : WeatherVolumeClipHandler._clipPlaneMaxY, attributes : attributes});
            var instance5 = new Cesium.GeometryInstance({geometry : geometry, id : WeatherVolumeClipHandler._clipPlaneMaxZ, attributes : attributes});
                                                                             
            var appearance = new Cesium.PerInstanceColorAppearance();

            var primitive1 = new Cesium.Primitive({geometryInstances:instance1, asynchronous:false,appearance:appearance});
            var primitive2 = new Cesium.Primitive({geometryInstances:instance2, asynchronous:false,appearance:appearance});
            var primitive3 = new Cesium.Primitive({geometryInstances:instance3, asynchronous:false,appearance:appearance});
            var primitive4 = new Cesium.Primitive({geometryInstances:instance4, asynchronous:false,appearance:appearance});
            var primitive5 = new Cesium.Primitive({geometryInstances:instance5, asynchronous:false,appearance:appearance});
            this._primitive1 = primitive1;
            this._primitive2 = primitive2;
            this._primitive3 = primitive3;
            this._primitive4 = primitive4;
            this._primitive5 = primitive5;
        }
    };

    WeatherVolumeClipHandler.prototype.update = function (frameState) {
        if(this._show){
            if(this.dirty){
                this.dirty = false;
                this.updateMatrix();
            }
            this._primitive1.update(frameState);
            this._primitive2.update(frameState);
            this._primitive3.update(frameState);
            this._primitive4.update(frameState);
            this._primitive5.update(frameState);
        }
    };

    WeatherVolumeClipHandler.isClipMovable = function (pickedFeature) {
      return (pickedFeature.id == WeatherVolumeClipHandler._clipPlaneMinX
        || pickedFeature.id == WeatherVolumeClipHandler._clipPlaneMaxX
        || pickedFeature.id == WeatherVolumeClipHandler._clipPlaneMinY
        || pickedFeature.id == WeatherVolumeClipHandler._clipPlaneMaxY
        || pickedFeature.id == WeatherVolumeClipHandler._clipPlaneMaxZ)
    };

    WeatherVolumeClipHandler.prototype.start = function () {
        var highlightedFeature = undefined;
        var scene = this._volume._scene;
        var volume = this._volume;

        var that = this;

        this._handler1 = new Cesium.ScreenSpaceEventHandler(scene.canvas);
        this._handler1.setInputAction(function (movement) {
            var pickedFeature = scene.pick(movement.position);
            if (Cesium.defined(pickedFeature) && Cesium.defined(pickedFeature.id)) {
                if (WeatherVolumeClipHandler.isClipMovable(pickedFeature)) {
                    highlightedFeature = pickedFeature;
                    var attributes = pickedFeature.primitive.getGeometryInstanceAttributes(pickedFeature.id);
                    attributes.color = WeatherVolumeClipHandler._highlightColor;
                    var pickPosition = movement.position;
                    var screenHeight = scene.canvas.height;

                    scene.screenSpaceCameraController.enableInputs = false;
                    that._handler3 = that._handler3 && that._handler3.destroy();
                    that._handler3 = new Cesium.ScreenSpaceEventHandler(scene.canvas);
                    that._handler3.setInputAction(function (movement) {
                        var cartesian = scene.camera.pickEllipsoid(
                            movement.endPosition,
                            scene.globe.ellipsoid
                        );
                        if (Cesium.defined(cartesian)) {
                            var cartographic = Cesium.Cartographic.fromCartesian(cartesian);
                            if (pickedFeature.id == WeatherVolumeClipHandler._clipPlaneMinY) {
                                if(volume.rectangle.north > cartographic.latitude && volume.rectangle.south < cartographic.latitude){
                                    var ratio = (cartographic.latitude - volume.rectangle.south) / volume.rectangle.height;
                                    if(ratio < volume.clipPlaneMaxY){
                                        volume.clipPlaneMinY = ratio;
                                    }
                                }
                            }else if (pickedFeature.id == WeatherVolumeClipHandler._clipPlaneMaxY) {
                                if(volume.rectangle.north > cartographic.latitude && volume.rectangle.south < cartographic.latitude){
                                    var ratio = 1.0 - (volume.rectangle.north - cartographic.latitude) / volume.rectangle.height;
                                    if(ratio > volume.clipPlaneMinY){
                                        volume.clipPlaneMaxY = ratio;
                                    }
                                }
                            }else if (pickedFeature.id == WeatherVolumeClipHandler._clipPlaneMinX) {
                                if(volume.rectangle.east > cartographic.longitude && volume.rectangle.west < cartographic.longitude){
                                    var ratio = (cartographic.longitude - volume.rectangle.west) / volume.rectangle.width;
                                    if(ratio < volume.clipPlaneMaxX){
                                        volume.clipPlaneMinX = ratio;
                                    }
                                }
                            }else if (pickedFeature.id == WeatherVolumeClipHandler._clipPlaneMaxX) {
                                if(volume.rectangle.east > cartographic.longitude && volume.rectangle.west < cartographic.longitude){
                                    var ratio = 1.0 - (volume.rectangle.east - cartographic.longitude) / volume.rectangle.width;
                                    if(ratio > volume.clipPlaneMinX){
                                        volume.clipPlaneMaxX = ratio;
                                    }
                                }
                            }else {
                                var offset = {
                                    x: movement.endPosition.x - pickPosition.x,
                                    y: movement.endPosition.y - pickPosition.y
                                };

                                var topHeight = pickPosition.y;
                                var bottomHeight = screenHeight - pickPosition.y;
                                var ratioY = offset.y > 0 ? offset.y / bottomHeight : offset.y / topHeight;

                                var ratio = ratioY * 2.0;
                                pickPosition.y = movement.endPosition.y;
                                ratio = volume.clipPlaneMaxZ - ratio;
                                if (ratio > 1.0) ratio = 1.0;
                                if (ratio < 0.01) ratio = 0.01;
                                volume.clipPlaneMaxZ = ratio;
                            }
                        }
                    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
                }
            }
        }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

        this._handler2 = new Cesium.ScreenSpaceEventHandler(scene.canvas);
        this._handler2.setInputAction(function (movement) {
            scene.screenSpaceCameraController.enableInputs = true;
            that._handler3 = that._handler3 && that._handler3.destroy();
            if (Cesium.defined(highlightedFeature)){
                var attributes = highlightedFeature.primitive.getGeometryInstanceAttributes(highlightedFeature.id);
                attributes.color = WeatherVolumeClipHandler._origionalColor;
                highlightedFeature = undefined;
            }
        }, Cesium.ScreenSpaceEventType.LEFT_UP);
    };

    WeatherVolumeInner.Mode = {
      Cube: 0,
      Slice: 1,
      Box: 2,
      Cone: 3
    };

    WeatherVolumeInner.Quality = {
      Low: 0,
      Medium: 1,
      High: 2
    };

    function WeatherVolumeInner(scene, options) {
      this._scene = scene;
      this._scale = { x: 1.0, y: 1.0, z: 1.0 };
      this._offset = { x: 0.0, y: 0.0, z: 0.0 };
      var position = options.position;
      var meter = options.meter;

      this._meter = meter;
      this._source = options.source;
      this._texture = undefined;
      this._displayMode = WeatherVolumeInner.Mode.Cube;
      this._definitionChanged = new Cesium.Event();
      this._clipMatrix = new Cesium.Matrix4(
        0.0, 1.0, 0.0, 1.0,
        1.0, 0.5, 0.0, 1.0,
        0.0, 0.5, 0.0, -1e+6,/*filtrationMin*/
        1.0, 0.5, 1.0, 1e+6/*filtrationMax*/);

      this._attributeMatrix = new Cesium.Matrix4(
        0.0/*scaler  */, 0.0/*coneScan*/  , 0.0/*st_bottom*/, 0.0/*circle_clip_y*/,
        0.0/*clampMin*/, -1.0/*summation*/, 1.0/*st_width*/ , 0.0/*circle_clip_r*/,
        0.0/*clampMax*/, WeatherVolumeInner.Quality.Medium/*quality*/, 1.0/*st_height*/, 0.0/*filterCustom*/,
        0.0/*lighting*/, 0.0/*st_left*/   , 0.0/*circle_clip_x*/     , 0.0);

      this._texgen = new Cesium.Matrix4(
        1.0 / meter.width, 0.0, 0.0, 0.0,
        0.0, 1.0 / meter.height, 0.0, 0.0,
        0.0, 0.0, 1.0 / meter.depth, 0.0,
        0.5, 0.5, 0.0, 1.0);

      this._showGrid = false;
      this._showPin = false;
      this._translucent = false;
      this._summationInEdge = false;
      this._onDemWhenHeightZero = false;
      this._alphaFuncValue = 0.02;
      this._transparencyValue = 1.0;

      if (Cesium.defined(options.u_s_o)) {
        this._attributeMatrix[0] = options.u_s_o.scaler;
        this._attributeMatrix[1] = options.u_s_o.clampMin;
        this._attributeMatrix[2] = options.u_s_o.clampMax;
      }

      this._propertyMatrix = new Cesium.Matrix4(
        meter.width, position.x, 0.0/*west*/, 0.0/*topMeterWidth*/,
        meter.height, position.y, 0.0/*south*/, 1.0/*SliceZAlpha*/,
        meter.depth, position.z, 0.0/*east*/, 0.0,
        0.0/*degreeW*/, 0.0/*degreeH*/, 0.0/*north*/, 0.0);

      this._statisticMatrix = new Cesium.Matrix4(
        0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0);
      
      if(Cesium.defined(options.statistic)){
        for(let i = 0;i<options.statistic.length;i++){
          this._statisticMatrix[i] = options.statistic[i];
        }
      }


      this._granularityFactor = 0.1;

      WeatherVolumeLibrary.computeVolume(this._propertyMatrix);
      this.reCalcMatrix();
      this._dirty = true;
      this._sourceRelease = Cesium.defaultValue(options.sourceRelease, false);

      this._transFunction = options.transFunction;
      this._texture = options.texture;
      this._textureTF = options.textureTF;
      this._releaseTexture = false;
      this._releaseTFTexture = false;

      var valueAndColorRamp = options.valueAndColorRamp;
      if (!Cesium.defined(this._textureTF) && Cesium.defined(valueAndColorRamp)) {
        this.createTFTexture(valueAndColorRamp);
        this._releaseTFTexture = true;
      }

      if (!Cesium.defined(this._texture)) {
        this._texture = WeatherVolumeLibrary.create3DTexture(scene.context, this._source);
        this._releaseTexture = true;
      }

      if (this._sourceRelease) {
        this._source = undefined;
      }

      if (Cesium.defined(options.region)) {
        this.region = options.region;
      }

      this.filterCustom = Cesium.defaultValue(options.filterCustom,false);

      this.lighting = false;
    }

    WeatherVolumeInner.prototype.computeReal = function (pixel) {
      var color = new Cesium.Cartesian4(pixel[0] / 255.0, pixel[1] / 255.0, pixel[2] / 255.0, pixel[3] / 255.0);
      var realValue = Cesium.Cartesian4.dot(color, new Cesium.Cartesian4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)) * this._attributeMatrix[0] + this._attributeMatrix[1];
      return realValue;
    };

    WeatherVolumeInner.prototype.getPixels = function (refX, refY) {
      var pixels = [];
      if (refX > 0.0 && refX < 1.0 && refX > 0.0 && refX < 1.0) {
        var width = this._source.width;
        var height = this._source.height;
        var depth = this._source.depth;
        var x = Math.ceil(refX * width);
        var y = Math.ceil(refY * height);
        for (var i = 0; i < depth; i++) {
          var idx = 4 * x + width * y * 4 + 4 * width * height * i;
          pixels[i] = [this._source.arrayBufferView[idx], this._source.arrayBufferView[idx + 1], this._source.arrayBufferView[idx + 2], this._source.arrayBufferView[idx + 3]];
        }
      }

      return pixels;
    };

    WeatherVolumeInner.prototype.reCalcMatrix = function () {
      var cartesion = Cesium.Cartesian3.fromDegrees(this.position.x, this.position.y, this.position.z);
      var modelmatrix = Cesium.Transforms.eastNorthUpToFixedFrame(cartesion);
      Cesium.Matrix4.multiplyByTranslation(modelmatrix, { x: 0.0, y: 0.0, z: this._offset.z }, modelmatrix);
      Cesium.Matrix4.multiplyByScale(modelmatrix, { x: 1.0, y: 1.0, z: this._scale.z }, modelmatrix);
      this._modelmatrix = modelmatrix;
    };

    Object.defineProperties(WeatherVolumeInner.prototype, {
      lighting: {
        get: function () {
          return this._attributeMatrix[3] == 1.0;
        },
        set: function (value) {
          this._attributeMatrix[3] = value ? 1.0 : 0.0;
        }
      },
      coneScaning: {
        get: function () {
          return this._attributeMatrix[4] == 1.0;
        },
        set: function (value) {
          this._attributeMatrix[4] = value ? 1.0 : 0.0;
        }
      },
      clipCircle: {
        get: function () {
          return { x: this._attributeMatrix[11], y: this._attributeMatrix[12], r: this._attributeMatrix[13] };
        },
        set: function (value) {
          this._attributeMatrix[11] = value.x;
          this._attributeMatrix[12] = value.y;
          this._attributeMatrix[13] = value.r;
        }
      },
      filterCustom: {
        get: function () {
          return this._attributeMatrix[14] > 1.0;
        },
        set: function (value) {
          this._attributeMatrix[14] = value ? 1.0 : 0.0;
        }
      },
      region: {
        get: function () {
          return new Cesium.BoundingRectangle(
            this._attributeMatrix[7],
            this._attributeMatrix[8],
            this._attributeMatrix[9],
            this._attributeMatrix[10]);
        },
        set: function (value) {
          this._attributeMatrix[7] = value.x;
          this._attributeMatrix[8] = value.y;
          this._attributeMatrix[9] = value.width;
          this._attributeMatrix[10] = value.height;
        }
      },
      position: {
        get: function () {
          return { x: this._propertyMatrix[4], y: this._propertyMatrix[5], z: this._propertyMatrix[6] };
        },
        set: function (value) {
          return { x: value.x, y: value.y, z: value.z };
        }
      },
      transferRange: {
        get: function () {
          return this._attributeMatrix[2] - this._attributeMatrix[1];
        }
      },
      meter: {
        get: function () {
          return {
            width: this._propertyMatrix[0],
            height: this._propertyMatrix[1],
            depth: this._propertyMatrix[2],
            topWidth: this._propertyMatrix[12]
          };
        },
      },
      rectangle: {
        get: function () {
          return Cesium.Rectangle.fromDegrees(this._propertyMatrix[8], this._propertyMatrix[9], this._propertyMatrix[10], this._propertyMatrix[11]);
        },
      },
      degreeWidth: {
        get: function () {
          return this._propertyMatrix[3];
        },
      },
      degreeHeight: {
        get: function () {
          return this._propertyMatrix[7];
        },
      },
      texture: {
        get: function () {
          return this._texture;
        },
      },
      nearestSample: {
        get: function () {
          if (Cesium.defined(this._texture)) {
            return this._texture.sampler.minificationFilter == Cesium.TextureMinificationFilter.NEAREST;
          } else {
            return false;
          }
        },
        set: function (value) {
          if (Cesium.defined(this._texture)) {
            var sampler = new Cesium.Sampler({
              wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
              wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
              wrapR: Cesium.TextureWrap.CLAMP_TO_EDGE,
              minificationFilter: value ? Cesium.TextureMinificationFilter.NEAREST : Cesium.TextureMinificationFilter.LINEAR,
              magnificationFilter: value ? Cesium.TextureMagnificationFilter.NEAREST : Cesium.TextureMagnificationFilter.LINEAR
            });
            this._texture.sampler = sampler;
          }
        },
      },
      granularityFactor: {
        get: function () {
          return this._granularityFactor;
        },
        set: function (value) {
          if (value !== this._granularityFactor) {
            this._granularityFactor = value;
            this._dirty = true;
          }
        }
      },
      quality: {
        get: function () {
          return this._attributeMatrix[6];
        },
        set: function (value) {
          if (value !== this._attributeMatrix[6]) {
            this._attributeMatrix[6] = Cesium.Math.clamp(value, 0.0, 2.0);
          }
        }
      },
      onDemWhenHeightZero: {
        get: function () {
          return this._onDemWhenHeightZero;
        },
        set: function (value) {
          if (value !== this._onDemWhenHeightZero) {
            this._onDemWhenHeightZero = value;
            this._dirty = true;
          }
        }
      },
      filtrationMin: {
        get: function () {
          return this._clipMatrix[14];
        },
        set: function (value) {
          this._clipMatrix[14] = value;
        }
      },
      filtrationMax: {
        get: function () {
          return this._clipMatrix[15];
        },
        set: function (value) {
          this._clipMatrix[15] = value;
        }
      },
      transFunction: {
        get: function () {
          return this._transFunction;
        },
        set: function (value) {
          this._transFunction = value;
        }
      },
      transparencyValue: {
        get: function () {
          return this._transparencyValue;
        },
        set: function (value) {
          this._transparencyValue = value;
        }
      },
      alphaFuncValue: {
        get: function () {
          return this._alphaFuncValue;
        },
        set: function (value) {
          this._alphaFuncValue = Cesium.Math.clamp(value, 0.02, 1.0);
        }
      },
      showGrid: {
        get: function () {
          return this._showGrid;
        },
        set: function (value) {
          if (this._showGrid !== value) {
            this._showGrid = value;
            this._dirty = true;
          }
        }
      },
      showSurface: {
        get: function () {
          return this._showSurface;
        },
        set: function (value) {
          if (this._showSurface !== value) {
            this._showSurface = value;
          }
        }
      },
      scaleZ: {
        get: function () {
          return this._scale.z;
        },
        set: function (value) {
          if (value !== this._scale.z) {
            this._scale.z = value;
            this._dirty = true;
          }
        }
      },
      offsetZ: {
        get: function () {
          return this._offset.z;
        },
        set: function (value) {
          if (value !== this._offset.z) {
            this._offset.z = value;
            this._dirty = true;
          }
        }
      },
      displayMode: {
        get: function () {
          return this._displayMode;
        },
        set: function (value) {
          //if (this._displayMode !== value) {
          //  this._scene.logarithmicDepthBuffer = value === WeatherVolumeInner.Mode.Cube;
          //}
          this._displayMode = value;
        }
      },
      clipPlaneMinX: {
        get: function () {
          return this._clipMatrix[0];
        },
        set: function (value) {
          var oldValue = this._clipMatrix[0];
          if (oldValue === value) {
            return;
          }
          this._clipMatrix[0] = value;
          this._dirty = true;
        }
      },
      clipPlaneMaxX: {
        get: function () {
          return this._clipMatrix[1];
        },
        set: function (value) {
          var oldValue = this._clipMatrix[1];

          if (oldValue === value) {
            return;
          }
          this._clipMatrix[1] = value;
          this._dirty = true;
        }
      },
      clipPlaneMinY: {
        get: function () {
          return this._clipMatrix[2];
        },
        set: function (value) {
          var oldValue = this._clipMatrix[2];

          if (oldValue === value) {
            return;
          }
          this._clipMatrix[2] = value;
          this._dirty = true;
        }
      },
      clipPlaneMaxY: {
        get: function () {
          return this._clipMatrix[3];
        },
        set: function (value) {
          var oldValue = this._clipMatrix[3];

          if (oldValue === value) {
            return;
          }
          this._clipMatrix[3] = value;
          this._dirty = true;
        }
      },
      clipPlaneMaxZ: {
        get: function () {
          return this._clipMatrix[4];
        },
        set: function (value) {
          var oldValue = this._clipMatrix[4];

          if (oldValue === value) {
            return;
          }
          this._clipMatrix[4] = value;
          this._dirty = true;
        }
      },
      SlicePlaneX: {
        get: function () {
          return this._clipMatrix[5];
        },
        set: function (value) {
          var oldValue = this._clipMatrix[5];
          if (oldValue === value) {
            return;
          }
          this._clipMatrix[5] = value;
          this._dirty = true;
        }
      },
      SlicePlaneY: {
        get: function () {
          return this._clipMatrix[6];
        },
        set: function (value) {
          var oldValue = this._clipMatrix[6];
          if (oldValue === value) {
            return;
          }
          this._clipMatrix[6] = value;
          this._dirty = true;
        }
      },
      SlicePlaneZ: {
        get: function () {
          return this._clipMatrix[7];
        },
        set: function (value) {
          var oldValue = this._clipMatrix[7];
          if (oldValue === value) {
            return;
          }
          this._clipMatrix[7] = value;
          this._dirty = true;
        }
      },
      SlicePlaneZAlpha: {
        get: function () {
          return this._propertyMatrix[13];
        },
        set: function (value) {
          this._propertyMatrix[13] = value;
        }
      },
      SlicePlaneX_Visible: {
        get: function () {
          return this._clipMatrix[8] < 1.0;
        },
        set: function (value) {
          var oldValue = this._clipMatrix[8] < 1.0;
          if (oldValue === value) {
            return;
          }
          this._clipMatrix[8] = value ? 0.0 : 1.0;      this._dirty = true;
        }
      },
      SlicePlaneY_Visible: {
        get: function () {
          return this._clipMatrix[9] < 1.0;
        },
        set: function (value) {
          var oldValue = this._clipMatrix[9] < 1.0;
          if (oldValue === value) {
            return;
          }
          this._clipMatrix[9] = value ? 0.0 : 1.1;
          this._dirty = true;
        }
      },
      SlicePlaneZ_Visible: {
        get: function () {
          return this._clipMatrix[10] < 1.0;
        },
        set: function (value) {
          var oldValue = this._clipMatrix[10] < 1.1;
          if (oldValue === value) {
            return;
          }
          this._clipMatrix[10] = value ? 0.0 : 1.1;
          this._dirty = true;
        }
      },
      summationInEdge: {
        get: function () {
          return this._summationInEdge;
        },
        set: function (value) {
          if (this._summationInEdge !== value) {
            this._summationInEdge = value;
            this._dirty = true;
          }
        },
      },
      definitionChanged: {
        get: function () {
          return this._definitionChanged;
        },
      },
    });

    WeatherVolumeInner.prototype.createTFTexture = function (valueAndColorRamp) {
      if (Cesium.defined(this._textureTF)) {
        this._textureTF = this._textureTF && this._textureTF.destroy();
      }

      if(Cesium.defined(Config.CreateTransferTextureFunction)){
        this._textureTF = Config.CreateTransferTextureFunction(this);
      }else {
        this._textureTF = WeatherVolumeLibrary.createTransferTexture(this._scene.context,
          valueAndColorRamp,
          this.transferRange,
          this._attributeMatrix[1]);
      }


    };

    WeatherVolumeInner.prototype.update = function (frameState) {
      if (this._dirty) {
        this.reCalcMatrix();
        this._definitionChanged.raiseEvent(this, "dirty");
      }
    };

    WeatherVolumeInner.prototype.isDestroyed = function () {
      return false;
    };

    WeatherVolumeInner.prototype.destroy = function () {
      this._source = undefined;
      if (this._releaseTexture) {
        this._texture = this._texture && this._texture.destroy();
      }
      if (this._releaseTFTexture) {
        this._textureTF = this._textureTF && this._textureTF.destroy();
      }

      return Cesium.destroyObject(this);
    };

    function WeatherVolumePickHandler(volume) {
      this._handler1 = undefined;
      this._volume = volume;
      this._scene = volume._scene;
      this._pickPosition = new Cesium.Cartesian3();
      this._visible = false;
      this._pickColor = new Cesium.Color(1.0,1.0,0.0,1.0);
      this._refPickPos = new Cesium.Cartesian3(0.1,0.1,1.0);
      var rectangle = volume.rectangle;
      this._minLon = Cesium.Math.toDegrees(rectangle.west);
      this._minLat = Cesium.Math.toDegrees(rectangle.south);
      this._gpuCompute = true;
      this._isPickingSurface = volume.displayMode == WeatherVolumeInner.Mode.Slice;
      this.create();
    }

    WeatherVolumePickHandler.prototype.destroy = function () {
      this._handler1 = this._handler1 && this._handler1.destroy();
      this._computeEngine = this._computeEngine && this._computeEngine.destroy();
      this._labels = this._labels && this._labels.destroy();
    };

    Object.defineProperties(WeatherVolumePickHandler.prototype, {
        pickColor : {
            get : function() {
                return this._pickColor;
            },
            set : function(value) {
                this._pickColor = value;
            }
        }
    });

    WeatherVolumePickHandler.prototype.createCompute = function () {
        var context = this._volume._scene.context;
        this._computeEngine = new Cesium.ComputeEngine(context);
        var outputTexture = new Cesium.Texture({
            context: context,
            width: 1,
            height: 1,
            PixelFormat: Cesium.PixelFormat.RGBA
        });

        var framebuffer = new Cesium.Framebuffer({
            context: context,
            colorTextures: [outputTexture],
            destroyAttachments: false
        });

        var readState = {
            framebuffer: framebuffer,
            x: 0,
            y: 0,
            width: 1,
            height: 1
        };

        var fs = "precision highp sampler3D;\n\
uniform sampler3D u_floatTexture;\n\
uniform vec3 u_pos;\n\
uniform mat4 calcMatrix;\n\
void main()\n\
{\n\
vec3 texcoord = u_pos;\n\
vec4 fragColor = texture3D(u_floatTexture,texcoord);\n\
float summation = calcMatrix[0][0];\n\
float scaler = calcMatrix[0][1];\n\
float offset = calcMatrix[0][2];\n\
if(summation > 0.0){\n\
    float v = czm_unpackDepth(fragColor) * scaler + offset;\n\
    for(float i=0.0;i<=1.0;i+=0.01){\n\
        vec4 color = texture3D(u_floatTexture,vec3(texcoord.xy,i));\n\
        float v2 = czm_unpackDepth(color) * scaler + offset;\n\
        if(v2>v){\n\
            v = v2; \n\
            fragColor = color; \n\
        }\n\
    }\n\
}\n\
gl_FragColor = fragColor;\n\
}\n\
";
        var summation = this._volume.summationInEdge ? 1.0 : 0.0;
        var scaler = this._volume._clipMatrix[11];
        var clampMin = this._volume._clipMatrix[12];
        var clampMax = this._volume._clipMatrix[13];
        this._calcMatrix = new Cesium.Matrix4(
            summation, 0.0, 0.0, 0.0,
            scaler, 0.0, 0.0, 0.0,
            clampMin, 0.0, 0.0, 0.0,
            clampMax, 0.0, 0.0, 0.0);

      var that = this;
      var t = this._volume._texture;
      var computeCommand = new Cesium.ComputeCommand({
          fragmentShaderSource: fs,
          outputTexture : outputTexture,
          uniformMap : {
              u_floatTexture : function() {
                  return t;
              },
              u_pos: function () {
                  return that._refPickPos;
              },
              calcMatrix: function () {
                  return that._calcMatrix;
              },
          },
          persists : false,
          postExecute : function() {
              var pixel = context.readPixels(readState);
              var realValue = that._volume.computeReal(pixel);
              that.setText(realValue);
          }
      });

      this._computeCommand = computeCommand;
    };

    WeatherVolumePickHandler.prototype.setText = function (realValue) {
      var longitudeString = this._pickPosition.x.toFixed(2);
      var latitudeString = this._pickPosition.y.toFixed(2);
      var heightString = this._pickPosition.z.toFixed(2);
      var text = '';
      text += "Lon: " + ("   " + longitudeString).slice(-10) + "\u00B0\n";
      text += "Lat: " + ("   " + latitudeString).slice(-10) + "\u00B0\n";
        //text += "Alt: " + ("   " + heightString).slice(-10) + "m\n";
        if (this._isPickingSurface) {
            var height = this._volume.offsetZ + this._volume.SlicePlaneZ * this._volume.meter.depth;
            var heightString = (height*0.001).toFixed(2);
            text += "Height: " + ("   " + heightString).slice(-6) + "km\n";
        }
      text += "Value: " + (" " + realValue.toFixed(3).slice(-7));
      this._label.show = true;
      this._label.text = text;
    };

    WeatherVolumePickHandler.prototype.computePickColor = function () {
        if (this._isPickingSurface) {
            if(!Cesium.defined(this._computeCommand))
              this.createCompute();
            this._computeCommand.execute(this._computeEngine);
            return true;
        }
        else {
            var pixels = this._volume.getPixels(this._refPickPos.x, this._refPickPos.y);
            if (!Cesium.defined(pixels) || pixels.length == 0) {
                return false;
            }

            var depthRatio = this._refPickPos.z;
            var summation = depthRatio == 0.0 && this._volume.summationInEdge;
            var size = Math.ceil(pixels.length * depthRatio);
            if (size == 0) size = 1;
            if(summation)size = pixels.length;
      
            var getValue = 0.0;
            for(var i = size - 1;i>-1;i--){
                var pixel = pixels[i];
                if(pixel[0] > 0 && pixel[1] > 0 && pixel[2] > 0){
                  var realValue = this._volume.computeReal(pixel);
                  if (realValue < this._volume.filtrationMin || realValue > this._volume.filtrationMax) {
                      continue;
                  }
                  if(summation){
                      if(getValue<realValue)getValue=realValue;
                  }
                  else {
                      getValue = realValue;
                      break;
                  }
                }
            }

            this.setText(getValue);
            return true;
        }
    };

    WeatherVolumePickHandler.prototype.createLabel = function () {
      if (!Cesium.defined(this._labels)) {
        this._labels = new Cesium.LabelCollection();
        this._label = this._labels.add({
          show: false,
          showBackground: true,
          font: "14px monospace",
          HorizontalOrigin: Cesium.HorizontalOrigin.LEFT,
          VerticalOrigin: Cesium.VerticalOrigin.TOP,
          pixelOffset: new Cesium.Cartesian2(10, -14),
          disableDepthTestDistance: Number.POSITIVE_INFINITY,
          });
      }
    };

    WeatherVolumePickHandler.prototype.create = function () {
      this.createLabel();
      var that = this;
      var scene = this._scene;
      this._handler1 = new Cesium.ScreenSpaceEventHandler(scene.canvas);
      this._handler1.setInputAction(function (movement) {
        var foundPosition = false;
        var pickedObject = scene.pick(movement.endPosition);
        if (scene.pickPositionSupported && Cesium.defined(pickedObject)){
          var pickCube = pickedObject.id instanceof WeatherVolumeInner ||
            ((Cesium.defined(pickedObject.primitive) && pickedObject.primitive.id instanceof WeatherVolumeInner));
          var pickSlice = (Cesium.defined(pickedObject.primitive) && pickedObject.primitive.id instanceof WeatherVolumeSurface);
            that._isPickingSurface = pickSlice;
          if(pickCube || pickSlice){

            var cartesian = scene.pickPosition(movement.endPosition);
            if(!Cesium.defined(cartesian) && pickSlice && pickedObject.primitive instanceof Cesium.GroundPrimitive){
              //scene.pickTranslucentDepth = true;
              //scene.render();

              cartesian = scene.camera.pickEllipsoid(
                movement.endPosition,
                scene.globe.ellipsoid
              );
            }
            if (Cesium.defined(cartesian)) {
              var Cartographic = Cesium.Cartographic.fromCartesian(cartesian);
              that._pickPosition.x = Cesium.Math.toDegrees(Cartographic.longitude);
              that._pickPosition.y = Cesium.Math.toDegrees(Cartographic.latitude);
              that._pickPosition.z = Cartographic.height;

              var x = (that._pickPosition.x - that._minLon) / that._volume.degreeWidth;
              var y = (that._pickPosition.y - that._minLat) / that._volume.degreeHeight;
              that._refPickPos.x = Cesium.Math.clamp(x, 0.0, 1.0);
              that._refPickPos.y = Cesium.Math.clamp(y, 0.0, 1.0);
                var depthRatio = pickSlice ? that._volume.SlicePlaneZ : that._volume.clipPlaneMaxZ;
                that._refPickPos.z = Cesium.Math.clamp(depthRatio, 0.0, 1.0);
                that._label.position = cartesian;
                foundPosition = that.computePickColor();
            }

          }
        }
        that._label.show = foundPosition;
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    };

    WeatherVolumePickHandler.prototype.update = function (frameState) {
      if (Cesium.defined(this._labels)) {
        this._labels.update(frameState);
      }
    };

    function WeatherVolumeGrid(volume, context) {
      this._LabelDistanceDisplayFator = 3;
      this.outFixDis = 200;
      this.xfloors = [];
      this.yfloors = [];
      this.zfloors = [];
      this.init(volume, context);
    }

    function addLabel(labels, position, text, distanceToDisplay, horizontalOrigin) {
      labels.add({
        position: position,
        font: Config.font,
        disableDepthTestDistance1: Number.POSITIVE_INFINITY,
        disableDepthTestDistance: 0,
        distanceDisplayCondition: new Cesium.DistanceDisplayCondition(
          0,
          distanceToDisplay
        ),
        text: text,
        fillColor: Config.fillColor,
        outlineColor: Config.outlineColor,
        backgroundColor: Config.backgroundColor,
        showBackground: Config.showBackground,
        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
        horizontalOrigin: horizontalOrigin,
      });
    }

    WeatherVolumeGrid.prototype.createLabels = function (w, h, d, volume) {
      var labels = (this._labels = new Cesium.LabelCollection());

      var half_w = 0.5 * w;
      var half_h = 0.5 * h;
      var outFixDis = this.outFixDis;
      const xmin = 0.0 - half_w - outFixDis;
      const ymin = 0.0 - half_h - outFixDis;

      var distanceToDisplay = (w > h ? w : h) * this._LabelDistanceDisplayFator;
      for (var i = 1; i < Config.AxesFloorsRatio.length; i++) {
        
        const offsetx = xmin + this.xfloors[i];
        const offsety = ymin + this.yfloors[i];
        const height = this.zfloors[i];
        
        var offsetRatio = Config.AxesFloorsRatio[i];
        var longitude = (volume.position.x + (offsetRatio - 0.5) * volume.degreeWidth);
        var latitude = (volume.position.y + (offsetRatio - 0.5) * volume.degreeHeight);

        addLabel(
          labels,
          new Cesium.Cartesian3(
            offsetx,
            ymin,
            0.0
          ),
          longitude.toFixed(2),
          distanceToDisplay,
          Cesium.HorizontalOrigin.LEFT
        );
        
        addLabel(
          labels,
          new Cesium.Cartesian3(
            xmin,
            offsety,
            0.0
          ),
          latitude.toFixed(2),
          distanceToDisplay,
          Cesium.HorizontalOrigin.RIGHT
        );

        addLabel(
          labels,
          new Cesium.Cartesian3(
            xmin,
            ymin,
            height
          ),
          (height * 0.001).toFixed(0) + "km",
          distanceToDisplay,
          Cesium.HorizontalOrigin.RIGHT
        );
      }
    };

    WeatherVolumeGrid.prototype.createLines = function (w, h, d) {
      this._polylines = new Cesium.PolylineCollection();

      var outFixDis = this.outFixDis;
      const xmin = 0.0 - 0.5 * w - outFixDis;
      const ymin = 0.0 - 0.5 * h - outFixDis;
      const xmax = 0.0 + 0.5 * w;
      const ymax = 0.0 + 0.5 * h;
      const zmax = this.zfloors[this.zfloors.length - 1];
      let length = this.zfloors.length;
      for (let i = 0; i < length; i++) {
        const height = this.zfloors[i];

        // z steps
        this._polylines.add({
          positions: [
            new Cesium.Cartesian3(xmin, ymax, height),
            new Cesium.Cartesian3(xmin, ymin, height),
            new Cesium.Cartesian3(xmax, ymin, height),
          ],
          width: Config.AxesLineWidth,
        });

      
        // x steps
        const offsetx = this.xfloors[i];
        this._polylines.add({
          positions: [
            new Cesium.Cartesian3(xmin + offsetx, ymin, 0.0),
            new Cesium.Cartesian3(xmin + offsetx, ymin, zmax),
          ],
          width: Config.AxesLineWidth,
        });

        // y steps
        if( i > 0) {
          const offsety = this.yfloors[i];
          this._polylines.add({
            positions: [
              new Cesium.Cartesian3(xmin, ymin + offsety, 0.0),
              new Cesium.Cartesian3(xmin, ymin + offsety, zmax),
            ],
            width: Config.AxesLineWidth,
          });
        }
      }
    };

    WeatherVolumeGrid.prototype.createPrimitive = function () {
      this._primitive = new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry: new Cesium.PolylineGeometry({
            positions: [
              new Cesium.Cartesian3(0.0, 0.0, 0.0),
              new Cesium.Cartesian3(w, 0.0, 0.0),
            ],
            width: 1.0,
            arcType: Cesium.ArcType.NONE,
            vertexFormat: Cesium.PolylineMaterialAppearance.VERTEX_FORMAT,
          }),
          attributes: {
            color: Cesium.ColorGeometryInstanceAttribute.fromColor(
              new Cesium.Color(1.0, 1.0, 1.0, 1.0)
            ),
          },
        }),
        appearance: new Cesium.PolylineMaterialAppearance({
          translucent: false,
          material: Cesium.Material.fromType("Color"),
        }),
        appearance1: new Cesium.PerInstanceColorAppearance({
          flat: true,
          translucent: true,
          renderState: {
            lineWidth: 1.0,
          },
        }),
        modelMatrix: volume._modelmatrix,
      });
    };

    WeatherVolumeGrid.prototype.init = function (volume, context) {
      var w = volume.meter.width;
      var h = volume.meter.height;
      var d = volume.meter.depth;

      for (let i = 0; i < Config.AxesFloorsRatio.length; i++) {
        this.zfloors.push(Math.ceil(Config.AxesFloorsRatio[i] * d * 0.001) * 1000.0);
        this.xfloors.push(Config.AxesFloorsRatio[i] * w);
        this.yfloors.push(Config.AxesFloorsRatio[i] * h);
      }

      this.createLabels(w, h, d, volume);
      this.createLines(w, h, d);
      this.updateMatrix(volume._modelmatrix);
    };

    WeatherVolumeGrid.prototype.createCommand = function (context) {
      //var fixTopWidth = (volume.meter.width - volume.meter.topWidth) * 0.5 * 0.0;
      var fixTopWidth = 0.0;

      var vs =
        "attribute vec3 position3DHigh;\
  attribute vec3 position3DLow;\
  void main()\
  {\
      vec4 p = czm_translateRelativeToEye(position3DHigh, position3DLow);\
      gl_Position = czm_modelViewProjectionRelativeToEye * p;\
  }";
      var fs = "void main()\
  {\
      gl_FragColor = vec4(1,1,1,1);\
  }";

      var shaderProgram = Cesium.ShaderProgram.fromCache({
        context: context,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
      });

      var renderState = Cesium.RenderState.fromCache({
        depthTest: {
          enabled: true,
        },
        depthMask: true,
        cull: {
          enabled: true,
          face: Cesium.CullFace.FRONT,
        },
      });

      var idx = [0, 1, 2, 3, 0, 2, 1, 3, 0, 4, 2, 5, 4, 5];

      var points = [
        0.0 - half_w,
        0.0 - half_h,
        0.0,
        1.0 * w - half_w,
        0.0 - half_h,
        0.0,
        0.0 - half_w,
        0.0 - half_h,
        1.0 * d,
        1.0 * w - half_w,
        0.0 - half_h,
        1.0 * d,
        0.0 + 0.5 * fixTopWidth - half_w,
        1.0 * h - half_h,
        0.0,
        0.0 + 0.5 * fixTopWidth - half_w,
        1.0 * h - half_h,
        1.0 * d,
      ];

      var lastidx = points.length / 3;
      var offset = 0.1;
      for (var i = 0; i < 3; i++) {
        if (i > 0) offset += 0.3;
        points.push(0.0 - half_w);
        points.push(0.0 - half_h);
        points.push((1.0 - offset) * d);
        points.push(1.0 * w - half_w);
        points.push(0.0 - half_h);
        points.push((1.0 - offset) * d);
        idx.push(lastidx++);
        idx.push(lastidx++);

        points.push(0.0 - half_w);
        points.push(0.0 - half_h);
        points.push((1.0 - offset) * d);
        points.push(0.0 + 0.5 * fixTopWidth - half_w);
        points.push(1.0 * h - half_h);
        points.push((1.0 - offset) * d);
        idx.push(lastidx++);
        idx.push(lastidx++);

        points.push(offset * w - half_w);
        points.push(0.0 - half_h);
        points.push(0.0);
        points.push(offset * w - half_w);
        points.push(0.0 - half_h);
        points.push(1.0 * d);
        idx.push(lastidx++);
        idx.push(lastidx++);

        points.push(0.0 + offset * 0.5 * fixTopWidth - half_w);
        points.push(offset * h - half_h);
        points.push(0.0);
        points.push(0.0 + offset * 0.5 * fixTopWidth - half_w);
        points.push(offset * h - half_h);
        points.push(1.0 * d);
        idx.push(lastidx++);
        idx.push(lastidx++);
      }

      var indexBuffer = Cesium.Buffer.createIndexBuffer({
        context: context,
        typedArray: new Uint32Array(idx),
        usage: Cesium.BufferUsage.STATIC_DRAW,
        indexDatatype: Cesium.IndexDatatype.UNSIGNED_INT,
      });

      var vertexBuffer = Cesium.Buffer.createVertexBuffer({
        context: context,
        typedArray: Cesium.ComponentDatatype.createTypedArray(
          Cesium.ComponentDatatype.FLOAT,
          points
        ),
        usage: Cesium.BufferUsage.STATIC_DRAW,
      });

      var attributes = [];
      attributes.push({
        index: 0,
        vertexBuffer: vertexBuffer,
        componentDatatype: Cesium.ComponentDatatype.FLOAT,
        componentsPerAttribute: 3,
        normalize: false,
        instanceDivisor: 0,
      });

      var vertexArray = new Cesium.VertexArray({
        context: context,
        attributes: attributes,
        indexBuffer: indexBuffer,
      });

      this._command = new Cesium.DrawCommand({
        boundingVolume: volume._boundingVolume,
        primitiveType: Cesium.PrimitiveType.LINES,
        shaderProgram: shaderProgram,
        renderState: renderState,
        vertexArray: vertexArray,
        modelMatrix: volume._modelmatrix,
        pass: Cesium.Pass.OPAQUE,
      });
    };

    WeatherVolumeGrid.prototype.update = function (frameState) {
      //var commandList = frameState.commandList;
      //commandList.push(this._command);
      this._polylines.update(frameState);
      this._labels.update(frameState);
      //this._primitive.update(frameState);
    };

    WeatherVolumeGrid.prototype.updateMatrix = function (modelmatrix) {
      if (Cesium.defined(this._command)) this._command.modelMatrix = modelmatrix;
      if (Cesium.defined(this._labels)) this._labels.modelMatrix = modelmatrix;
      if (Cesium.defined(this._polylines))
        this._polylines.modelMatrix = modelmatrix;
    };

    WeatherVolumeGrid.prototype.destroy = function () {
      if (Cesium.defined(this._labels)) {
        this._labels.destroy();
        this._labels = undefined;
      }
      this._polylines = this._polylines && this._polylines.destroy();
    };

    function WeatherData(options) {}

    var MimeTypes = {
      avi: "video/x-msvideo",
      bmp: "image/bmp",
      bz2: "application/x-bzip2",
      chm: "application/vnd.ms-htmlhelp",
      css: "text/css",
      csv: "text/csv",
      doc: "application/msword",
      dvi: "application/x-dvi",
      eps: "application/postscript",
      flv: "video/x-flv",
      gif: "image/gif",
      gz: "application/x-gzip",
      htm: "text/html",
      html: "text/html",
      ico: "image/vnd.microsoft.icon",
      jnlp: "application/x-java-jnlp-file",
      jpeg: "image/jpeg",
      jpg: "image/jpeg",
      m3u: "audio/x-mpegurl",
      m4v: "video/mp4",
      mathml: "application/mathml+xml",
      mid: "audio/midi",
      midi: "audio/midi",
      mov: "video/quicktime",
      mp3: "audio/mpeg",
      mp4: "video/mp4",
      mp4v: "video/mp4",
      mpeg: "video/mpeg",
      mpg: "video/mpeg",
      odp: "application/vnd.oasis.opendocument.presentation",
      ods: "application/vnd.oasis.opendocument.spreadsheet",
      odt: "application/vnd.oasis.opendocument.text",
      ogg: "application/ogg",
      pdf: "application/pdf",
      png: "image/png",
      pps: "application/vnd.ms-powerpoint",
      ppt: "application/vnd.ms-powerpoint",
      ps: "application/postscript",
      qt: "video/quicktime",
      rdf: "application/rdf+xml",
      rss: "application/rss+xml",
      rtf: "application/rtf",
      svg: "image/svg+xml",
      swf: "application/x-shockwave-flash",
      text: "text/plain",
      json: "text/plain",
      tif: "image/tiff",
      tiff: "image/tiff",
      txt: "text/plain",
      wav: "audio/x-wav",
      wma: "audio/x-ms-wma",
      wmv: "video/x-ms-wmv",
      xml: "application/xml",
      zip: "application/zip",

      detectFromFilename: function (filename) {
        var ext = filename.toLowerCase();
        ext = Cesium.getExtensionFromUri(ext);
        return MimeTypes[ext];
      },
    };

    function loadDataFromZip(entry, uriResolver, deferred) {
      var mimeType = Cesium.defaultValue(
        MimeTypes.detectFromFilename(entry.filename),
        "application/octet-stream"
      );
      var writer;
      if (mimeType === "text/plain") {
        writer = new Cesium.zip.TextWriter();
      } else {
        writer = new Cesium.zip.BlobWriter(mimeType);
      }
      entry.getData(writer, function (data) {
        uriResolver[entry.filename] = data;
        deferred.resolve();
      });
    }

    var sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;
    function parsew3dm(arrayBuffer) {
      var byteOffset = 0;
      var uint8Array = new Uint8Array(arrayBuffer);
      var view = new DataView(arrayBuffer);
      byteOffset += sizeOfUint32; // Skip magic
      var version = view.getUint32(byteOffset, true);
      if (version !== 1) {
        throw new Cesium.RuntimeError(
          "Only Weather 3d model version 1 is supported.  Version " +
            version +
            " is not."
        );
      }
      byteOffset += sizeOfUint32;

      // Skip byteLength
      byteOffset += sizeOfUint32;

      var featureTableJsonByteLength = view.getUint32(byteOffset, true);
      if (featureTableJsonByteLength === 0) {
        throw new Cesium.RuntimeError(
          "Feature table must have a byte length greater than zero"
        );
      }
      byteOffset += sizeOfUint32;
      var featureTableBinaryByteLength = view.getUint32(byteOffset, true);
      byteOffset += sizeOfUint32;
      var featureTableString = Cesium.getStringFromTypedArray(
        uint8Array,
        byteOffset,
        featureTableJsonByteLength
      );
      var featureTableJson = JSON.parse(featureTableString);
      byteOffset += featureTableJsonByteLength;
      var featureTableBinary = new Uint8Array(
        arrayBuffer,
        byteOffset,
        featureTableBinaryByteLength
      );
      byteOffset += featureTableBinaryByteLength;
      var isCompress = Cesium.defaultValue(featureTableJson.isCompress, true);
      if (isCompress) {
        featureTableJson.source.arrayBufferView =
          pako.inflateRaw(featureTableBinary);
      } else {
        featureTableJson.source.arrayBufferView = featureTableBinary;
      }
      return featureTableJson;
    }

    function parseZip(arrayBuffer) {
      var resolveData = {};
      var arrayBufferView;
      var zip = new JSZip(arrayBuffer);
      Object.keys(zip.files).forEach((filename) => {
        var ext = filename.toLowerCase();
        ext = Cesium.getExtensionFromUri(ext);
        if (ext === "raw") {
          arrayBufferView = zip.files[filename].asUint8Array();
        } else if (ext === "json") {
          var params = zip.files[filename].asText();
          resolveData = eval("(" + params + ")");
        }
      });
      resolveData.source.arrayBufferView = arrayBufferView;
      return resolveData;
    }

    WeatherData.requestWithParams = function (
      name,
      varname,
      ext,
      templateUrl,
      version
    ) {
      var url = Cesium.defaultValue(templateUrl, Config.WeatherDataTemplateUrl);
      url = url.replace("{0}", name);
      url = url.replace("{1}", varname);
      url = url.replace("{2}", Cesium.defaultValue(ext, "nc"));
      var version = parseFloat(
        Cesium.defaultValue(version, Config.WeatherDataVersion)
      );
      if (version > 1.0) {
        if (url.indexOf("{3}") === -1) {
          url += "%3B{3}";
        }
        url = url.replace(
          "{3}",
          Cesium.defaultValue(version, Config.WeatherDataVersion)
        );
        return WeatherData.request1(url, parsew3dm);
      } else {
        return WeatherData.request1(url, parseZip);
      }
    };

    WeatherData.postWithParams = function (
      data,
      name,
      varname,
      ext,
      templateUrl,
      version
    ) {
      var url = Cesium.defaultValue(templateUrl, Config.WeatherDataTemplateUrl);
      url = url.replace("{0}", name);
      url = url.replace("{1}", varname);
      url = url.replace("{2}", Cesium.defaultValue(ext, "nc"));
      var version = parseFloat(
        Cesium.defaultValue(version, Config.WeatherDataVersion)
      );
      if (version > 1.0) {
        if (url.indexOf("{3}") === -1) {
          url += "%3B{3}";
        }
        url = url.replace(
          "{3}",
          Cesium.defaultValue(version, Config.WeatherDataVersion)
        );
        return WeatherData.post1(data, url, parsew3dm);
      } else {
        return WeatherData.post1(data, url, parseZip);
      }
    };

    WeatherData.post = function (url, data) {
      var version = parseFloat(Config.WeatherDataVersion);
      if (version > 1.0) {
        return WeatherData.post1(url, data, parsew3dm);
      } else {
        return WeatherData.post1(url, data, parseZip);
      }
    };

    WeatherData.request = function (url) {
      var version = parseFloat(Config.WeatherDataVersion);
      if (version > 1.0) {
        return WeatherData.request1(url, parsew3dm);
      } else {
        return WeatherData.request1(url, parseZip);
      }
    };

    WeatherData.request1 = function (url, parseFunc) {
      var deferred = Cesium.when.defer();
      Cesium.Resource.fetchArrayBuffer(url)
        .then((arrayBuffer) => {
          var volumeData = parseFunc(arrayBuffer);
          if (
            Cesium.defined(volumeData.source) &&
            Cesium.defined(volumeData.source.arrayBufferView)
          ) {
            deferred.resolve(volumeData);
          } else {
            deferred.reject(new Cesium.RuntimeError("not valid volume data."));
          }
        })
        .otherwise((error) => {
          deferred.reject(error);
        });

      return deferred.promise;
    };

    WeatherData.post1 = function (data, url, parseFunc) {
      var deferred = Cesium.when.defer();
      Cesium.Resource.post({
        responseType: "arraybuffer",
        url: url,
        data: data,
      })
        .then((arrayBuffer) => {
          var volumeData = parseFunc(arrayBuffer);
          if (
            Cesium.defined(volumeData.source) &&
            Cesium.defined(volumeData.source.arrayBufferView)
          ) {
            deferred.resolve(volumeData);
          } else {
            deferred.reject(new Cesium.RuntimeError("not valid volume data."));
          }
        })
        .otherwise((error) => {
          deferred.reject(error);
        });

      return deferred.promise;
    };

    WeatherData.request3 = function (url) {
      var deferred = Cesium.when.defer();
      Cesium.Resource.fetchBlob(url)
        .then((blob) => {
          Cesium.zip.createReader(
            new Cesium.zip.BlobReader(blob),
            function (reader) {
              reader.getEntries(function (entries) {
                var promises = [];
                var uriResolver = [];
                for (var i = 0; i < entries.length; i++) {
                  var entry = entries[i];
                  if (!entry.directory) {
                    var innerDefer = Cesium.when.defer();
                    promises.push(innerDefer.promise);
                    loadDataFromZip(entry, uriResolver, innerDefer);
                  }
                }

                Cesium.when
                  .all(promises)
                  .then(function () {
                    reader.close();
                    deferred.resolve(uriResolver);
                  })
                  .then(deferred.resolve)
                  .otherwise(deferred.reject);
              });
            }
          );
        })
        .otherwise((error) => {
          deferred.reject(error);
        });

      return deferred.promise;
    };

    WeatherData.prototype.sucess = function () {};

    function WeatherVolume(scene, options) {
      this.timestamp = new Date().getTime();
      this._name = options.name;
      this.varname = options.varname;
      this._readyPromise = Cesium.when.defer();
      this._TransFunction = options.TransFunction;
      this._ValueAndColorRamp = options.ValueAndColorRamp;
      this._onPick = false;
      this._dirty = false;
      this._showInner = true;
      this._box = undefined;
      this._cone = undefined;
      this._lengthway = undefined;
      this._lengthwayXYZ = undefined;
      this._volumeHandler = undefined;
      this._volumeGrid = undefined;
      this.dirty = false;
      this._lengthWays = new Cesium.AssociativeArray();
      this._clearing = false;

      var that = this;
      var parse = function (volumeData) {
        volumeData.transFunction = options.TransFunction;
        volumeData.valueAndColorRamp = options.ValueAndColorRamp;
        if(Cesium.defeind(options.position)){
          volumeData.position = options.position;
        }
        var volume = new WeatherVolumeInner(scene, volumeData);
        that._removeEntitySubscription = volume.definitionChanged.addEventListener(
          WeatherVolume.prototype._onVolumePropertyChanged,
          that
        );
        that._volume = volume;
        that._readyPromise.resolve(that);
      };

      if (Cesium.defined(options.source)) {
        options.source.transFunction = options.TransFunction;
        options.source.valueAndColorRamp = options.ValueAndColorRamp;
        var volume = new WeatherVolumeInner(scene, options.source);
        this._removeEntitySubscription = volume.definitionChanged.addEventListener(
          WeatherVolume.prototype._onVolumePropertyChanged,
          this
        );
        this._volume = volume;
        this._readyPromise.resolve(this);
      } else {
        WeatherData.request(options.url)
          .then(function (volumeData) {
            parse(volumeData);
          })
          .otherwise(function (error) {
            that._readyPromise.reject(error);
          });
      }
    }

    WeatherVolume.prototype._onVolumePropertyChanged = function (
      entity,
      propertyName,
      newValue,
      oldValue
    ) {
      if (propertyName == "dirty") {
        if (Cesium.defined(this._volumeHandler)) {
          this._volumeHandler.dirty = true;
        }
        this.dirty = true;
      }
    };

    Object.defineProperties(WeatherVolume.prototype, {
      readyPromise: {
        get: function () {
          return this._readyPromise.promise;
        },
      },
      inner: {
        get: function () {
          return this._volume;
        },
      },
      showInner: {
        get: function () {
          return this._showInner;
        },
        set: function (value) {
          this._showInner = value;
        },
      },
      dirty: {
        get: function () {
          return this._dirty;
        },
        set: function (value) {
          this._dirty = value;
        },
      },
      name: {
        get: function () {
          return this._name;
        },
      },
      hierarchyObj: {
        get: function () {
          return this._hierarchy;
        },
      },
      showMovable: {
        get: function () {
          return Cesium.defined(this._volumeHandler);
        },
        set: function (value) {
          if (value) {
            if (!Cesium.defined(this._volumeHandler)) {
              this._volumeHandler = new WeatherVolumeClipHandler(this.inner);
            }
          } else {
            this._volumeHandler =
              this._volumeHandler && this._volumeHandler.destroy();
          }
        },
      },
      onPick: {
        get: function () {
          return this._onPick;
        },
        set: function (value) {
          if (this._onPick != value) {
            this._onPick = value;
            if (value) {
              if (Cesium.defined(this._volumePickHandler)) {
                this._volumePickHandler.destroy();
                this._volumePickHandler = undefined;
              }
              this._volumePickHandler = new WeatherVolumePickHandler(this.inner);
            } else {
              if (Cesium.defined(this._volumePickHandler)) {
                this._volumePickHandler.destroy();
                this._volumePickHandler = undefined;
              }
            }
          }
        },
      },
      clipCircle: {
        set: function (value) {
          if (Cesium.defined(this.inner)) {
            const { longitude, latitude, radius } = value;
            const west = this.inner.rectangle.west;
            const north = this.inner.rectangle.north;
            const east = this.inner.rectangle.east;
            const south = this.inner.rectangle.south;
            if (longitude <= east && longitude >= west
              && latitude >= south
              && latitude <= north) {
              const r = radius / this.inner.meter.width; 
              let x = (longitude - west) / (east - west);
              const y = (latitude - south) / (north - south);
              this.inner.clipCircle = { x, y, r};
            }
            else {
              this.inner.clipCircle = { x:0, y:0, r:0};
            }
          }
        },
      },
    });

    WeatherVolume.fromRemoteUrl = function (scene, remoteUrl, options) {
      var optionCopy = options;
      var url = remoteUrl;
      url = url.replace("{0}", options.name);
      url = url.replace("{1}", options.varname);
      url = url.replace("{2}", Cesium.defaultValue(options.ext, "nc"));
      optionCopy.url = url;
      return new WeatherVolume(scene, optionCopy);
    };

    WeatherVolume.prototype.setState = function (state) {
      if (Cesium.defined(this.inner)) {
        this.inner.displayMode = state.mode;
        this.inner.filtrationMin = state.filtrationMin;
        this.inner.filtrationMax = state.filtrationMax;
        this.inner.SlicePlaneX = state.SlicePlaneX;
        this.inner.SlicePlaneY = state.SlicePlaneY;
        this.inner.SlicePlaneZ = state.SlicePlaneZ;
        this.inner.SlicePlaneX_Visible = state.SlicePlaneX_Visible;
        this.inner.SlicePlaneY_Visible = state.SlicePlaneY_Visible;
        this.inner.SlicePlaneZ_Visible = state.SlicePlaneZ_Visible;
        this.inner.summationInEdge = state.summationInEdge;
        this.inner.showGrid = state.showGrid;
        this.inner.offsetZ = state.offsetZ;
        this.inner.scaleZ = state.scaleZ;
        this.inner.transparencyValue = state.transparencyValue;
        this.inner.lighting = state.lighting;
        this.inner.onDemWhenHeightZero = state.onDemWhenHeightZero;
      }
    };

    WeatherVolume.prototype.chop2 = function (rectangle) {
      if (Cesium.defined(this.inner)) {
        var volumeRectangle = this.inner.rectangle;
        if (
          rectangle.west < volumeRectangle.west ||
          rectangle.east > volumeRectangle.east ||
          rectangle.south < volumeRectangle.south ||
          rectangle.north > volumeRectangle.north
        ) {
          return undefined;
        }

        var center = new Cesium.Cartographic(0.0, 0.0, 0.0);
        Cesium.Rectangle.center(rectangle, center);
        var newPosition = {
          x: Cesium.Math.toDegrees(center.longitude),
          y: Cesium.Math.toDegrees(center.latitude),
          z: this.inner.position.z,
        };

        var inWest = rectangle.west;
        var inSouth = rectangle.south;
        var inWidth = Cesium.Rectangle.computeWidth(rectangle);
        var inHeight = Cesium.Rectangle.computeHeight(rectangle);
        var outWest = volumeRectangle.west;
        var outSouth = volumeRectangle.south;
        var outWidth = Cesium.Rectangle.computeWidth(volumeRectangle);
        var outHeight = Cesium.Rectangle.computeHeight(volumeRectangle);

        var leftRatio = (inWest - outWest) / outWidth;
        var bottomRatio = (inSouth - outSouth) / outHeight;

        var st_width = inWidth / outWidth;
        var st_height = inHeight / outHeight;

        var region = new Cesium.BoundingRectangle(
          leftRatio,
          bottomRatio,
          st_width,
          st_height
        );

        var chopSource = {
          position: {},
          meter: { width: 0, height: 0, depth: 0 },
          source: { width: 0, height: 0, depth: 0 },
          u_s_o: { scaler: 0, clampMin: 0, clampMax: 0 },
        };
        chopSource.position = newPosition;
        chopSource.meter.width = Math.floor(st_width * this.inner._meter.width);
        chopSource.meter.height = Math.floor(st_height * this.inner._meter.height);
        chopSource.meter.depth = this.inner._meter.depth;
        chopSource.u_s_o.scaler = this.inner._attributeMatrix[0];
        chopSource.u_s_o.clampMin = this.inner._attributeMatrix[1];
        chopSource.u_s_o.clampMax = this.inner._attributeMatrix[2];
        chopSource.region = region;
        (chopSource.texture = this.inner._texture),
          (chopSource.textureTF = this.inner._textureTF);
        return chopSource;
      }
    };

    WeatherVolume.prototype.chop = function (rectangle) {
      if (Cesium.defined(this.inner)) {
        var volumeRectangle = this.inner.rectangle;
        if (
          rectangle.west < volumeRectangle.west ||
          rectangle.east > volumeRectangle.east ||
          rectangle.south < volumeRectangle.south ||
          rectangle.north > volumeRectangle.north
        ) {
          return undefined;
        }

        var inWest = Cesium.Math.toDegrees(rectangle.west);
        var inEast = Cesium.Math.toDegrees(rectangle.east);
        var inSouth = Cesium.Math.toDegrees(rectangle.south);
        var inNorth = Cesium.Math.toDegrees(rectangle.north);

        var newPosition = {
          x: (inWest + inEast) * 0.5,
          y: (inSouth + inNorth) * 0.5,
          z: this.inner.position.z,
        };

        var degreeHeight = this.inner.degreeHeight;
        var degreeWidth = this.inner.degreeWidth;

        var width = this.inner._source.width;
        var height = this.inner._source.height;
        var depth = this.inner._source.depth;

        var rectangle = this.inner.rectangle;
        var w = Cesium.Math.toDegrees(rectangle.west);
        var e = Cesium.Math.toDegrees(rectangle.east);
        var n = Cesium.Math.toDegrees(rectangle.north);
        var s = Cesium.Math.toDegrees(rectangle.south);

        var leftRatio = (inWest - w) / degreeWidth;
        var rightRatio = 1.0 - (e - inEast) / degreeWidth;

        var topRatio = 1.0 - (n - inNorth) / degreeHeight;
        var bottomRatio = (inSouth - s) / degreeHeight;

        var left = Math.floor(leftRatio * width);
        var right = Math.floor(rightRatio * width);

        var top = Math.floor(topRatio * height);
        var bottom = Math.floor(bottomRatio * height);

        var pixel = [];
        var newWidth = right - left;
        var newHeight = top - bottom;
        var newSize = newWidth * newHeight * depth * 4;
        var newSourceArray = new Uint8Array(newSize);
        var offset0 = 0;
        var offset = 0;
        for (var d = 0; d < depth; d++) {
          offset0 += bottom * width * 4;
          for (var c = 0; c < newHeight; c++) {
            offset0 += left * 4;
            for (var r = 0; r < newWidth; r++) {
              newSourceArray[offset + 0] = pixel[0] =
                this.inner._source.arrayBufferView[offset0++];
              newSourceArray[offset + 1] = pixel[1] =
                this.inner._source.arrayBufferView[offset0++];
              newSourceArray[offset + 2] = pixel[2] =
                this.inner._source.arrayBufferView[offset0++];
              newSourceArray[offset + 3] = pixel[3] =
                this.inner._source.arrayBufferView[offset0++];
              offset += 4;
            }
            offset0 += (width - right) * 4;
          }
          offset0 += (height - top) * width * 4;
        }

        var chopSource = {
          position: {},
          meter: { width: 0, height: 0, depth: 0 },
          source: { width: 0, height: 0, depth: 0 },
          u_s_o: { scaler: 0, clampMin: 0, clampMax: 0 },
        };
        chopSource.position = newPosition;
        chopSource.meter.width = Math.floor(
          (rightRatio - leftRatio) * this.inner._meter.width
        );
        chopSource.meter.height = Math.floor(
          (topRatio - bottomRatio) * this.inner._meter.height
        );
        chopSource.meter.depth = this.inner._meter.depth;
        chopSource.source.width = newWidth;
        chopSource.source.height = newHeight;
        chopSource.source.depth = depth;
        chopSource.u_s_o.scaler = this.inner._attributeMatrix[0];
        chopSource.u_s_o.clampMin = this.inner._attributeMatrix[1];
        chopSource.u_s_o.clampMax = this.inner._attributeMatrix[2];
        chopSource.source.arrayBufferView = newSourceArray;
        return chopSource;
      }
    };

    WeatherVolume.prototype.addLengthWay = function (positions, extraOptions) {
      var lengthway = new WeatherLengthWay(this.inner, positions, extraOptions);
      lengthway.positions = positions;
      this._lengthWays.set(lengthway.id, lengthway);
      return lengthway;
    };

    WeatherVolume.prototype.removeLengthWay = function (lengthWay) {
      if (!Cesium.defined(lengthWay)) {
        return false;
      }
      var id = lengthWay instanceof WeatherLengthWay ? lengthWay.id : lengthWay;

      var obj = this._lengthWays.get(id);  if (!Cesium.defined(obj)) {
        return false;
      }

      if (!this._lengthWays.remove(id)) {
        return false;
      }

      obj.destroy();
      return true;
    };

    WeatherVolume.prototype.clearLengthWay = function () {
      this._lengthway = this._lengthway && this._lengthway.destroy();
      this._clearing = true;
      var i = 0;
      for (; i < this._lengthWays.length; i++) {
        this._lengthWays._array[i].destroy();
      }
      this._lengthWays.removeAll();
      this._clearing = false;
    };

    WeatherVolume.prototype.hierarchy = function (rectangle) {
      if (Cesium.defined(this._hierarchy)) {
        this._hierarchy.destroy();
        this._hierarchy = undefined;
      }
      if (Cesium.defined(rectangle)) {
        var volumeRectangle = this.inner.rectangle;
        if (
          rectangle.west < volumeRectangle.west ||
          rectangle.east > volumeRectangle.east ||
          rectangle.south < volumeRectangle.south ||
          rectangle.north > volumeRectangle.north
        ) {
          return;
        }
        this._hierarchy = new WeatherVolumeHierarchy(this.inner, rectangle);
        return this._hierarchy;
      }
    };

    WeatherVolume.prototype.updateStyle = function (valueAndColorRamp) {
      if (Cesium.defined(this.inner)) {
        var size = this.inner.transferRange;
        var min = this.inner._attributeMatrix[1];
        var tfSource = new Uint8Array(size * 2 * 4);
        for (var i = 0; i < size; i++) {
          var rampSt = 0;
          var rampEd = 0;
          var idx = valueAndColorRamp.ValueRamp.length - 1;
          for (var j = 0; j < valueAndColorRamp.ValueRamp.length; j++) {
            if (i < valueAndColorRamp.ValueRamp[j] - min) {
              idx = j;
              rampEd = valueAndColorRamp.ValueRamp[j] - min;
              if (j > 0) {
                rampSt = valueAndColorRamp.ValueRamp[j - 1] - min;
              }
              break;
            }
          }
          var pixels = valueAndColorRamp.ColorRamp[idx];
          idx = i * 4;
          tfSource[idx] = rampSt;
          tfSource[idx + 1] = rampEd;
          tfSource[idx + 2] = 0;
          tfSource[idx + 3] = 0;

          idx += size * 4;
          tfSource[idx] = pixels[0];
          tfSource[idx + 1] = pixels[1];
          tfSource[idx + 2] = pixels[2];
          tfSource[idx + 3] = pixels[3];
        }
        this.inner._textureTF.copyFrom({
          width: size,
          height: 2,
          arrayBufferView: tfSource,
        });
        //this.inner.createTFTexture(valueAndColorRamp);
      }
    };

    WeatherVolume.prototype.update = function (frameState) {
      if (Cesium.defined(this.inner) && !this.isDestroyed()) {
        //slice
        if (this.inner.displayMode === WeatherVolumeInner.Mode.Slice) {
          if (!Cesium.defined(this._lengthwayXYZ)) {
            this._lengthwayXYZ = new WeatherLengthWayXYZ(this.inner);
          }
          if (this.dirty || this.inner._dirty) {
            this._lengthwayXYZ.updateOptions(this.inner);
          }
          this._lengthwayXYZ.update(frameState);
        } else {
          this._lengthwayXYZ = this._lengthwayXYZ && this._lengthwayXYZ.destroy();
        }

        //cone
        if (this.inner.displayMode === WeatherVolumeInner.Mode.Cone) {
          if (!Cesium.defined(this._cone)) {
            this._cone = new WeatherVolumeCone(this.inner);
            this._cone.onDirty(this.inner);
          }
          this._cone.scanMode = this.inner.coneScaning;
          if (this.dirty) {
            this._cone.onDirty(this.inner);
          }
          this._cone.update(frameState);
        } else {
          this._cone = this._cone && this._cone.destroy();
        }

        //cube
        var showInner = Cesium.defaultValue(frameState.showInner, this._showInner);
        if (showInner) {
          this.inner.update(frameState);
          if (this.inner.displayMode === WeatherVolumeInner.Mode.Cube) {
            //体
            if (!Cesium.defined(this._box)) {
              this._box = new WeatherVolumeBox(this.inner);
            }
            if (this.dirty) {
              this._box.updateMatrix(this.inner._modelmatrix);
            }

            if (Cesium.defined(this._volumeHandler)) {
              this._volumeHandler.update(frameState);
            }

            this._box.update(frameState);

            if (this.inner.showGrid && frameState.passes.render) {
              if (!Cesium.defined(this._volumeGrid)) {
                this._volumeGrid = new WeatherVolumeGrid(
                  this.inner,
                  frameState.context
                );
              }
              if (this.dirty) {
                this._volumeGrid.updateMatrix(this.inner._modelmatrix);
              }
              this._volumeGrid.update(frameState);
            }
          }
        }

        this.dirty = false;

        if (Cesium.defined(this._hierarchy)) {
          this._hierarchy.update(frameState);
        }
        if (!this._clearing) {
          var i = 0;
          for (; i < this._lengthWays.length; i++) {
            this._lengthWays._array[i].update(frameState);
          }
        }
        if (Cesium.defined(this._volumePickHandler)) {
          this._volumePickHandler.update(frameState);
        }

        this.inner._dirty = false;
      }
    };

    WeatherVolume.prototype.isDestroyed = function () {
      return false;
    };

    WeatherVolume.prototype.destroy = function () {
      this._volumeHandler = this._volumeHandler && this._volumeHandler.destroy();
      this._box = this._box && this._box.destroy();
      this._cone = this._cone && this._cone.destroy();
      this._lengthway = this._lengthway && this._lengthway.destroy();
      this._hierarchy = this._hierarchy && this._hierarchy.destroy();
      this._lengthwayXYZ = this._lengthwayXYZ && this._lengthwayXYZ.destroy();
      this._volumeGrid = this._volumeGrid && this._volumeGrid.destroy();
      if (Cesium.defined(this.inner)) {
        this._removeEntitySubscription();
        this.inner.destroy();
      }
      return Cesium.destroyObject(this);
    };

    function WeatherVolumeSchedule(we, options) {
        this._we = we;
        this._scene = we.viewer.scene;
        this._volumeUrls = options.urls;
        this._ext = Cesium.defaultValue(options.ext,'nc');
        this._varname = options.varname;
        this._Transfunction = options.Transfunction;
        this._ValueAndColorRamp = options.ValueAndColorRamp;
        this._childValueAndColorRamp = Cesium.defaultValue(options.childValueAndColorRamp,options.ValueAndColorRamp);
        this._showGrid = Cesium.defaultValue(options.showGrid,true);
        this._queue = new Cesium.Queue();
        this._interval = Cesium.defaultValue(options.interval,'500');    this._currentVolume = undefined;
        this._currentChildVolume = undefined;
        this._currentIndex = -1;
        this._getNext = true;
        this._lastUpdateTime = 0;
        this._remoteUrl = options.remoteUrl;
        this._loading = false;
        this._dirty = false;
        this.prepare();
        this._contentChangedEvent = new Cesium.Event();
        this._removeEventSubscription = this._contentChangedEvent.addEventListener(
            WeatherVolumeSchedule.prototype._onContentChanged,
            this
        );
        this._gridAxis = undefined;
        this._blackNameList = new Cesium.AssociativeArray();
    }
    WeatherVolumeSchedule.prototype._onContentChanged = function (
        entity,
        propertyName,
        newValue,
        oldValue
    ) {
        if (propertyName == 'onLoadNew') {
            this._onLoadNew(newValue,oldValue);
        }
    };

    WeatherVolumeSchedule.prototype._onLoadNew = function (newValue,oldValue) {
        //console.log(name + '\n');
    };

    Object.defineProperties(WeatherVolumeSchedule.prototype, {
        contentChangedEvent: {
            get: function () {
                return this._contentChangedEvent;
            },
        },
        dirty: {
            get: function () {
                return this._dirty;
            },
            set: function (value) {
                this._dirty = value;
            }
        },
        showGrid: {
            get: function () {
                return this._showGrid;
            },
            set: function (value) {
                this._showGrid = value;
            }
        },
    });

    WeatherVolumeSchedule.prototype.isDestroyed = function () {
        return false;
    };

    WeatherVolumeSchedule.prototype.destroy = function () {
        this._gridAxis = this._gridAxis && this._gridAxis.destroy();
        this._removeEventSubscription();
        // if (Cesium.defined(this._currentVolume)) {
        //     this._scene.primitives.removeAndDestroy(this._currentVolume);
        // }
        // if (Cesium.defined(this._currentChildVolume)) {
        //     this._scene.primitives.removeAndDestroy(this._currentChildVolume);
        // }

        this._currentVolume = this._currentVolume && this._currentVolume.destroy();
        this._currentChildVolume = this._currentChildVolume && this._currentChildVolume.destroy();
    };

    WeatherVolumeSchedule.prototype.play = function () {

    };

    WeatherVolumeSchedule.prototype.createGrid = function (childRectangle,depth) {
        if(Cesium.defined(this._gridAxis)){
            return;
        }
        var rect = childRectangle.clone();
        rect.west -= 0.002;
        rect.east += 0.002;
        var floors = [0.0
            , Math.ceil((0.1 * depth) * 0.001) * 1000.0
            , Math.ceil((0.3 * depth) * 0.001) * 1000.0
            , Math.ceil((0.7 * depth) * 0.001) * 1000.0
            , depth];

        this._gridAxis = new WeatherVolumeAxes({
            rectangle:rect,
            floors: floors,
            offsetZ:this._we.globalVolumeState.childState.offsetZ
        });

        this._gridAxis.scaleZ = this._we.globalVolumeState.childState.scaleZ;
    };

    WeatherVolumeSchedule.prototype.requestNext = function () {
        if (this._loading) {
            return;
        }

        if (this._currentIndex >= this._queue.length - 1) {
            this._currentIndex = -1;
        }

        var i = ++this._currentIndex;
        var obj = this._queue._array[i];

        if(this._blackNameList.contains(obj.url)){
            return;
        }

        var weatherVolume = WeatherVolume.fromRemoteUrl(this._scene, this._remoteUrl, {
            name: obj.url,
            varname: this._varname,
            ext: this._ext,
            TransFunction: this._Transfunction,
            ValueAndColorRamp: this._ValueAndColorRamp,
        });
        var that = this;
        this._loading = true;
        weatherVolume.readyPromise.then(function (weatherVolume) {
            that._we.globalVolumeState.setVolume(weatherVolume);
            
            that._currentVolume = that._currentVolume && that._currentVolume.destroy();
            that._currentChildVolume = that._currentChildVolume && that._currentChildVolume.destroy();
            
            var childRectangle = that._we.weatherVolumeManager.childRectangle;
            var childLengthWayPositions = that._we.weatherVolumeManager.childLengthWayPositions;
            if(Cesium.defined(childRectangle)){
                var childState = that._we.globalVolumeState.childState;
                if(childState.mode === WeatherVolumeInner.Mode.Cube){
                    var chopSource = weatherVolume.chop(childRectangle);
                    if (Cesium.defined(chopSource)) {
                        var newVolume = new WeatherVolume(that._scene, {
                            name: obj.url + '_child',
                            source: chopSource,
                            varname: that._varname,
                            TransFunction: that._Transfunction,
                            ValueAndColorRamp: that._childValueAndColorRamp,
                        });
                        newVolume.setState(childState);
                        that._currentChildVolume = newVolume;
                    }
                }else {
                    weatherVolume.setState(childState);
                    weatherVolume.hierarchy(childRectangle);
                }

                if(that._showGrid){
                    that.createGrid(childRectangle,weatherVolume.inner.meter.depth);
                }
            }
            else if(Cesium.defined(childLengthWayPositions)){
                weatherVolume.addLengthWay(childLengthWayPositions);
            }

            that._contentChangedEvent.raiseEvent(this, "onLoadNew",weatherVolume.name,Cesium.defined(that._currentVolume)?
                that._currentVolume.name:'');
            that._currentVolume = weatherVolume;
            that._lastUpdateTime = (new Date()).getTime();
            that._loading = false;
        }).otherwise(function (error) {
            that._blackNameList.set(obj.url,error);
            that._loading = false;
        });
    };

    WeatherVolumeSchedule.prototype.prepare = function () {
        for (var i = 0; i < this._volumeUrls.length; i++) {
            this._queue.enqueue({
                url: this._volumeUrls[i],
                source: undefined,
            });
        }
    };

    WeatherVolumeSchedule.prototype.update = function (frameState) {
        if(this.showGrid && Cesium.defined(this._gridAxis)){
            this._gridAxis.update(frameState);
        }

        if (Cesium.defined(this._currentVolume)) {
            this._currentVolume.update(frameState);
        }
        if (Cesium.defined(this._currentChildVolume)) {
            this._currentChildVolume.update(frameState);
        }

        if (this._loading || !frameState.passes.render) {
            return;
        }

        var elapseTime = (new Date()).getTime() - this._lastUpdateTime;
        if (elapseTime > this._interval) {
            this.requestNext();
        }
    };

    function WeatherVolumeManager(we) {
        this._we = we;
        this._scene = this._we.viewer.scene;
        this._activeVolume = undefined;
        this._childVolume = undefined;
        this._vols = new Cesium.AssociativeArray();
        this._clearing = false;
        this._schedule = undefined;
        this._childRectangle = undefined;
        this._childLengthWayPositions = undefined;
    }
    WeatherVolumeManager.prototype.createSchedule = function (options) {
        this.removeSchedule();
        this._schedule = new WeatherVolumeSchedule(this._we,options);
        return this._schedule;
    };

    WeatherVolumeManager.prototype.removeSchedule = function () {
        this._schedule = this._schedule && this._schedule.destroy();
    };

    WeatherVolumeManager.prototype.add = function (options,func,notActive) {
        var id = Cesium.defined(options.id) ? options.id : options.name;
        if (!Cesium.defined(id)) {
          id = Cesium.createGuid();
        }  

        var weatherVolume = undefined;

        if(Cesium.defined(options.url)){
            weatherVolume = WeatherVolume.fromRemoteUrl(this._scene,options.url,options);
        }
        else if(Cesium.defined(options.source)){
            weatherVolume = new WeatherVolume(this._scene, options);
        }

        var that = this;
        if(Cesium.defined(weatherVolume)){
            weatherVolume.readyPromise.then(function (weatherVolume) {
                if(Cesium.defaultValue(notActive,true)){
                    if(Cesium.defined(that._activeVolume) && weatherVolume.timestamp < that._activeVolume.timestamp){
                        weatherVolume.destroy();
                        return;
                    }
                    that._activeVolume = weatherVolume;
                    that._we.globalVolumeState.setVolume(weatherVolume);
                }else {
                    weatherVolume.setState(that._we.globalVolumeState.childState);
                    that._childVolume = weatherVolume;
                }
                var v = that._vols.get(id);
                if(Cesium.defined(v)){
                    v.destroy();
                }
                that._vols.set(id,weatherVolume);
                if(Cesium.defined(func)){
                    func(weatherVolume);
                }
            });
        }

        return weatherVolume;
    };

    WeatherVolumeManager.prototype.addChild = function (options,func) {
        return this.add(options,func,false);
    };

    WeatherVolumeManager.prototype.removeById = function (id) {
        if (!Cesium.defined(id)) {
          return false;
        }
      
        var vol = this.getById(id);
        if (!Cesium.defined(vol)) {
          return false;
        }

        if (!this._vols.remove(id)) {
          return false;
        }
      
        vol.destroy();
        return true;
     };

    WeatherVolumeManager.prototype.getById = function (id) {
        if (!Cesium.defined(id)) {
            throw new Cesium.DeveloperError("id is required.");
        }

        return this._vols.get(id);
    };

    WeatherVolumeManager.prototype.clear = function () {
        this._clearing =  true;
        var i = 0;
        for(;i<this._vols.length;i++){
            this._vols._array[i].destroy();
        }
        this._vols.removeAll();
        this._clearing = false;
        this._activeVolume = undefined;
        this._childVolume = undefined;
    };

    WeatherVolumeManager.prototype.clearAll = function () {
        this.removeSchedule();
        this.clear();
    };


    WeatherVolumeManager.prototype.clearState = function () {
        this._childRectangle = undefined;
        this._childLengthWayPositions = undefined;
    };

    WeatherVolumeManager.prototype.update = function (frameState) {
        if(this._clearing){
            return;
        }

        //weather volume
        var i = 0;
        for(;i<this._vols.length;i++){
            var volume = this._vols._array[i];
            volume.update(frameState);
        }

        //schedule
        if(Cesium.defined(this._schedule)){
            this._schedule.update(frameState);
        }
    };

    WeatherVolumeManager.prototype.isDestroyed = function () {
        return false;
    };

    WeatherVolumeManager.prototype.destroy = function () {
        this.removeSchedule();
        this.clear();
        this._activeVolume = undefined;
        this._childVolume = undefined;
        return Cesium.destroyObject(this);
    };


    Object.defineProperties(WeatherVolumeManager.prototype, {
        activeVolume: {
            get: function () {
                return this._activeVolume;
            },
            set: function (value) {
                this._activeVolume = value;
            }
        },
        schedule: {
            get: function () {
                return this._schedule;
            }
        },
        childRectangle: {
            get: function () {
                return this._childRectangle;
            },
            set: function (value) {
                this._childRectangle = value;
            }
        },
        childLengthWayPositions: {
            get: function () {
                return this._childLengthWayPositions;
            },
            set: function (value) {
                this._childLengthWayPositions = value;
            }
        },
    });

    function WeatherVolumeState() {
        this.mode = 0;
        this.filtrationMin = -10000.0;
        this.filtrationMax = 10000.0;
        this.SlicePlaneX = 0.5;
        this.SlicePlaneY = 0.5;
        this.SlicePlaneZ = 0.5;
        this.SlicePlaneX_Visible = false;
        this.SlicePlaneY_Visible = false;
        this.SlicePlaneZ_Visible = true;
        this.offsetZ = 0.0;
        this.scaleZ = 1.0;
        this.showGrid = false;
        this.summationInEdge = true;
        this.transparencyValue = 1.0;
        this.lighting = true;
        this.onDemWhenHeightZero = false;
        
        //
        this.hierarchyScaleZ = 10.0;
    }

    function WeatherVolumeStateMVVM(we) {
        this._we = we;

        this.filtrationMin = -100000.0;
        this.filtrationMax = 100000.0;
        this.transparencyValue = 100.0;
        this.scaleZ = 1.0;
        this.onPick = false;
        this.showMovable = false;
        this.showGrid = false;
        this.SlicePlaneX = 0.0;
        this.SlicePlaneY = 0.0;
        this.SlicePlaneZ = 0.0;
        this.SlicePlaneX_Visible = true;
        this.SlicePlaneY_Visible = true;
        this.SlicePlaneZ_Visible = true;
        this.displayMode = 'Cube';
        this.quality = '中';
        this.Sample = '线性';
        this.lighting = true;

        this.SlicePlaneX_Min = 0.0;
        this.SlicePlaneY_Min = 0.0;
        this.SlicePlaneZ_Min = 0.0;
        this.SlicePlaneX_Max = 10000.0;
        this.SlicePlaneY_Max = 10000.0;
        this.SlicePlaneZ_Max = 10000.0;

        //
        this.summationInEdge = false;
        this.offsetZ = 0.0;
        this.onDemWhenHeightZero = false;

        //
        this._childState = new WeatherVolumeState;

        Cesium.knockout.track(this, [
            "filtrationMin",
            "filtrationMax",
            "transparencyValue",
            "scaleZ",
            "onPick",
            "showMovable",
            "showGrid",
            "transparencyValue",
            "SlicePlaneX",
            "SlicePlaneY",
            "SlicePlaneZ",
            "SlicePlaneX_Visible",
            "SlicePlaneY_Visible",
            "SlicePlaneZ_Visible",
            "displayMode",
            "quality",
            "lighting",
            "Sample",
            "summationInEdge",
            "offsetZ",
            "onDemWhenHeightZero",
        ]);

        Cesium.knockout.track(this._childState, [
            "filtrationMin",
            "filtrationMax",
            "scaleZ",
            "hierarchyScaleZ",
        ]);

        this._ko = [];


        this.bind(undefined,this,'onDemWhenHeightZero');

        this._contentChangedEvent = new Cesium.Event();
        this._removeEventSubscription = this._contentChangedEvent.addEventListener(
            WeatherVolumeStateMVVM.prototype._onContentChanged,
            this
        );
    }
    Object.defineProperties(WeatherVolumeStateMVVM.prototype, {
        contentChangedEvent: {
            get: function () {
                return this._contentChangedEvent;
            },
        },
        SlicePlaneX_InUnit: {
            set: function (value) {
                return this.SlicePlaneX = value / (this.SlicePlaneX_Max - this.SlicePlaneX_Min);
            },
        },
        SlicePlaneY_InUnit: {
            get: function () {
                return this.SlicePlaneY = value / (this.SlicePlaneY_Max - this.SlicePlaneY_Min);
            },
        },
        SlicePlaneZ_InUnit: {
            get: function () {
                return this.SlicePlaneZ = value / (this.SlicePlaneZ_Max - this.SlicePlaneZ_Min);
            },
        },
        childState: {
            get: function () {
                return this._childState;
            },
        }
    });

    WeatherVolumeStateMVVM.prototype.getDisplayMode = function () {
        var dict2 = ['Slice','切片','1',WeatherVolumeInner.Mode.Slice];
        var dict3 = ['Cone','体扫','3',WeatherVolumeInner.Mode.Cone];
        var mode = this.displayMode;
        var displayMode = WeatherVolumeInner.Mode.Cube;//default mode
        dict2.forEach(function(element) {
            if(element === mode){
                displayMode = WeatherVolumeInner.Mode.Slice;
            }
        });
        dict3.forEach(function(element) {
            if(element === mode){
                displayMode = WeatherVolumeInner.Mode.Cone;
            }
        });
        return displayMode;
    };

    WeatherVolumeStateMVVM.prototype.getQuatity = function () {
        var dict1 = ['低','极速','0','Low',WeatherVolumeInner.Quality.Low];
        var dict3 = ['高','高清','2','High',WeatherVolumeInner.Quality.High];
        var quality = this.quality;
        var qualityMode = WeatherVolumeInner.Quality.Medium;//default quality
        dict1.forEach(function(element) {
            if(element === quality){
                qualityMode = WeatherVolumeInner.Quality.Low;
            }
        });
        dict3.forEach(function(element) {
            if(element === quality){
                qualityMode = WeatherVolumeInner.Quality.High;
            }
        });
        return qualityMode;
    };

    WeatherVolumeStateMVVM.prototype.isNearestSample = function () {
        var isNearestSample = false;
        var dict1 = ['邻近','NEAREST'];
        var sample = this.Sample;
        dict1.forEach(function(element) {
            if(sample === element){
                isNearestSample = true;
            }
        });
        return isNearestSample;
    };

    WeatherVolumeStateMVVM.prototype.setVolume = function (volume) {
        volume.inner.scaleZ = this.scaleZ;
        volume.inner.filtrationMin = this.filtrationMin;
        volume.inner.filtrationMax = this.filtrationMax;
        volume.inner.transparencyValue = this.transparencyValue * 0.01;
        volume.inner.SlicePlaneX = this.SlicePlaneX / (this.SlicePlaneX_Max- this.SlicePlaneX_Min);
        volume.inner.SlicePlaneY = this.SlicePlaneY / (this.SlicePlaneY_Max- this.SlicePlaneY_Min);
        volume.inner.SlicePlaneZ = this.SlicePlaneZ / (this.SlicePlaneZ_Max- this.SlicePlaneZ_Min);
        volume.inner.SlicePlaneX_Visible = this.SlicePlaneX_Visible;
        volume.inner.SlicePlaneY_Visible = this.SlicePlaneY_Visible;
        volume.inner.SlicePlaneZ_Visible = this.SlicePlaneZ_Visible;
        volume.inner.onDemWhenHeightZero = this.onDemWhenHeightZero;
        volume.inner.showGrid = this.showGrid;
        volume.inner.lighting = this.lighting;
        volume.onPick = this.onPick;
        volume.showMovable = this.showMovable;
        volume.inner.quality = this.getQuatity();
        volume.inner.displayMode = this.getDisplayMode();

        volume.inner.nearestSample = this.Sample !== '线性';
        volume.inner.summationInEdge = this.summationInEdge;
        volume.inner.offsetZ = this.offsetZ;
    };

    WeatherVolumeStateMVVM.prototype.setState = function (modelView,value,property) {
        var that = this;

        var layers = this._we.layerManager.getVolumeLayerCollection();
        layers.forEach(function(element){
            if(modelView === that){
                var weatherVolume = element._weatherVolume;
                if(Cesium.defined(weatherVolume)){
                    if(property === 'onPick' || property === 'showMovable'){
                        weatherVolume[property] = value;
                    }else {
                        if(property === 'Sample') {
                            property = 'nearestSample';
                            value = that.isNearestSample();
                        }else if(property === 'quality'){
                            value = that.getQuatity();
                        }else if(property === 'displayMode'){
                            value = that.getDisplayMode();
                        }
                        // if(Cesium.defined(element[property])){
                        //     element[property] = value;
                        // } else
                        {
                            weatherVolume.inner[property] = value;
                            element._reCompute = true;
                        }
                    }
                }
            }
            else if(modelView === that._childState){
                if(Cesium.defined(element._childWeatherVolume)){
                    element._childWeatherVolume.inner.filtrationMin = modelView.filtrationMin;
                    element._childWeatherVolume.inner.filtrationMax = modelView.filtrationMax;
                }
            }
        });



        if(modelView === this && Cesium.defined(that._we.weatherVolumeManager.activeVolume)){
            if(property === 'onPick' || property === 'showMovable'){
                that._we.weatherVolumeManager.activeVolume[property] = value;
            }else {
                if(property === 'Sample') {
                    property = 'nearestSample';
                    value = this.isNearestSample();
                }else if(property === 'quality'){
                    value = this.getQuatity();
                }else if(property === 'displayMode'){
                    value = this.getDisplayMode();
                }
                
                that._we.weatherVolumeManager.activeVolume.inner[property] = value;
            }
        }
        else if(modelView === this._childState){
            if(property === 'hierarchyScaleZ' && Cesium.defined(that._we.weatherVolumeManager.activeVolume)){
                var hierarchyObj = that._we.weatherVolumeManager.activeVolume.hierarchyObj;
                if(Cesium.defined(hierarchyObj)){
                    hierarchyObj.scaleZ = value;
                }
            }
            else if(Cesium.defined(that._we.weatherVolumeManager._childVolume)){
                that._we.weatherVolumeManager._childVolume.inner.filtrationMin = modelView.filtrationMin;
                that._we.weatherVolumeManager._childVolume.inner.filtrationMax = modelView.filtrationMax;
            }
        }
    };

    WeatherVolumeStateMVVM.prototype.bind = function (viewModel,modelView,property,revFunc) {
        var that = this;
        var ko = Cesium.knockout
        .getObservable(modelView, property)
        .subscribe(function () {
            var value = modelView[property];
            if(Cesium.defined(viewModel)){
                viewModel.setValue(value);
            }
            if(Cesium.defined(revFunc)){
                value = revFunc(value);
            }
            that.setState(modelView,value,property);
            that._contentChangedEvent.raiseEvent(that, property, value,'');
        });

        this._ko.push(ko);
    };

    WeatherVolumeStateMVVM.prototype._onContentChanged = function (
        entity,
        propertyName,
        newValue,
        oldValue
    ) {
        if(Cesium.defined(this.onContentChanged)){
            this.onContentChanged(
                entity,
                propertyName,
                newValue,
                oldValue);
        }
    };

    WeatherVolumeStateMVVM.prototype.isDestroyed = function () {
        return false;
    };

    WeatherVolumeStateMVVM.prototype.destroy = function () {
        this._removeEventSubscription();
        var i=0;
        for(;i<this._ko.length;i++){
            this._ko[i].dispose();
        }
        this._ko = [];
        return Cesium.destroyObject(this);
    };

    // Sanitizer

    var markdownItSanitizer = function sanitizer_plugin(md, options) {

      var linkify = md.linkify,
          escapeHtml = md.utils.escapeHtml,
          // <a href="url" title="(optional)"></a>
          patternLinkOpen = '<a\\s([^<>]*href="[^"<>]*"[^<>]*)\\s?>',
          regexpLinkOpen = RegExp(patternLinkOpen, 'i'),
          // <img src="url" alt=""(optional) title=""(optional)>
          patternImage = '<img\\s([^<>]*src="[^"<>]*"[^<>]*)\\s?\\/?>',
          regexpImage = RegExp(patternImage, 'i'),
          regexpImageProtocols = /^(?:https?:)?\/\//i,
          regexpLinkProtocols = /^(?:https?:\/\/|ftp:\/\/|\/\/|mailto:|xmpp:)/i;

      options = options ? options : {};
      var removeUnknown = (typeof options.removeUnknown !== 'undefined') ? options.removeUnknown : false;
      var removeUnbalanced = (typeof options.removeUnbalanced !== 'undefined') ? options.removeUnbalanced : false;
      var imageClass = (typeof options.imageClass !== 'undefined') ? options.imageClass : '';
      var runBalancer = false;
      var j;


      var allowedTags = [ 'a', 'b', 'blockquote', 'code', 'em', 'h1', 'h2', 'h3', 'h4', 'h5',
                         'h6', 'li', 'ol', 'p', 'pre', 's', 'sub', 'sup', 'strong', 'ul' ];
      var openTagCount = new Array(allowedTags.length);
      var removeTag = new Array(allowedTags.length);
      for (j = 0; j < allowedTags.length; j++) { openTagCount[j] = 0; }
      for (j = 0; j < allowedTags.length; j++) { removeTag[j] = false; }

      function getUrl(link) {
        var match = linkify.match(link);
        if (match && match.length === 1 && match[0].index === 0 && match[0].lastIndex === link.length) {
          return match[0].url;
        }
        return null;
      }

      /////////////////////////////////////////////////////////////////////////////////////////////////
      //          REPLACE UNKNOWN TAGS
      /////////////////////////////////////////////////////////////////////////////////////////////////

      function replaceUnknownTags(str) {
        /*
         * it starts with '<' and maybe ends with '>',
         * maybe has a '<' on the right
         * it doesnt have '<' or '>' in between
         * -> it's a tag!
         */
        str = str.replace(/<[^<>]*>?/gi, function (tag) {
          var match, attrs, url, alt, title, tagnameIndex;

          // '<->', '<- ' and '<3 ' look nice, they are harmless
          if (/(^<->|^<-\s|^<3\s)/.test(tag)) { return tag; }

          // images
          match = tag.match(regexpImage);
          if (match) {
            attrs = match[1];
            url   = getUrl(attrs.match(/src="([^"<>]*)"/i)[1]);
            alt   = attrs.match(/alt="([^"<>]*)"/i);
            alt   = (alt && typeof alt[1] !== 'undefined') ? alt[1] : '';
            title = attrs.match(/title="([^"<>]*)"/i);
            title = (title && typeof title[1] !== 'undefined') ? title[1] : '';

            // only http and https are allowed for images
            if (url && regexpImageProtocols.test(url)) {
              if (imageClass !== '') {
                return '<img src="' + url + '" alt="' + alt + '" title="' + title + '" class="' + imageClass + '">';
              }
              return '<img src="' + url + '" alt="' + alt + '" title="' + title + '">';
            }
          }

          // links
          tagnameIndex = allowedTags.indexOf('a');
          match = tag.match(regexpLinkOpen);
          if (match) {
            attrs = match[1];
            url   = getUrl(attrs.match(/href="([^"<>]*)"/i)[1]);
            title = attrs.match(/title="([^"<>]*)"/i);
            title = (title && typeof title[1] !== 'undefined') ? title[1] : '';
            // only http, https, ftp, mailto and xmpp are allowed for links
            if (url && regexpLinkProtocols.test(url)) {
              runBalancer = true;
              openTagCount[tagnameIndex] += 1;
              return '<a href="' + url + '" title="' + title + '" target="_blank">';
            }
          }
          match = /<\/a>/i.test(tag);
          if (match) {
            runBalancer = true;
            openTagCount[tagnameIndex] -= 1;
            if (openTagCount[tagnameIndex] < 0) {
              removeTag[tagnameIndex] = true;
            }
            return '</a>';
          }

          // standalone tags
          match = tag.match(/<(br|hr)\s?\/?>/i);
          if (match) {
            return '<' + match[1].toLowerCase() + '>';
          }

          // whitelisted tags
          match = tag.match(/<(\/?)(b|blockquote|code|em|h[1-6]|li|ol(?: start="\d+")?|p|pre|s|sub|sup|strong|ul)>/i);
          if (match && !/<\/ol start="\d+"/i.test(tag)) {
            runBalancer = true;
            tagnameIndex = allowedTags.indexOf(match[2].toLowerCase().split(' ')[0]);
            if (match[1] === '/') {
              openTagCount[tagnameIndex] -= 1;
            } else {
              openTagCount[tagnameIndex] += 1;
            }
            if (openTagCount[tagnameIndex] < 0) {
              removeTag[tagnameIndex] = true;
            }
            return '<' + match[1] + match[2].toLowerCase() + '>';
          }

          // other tags we don't recognize
          if (removeUnknown === true) {
            return '';
          }
          return escapeHtml(tag);
        });

        return str;
      }


      function sanitizeInlineAndBlock(state) {
        var i, blkIdx, inlineTokens;
        // reset counts
        for (j = 0; j < allowedTags.length; j++) { openTagCount[j] = 0; }
        for (j = 0; j < allowedTags.length; j++) { removeTag[j] = false; }
        runBalancer = false;


        for (blkIdx = 0; blkIdx < state.tokens.length; blkIdx++) {
          if (state.tokens[blkIdx].type === 'html_block') {
            state.tokens[blkIdx].content = replaceUnknownTags(state.tokens[blkIdx].content);
          }
          if (state.tokens[blkIdx].type !== 'inline') {
            continue;
          }

          inlineTokens = state.tokens[blkIdx].children;
          for (i = 0; i < inlineTokens.length; i++) {
            if (inlineTokens[i].type === 'html_inline') {
              inlineTokens[i].content = replaceUnknownTags(inlineTokens[i].content);
            }
          }
        }
      }

      /////////////////////////////////////////////////////////////////////////////////////////////////
      //          REPLACE UNBALANCED TAGS
      /////////////////////////////////////////////////////////////////////////////////////////////////

      function balance(state) {
        if (runBalancer === false) { return; }
        var blkIdx, inlineTokens;

        function replaceUnbalancedTag(str, tagname) {
          var openingRegexp, closingRegexp;
          if (tagname === 'a') {
            openingRegexp = RegExp('<a href="[^"<>]*" title="[^"<>]*" target="_blank">', 'g');
          } else if (tagname === 'ol') {
            openingRegexp = /<ol(?: start="\d+")?>/g;
          } else {
            openingRegexp = RegExp('<' + tagname + '>', 'g');
          }
          closingRegexp = RegExp('</' + tagname + '>', 'g');
          if (removeUnbalanced === true) {
            str = str.replace(openingRegexp, '');
            str = str.replace(closingRegexp, '');
          } else {
            str = str.replace(openingRegexp, function (m) { return escapeHtml(m); });
            str = str.replace(closingRegexp, function (m) { return escapeHtml(m); });
          }
          return str;
        }

        function replaceAllUnbalancedTags(str) {
          var i;
          for (i = 0; i < allowedTags.length; i++) {
            if (removeTag[i] === true) {
              str = replaceUnbalancedTag(str, allowedTags[i]);
            }
          }
          return str;
        }

        for (j = 0; j < allowedTags.length; j++) {
          if (openTagCount[j] !== 0) {
            removeTag[j] = true;
          }
        }

        // replace unbalanced tags
        for (blkIdx = 0; blkIdx < state.tokens.length; blkIdx++) {
          if (state.tokens[blkIdx].type === 'html_block') {
            state.tokens[blkIdx].content = replaceAllUnbalancedTags(state.tokens[blkIdx].content);
            continue;
          }
          if (state.tokens[blkIdx].type !== 'inline') {
            continue;
          }
          inlineTokens = state.tokens[blkIdx].children;
          for (j = 0; j < inlineTokens.length; j++) {
            if (inlineTokens[j].type === 'html_inline') {
              inlineTokens[j].content = replaceAllUnbalancedTags(inlineTokens[j].content);
            }
          }
        }
      }

      md.core.ruler.after('linkify', 'sanitize_inline', sanitizeInlineAndBlock);
      md.core.ruler.after('sanitize_inline', 'sanitize_balance', balance);
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    function getCjsExportFromNamespace (n) {
    	return n && n['default'] || n;
    }

    var Aacute = "Á";
    var aacute = "á";
    var Abreve = "Ă";
    var abreve = "ă";
    var ac = "∾";
    var acd = "∿";
    var acE = "∾̳";
    var Acirc = "Â";
    var acirc = "â";
    var acute = "´";
    var Acy = "А";
    var acy = "а";
    var AElig = "Æ";
    var aelig = "æ";
    var af = "⁡";
    var Afr = "𝔄";
    var afr = "𝔞";
    var Agrave = "À";
    var agrave = "à";
    var alefsym = "ℵ";
    var aleph = "ℵ";
    var Alpha = "Α";
    var alpha = "α";
    var Amacr = "Ā";
    var amacr = "ā";
    var amalg = "⨿";
    var amp = "&";
    var AMP = "&";
    var andand = "⩕";
    var And = "⩓";
    var and = "∧";
    var andd = "⩜";
    var andslope = "⩘";
    var andv = "⩚";
    var ang = "∠";
    var ange = "⦤";
    var angle = "∠";
    var angmsdaa = "⦨";
    var angmsdab = "⦩";
    var angmsdac = "⦪";
    var angmsdad = "⦫";
    var angmsdae = "⦬";
    var angmsdaf = "⦭";
    var angmsdag = "⦮";
    var angmsdah = "⦯";
    var angmsd = "∡";
    var angrt = "∟";
    var angrtvb = "⊾";
    var angrtvbd = "⦝";
    var angsph = "∢";
    var angst = "Å";
    var angzarr = "⍼";
    var Aogon = "Ą";
    var aogon = "ą";
    var Aopf = "𝔸";
    var aopf = "𝕒";
    var apacir = "⩯";
    var ap = "≈";
    var apE = "⩰";
    var ape = "≊";
    var apid = "≋";
    var apos = "'";
    var ApplyFunction = "⁡";
    var approx = "≈";
    var approxeq = "≊";
    var Aring = "Å";
    var aring = "å";
    var Ascr = "𝒜";
    var ascr = "𝒶";
    var Assign = "≔";
    var ast = "*";
    var asymp = "≈";
    var asympeq = "≍";
    var Atilde = "Ã";
    var atilde = "ã";
    var Auml = "Ä";
    var auml = "ä";
    var awconint = "∳";
    var awint = "⨑";
    var backcong = "≌";
    var backepsilon = "϶";
    var backprime = "‵";
    var backsim = "∽";
    var backsimeq = "⋍";
    var Backslash = "∖";
    var Barv = "⫧";
    var barvee = "⊽";
    var barwed = "⌅";
    var Barwed = "⌆";
    var barwedge = "⌅";
    var bbrk = "⎵";
    var bbrktbrk = "⎶";
    var bcong = "≌";
    var Bcy = "Б";
    var bcy = "б";
    var bdquo = "„";
    var becaus = "∵";
    var because = "∵";
    var Because = "∵";
    var bemptyv = "⦰";
    var bepsi = "϶";
    var bernou = "ℬ";
    var Bernoullis = "ℬ";
    var Beta = "Β";
    var beta = "β";
    var beth = "ℶ";
    var between = "≬";
    var Bfr = "𝔅";
    var bfr = "𝔟";
    var bigcap = "⋂";
    var bigcirc = "◯";
    var bigcup = "⋃";
    var bigodot = "⨀";
    var bigoplus = "⨁";
    var bigotimes = "⨂";
    var bigsqcup = "⨆";
    var bigstar = "★";
    var bigtriangledown = "▽";
    var bigtriangleup = "△";
    var biguplus = "⨄";
    var bigvee = "⋁";
    var bigwedge = "⋀";
    var bkarow = "⤍";
    var blacklozenge = "⧫";
    var blacksquare = "▪";
    var blacktriangle = "▴";
    var blacktriangledown = "▾";
    var blacktriangleleft = "◂";
    var blacktriangleright = "▸";
    var blank = "␣";
    var blk12 = "▒";
    var blk14 = "░";
    var blk34 = "▓";
    var block = "█";
    var bne = "=⃥";
    var bnequiv = "≡⃥";
    var bNot = "⫭";
    var bnot = "⌐";
    var Bopf = "𝔹";
    var bopf = "𝕓";
    var bot = "⊥";
    var bottom = "⊥";
    var bowtie = "⋈";
    var boxbox = "⧉";
    var boxdl = "┐";
    var boxdL = "╕";
    var boxDl = "╖";
    var boxDL = "╗";
    var boxdr = "┌";
    var boxdR = "╒";
    var boxDr = "╓";
    var boxDR = "╔";
    var boxh = "─";
    var boxH = "═";
    var boxhd = "┬";
    var boxHd = "╤";
    var boxhD = "╥";
    var boxHD = "╦";
    var boxhu = "┴";
    var boxHu = "╧";
    var boxhU = "╨";
    var boxHU = "╩";
    var boxminus = "⊟";
    var boxplus = "⊞";
    var boxtimes = "⊠";
    var boxul = "┘";
    var boxuL = "╛";
    var boxUl = "╜";
    var boxUL = "╝";
    var boxur = "└";
    var boxuR = "╘";
    var boxUr = "╙";
    var boxUR = "╚";
    var boxv = "│";
    var boxV = "║";
    var boxvh = "┼";
    var boxvH = "╪";
    var boxVh = "╫";
    var boxVH = "╬";
    var boxvl = "┤";
    var boxvL = "╡";
    var boxVl = "╢";
    var boxVL = "╣";
    var boxvr = "├";
    var boxvR = "╞";
    var boxVr = "╟";
    var boxVR = "╠";
    var bprime = "‵";
    var breve = "˘";
    var Breve = "˘";
    var brvbar = "¦";
    var bscr = "𝒷";
    var Bscr = "ℬ";
    var bsemi = "⁏";
    var bsim = "∽";
    var bsime = "⋍";
    var bsolb = "⧅";
    var bsol = "\\";
    var bsolhsub = "⟈";
    var bull = "•";
    var bullet = "•";
    var bump = "≎";
    var bumpE = "⪮";
    var bumpe = "≏";
    var Bumpeq = "≎";
    var bumpeq = "≏";
    var Cacute = "Ć";
    var cacute = "ć";
    var capand = "⩄";
    var capbrcup = "⩉";
    var capcap = "⩋";
    var cap = "∩";
    var Cap = "⋒";
    var capcup = "⩇";
    var capdot = "⩀";
    var CapitalDifferentialD = "ⅅ";
    var caps = "∩︀";
    var caret = "⁁";
    var caron = "ˇ";
    var Cayleys = "ℭ";
    var ccaps = "⩍";
    var Ccaron = "Č";
    var ccaron = "č";
    var Ccedil = "Ç";
    var ccedil = "ç";
    var Ccirc = "Ĉ";
    var ccirc = "ĉ";
    var Cconint = "∰";
    var ccups = "⩌";
    var ccupssm = "⩐";
    var Cdot = "Ċ";
    var cdot = "ċ";
    var cedil = "¸";
    var Cedilla = "¸";
    var cemptyv = "⦲";
    var cent = "¢";
    var centerdot = "·";
    var CenterDot = "·";
    var cfr = "𝔠";
    var Cfr = "ℭ";
    var CHcy = "Ч";
    var chcy = "ч";
    var check = "✓";
    var checkmark = "✓";
    var Chi = "Χ";
    var chi = "χ";
    var circ = "ˆ";
    var circeq = "≗";
    var circlearrowleft = "↺";
    var circlearrowright = "↻";
    var circledast = "⊛";
    var circledcirc = "⊚";
    var circleddash = "⊝";
    var CircleDot = "⊙";
    var circledR = "®";
    var circledS = "Ⓢ";
    var CircleMinus = "⊖";
    var CirclePlus = "⊕";
    var CircleTimes = "⊗";
    var cir = "○";
    var cirE = "⧃";
    var cire = "≗";
    var cirfnint = "⨐";
    var cirmid = "⫯";
    var cirscir = "⧂";
    var ClockwiseContourIntegral = "∲";
    var CloseCurlyDoubleQuote = "”";
    var CloseCurlyQuote = "’";
    var clubs = "♣";
    var clubsuit = "♣";
    var colon = ":";
    var Colon = "∷";
    var Colone = "⩴";
    var colone = "≔";
    var coloneq = "≔";
    var comma = ",";
    var commat = "@";
    var comp = "∁";
    var compfn = "∘";
    var complement = "∁";
    var complexes = "ℂ";
    var cong = "≅";
    var congdot = "⩭";
    var Congruent = "≡";
    var conint = "∮";
    var Conint = "∯";
    var ContourIntegral = "∮";
    var copf = "𝕔";
    var Copf = "ℂ";
    var coprod = "∐";
    var Coproduct = "∐";
    var copy = "©";
    var COPY$1 = "©";
    var copysr = "℗";
    var CounterClockwiseContourIntegral = "∳";
    var crarr = "↵";
    var cross = "✗";
    var Cross = "⨯";
    var Cscr = "𝒞";
    var cscr = "𝒸";
    var csub = "⫏";
    var csube = "⫑";
    var csup = "⫐";
    var csupe = "⫒";
    var ctdot = "⋯";
    var cudarrl = "⤸";
    var cudarrr = "⤵";
    var cuepr = "⋞";
    var cuesc = "⋟";
    var cularr = "↶";
    var cularrp = "⤽";
    var cupbrcap = "⩈";
    var cupcap = "⩆";
    var CupCap = "≍";
    var cup = "∪";
    var Cup = "⋓";
    var cupcup = "⩊";
    var cupdot = "⊍";
    var cupor = "⩅";
    var cups = "∪︀";
    var curarr = "↷";
    var curarrm = "⤼";
    var curlyeqprec = "⋞";
    var curlyeqsucc = "⋟";
    var curlyvee = "⋎";
    var curlywedge = "⋏";
    var curren = "¤";
    var curvearrowleft = "↶";
    var curvearrowright = "↷";
    var cuvee = "⋎";
    var cuwed = "⋏";
    var cwconint = "∲";
    var cwint = "∱";
    var cylcty = "⌭";
    var dagger = "†";
    var Dagger = "‡";
    var daleth = "ℸ";
    var darr = "↓";
    var Darr = "↡";
    var dArr = "⇓";
    var dash = "‐";
    var Dashv = "⫤";
    var dashv = "⊣";
    var dbkarow = "⤏";
    var dblac = "˝";
    var Dcaron = "Ď";
    var dcaron = "ď";
    var Dcy = "Д";
    var dcy = "д";
    var ddagger = "‡";
    var ddarr = "⇊";
    var DD = "ⅅ";
    var dd = "ⅆ";
    var DDotrahd = "⤑";
    var ddotseq = "⩷";
    var deg = "°";
    var Del = "∇";
    var Delta = "Δ";
    var delta = "δ";
    var demptyv = "⦱";
    var dfisht = "⥿";
    var Dfr = "𝔇";
    var dfr = "𝔡";
    var dHar = "⥥";
    var dharl = "⇃";
    var dharr = "⇂";
    var DiacriticalAcute = "´";
    var DiacriticalDot = "˙";
    var DiacriticalDoubleAcute = "˝";
    var DiacriticalGrave = "`";
    var DiacriticalTilde = "˜";
    var diam = "⋄";
    var diamond = "⋄";
    var Diamond = "⋄";
    var diamondsuit = "♦";
    var diams = "♦";
    var die = "¨";
    var DifferentialD = "ⅆ";
    var digamma = "ϝ";
    var disin = "⋲";
    var div = "÷";
    var divide = "÷";
    var divideontimes = "⋇";
    var divonx = "⋇";
    var DJcy = "Ђ";
    var djcy = "ђ";
    var dlcorn = "⌞";
    var dlcrop = "⌍";
    var dollar = "$";
    var Dopf = "𝔻";
    var dopf = "𝕕";
    var Dot = "¨";
    var dot = "˙";
    var DotDot = "⃜";
    var doteq = "≐";
    var doteqdot = "≑";
    var DotEqual = "≐";
    var dotminus = "∸";
    var dotplus = "∔";
    var dotsquare = "⊡";
    var doublebarwedge = "⌆";
    var DoubleContourIntegral = "∯";
    var DoubleDot = "¨";
    var DoubleDownArrow = "⇓";
    var DoubleLeftArrow = "⇐";
    var DoubleLeftRightArrow = "⇔";
    var DoubleLeftTee = "⫤";
    var DoubleLongLeftArrow = "⟸";
    var DoubleLongLeftRightArrow = "⟺";
    var DoubleLongRightArrow = "⟹";
    var DoubleRightArrow = "⇒";
    var DoubleRightTee = "⊨";
    var DoubleUpArrow = "⇑";
    var DoubleUpDownArrow = "⇕";
    var DoubleVerticalBar = "∥";
    var DownArrowBar = "⤓";
    var downarrow = "↓";
    var DownArrow = "↓";
    var Downarrow = "⇓";
    var DownArrowUpArrow = "⇵";
    var DownBreve = "̑";
    var downdownarrows = "⇊";
    var downharpoonleft = "⇃";
    var downharpoonright = "⇂";
    var DownLeftRightVector = "⥐";
    var DownLeftTeeVector = "⥞";
    var DownLeftVectorBar = "⥖";
    var DownLeftVector = "↽";
    var DownRightTeeVector = "⥟";
    var DownRightVectorBar = "⥗";
    var DownRightVector = "⇁";
    var DownTeeArrow = "↧";
    var DownTee = "⊤";
    var drbkarow = "⤐";
    var drcorn = "⌟";
    var drcrop = "⌌";
    var Dscr = "𝒟";
    var dscr = "𝒹";
    var DScy = "Ѕ";
    var dscy = "ѕ";
    var dsol = "⧶";
    var Dstrok = "Đ";
    var dstrok = "đ";
    var dtdot = "⋱";
    var dtri = "▿";
    var dtrif = "▾";
    var duarr = "⇵";
    var duhar = "⥯";
    var dwangle = "⦦";
    var DZcy = "Џ";
    var dzcy = "џ";
    var dzigrarr = "⟿";
    var Eacute = "É";
    var eacute = "é";
    var easter = "⩮";
    var Ecaron = "Ě";
    var ecaron = "ě";
    var Ecirc = "Ê";
    var ecirc = "ê";
    var ecir = "≖";
    var ecolon = "≕";
    var Ecy = "Э";
    var ecy = "э";
    var eDDot = "⩷";
    var Edot = "Ė";
    var edot = "ė";
    var eDot = "≑";
    var ee = "ⅇ";
    var efDot = "≒";
    var Efr = "𝔈";
    var efr = "𝔢";
    var eg = "⪚";
    var Egrave = "È";
    var egrave = "è";
    var egs = "⪖";
    var egsdot = "⪘";
    var el = "⪙";
    var Element = "∈";
    var elinters = "⏧";
    var ell = "ℓ";
    var els = "⪕";
    var elsdot = "⪗";
    var Emacr = "Ē";
    var emacr = "ē";
    var empty = "∅";
    var emptyset = "∅";
    var EmptySmallSquare = "◻";
    var emptyv = "∅";
    var EmptyVerySmallSquare = "▫";
    var emsp13 = " ";
    var emsp14 = " ";
    var emsp = " ";
    var ENG = "Ŋ";
    var eng = "ŋ";
    var ensp = " ";
    var Eogon = "Ę";
    var eogon = "ę";
    var Eopf = "𝔼";
    var eopf = "𝕖";
    var epar = "⋕";
    var eparsl = "⧣";
    var eplus = "⩱";
    var epsi = "ε";
    var Epsilon = "Ε";
    var epsilon = "ε";
    var epsiv = "ϵ";
    var eqcirc = "≖";
    var eqcolon = "≕";
    var eqsim = "≂";
    var eqslantgtr = "⪖";
    var eqslantless = "⪕";
    var Equal = "⩵";
    var equals = "=";
    var EqualTilde = "≂";
    var equest = "≟";
    var Equilibrium = "⇌";
    var equiv = "≡";
    var equivDD = "⩸";
    var eqvparsl = "⧥";
    var erarr = "⥱";
    var erDot = "≓";
    var escr = "ℯ";
    var Escr = "ℰ";
    var esdot = "≐";
    var Esim = "⩳";
    var esim = "≂";
    var Eta = "Η";
    var eta = "η";
    var ETH = "Ð";
    var eth = "ð";
    var Euml = "Ë";
    var euml = "ë";
    var euro = "€";
    var excl = "!";
    var exist = "∃";
    var Exists = "∃";
    var expectation = "ℰ";
    var exponentiale = "ⅇ";
    var ExponentialE = "ⅇ";
    var fallingdotseq = "≒";
    var Fcy = "Ф";
    var fcy = "ф";
    var female = "♀";
    var ffilig = "ﬃ";
    var fflig = "ﬀ";
    var ffllig = "ﬄ";
    var Ffr = "𝔉";
    var ffr = "𝔣";
    var filig = "ﬁ";
    var FilledSmallSquare = "◼";
    var FilledVerySmallSquare = "▪";
    var fjlig = "fj";
    var flat = "♭";
    var fllig = "ﬂ";
    var fltns = "▱";
    var fnof = "ƒ";
    var Fopf = "𝔽";
    var fopf = "𝕗";
    var forall = "∀";
    var ForAll = "∀";
    var fork = "⋔";
    var forkv = "⫙";
    var Fouriertrf = "ℱ";
    var fpartint = "⨍";
    var frac12 = "½";
    var frac13 = "⅓";
    var frac14 = "¼";
    var frac15 = "⅕";
    var frac16 = "⅙";
    var frac18 = "⅛";
    var frac23 = "⅔";
    var frac25 = "⅖";
    var frac34 = "¾";
    var frac35 = "⅗";
    var frac38 = "⅜";
    var frac45 = "⅘";
    var frac56 = "⅚";
    var frac58 = "⅝";
    var frac78 = "⅞";
    var frasl = "⁄";
    var frown = "⌢";
    var fscr = "𝒻";
    var Fscr = "ℱ";
    var gacute = "ǵ";
    var Gamma = "Γ";
    var gamma = "γ";
    var Gammad = "Ϝ";
    var gammad = "ϝ";
    var gap = "⪆";
    var Gbreve = "Ğ";
    var gbreve = "ğ";
    var Gcedil = "Ģ";
    var Gcirc = "Ĝ";
    var gcirc = "ĝ";
    var Gcy = "Г";
    var gcy = "г";
    var Gdot = "Ġ";
    var gdot = "ġ";
    var ge = "≥";
    var gE = "≧";
    var gEl = "⪌";
    var gel = "⋛";
    var geq = "≥";
    var geqq = "≧";
    var geqslant = "⩾";
    var gescc = "⪩";
    var ges = "⩾";
    var gesdot = "⪀";
    var gesdoto = "⪂";
    var gesdotol = "⪄";
    var gesl = "⋛︀";
    var gesles = "⪔";
    var Gfr = "𝔊";
    var gfr = "𝔤";
    var gg = "≫";
    var Gg = "⋙";
    var ggg = "⋙";
    var gimel = "ℷ";
    var GJcy = "Ѓ";
    var gjcy = "ѓ";
    var gla = "⪥";
    var gl = "≷";
    var glE = "⪒";
    var glj = "⪤";
    var gnap = "⪊";
    var gnapprox = "⪊";
    var gne = "⪈";
    var gnE = "≩";
    var gneq = "⪈";
    var gneqq = "≩";
    var gnsim = "⋧";
    var Gopf = "𝔾";
    var gopf = "𝕘";
    var grave = "`";
    var GreaterEqual = "≥";
    var GreaterEqualLess = "⋛";
    var GreaterFullEqual = "≧";
    var GreaterGreater = "⪢";
    var GreaterLess = "≷";
    var GreaterSlantEqual = "⩾";
    var GreaterTilde = "≳";
    var Gscr = "𝒢";
    var gscr = "ℊ";
    var gsim = "≳";
    var gsime = "⪎";
    var gsiml = "⪐";
    var gtcc = "⪧";
    var gtcir = "⩺";
    var gt = ">";
    var GT = ">";
    var Gt = "≫";
    var gtdot = "⋗";
    var gtlPar = "⦕";
    var gtquest = "⩼";
    var gtrapprox = "⪆";
    var gtrarr = "⥸";
    var gtrdot = "⋗";
    var gtreqless = "⋛";
    var gtreqqless = "⪌";
    var gtrless = "≷";
    var gtrsim = "≳";
    var gvertneqq = "≩︀";
    var gvnE = "≩︀";
    var Hacek = "ˇ";
    var hairsp = " ";
    var half = "½";
    var hamilt = "ℋ";
    var HARDcy = "Ъ";
    var hardcy = "ъ";
    var harrcir = "⥈";
    var harr = "↔";
    var hArr = "⇔";
    var harrw = "↭";
    var Hat = "^";
    var hbar = "ℏ";
    var Hcirc = "Ĥ";
    var hcirc = "ĥ";
    var hearts = "♥";
    var heartsuit = "♥";
    var hellip = "…";
    var hercon = "⊹";
    var hfr = "𝔥";
    var Hfr = "ℌ";
    var HilbertSpace = "ℋ";
    var hksearow = "⤥";
    var hkswarow = "⤦";
    var hoarr = "⇿";
    var homtht = "∻";
    var hookleftarrow = "↩";
    var hookrightarrow = "↪";
    var hopf = "𝕙";
    var Hopf = "ℍ";
    var horbar = "―";
    var HorizontalLine = "─";
    var hscr = "𝒽";
    var Hscr = "ℋ";
    var hslash = "ℏ";
    var Hstrok = "Ħ";
    var hstrok = "ħ";
    var HumpDownHump = "≎";
    var HumpEqual = "≏";
    var hybull = "⁃";
    var hyphen = "‐";
    var Iacute = "Í";
    var iacute = "í";
    var ic = "⁣";
    var Icirc = "Î";
    var icirc = "î";
    var Icy = "И";
    var icy = "и";
    var Idot = "İ";
    var IEcy = "Е";
    var iecy = "е";
    var iexcl = "¡";
    var iff = "⇔";
    var ifr = "𝔦";
    var Ifr = "ℑ";
    var Igrave = "Ì";
    var igrave = "ì";
    var ii = "ⅈ";
    var iiiint = "⨌";
    var iiint = "∭";
    var iinfin = "⧜";
    var iiota = "℩";
    var IJlig = "Ĳ";
    var ijlig = "ĳ";
    var Imacr = "Ī";
    var imacr = "ī";
    var image = "ℑ";
    var ImaginaryI = "ⅈ";
    var imagline = "ℐ";
    var imagpart = "ℑ";
    var imath = "ı";
    var Im = "ℑ";
    var imof = "⊷";
    var imped = "Ƶ";
    var Implies = "⇒";
    var incare = "℅";
    var infin = "∞";
    var infintie = "⧝";
    var inodot = "ı";
    var intcal = "⊺";
    var int = "∫";
    var Int = "∬";
    var integers = "ℤ";
    var Integral = "∫";
    var intercal = "⊺";
    var Intersection = "⋂";
    var intlarhk = "⨗";
    var intprod = "⨼";
    var InvisibleComma = "⁣";
    var InvisibleTimes = "⁢";
    var IOcy = "Ё";
    var iocy = "ё";
    var Iogon = "Į";
    var iogon = "į";
    var Iopf = "𝕀";
    var iopf = "𝕚";
    var Iota = "Ι";
    var iota = "ι";
    var iprod = "⨼";
    var iquest = "¿";
    var iscr = "𝒾";
    var Iscr = "ℐ";
    var isin = "∈";
    var isindot = "⋵";
    var isinE = "⋹";
    var isins = "⋴";
    var isinsv = "⋳";
    var isinv = "∈";
    var it = "⁢";
    var Itilde = "Ĩ";
    var itilde = "ĩ";
    var Iukcy = "І";
    var iukcy = "і";
    var Iuml = "Ï";
    var iuml = "ï";
    var Jcirc = "Ĵ";
    var jcirc = "ĵ";
    var Jcy = "Й";
    var jcy = "й";
    var Jfr = "𝔍";
    var jfr = "𝔧";
    var jmath = "ȷ";
    var Jopf = "𝕁";
    var jopf = "𝕛";
    var Jscr = "𝒥";
    var jscr = "𝒿";
    var Jsercy = "Ј";
    var jsercy = "ј";
    var Jukcy = "Є";
    var jukcy = "є";
    var Kappa = "Κ";
    var kappa = "κ";
    var kappav = "ϰ";
    var Kcedil = "Ķ";
    var kcedil = "ķ";
    var Kcy = "К";
    var kcy = "к";
    var Kfr = "𝔎";
    var kfr = "𝔨";
    var kgreen = "ĸ";
    var KHcy = "Х";
    var khcy = "х";
    var KJcy = "Ќ";
    var kjcy = "ќ";
    var Kopf = "𝕂";
    var kopf = "𝕜";
    var Kscr = "𝒦";
    var kscr = "𝓀";
    var lAarr = "⇚";
    var Lacute = "Ĺ";
    var lacute = "ĺ";
    var laemptyv = "⦴";
    var lagran = "ℒ";
    var Lambda = "Λ";
    var lambda = "λ";
    var lang = "⟨";
    var Lang = "⟪";
    var langd = "⦑";
    var langle = "⟨";
    var lap = "⪅";
    var Laplacetrf = "ℒ";
    var laquo = "«";
    var larrb = "⇤";
    var larrbfs = "⤟";
    var larr = "←";
    var Larr = "↞";
    var lArr = "⇐";
    var larrfs = "⤝";
    var larrhk = "↩";
    var larrlp = "↫";
    var larrpl = "⤹";
    var larrsim = "⥳";
    var larrtl = "↢";
    var latail = "⤙";
    var lAtail = "⤛";
    var lat = "⪫";
    var late = "⪭";
    var lates = "⪭︀";
    var lbarr = "⤌";
    var lBarr = "⤎";
    var lbbrk = "❲";
    var lbrace = "{";
    var lbrack = "[";
    var lbrke = "⦋";
    var lbrksld = "⦏";
    var lbrkslu = "⦍";
    var Lcaron = "Ľ";
    var lcaron = "ľ";
    var Lcedil = "Ļ";
    var lcedil = "ļ";
    var lceil = "⌈";
    var lcub = "{";
    var Lcy = "Л";
    var lcy = "л";
    var ldca = "⤶";
    var ldquo = "“";
    var ldquor = "„";
    var ldrdhar = "⥧";
    var ldrushar = "⥋";
    var ldsh = "↲";
    var le = "≤";
    var lE = "≦";
    var LeftAngleBracket = "⟨";
    var LeftArrowBar = "⇤";
    var leftarrow = "←";
    var LeftArrow = "←";
    var Leftarrow = "⇐";
    var LeftArrowRightArrow = "⇆";
    var leftarrowtail = "↢";
    var LeftCeiling = "⌈";
    var LeftDoubleBracket = "⟦";
    var LeftDownTeeVector = "⥡";
    var LeftDownVectorBar = "⥙";
    var LeftDownVector = "⇃";
    var LeftFloor = "⌊";
    var leftharpoondown = "↽";
    var leftharpoonup = "↼";
    var leftleftarrows = "⇇";
    var leftrightarrow = "↔";
    var LeftRightArrow = "↔";
    var Leftrightarrow = "⇔";
    var leftrightarrows = "⇆";
    var leftrightharpoons = "⇋";
    var leftrightsquigarrow = "↭";
    var LeftRightVector = "⥎";
    var LeftTeeArrow = "↤";
    var LeftTee = "⊣";
    var LeftTeeVector = "⥚";
    var leftthreetimes = "⋋";
    var LeftTriangleBar = "⧏";
    var LeftTriangle = "⊲";
    var LeftTriangleEqual = "⊴";
    var LeftUpDownVector = "⥑";
    var LeftUpTeeVector = "⥠";
    var LeftUpVectorBar = "⥘";
    var LeftUpVector = "↿";
    var LeftVectorBar = "⥒";
    var LeftVector = "↼";
    var lEg = "⪋";
    var leg = "⋚";
    var leq = "≤";
    var leqq = "≦";
    var leqslant = "⩽";
    var lescc = "⪨";
    var les = "⩽";
    var lesdot = "⩿";
    var lesdoto = "⪁";
    var lesdotor = "⪃";
    var lesg = "⋚︀";
    var lesges = "⪓";
    var lessapprox = "⪅";
    var lessdot = "⋖";
    var lesseqgtr = "⋚";
    var lesseqqgtr = "⪋";
    var LessEqualGreater = "⋚";
    var LessFullEqual = "≦";
    var LessGreater = "≶";
    var lessgtr = "≶";
    var LessLess = "⪡";
    var lesssim = "≲";
    var LessSlantEqual = "⩽";
    var LessTilde = "≲";
    var lfisht = "⥼";
    var lfloor = "⌊";
    var Lfr = "𝔏";
    var lfr = "𝔩";
    var lg = "≶";
    var lgE = "⪑";
    var lHar = "⥢";
    var lhard = "↽";
    var lharu = "↼";
    var lharul = "⥪";
    var lhblk = "▄";
    var LJcy = "Љ";
    var ljcy = "љ";
    var llarr = "⇇";
    var ll = "≪";
    var Ll = "⋘";
    var llcorner = "⌞";
    var Lleftarrow = "⇚";
    var llhard = "⥫";
    var lltri = "◺";
    var Lmidot = "Ŀ";
    var lmidot = "ŀ";
    var lmoustache = "⎰";
    var lmoust = "⎰";
    var lnap = "⪉";
    var lnapprox = "⪉";
    var lne = "⪇";
    var lnE = "≨";
    var lneq = "⪇";
    var lneqq = "≨";
    var lnsim = "⋦";
    var loang = "⟬";
    var loarr = "⇽";
    var lobrk = "⟦";
    var longleftarrow = "⟵";
    var LongLeftArrow = "⟵";
    var Longleftarrow = "⟸";
    var longleftrightarrow = "⟷";
    var LongLeftRightArrow = "⟷";
    var Longleftrightarrow = "⟺";
    var longmapsto = "⟼";
    var longrightarrow = "⟶";
    var LongRightArrow = "⟶";
    var Longrightarrow = "⟹";
    var looparrowleft = "↫";
    var looparrowright = "↬";
    var lopar = "⦅";
    var Lopf = "𝕃";
    var lopf = "𝕝";
    var loplus = "⨭";
    var lotimes = "⨴";
    var lowast = "∗";
    var lowbar = "_";
    var LowerLeftArrow = "↙";
    var LowerRightArrow = "↘";
    var loz = "◊";
    var lozenge = "◊";
    var lozf = "⧫";
    var lpar = "(";
    var lparlt = "⦓";
    var lrarr = "⇆";
    var lrcorner = "⌟";
    var lrhar = "⇋";
    var lrhard = "⥭";
    var lrm = "‎";
    var lrtri = "⊿";
    var lsaquo = "‹";
    var lscr = "𝓁";
    var Lscr = "ℒ";
    var lsh = "↰";
    var Lsh = "↰";
    var lsim = "≲";
    var lsime = "⪍";
    var lsimg = "⪏";
    var lsqb = "[";
    var lsquo = "‘";
    var lsquor = "‚";
    var Lstrok = "Ł";
    var lstrok = "ł";
    var ltcc = "⪦";
    var ltcir = "⩹";
    var lt = "<";
    var LT = "<";
    var Lt = "≪";
    var ltdot = "⋖";
    var lthree = "⋋";
    var ltimes = "⋉";
    var ltlarr = "⥶";
    var ltquest = "⩻";
    var ltri = "◃";
    var ltrie = "⊴";
    var ltrif = "◂";
    var ltrPar = "⦖";
    var lurdshar = "⥊";
    var luruhar = "⥦";
    var lvertneqq = "≨︀";
    var lvnE = "≨︀";
    var macr = "¯";
    var male = "♂";
    var malt = "✠";
    var maltese = "✠";
    var map = "↦";
    var mapsto = "↦";
    var mapstodown = "↧";
    var mapstoleft = "↤";
    var mapstoup = "↥";
    var marker = "▮";
    var mcomma = "⨩";
    var Mcy = "М";
    var mcy = "м";
    var mdash = "—";
    var mDDot = "∺";
    var measuredangle = "∡";
    var MediumSpace = " ";
    var Mellintrf = "ℳ";
    var Mfr = "𝔐";
    var mfr = "𝔪";
    var mho = "℧";
    var micro = "µ";
    var midast = "*";
    var midcir = "⫰";
    var mid = "∣";
    var middot = "·";
    var minusb = "⊟";
    var minus = "−";
    var minusd = "∸";
    var minusdu = "⨪";
    var MinusPlus = "∓";
    var mlcp = "⫛";
    var mldr = "…";
    var mnplus = "∓";
    var models = "⊧";
    var Mopf = "𝕄";
    var mopf = "𝕞";
    var mp = "∓";
    var mscr = "𝓂";
    var Mscr = "ℳ";
    var mstpos = "∾";
    var Mu = "Μ";
    var mu = "μ";
    var multimap = "⊸";
    var mumap = "⊸";
    var nabla = "∇";
    var Nacute = "Ń";
    var nacute = "ń";
    var nang = "∠⃒";
    var nap = "≉";
    var napE = "⩰̸";
    var napid = "≋̸";
    var napos = "ŉ";
    var napprox = "≉";
    var natural = "♮";
    var naturals = "ℕ";
    var natur = "♮";
    var nbsp = " ";
    var nbump = "≎̸";
    var nbumpe = "≏̸";
    var ncap = "⩃";
    var Ncaron = "Ň";
    var ncaron = "ň";
    var Ncedil = "Ņ";
    var ncedil = "ņ";
    var ncong = "≇";
    var ncongdot = "⩭̸";
    var ncup = "⩂";
    var Ncy = "Н";
    var ncy = "н";
    var ndash = "–";
    var nearhk = "⤤";
    var nearr = "↗";
    var neArr = "⇗";
    var nearrow = "↗";
    var ne = "≠";
    var nedot = "≐̸";
    var NegativeMediumSpace = "​";
    var NegativeThickSpace = "​";
    var NegativeThinSpace = "​";
    var NegativeVeryThinSpace = "​";
    var nequiv = "≢";
    var nesear = "⤨";
    var nesim = "≂̸";
    var NestedGreaterGreater = "≫";
    var NestedLessLess = "≪";
    var NewLine = "\n";
    var nexist = "∄";
    var nexists = "∄";
    var Nfr = "𝔑";
    var nfr = "𝔫";
    var ngE = "≧̸";
    var nge = "≱";
    var ngeq = "≱";
    var ngeqq = "≧̸";
    var ngeqslant = "⩾̸";
    var nges = "⩾̸";
    var nGg = "⋙̸";
    var ngsim = "≵";
    var nGt = "≫⃒";
    var ngt = "≯";
    var ngtr = "≯";
    var nGtv = "≫̸";
    var nharr = "↮";
    var nhArr = "⇎";
    var nhpar = "⫲";
    var ni = "∋";
    var nis = "⋼";
    var nisd = "⋺";
    var niv = "∋";
    var NJcy = "Њ";
    var njcy = "њ";
    var nlarr = "↚";
    var nlArr = "⇍";
    var nldr = "‥";
    var nlE = "≦̸";
    var nle = "≰";
    var nleftarrow = "↚";
    var nLeftarrow = "⇍";
    var nleftrightarrow = "↮";
    var nLeftrightarrow = "⇎";
    var nleq = "≰";
    var nleqq = "≦̸";
    var nleqslant = "⩽̸";
    var nles = "⩽̸";
    var nless = "≮";
    var nLl = "⋘̸";
    var nlsim = "≴";
    var nLt = "≪⃒";
    var nlt = "≮";
    var nltri = "⋪";
    var nltrie = "⋬";
    var nLtv = "≪̸";
    var nmid = "∤";
    var NoBreak = "⁠";
    var NonBreakingSpace = " ";
    var nopf = "𝕟";
    var Nopf = "ℕ";
    var Not = "⫬";
    var not = "¬";
    var NotCongruent = "≢";
    var NotCupCap = "≭";
    var NotDoubleVerticalBar = "∦";
    var NotElement = "∉";
    var NotEqual = "≠";
    var NotEqualTilde = "≂̸";
    var NotExists = "∄";
    var NotGreater = "≯";
    var NotGreaterEqual = "≱";
    var NotGreaterFullEqual = "≧̸";
    var NotGreaterGreater = "≫̸";
    var NotGreaterLess = "≹";
    var NotGreaterSlantEqual = "⩾̸";
    var NotGreaterTilde = "≵";
    var NotHumpDownHump = "≎̸";
    var NotHumpEqual = "≏̸";
    var notin = "∉";
    var notindot = "⋵̸";
    var notinE = "⋹̸";
    var notinva = "∉";
    var notinvb = "⋷";
    var notinvc = "⋶";
    var NotLeftTriangleBar = "⧏̸";
    var NotLeftTriangle = "⋪";
    var NotLeftTriangleEqual = "⋬";
    var NotLess = "≮";
    var NotLessEqual = "≰";
    var NotLessGreater = "≸";
    var NotLessLess = "≪̸";
    var NotLessSlantEqual = "⩽̸";
    var NotLessTilde = "≴";
    var NotNestedGreaterGreater = "⪢̸";
    var NotNestedLessLess = "⪡̸";
    var notni = "∌";
    var notniva = "∌";
    var notnivb = "⋾";
    var notnivc = "⋽";
    var NotPrecedes = "⊀";
    var NotPrecedesEqual = "⪯̸";
    var NotPrecedesSlantEqual = "⋠";
    var NotReverseElement = "∌";
    var NotRightTriangleBar = "⧐̸";
    var NotRightTriangle = "⋫";
    var NotRightTriangleEqual = "⋭";
    var NotSquareSubset = "⊏̸";
    var NotSquareSubsetEqual = "⋢";
    var NotSquareSuperset = "⊐̸";
    var NotSquareSupersetEqual = "⋣";
    var NotSubset = "⊂⃒";
    var NotSubsetEqual = "⊈";
    var NotSucceeds = "⊁";
    var NotSucceedsEqual = "⪰̸";
    var NotSucceedsSlantEqual = "⋡";
    var NotSucceedsTilde = "≿̸";
    var NotSuperset = "⊃⃒";
    var NotSupersetEqual = "⊉";
    var NotTilde = "≁";
    var NotTildeEqual = "≄";
    var NotTildeFullEqual = "≇";
    var NotTildeTilde = "≉";
    var NotVerticalBar = "∤";
    var nparallel = "∦";
    var npar = "∦";
    var nparsl = "⫽⃥";
    var npart = "∂̸";
    var npolint = "⨔";
    var npr = "⊀";
    var nprcue = "⋠";
    var nprec = "⊀";
    var npreceq = "⪯̸";
    var npre = "⪯̸";
    var nrarrc = "⤳̸";
    var nrarr = "↛";
    var nrArr = "⇏";
    var nrarrw = "↝̸";
    var nrightarrow = "↛";
    var nRightarrow = "⇏";
    var nrtri = "⋫";
    var nrtrie = "⋭";
    var nsc = "⊁";
    var nsccue = "⋡";
    var nsce = "⪰̸";
    var Nscr = "𝒩";
    var nscr = "𝓃";
    var nshortmid = "∤";
    var nshortparallel = "∦";
    var nsim = "≁";
    var nsime = "≄";
    var nsimeq = "≄";
    var nsmid = "∤";
    var nspar = "∦";
    var nsqsube = "⋢";
    var nsqsupe = "⋣";
    var nsub = "⊄";
    var nsubE = "⫅̸";
    var nsube = "⊈";
    var nsubset = "⊂⃒";
    var nsubseteq = "⊈";
    var nsubseteqq = "⫅̸";
    var nsucc = "⊁";
    var nsucceq = "⪰̸";
    var nsup = "⊅";
    var nsupE = "⫆̸";
    var nsupe = "⊉";
    var nsupset = "⊃⃒";
    var nsupseteq = "⊉";
    var nsupseteqq = "⫆̸";
    var ntgl = "≹";
    var Ntilde = "Ñ";
    var ntilde = "ñ";
    var ntlg = "≸";
    var ntriangleleft = "⋪";
    var ntrianglelefteq = "⋬";
    var ntriangleright = "⋫";
    var ntrianglerighteq = "⋭";
    var Nu = "Ν";
    var nu = "ν";
    var num = "#";
    var numero = "№";
    var numsp = " ";
    var nvap = "≍⃒";
    var nvdash = "⊬";
    var nvDash = "⊭";
    var nVdash = "⊮";
    var nVDash = "⊯";
    var nvge = "≥⃒";
    var nvgt = ">⃒";
    var nvHarr = "⤄";
    var nvinfin = "⧞";
    var nvlArr = "⤂";
    var nvle = "≤⃒";
    var nvlt = "<⃒";
    var nvltrie = "⊴⃒";
    var nvrArr = "⤃";
    var nvrtrie = "⊵⃒";
    var nvsim = "∼⃒";
    var nwarhk = "⤣";
    var nwarr = "↖";
    var nwArr = "⇖";
    var nwarrow = "↖";
    var nwnear = "⤧";
    var Oacute = "Ó";
    var oacute = "ó";
    var oast = "⊛";
    var Ocirc = "Ô";
    var ocirc = "ô";
    var ocir = "⊚";
    var Ocy = "О";
    var ocy = "о";
    var odash = "⊝";
    var Odblac = "Ő";
    var odblac = "ő";
    var odiv = "⨸";
    var odot = "⊙";
    var odsold = "⦼";
    var OElig = "Œ";
    var oelig = "œ";
    var ofcir = "⦿";
    var Ofr = "𝔒";
    var ofr = "𝔬";
    var ogon = "˛";
    var Ograve = "Ò";
    var ograve = "ò";
    var ogt = "⧁";
    var ohbar = "⦵";
    var ohm = "Ω";
    var oint = "∮";
    var olarr = "↺";
    var olcir = "⦾";
    var olcross = "⦻";
    var oline = "‾";
    var olt = "⧀";
    var Omacr = "Ō";
    var omacr = "ō";
    var Omega = "Ω";
    var omega = "ω";
    var Omicron = "Ο";
    var omicron = "ο";
    var omid = "⦶";
    var ominus = "⊖";
    var Oopf = "𝕆";
    var oopf = "𝕠";
    var opar = "⦷";
    var OpenCurlyDoubleQuote = "“";
    var OpenCurlyQuote = "‘";
    var operp = "⦹";
    var oplus = "⊕";
    var orarr = "↻";
    var Or = "⩔";
    var or = "∨";
    var ord = "⩝";
    var order = "ℴ";
    var orderof = "ℴ";
    var ordf = "ª";
    var ordm = "º";
    var origof = "⊶";
    var oror = "⩖";
    var orslope = "⩗";
    var orv = "⩛";
    var oS = "Ⓢ";
    var Oscr = "𝒪";
    var oscr = "ℴ";
    var Oslash = "Ø";
    var oslash = "ø";
    var osol = "⊘";
    var Otilde = "Õ";
    var otilde = "õ";
    var otimesas = "⨶";
    var Otimes = "⨷";
    var otimes = "⊗";
    var Ouml = "Ö";
    var ouml = "ö";
    var ovbar = "⌽";
    var OverBar = "‾";
    var OverBrace = "⏞";
    var OverBracket = "⎴";
    var OverParenthesis = "⏜";
    var para = "¶";
    var parallel = "∥";
    var par = "∥";
    var parsim = "⫳";
    var parsl = "⫽";
    var part = "∂";
    var PartialD = "∂";
    var Pcy = "П";
    var pcy = "п";
    var percnt = "%";
    var period = ".";
    var permil = "‰";
    var perp = "⊥";
    var pertenk = "‱";
    var Pfr = "𝔓";
    var pfr = "𝔭";
    var Phi = "Φ";
    var phi = "φ";
    var phiv = "ϕ";
    var phmmat = "ℳ";
    var phone = "☎";
    var Pi = "Π";
    var pi = "π";
    var pitchfork = "⋔";
    var piv = "ϖ";
    var planck = "ℏ";
    var planckh = "ℎ";
    var plankv = "ℏ";
    var plusacir = "⨣";
    var plusb = "⊞";
    var pluscir = "⨢";
    var plus = "+";
    var plusdo = "∔";
    var plusdu = "⨥";
    var pluse = "⩲";
    var PlusMinus = "±";
    var plusmn = "±";
    var plussim = "⨦";
    var plustwo = "⨧";
    var pm = "±";
    var Poincareplane = "ℌ";
    var pointint = "⨕";
    var popf = "𝕡";
    var Popf = "ℙ";
    var pound = "£";
    var prap = "⪷";
    var Pr = "⪻";
    var pr = "≺";
    var prcue = "≼";
    var precapprox = "⪷";
    var prec = "≺";
    var preccurlyeq = "≼";
    var Precedes = "≺";
    var PrecedesEqual = "⪯";
    var PrecedesSlantEqual = "≼";
    var PrecedesTilde = "≾";
    var preceq = "⪯";
    var precnapprox = "⪹";
    var precneqq = "⪵";
    var precnsim = "⋨";
    var pre = "⪯";
    var prE = "⪳";
    var precsim = "≾";
    var prime = "′";
    var Prime = "″";
    var primes = "ℙ";
    var prnap = "⪹";
    var prnE = "⪵";
    var prnsim = "⋨";
    var prod = "∏";
    var Product = "∏";
    var profalar = "⌮";
    var profline = "⌒";
    var profsurf = "⌓";
    var prop = "∝";
    var Proportional = "∝";
    var Proportion = "∷";
    var propto = "∝";
    var prsim = "≾";
    var prurel = "⊰";
    var Pscr = "𝒫";
    var pscr = "𝓅";
    var Psi = "Ψ";
    var psi = "ψ";
    var puncsp = " ";
    var Qfr = "𝔔";
    var qfr = "𝔮";
    var qint = "⨌";
    var qopf = "𝕢";
    var Qopf = "ℚ";
    var qprime = "⁗";
    var Qscr = "𝒬";
    var qscr = "𝓆";
    var quaternions = "ℍ";
    var quatint = "⨖";
    var quest = "?";
    var questeq = "≟";
    var quot = "\"";
    var QUOT = "\"";
    var rAarr = "⇛";
    var race = "∽̱";
    var Racute = "Ŕ";
    var racute = "ŕ";
    var radic = "√";
    var raemptyv = "⦳";
    var rang = "⟩";
    var Rang = "⟫";
    var rangd = "⦒";
    var range = "⦥";
    var rangle = "⟩";
    var raquo = "»";
    var rarrap = "⥵";
    var rarrb = "⇥";
    var rarrbfs = "⤠";
    var rarrc = "⤳";
    var rarr = "→";
    var Rarr = "↠";
    var rArr = "⇒";
    var rarrfs = "⤞";
    var rarrhk = "↪";
    var rarrlp = "↬";
    var rarrpl = "⥅";
    var rarrsim = "⥴";
    var Rarrtl = "⤖";
    var rarrtl = "↣";
    var rarrw = "↝";
    var ratail = "⤚";
    var rAtail = "⤜";
    var ratio = "∶";
    var rationals = "ℚ";
    var rbarr = "⤍";
    var rBarr = "⤏";
    var RBarr = "⤐";
    var rbbrk = "❳";
    var rbrace = "}";
    var rbrack = "]";
    var rbrke = "⦌";
    var rbrksld = "⦎";
    var rbrkslu = "⦐";
    var Rcaron = "Ř";
    var rcaron = "ř";
    var Rcedil = "Ŗ";
    var rcedil = "ŗ";
    var rceil = "⌉";
    var rcub = "}";
    var Rcy = "Р";
    var rcy = "р";
    var rdca = "⤷";
    var rdldhar = "⥩";
    var rdquo = "”";
    var rdquor = "”";
    var rdsh = "↳";
    var real = "ℜ";
    var realine = "ℛ";
    var realpart = "ℜ";
    var reals = "ℝ";
    var Re = "ℜ";
    var rect = "▭";
    var reg = "®";
    var REG = "®";
    var ReverseElement = "∋";
    var ReverseEquilibrium = "⇋";
    var ReverseUpEquilibrium = "⥯";
    var rfisht = "⥽";
    var rfloor = "⌋";
    var rfr = "𝔯";
    var Rfr = "ℜ";
    var rHar = "⥤";
    var rhard = "⇁";
    var rharu = "⇀";
    var rharul = "⥬";
    var Rho = "Ρ";
    var rho = "ρ";
    var rhov = "ϱ";
    var RightAngleBracket = "⟩";
    var RightArrowBar = "⇥";
    var rightarrow = "→";
    var RightArrow = "→";
    var Rightarrow = "⇒";
    var RightArrowLeftArrow = "⇄";
    var rightarrowtail = "↣";
    var RightCeiling = "⌉";
    var RightDoubleBracket = "⟧";
    var RightDownTeeVector = "⥝";
    var RightDownVectorBar = "⥕";
    var RightDownVector = "⇂";
    var RightFloor = "⌋";
    var rightharpoondown = "⇁";
    var rightharpoonup = "⇀";
    var rightleftarrows = "⇄";
    var rightleftharpoons = "⇌";
    var rightrightarrows = "⇉";
    var rightsquigarrow = "↝";
    var RightTeeArrow = "↦";
    var RightTee = "⊢";
    var RightTeeVector = "⥛";
    var rightthreetimes = "⋌";
    var RightTriangleBar = "⧐";
    var RightTriangle = "⊳";
    var RightTriangleEqual = "⊵";
    var RightUpDownVector = "⥏";
    var RightUpTeeVector = "⥜";
    var RightUpVectorBar = "⥔";
    var RightUpVector = "↾";
    var RightVectorBar = "⥓";
    var RightVector = "⇀";
    var ring = "˚";
    var risingdotseq = "≓";
    var rlarr = "⇄";
    var rlhar = "⇌";
    var rlm = "‏";
    var rmoustache = "⎱";
    var rmoust = "⎱";
    var rnmid = "⫮";
    var roang = "⟭";
    var roarr = "⇾";
    var robrk = "⟧";
    var ropar = "⦆";
    var ropf = "𝕣";
    var Ropf = "ℝ";
    var roplus = "⨮";
    var rotimes = "⨵";
    var RoundImplies = "⥰";
    var rpar = ")";
    var rpargt = "⦔";
    var rppolint = "⨒";
    var rrarr = "⇉";
    var Rrightarrow = "⇛";
    var rsaquo = "›";
    var rscr = "𝓇";
    var Rscr = "ℛ";
    var rsh = "↱";
    var Rsh = "↱";
    var rsqb = "]";
    var rsquo = "’";
    var rsquor = "’";
    var rthree = "⋌";
    var rtimes = "⋊";
    var rtri = "▹";
    var rtrie = "⊵";
    var rtrif = "▸";
    var rtriltri = "⧎";
    var RuleDelayed = "⧴";
    var ruluhar = "⥨";
    var rx = "℞";
    var Sacute = "Ś";
    var sacute = "ś";
    var sbquo = "‚";
    var scap = "⪸";
    var Scaron = "Š";
    var scaron = "š";
    var Sc = "⪼";
    var sc = "≻";
    var sccue = "≽";
    var sce = "⪰";
    var scE = "⪴";
    var Scedil = "Ş";
    var scedil = "ş";
    var Scirc = "Ŝ";
    var scirc = "ŝ";
    var scnap = "⪺";
    var scnE = "⪶";
    var scnsim = "⋩";
    var scpolint = "⨓";
    var scsim = "≿";
    var Scy = "С";
    var scy = "с";
    var sdotb = "⊡";
    var sdot = "⋅";
    var sdote = "⩦";
    var searhk = "⤥";
    var searr = "↘";
    var seArr = "⇘";
    var searrow = "↘";
    var sect = "§";
    var semi = ";";
    var seswar = "⤩";
    var setminus = "∖";
    var setmn = "∖";
    var sext = "✶";
    var Sfr = "𝔖";
    var sfr = "𝔰";
    var sfrown = "⌢";
    var sharp = "♯";
    var SHCHcy = "Щ";
    var shchcy = "щ";
    var SHcy = "Ш";
    var shcy = "ш";
    var ShortDownArrow = "↓";
    var ShortLeftArrow = "←";
    var shortmid = "∣";
    var shortparallel = "∥";
    var ShortRightArrow = "→";
    var ShortUpArrow = "↑";
    var shy = "­";
    var Sigma = "Σ";
    var sigma = "σ";
    var sigmaf = "ς";
    var sigmav = "ς";
    var sim = "∼";
    var simdot = "⩪";
    var sime = "≃";
    var simeq = "≃";
    var simg = "⪞";
    var simgE = "⪠";
    var siml = "⪝";
    var simlE = "⪟";
    var simne = "≆";
    var simplus = "⨤";
    var simrarr = "⥲";
    var slarr = "←";
    var SmallCircle = "∘";
    var smallsetminus = "∖";
    var smashp = "⨳";
    var smeparsl = "⧤";
    var smid = "∣";
    var smile = "⌣";
    var smt = "⪪";
    var smte = "⪬";
    var smtes = "⪬︀";
    var SOFTcy = "Ь";
    var softcy = "ь";
    var solbar = "⌿";
    var solb = "⧄";
    var sol = "/";
    var Sopf = "𝕊";
    var sopf = "𝕤";
    var spades = "♠";
    var spadesuit = "♠";
    var spar = "∥";
    var sqcap = "⊓";
    var sqcaps = "⊓︀";
    var sqcup = "⊔";
    var sqcups = "⊔︀";
    var Sqrt = "√";
    var sqsub = "⊏";
    var sqsube = "⊑";
    var sqsubset = "⊏";
    var sqsubseteq = "⊑";
    var sqsup = "⊐";
    var sqsupe = "⊒";
    var sqsupset = "⊐";
    var sqsupseteq = "⊒";
    var square = "□";
    var Square = "□";
    var SquareIntersection = "⊓";
    var SquareSubset = "⊏";
    var SquareSubsetEqual = "⊑";
    var SquareSuperset = "⊐";
    var SquareSupersetEqual = "⊒";
    var SquareUnion = "⊔";
    var squarf = "▪";
    var squ = "□";
    var squf = "▪";
    var srarr = "→";
    var Sscr = "𝒮";
    var sscr = "𝓈";
    var ssetmn = "∖";
    var ssmile = "⌣";
    var sstarf = "⋆";
    var Star = "⋆";
    var star = "☆";
    var starf = "★";
    var straightepsilon = "ϵ";
    var straightphi = "ϕ";
    var strns = "¯";
    var sub = "⊂";
    var Sub = "⋐";
    var subdot = "⪽";
    var subE = "⫅";
    var sube = "⊆";
    var subedot = "⫃";
    var submult = "⫁";
    var subnE = "⫋";
    var subne = "⊊";
    var subplus = "⪿";
    var subrarr = "⥹";
    var subset = "⊂";
    var Subset = "⋐";
    var subseteq = "⊆";
    var subseteqq = "⫅";
    var SubsetEqual = "⊆";
    var subsetneq = "⊊";
    var subsetneqq = "⫋";
    var subsim = "⫇";
    var subsub = "⫕";
    var subsup = "⫓";
    var succapprox = "⪸";
    var succ = "≻";
    var succcurlyeq = "≽";
    var Succeeds = "≻";
    var SucceedsEqual = "⪰";
    var SucceedsSlantEqual = "≽";
    var SucceedsTilde = "≿";
    var succeq = "⪰";
    var succnapprox = "⪺";
    var succneqq = "⪶";
    var succnsim = "⋩";
    var succsim = "≿";
    var SuchThat = "∋";
    var sum = "∑";
    var Sum = "∑";
    var sung = "♪";
    var sup1 = "¹";
    var sup2 = "²";
    var sup3 = "³";
    var sup = "⊃";
    var Sup = "⋑";
    var supdot = "⪾";
    var supdsub = "⫘";
    var supE = "⫆";
    var supe = "⊇";
    var supedot = "⫄";
    var Superset = "⊃";
    var SupersetEqual = "⊇";
    var suphsol = "⟉";
    var suphsub = "⫗";
    var suplarr = "⥻";
    var supmult = "⫂";
    var supnE = "⫌";
    var supne = "⊋";
    var supplus = "⫀";
    var supset = "⊃";
    var Supset = "⋑";
    var supseteq = "⊇";
    var supseteqq = "⫆";
    var supsetneq = "⊋";
    var supsetneqq = "⫌";
    var supsim = "⫈";
    var supsub = "⫔";
    var supsup = "⫖";
    var swarhk = "⤦";
    var swarr = "↙";
    var swArr = "⇙";
    var swarrow = "↙";
    var swnwar = "⤪";
    var szlig = "ß";
    var Tab = "\t";
    var target = "⌖";
    var Tau = "Τ";
    var tau = "τ";
    var tbrk = "⎴";
    var Tcaron = "Ť";
    var tcaron = "ť";
    var Tcedil = "Ţ";
    var tcedil = "ţ";
    var Tcy = "Т";
    var tcy = "т";
    var tdot = "⃛";
    var telrec = "⌕";
    var Tfr = "𝔗";
    var tfr = "𝔱";
    var there4 = "∴";
    var therefore = "∴";
    var Therefore = "∴";
    var Theta = "Θ";
    var theta = "θ";
    var thetasym = "ϑ";
    var thetav = "ϑ";
    var thickapprox = "≈";
    var thicksim = "∼";
    var ThickSpace = "  ";
    var ThinSpace = " ";
    var thinsp = " ";
    var thkap = "≈";
    var thksim = "∼";
    var THORN = "Þ";
    var thorn = "þ";
    var tilde = "˜";
    var Tilde = "∼";
    var TildeEqual = "≃";
    var TildeFullEqual = "≅";
    var TildeTilde = "≈";
    var timesbar = "⨱";
    var timesb = "⊠";
    var times = "×";
    var timesd = "⨰";
    var tint = "∭";
    var toea = "⤨";
    var topbot = "⌶";
    var topcir = "⫱";
    var top = "⊤";
    var Topf = "𝕋";
    var topf = "𝕥";
    var topfork = "⫚";
    var tosa = "⤩";
    var tprime = "‴";
    var trade = "™";
    var TRADE = "™";
    var triangle = "▵";
    var triangledown = "▿";
    var triangleleft = "◃";
    var trianglelefteq = "⊴";
    var triangleq = "≜";
    var triangleright = "▹";
    var trianglerighteq = "⊵";
    var tridot = "◬";
    var trie = "≜";
    var triminus = "⨺";
    var TripleDot = "⃛";
    var triplus = "⨹";
    var trisb = "⧍";
    var tritime = "⨻";
    var trpezium = "⏢";
    var Tscr = "𝒯";
    var tscr = "𝓉";
    var TScy = "Ц";
    var tscy = "ц";
    var TSHcy = "Ћ";
    var tshcy = "ћ";
    var Tstrok = "Ŧ";
    var tstrok = "ŧ";
    var twixt = "≬";
    var twoheadleftarrow = "↞";
    var twoheadrightarrow = "↠";
    var Uacute = "Ú";
    var uacute = "ú";
    var uarr = "↑";
    var Uarr = "↟";
    var uArr = "⇑";
    var Uarrocir = "⥉";
    var Ubrcy = "Ў";
    var ubrcy = "ў";
    var Ubreve = "Ŭ";
    var ubreve = "ŭ";
    var Ucirc = "Û";
    var ucirc = "û";
    var Ucy = "У";
    var ucy = "у";
    var udarr = "⇅";
    var Udblac = "Ű";
    var udblac = "ű";
    var udhar = "⥮";
    var ufisht = "⥾";
    var Ufr = "𝔘";
    var ufr = "𝔲";
    var Ugrave = "Ù";
    var ugrave = "ù";
    var uHar = "⥣";
    var uharl = "↿";
    var uharr = "↾";
    var uhblk = "▀";
    var ulcorn = "⌜";
    var ulcorner = "⌜";
    var ulcrop = "⌏";
    var ultri = "◸";
    var Umacr = "Ū";
    var umacr = "ū";
    var uml = "¨";
    var UnderBar = "_";
    var UnderBrace = "⏟";
    var UnderBracket = "⎵";
    var UnderParenthesis = "⏝";
    var Union = "⋃";
    var UnionPlus = "⊎";
    var Uogon = "Ų";
    var uogon = "ų";
    var Uopf = "𝕌";
    var uopf = "𝕦";
    var UpArrowBar = "⤒";
    var uparrow = "↑";
    var UpArrow = "↑";
    var Uparrow = "⇑";
    var UpArrowDownArrow = "⇅";
    var updownarrow = "↕";
    var UpDownArrow = "↕";
    var Updownarrow = "⇕";
    var UpEquilibrium = "⥮";
    var upharpoonleft = "↿";
    var upharpoonright = "↾";
    var uplus = "⊎";
    var UpperLeftArrow = "↖";
    var UpperRightArrow = "↗";
    var upsi = "υ";
    var Upsi = "ϒ";
    var upsih = "ϒ";
    var Upsilon = "Υ";
    var upsilon = "υ";
    var UpTeeArrow = "↥";
    var UpTee = "⊥";
    var upuparrows = "⇈";
    var urcorn = "⌝";
    var urcorner = "⌝";
    var urcrop = "⌎";
    var Uring = "Ů";
    var uring = "ů";
    var urtri = "◹";
    var Uscr = "𝒰";
    var uscr = "𝓊";
    var utdot = "⋰";
    var Utilde = "Ũ";
    var utilde = "ũ";
    var utri = "▵";
    var utrif = "▴";
    var uuarr = "⇈";
    var Uuml = "Ü";
    var uuml = "ü";
    var uwangle = "⦧";
    var vangrt = "⦜";
    var varepsilon = "ϵ";
    var varkappa = "ϰ";
    var varnothing = "∅";
    var varphi = "ϕ";
    var varpi = "ϖ";
    var varpropto = "∝";
    var varr = "↕";
    var vArr = "⇕";
    var varrho = "ϱ";
    var varsigma = "ς";
    var varsubsetneq = "⊊︀";
    var varsubsetneqq = "⫋︀";
    var varsupsetneq = "⊋︀";
    var varsupsetneqq = "⫌︀";
    var vartheta = "ϑ";
    var vartriangleleft = "⊲";
    var vartriangleright = "⊳";
    var vBar = "⫨";
    var Vbar = "⫫";
    var vBarv = "⫩";
    var Vcy = "В";
    var vcy = "в";
    var vdash = "⊢";
    var vDash = "⊨";
    var Vdash = "⊩";
    var VDash = "⊫";
    var Vdashl = "⫦";
    var veebar = "⊻";
    var vee = "∨";
    var Vee = "⋁";
    var veeeq = "≚";
    var vellip = "⋮";
    var verbar = "|";
    var Verbar = "‖";
    var vert = "|";
    var Vert = "‖";
    var VerticalBar = "∣";
    var VerticalLine = "|";
    var VerticalSeparator = "❘";
    var VerticalTilde = "≀";
    var VeryThinSpace = " ";
    var Vfr = "𝔙";
    var vfr = "𝔳";
    var vltri = "⊲";
    var vnsub = "⊂⃒";
    var vnsup = "⊃⃒";
    var Vopf = "𝕍";
    var vopf = "𝕧";
    var vprop = "∝";
    var vrtri = "⊳";
    var Vscr = "𝒱";
    var vscr = "𝓋";
    var vsubnE = "⫋︀";
    var vsubne = "⊊︀";
    var vsupnE = "⫌︀";
    var vsupne = "⊋︀";
    var Vvdash = "⊪";
    var vzigzag = "⦚";
    var Wcirc = "Ŵ";
    var wcirc = "ŵ";
    var wedbar = "⩟";
    var wedge = "∧";
    var Wedge = "⋀";
    var wedgeq = "≙";
    var weierp = "℘";
    var Wfr = "𝔚";
    var wfr = "𝔴";
    var Wopf = "𝕎";
    var wopf = "𝕨";
    var wp = "℘";
    var wr = "≀";
    var wreath = "≀";
    var Wscr = "𝒲";
    var wscr = "𝓌";
    var xcap = "⋂";
    var xcirc = "◯";
    var xcup = "⋃";
    var xdtri = "▽";
    var Xfr = "𝔛";
    var xfr = "𝔵";
    var xharr = "⟷";
    var xhArr = "⟺";
    var Xi = "Ξ";
    var xi = "ξ";
    var xlarr = "⟵";
    var xlArr = "⟸";
    var xmap = "⟼";
    var xnis = "⋻";
    var xodot = "⨀";
    var Xopf = "𝕏";
    var xopf = "𝕩";
    var xoplus = "⨁";
    var xotime = "⨂";
    var xrarr = "⟶";
    var xrArr = "⟹";
    var Xscr = "𝒳";
    var xscr = "𝓍";
    var xsqcup = "⨆";
    var xuplus = "⨄";
    var xutri = "△";
    var xvee = "⋁";
    var xwedge = "⋀";
    var Yacute = "Ý";
    var yacute = "ý";
    var YAcy = "Я";
    var yacy = "я";
    var Ycirc = "Ŷ";
    var ycirc = "ŷ";
    var Ycy = "Ы";
    var ycy = "ы";
    var yen = "¥";
    var Yfr = "𝔜";
    var yfr = "𝔶";
    var YIcy = "Ї";
    var yicy = "ї";
    var Yopf = "𝕐";
    var yopf = "𝕪";
    var Yscr = "𝒴";
    var yscr = "𝓎";
    var YUcy = "Ю";
    var yucy = "ю";
    var yuml = "ÿ";
    var Yuml = "Ÿ";
    var Zacute = "Ź";
    var zacute = "ź";
    var Zcaron = "Ž";
    var zcaron = "ž";
    var Zcy = "З";
    var zcy = "з";
    var Zdot = "Ż";
    var zdot = "ż";
    var zeetrf = "ℨ";
    var ZeroWidthSpace = "​";
    var Zeta = "Ζ";
    var zeta = "ζ";
    var zfr = "𝔷";
    var Zfr = "ℨ";
    var ZHcy = "Ж";
    var zhcy = "ж";
    var zigrarr = "⇝";
    var zopf = "𝕫";
    var Zopf = "ℤ";
    var Zscr = "𝒵";
    var zscr = "𝓏";
    var zwj = "‍";
    var zwnj = "‌";
    var entities = {
    	Aacute: Aacute,
    	aacute: aacute,
    	Abreve: Abreve,
    	abreve: abreve,
    	ac: ac,
    	acd: acd,
    	acE: acE,
    	Acirc: Acirc,
    	acirc: acirc,
    	acute: acute,
    	Acy: Acy,
    	acy: acy,
    	AElig: AElig,
    	aelig: aelig,
    	af: af,
    	Afr: Afr,
    	afr: afr,
    	Agrave: Agrave,
    	agrave: agrave,
    	alefsym: alefsym,
    	aleph: aleph,
    	Alpha: Alpha,
    	alpha: alpha,
    	Amacr: Amacr,
    	amacr: amacr,
    	amalg: amalg,
    	amp: amp,
    	AMP: AMP,
    	andand: andand,
    	And: And,
    	and: and,
    	andd: andd,
    	andslope: andslope,
    	andv: andv,
    	ang: ang,
    	ange: ange,
    	angle: angle,
    	angmsdaa: angmsdaa,
    	angmsdab: angmsdab,
    	angmsdac: angmsdac,
    	angmsdad: angmsdad,
    	angmsdae: angmsdae,
    	angmsdaf: angmsdaf,
    	angmsdag: angmsdag,
    	angmsdah: angmsdah,
    	angmsd: angmsd,
    	angrt: angrt,
    	angrtvb: angrtvb,
    	angrtvbd: angrtvbd,
    	angsph: angsph,
    	angst: angst,
    	angzarr: angzarr,
    	Aogon: Aogon,
    	aogon: aogon,
    	Aopf: Aopf,
    	aopf: aopf,
    	apacir: apacir,
    	ap: ap,
    	apE: apE,
    	ape: ape,
    	apid: apid,
    	apos: apos,
    	ApplyFunction: ApplyFunction,
    	approx: approx,
    	approxeq: approxeq,
    	Aring: Aring,
    	aring: aring,
    	Ascr: Ascr,
    	ascr: ascr,
    	Assign: Assign,
    	ast: ast,
    	asymp: asymp,
    	asympeq: asympeq,
    	Atilde: Atilde,
    	atilde: atilde,
    	Auml: Auml,
    	auml: auml,
    	awconint: awconint,
    	awint: awint,
    	backcong: backcong,
    	backepsilon: backepsilon,
    	backprime: backprime,
    	backsim: backsim,
    	backsimeq: backsimeq,
    	Backslash: Backslash,
    	Barv: Barv,
    	barvee: barvee,
    	barwed: barwed,
    	Barwed: Barwed,
    	barwedge: barwedge,
    	bbrk: bbrk,
    	bbrktbrk: bbrktbrk,
    	bcong: bcong,
    	Bcy: Bcy,
    	bcy: bcy,
    	bdquo: bdquo,
    	becaus: becaus,
    	because: because,
    	Because: Because,
    	bemptyv: bemptyv,
    	bepsi: bepsi,
    	bernou: bernou,
    	Bernoullis: Bernoullis,
    	Beta: Beta,
    	beta: beta,
    	beth: beth,
    	between: between,
    	Bfr: Bfr,
    	bfr: bfr,
    	bigcap: bigcap,
    	bigcirc: bigcirc,
    	bigcup: bigcup,
    	bigodot: bigodot,
    	bigoplus: bigoplus,
    	bigotimes: bigotimes,
    	bigsqcup: bigsqcup,
    	bigstar: bigstar,
    	bigtriangledown: bigtriangledown,
    	bigtriangleup: bigtriangleup,
    	biguplus: biguplus,
    	bigvee: bigvee,
    	bigwedge: bigwedge,
    	bkarow: bkarow,
    	blacklozenge: blacklozenge,
    	blacksquare: blacksquare,
    	blacktriangle: blacktriangle,
    	blacktriangledown: blacktriangledown,
    	blacktriangleleft: blacktriangleleft,
    	blacktriangleright: blacktriangleright,
    	blank: blank,
    	blk12: blk12,
    	blk14: blk14,
    	blk34: blk34,
    	block: block,
    	bne: bne,
    	bnequiv: bnequiv,
    	bNot: bNot,
    	bnot: bnot,
    	Bopf: Bopf,
    	bopf: bopf,
    	bot: bot,
    	bottom: bottom,
    	bowtie: bowtie,
    	boxbox: boxbox,
    	boxdl: boxdl,
    	boxdL: boxdL,
    	boxDl: boxDl,
    	boxDL: boxDL,
    	boxdr: boxdr,
    	boxdR: boxdR,
    	boxDr: boxDr,
    	boxDR: boxDR,
    	boxh: boxh,
    	boxH: boxH,
    	boxhd: boxhd,
    	boxHd: boxHd,
    	boxhD: boxhD,
    	boxHD: boxHD,
    	boxhu: boxhu,
    	boxHu: boxHu,
    	boxhU: boxhU,
    	boxHU: boxHU,
    	boxminus: boxminus,
    	boxplus: boxplus,
    	boxtimes: boxtimes,
    	boxul: boxul,
    	boxuL: boxuL,
    	boxUl: boxUl,
    	boxUL: boxUL,
    	boxur: boxur,
    	boxuR: boxuR,
    	boxUr: boxUr,
    	boxUR: boxUR,
    	boxv: boxv,
    	boxV: boxV,
    	boxvh: boxvh,
    	boxvH: boxvH,
    	boxVh: boxVh,
    	boxVH: boxVH,
    	boxvl: boxvl,
    	boxvL: boxvL,
    	boxVl: boxVl,
    	boxVL: boxVL,
    	boxvr: boxvr,
    	boxvR: boxvR,
    	boxVr: boxVr,
    	boxVR: boxVR,
    	bprime: bprime,
    	breve: breve,
    	Breve: Breve,
    	brvbar: brvbar,
    	bscr: bscr,
    	Bscr: Bscr,
    	bsemi: bsemi,
    	bsim: bsim,
    	bsime: bsime,
    	bsolb: bsolb,
    	bsol: bsol,
    	bsolhsub: bsolhsub,
    	bull: bull,
    	bullet: bullet,
    	bump: bump,
    	bumpE: bumpE,
    	bumpe: bumpe,
    	Bumpeq: Bumpeq,
    	bumpeq: bumpeq,
    	Cacute: Cacute,
    	cacute: cacute,
    	capand: capand,
    	capbrcup: capbrcup,
    	capcap: capcap,
    	cap: cap,
    	Cap: Cap,
    	capcup: capcup,
    	capdot: capdot,
    	CapitalDifferentialD: CapitalDifferentialD,
    	caps: caps,
    	caret: caret,
    	caron: caron,
    	Cayleys: Cayleys,
    	ccaps: ccaps,
    	Ccaron: Ccaron,
    	ccaron: ccaron,
    	Ccedil: Ccedil,
    	ccedil: ccedil,
    	Ccirc: Ccirc,
    	ccirc: ccirc,
    	Cconint: Cconint,
    	ccups: ccups,
    	ccupssm: ccupssm,
    	Cdot: Cdot,
    	cdot: cdot,
    	cedil: cedil,
    	Cedilla: Cedilla,
    	cemptyv: cemptyv,
    	cent: cent,
    	centerdot: centerdot,
    	CenterDot: CenterDot,
    	cfr: cfr,
    	Cfr: Cfr,
    	CHcy: CHcy,
    	chcy: chcy,
    	check: check,
    	checkmark: checkmark,
    	Chi: Chi,
    	chi: chi,
    	circ: circ,
    	circeq: circeq,
    	circlearrowleft: circlearrowleft,
    	circlearrowright: circlearrowright,
    	circledast: circledast,
    	circledcirc: circledcirc,
    	circleddash: circleddash,
    	CircleDot: CircleDot,
    	circledR: circledR,
    	circledS: circledS,
    	CircleMinus: CircleMinus,
    	CirclePlus: CirclePlus,
    	CircleTimes: CircleTimes,
    	cir: cir,
    	cirE: cirE,
    	cire: cire,
    	cirfnint: cirfnint,
    	cirmid: cirmid,
    	cirscir: cirscir,
    	ClockwiseContourIntegral: ClockwiseContourIntegral,
    	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
    	CloseCurlyQuote: CloseCurlyQuote,
    	clubs: clubs,
    	clubsuit: clubsuit,
    	colon: colon,
    	Colon: Colon,
    	Colone: Colone,
    	colone: colone,
    	coloneq: coloneq,
    	comma: comma,
    	commat: commat,
    	comp: comp,
    	compfn: compfn,
    	complement: complement,
    	complexes: complexes,
    	cong: cong,
    	congdot: congdot,
    	Congruent: Congruent,
    	conint: conint,
    	Conint: Conint,
    	ContourIntegral: ContourIntegral,
    	copf: copf,
    	Copf: Copf,
    	coprod: coprod,
    	Coproduct: Coproduct,
    	copy: copy,
    	COPY: COPY$1,
    	copysr: copysr,
    	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
    	crarr: crarr,
    	cross: cross,
    	Cross: Cross,
    	Cscr: Cscr,
    	cscr: cscr,
    	csub: csub,
    	csube: csube,
    	csup: csup,
    	csupe: csupe,
    	ctdot: ctdot,
    	cudarrl: cudarrl,
    	cudarrr: cudarrr,
    	cuepr: cuepr,
    	cuesc: cuesc,
    	cularr: cularr,
    	cularrp: cularrp,
    	cupbrcap: cupbrcap,
    	cupcap: cupcap,
    	CupCap: CupCap,
    	cup: cup,
    	Cup: Cup,
    	cupcup: cupcup,
    	cupdot: cupdot,
    	cupor: cupor,
    	cups: cups,
    	curarr: curarr,
    	curarrm: curarrm,
    	curlyeqprec: curlyeqprec,
    	curlyeqsucc: curlyeqsucc,
    	curlyvee: curlyvee,
    	curlywedge: curlywedge,
    	curren: curren,
    	curvearrowleft: curvearrowleft,
    	curvearrowright: curvearrowright,
    	cuvee: cuvee,
    	cuwed: cuwed,
    	cwconint: cwconint,
    	cwint: cwint,
    	cylcty: cylcty,
    	dagger: dagger,
    	Dagger: Dagger,
    	daleth: daleth,
    	darr: darr,
    	Darr: Darr,
    	dArr: dArr,
    	dash: dash,
    	Dashv: Dashv,
    	dashv: dashv,
    	dbkarow: dbkarow,
    	dblac: dblac,
    	Dcaron: Dcaron,
    	dcaron: dcaron,
    	Dcy: Dcy,
    	dcy: dcy,
    	ddagger: ddagger,
    	ddarr: ddarr,
    	DD: DD,
    	dd: dd,
    	DDotrahd: DDotrahd,
    	ddotseq: ddotseq,
    	deg: deg,
    	Del: Del,
    	Delta: Delta,
    	delta: delta,
    	demptyv: demptyv,
    	dfisht: dfisht,
    	Dfr: Dfr,
    	dfr: dfr,
    	dHar: dHar,
    	dharl: dharl,
    	dharr: dharr,
    	DiacriticalAcute: DiacriticalAcute,
    	DiacriticalDot: DiacriticalDot,
    	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
    	DiacriticalGrave: DiacriticalGrave,
    	DiacriticalTilde: DiacriticalTilde,
    	diam: diam,
    	diamond: diamond,
    	Diamond: Diamond,
    	diamondsuit: diamondsuit,
    	diams: diams,
    	die: die,
    	DifferentialD: DifferentialD,
    	digamma: digamma,
    	disin: disin,
    	div: div,
    	divide: divide,
    	divideontimes: divideontimes,
    	divonx: divonx,
    	DJcy: DJcy,
    	djcy: djcy,
    	dlcorn: dlcorn,
    	dlcrop: dlcrop,
    	dollar: dollar,
    	Dopf: Dopf,
    	dopf: dopf,
    	Dot: Dot,
    	dot: dot,
    	DotDot: DotDot,
    	doteq: doteq,
    	doteqdot: doteqdot,
    	DotEqual: DotEqual,
    	dotminus: dotminus,
    	dotplus: dotplus,
    	dotsquare: dotsquare,
    	doublebarwedge: doublebarwedge,
    	DoubleContourIntegral: DoubleContourIntegral,
    	DoubleDot: DoubleDot,
    	DoubleDownArrow: DoubleDownArrow,
    	DoubleLeftArrow: DoubleLeftArrow,
    	DoubleLeftRightArrow: DoubleLeftRightArrow,
    	DoubleLeftTee: DoubleLeftTee,
    	DoubleLongLeftArrow: DoubleLongLeftArrow,
    	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
    	DoubleLongRightArrow: DoubleLongRightArrow,
    	DoubleRightArrow: DoubleRightArrow,
    	DoubleRightTee: DoubleRightTee,
    	DoubleUpArrow: DoubleUpArrow,
    	DoubleUpDownArrow: DoubleUpDownArrow,
    	DoubleVerticalBar: DoubleVerticalBar,
    	DownArrowBar: DownArrowBar,
    	downarrow: downarrow,
    	DownArrow: DownArrow,
    	Downarrow: Downarrow,
    	DownArrowUpArrow: DownArrowUpArrow,
    	DownBreve: DownBreve,
    	downdownarrows: downdownarrows,
    	downharpoonleft: downharpoonleft,
    	downharpoonright: downharpoonright,
    	DownLeftRightVector: DownLeftRightVector,
    	DownLeftTeeVector: DownLeftTeeVector,
    	DownLeftVectorBar: DownLeftVectorBar,
    	DownLeftVector: DownLeftVector,
    	DownRightTeeVector: DownRightTeeVector,
    	DownRightVectorBar: DownRightVectorBar,
    	DownRightVector: DownRightVector,
    	DownTeeArrow: DownTeeArrow,
    	DownTee: DownTee,
    	drbkarow: drbkarow,
    	drcorn: drcorn,
    	drcrop: drcrop,
    	Dscr: Dscr,
    	dscr: dscr,
    	DScy: DScy,
    	dscy: dscy,
    	dsol: dsol,
    	Dstrok: Dstrok,
    	dstrok: dstrok,
    	dtdot: dtdot,
    	dtri: dtri,
    	dtrif: dtrif,
    	duarr: duarr,
    	duhar: duhar,
    	dwangle: dwangle,
    	DZcy: DZcy,
    	dzcy: dzcy,
    	dzigrarr: dzigrarr,
    	Eacute: Eacute,
    	eacute: eacute,
    	easter: easter,
    	Ecaron: Ecaron,
    	ecaron: ecaron,
    	Ecirc: Ecirc,
    	ecirc: ecirc,
    	ecir: ecir,
    	ecolon: ecolon,
    	Ecy: Ecy,
    	ecy: ecy,
    	eDDot: eDDot,
    	Edot: Edot,
    	edot: edot,
    	eDot: eDot,
    	ee: ee,
    	efDot: efDot,
    	Efr: Efr,
    	efr: efr,
    	eg: eg,
    	Egrave: Egrave,
    	egrave: egrave,
    	egs: egs,
    	egsdot: egsdot,
    	el: el,
    	Element: Element,
    	elinters: elinters,
    	ell: ell,
    	els: els,
    	elsdot: elsdot,
    	Emacr: Emacr,
    	emacr: emacr,
    	empty: empty,
    	emptyset: emptyset,
    	EmptySmallSquare: EmptySmallSquare,
    	emptyv: emptyv,
    	EmptyVerySmallSquare: EmptyVerySmallSquare,
    	emsp13: emsp13,
    	emsp14: emsp14,
    	emsp: emsp,
    	ENG: ENG,
    	eng: eng,
    	ensp: ensp,
    	Eogon: Eogon,
    	eogon: eogon,
    	Eopf: Eopf,
    	eopf: eopf,
    	epar: epar,
    	eparsl: eparsl,
    	eplus: eplus,
    	epsi: epsi,
    	Epsilon: Epsilon,
    	epsilon: epsilon,
    	epsiv: epsiv,
    	eqcirc: eqcirc,
    	eqcolon: eqcolon,
    	eqsim: eqsim,
    	eqslantgtr: eqslantgtr,
    	eqslantless: eqslantless,
    	Equal: Equal,
    	equals: equals,
    	EqualTilde: EqualTilde,
    	equest: equest,
    	Equilibrium: Equilibrium,
    	equiv: equiv,
    	equivDD: equivDD,
    	eqvparsl: eqvparsl,
    	erarr: erarr,
    	erDot: erDot,
    	escr: escr,
    	Escr: Escr,
    	esdot: esdot,
    	Esim: Esim,
    	esim: esim,
    	Eta: Eta,
    	eta: eta,
    	ETH: ETH,
    	eth: eth,
    	Euml: Euml,
    	euml: euml,
    	euro: euro,
    	excl: excl,
    	exist: exist,
    	Exists: Exists,
    	expectation: expectation,
    	exponentiale: exponentiale,
    	ExponentialE: ExponentialE,
    	fallingdotseq: fallingdotseq,
    	Fcy: Fcy,
    	fcy: fcy,
    	female: female,
    	ffilig: ffilig,
    	fflig: fflig,
    	ffllig: ffllig,
    	Ffr: Ffr,
    	ffr: ffr,
    	filig: filig,
    	FilledSmallSquare: FilledSmallSquare,
    	FilledVerySmallSquare: FilledVerySmallSquare,
    	fjlig: fjlig,
    	flat: flat,
    	fllig: fllig,
    	fltns: fltns,
    	fnof: fnof,
    	Fopf: Fopf,
    	fopf: fopf,
    	forall: forall,
    	ForAll: ForAll,
    	fork: fork,
    	forkv: forkv,
    	Fouriertrf: Fouriertrf,
    	fpartint: fpartint,
    	frac12: frac12,
    	frac13: frac13,
    	frac14: frac14,
    	frac15: frac15,
    	frac16: frac16,
    	frac18: frac18,
    	frac23: frac23,
    	frac25: frac25,
    	frac34: frac34,
    	frac35: frac35,
    	frac38: frac38,
    	frac45: frac45,
    	frac56: frac56,
    	frac58: frac58,
    	frac78: frac78,
    	frasl: frasl,
    	frown: frown,
    	fscr: fscr,
    	Fscr: Fscr,
    	gacute: gacute,
    	Gamma: Gamma,
    	gamma: gamma,
    	Gammad: Gammad,
    	gammad: gammad,
    	gap: gap,
    	Gbreve: Gbreve,
    	gbreve: gbreve,
    	Gcedil: Gcedil,
    	Gcirc: Gcirc,
    	gcirc: gcirc,
    	Gcy: Gcy,
    	gcy: gcy,
    	Gdot: Gdot,
    	gdot: gdot,
    	ge: ge,
    	gE: gE,
    	gEl: gEl,
    	gel: gel,
    	geq: geq,
    	geqq: geqq,
    	geqslant: geqslant,
    	gescc: gescc,
    	ges: ges,
    	gesdot: gesdot,
    	gesdoto: gesdoto,
    	gesdotol: gesdotol,
    	gesl: gesl,
    	gesles: gesles,
    	Gfr: Gfr,
    	gfr: gfr,
    	gg: gg,
    	Gg: Gg,
    	ggg: ggg,
    	gimel: gimel,
    	GJcy: GJcy,
    	gjcy: gjcy,
    	gla: gla,
    	gl: gl,
    	glE: glE,
    	glj: glj,
    	gnap: gnap,
    	gnapprox: gnapprox,
    	gne: gne,
    	gnE: gnE,
    	gneq: gneq,
    	gneqq: gneqq,
    	gnsim: gnsim,
    	Gopf: Gopf,
    	gopf: gopf,
    	grave: grave,
    	GreaterEqual: GreaterEqual,
    	GreaterEqualLess: GreaterEqualLess,
    	GreaterFullEqual: GreaterFullEqual,
    	GreaterGreater: GreaterGreater,
    	GreaterLess: GreaterLess,
    	GreaterSlantEqual: GreaterSlantEqual,
    	GreaterTilde: GreaterTilde,
    	Gscr: Gscr,
    	gscr: gscr,
    	gsim: gsim,
    	gsime: gsime,
    	gsiml: gsiml,
    	gtcc: gtcc,
    	gtcir: gtcir,
    	gt: gt,
    	GT: GT,
    	Gt: Gt,
    	gtdot: gtdot,
    	gtlPar: gtlPar,
    	gtquest: gtquest,
    	gtrapprox: gtrapprox,
    	gtrarr: gtrarr,
    	gtrdot: gtrdot,
    	gtreqless: gtreqless,
    	gtreqqless: gtreqqless,
    	gtrless: gtrless,
    	gtrsim: gtrsim,
    	gvertneqq: gvertneqq,
    	gvnE: gvnE,
    	Hacek: Hacek,
    	hairsp: hairsp,
    	half: half,
    	hamilt: hamilt,
    	HARDcy: HARDcy,
    	hardcy: hardcy,
    	harrcir: harrcir,
    	harr: harr,
    	hArr: hArr,
    	harrw: harrw,
    	Hat: Hat,
    	hbar: hbar,
    	Hcirc: Hcirc,
    	hcirc: hcirc,
    	hearts: hearts,
    	heartsuit: heartsuit,
    	hellip: hellip,
    	hercon: hercon,
    	hfr: hfr,
    	Hfr: Hfr,
    	HilbertSpace: HilbertSpace,
    	hksearow: hksearow,
    	hkswarow: hkswarow,
    	hoarr: hoarr,
    	homtht: homtht,
    	hookleftarrow: hookleftarrow,
    	hookrightarrow: hookrightarrow,
    	hopf: hopf,
    	Hopf: Hopf,
    	horbar: horbar,
    	HorizontalLine: HorizontalLine,
    	hscr: hscr,
    	Hscr: Hscr,
    	hslash: hslash,
    	Hstrok: Hstrok,
    	hstrok: hstrok,
    	HumpDownHump: HumpDownHump,
    	HumpEqual: HumpEqual,
    	hybull: hybull,
    	hyphen: hyphen,
    	Iacute: Iacute,
    	iacute: iacute,
    	ic: ic,
    	Icirc: Icirc,
    	icirc: icirc,
    	Icy: Icy,
    	icy: icy,
    	Idot: Idot,
    	IEcy: IEcy,
    	iecy: iecy,
    	iexcl: iexcl,
    	iff: iff,
    	ifr: ifr,
    	Ifr: Ifr,
    	Igrave: Igrave,
    	igrave: igrave,
    	ii: ii,
    	iiiint: iiiint,
    	iiint: iiint,
    	iinfin: iinfin,
    	iiota: iiota,
    	IJlig: IJlig,
    	ijlig: ijlig,
    	Imacr: Imacr,
    	imacr: imacr,
    	image: image,
    	ImaginaryI: ImaginaryI,
    	imagline: imagline,
    	imagpart: imagpart,
    	imath: imath,
    	Im: Im,
    	imof: imof,
    	imped: imped,
    	Implies: Implies,
    	incare: incare,
    	"in": "∈",
    	infin: infin,
    	infintie: infintie,
    	inodot: inodot,
    	intcal: intcal,
    	int: int,
    	Int: Int,
    	integers: integers,
    	Integral: Integral,
    	intercal: intercal,
    	Intersection: Intersection,
    	intlarhk: intlarhk,
    	intprod: intprod,
    	InvisibleComma: InvisibleComma,
    	InvisibleTimes: InvisibleTimes,
    	IOcy: IOcy,
    	iocy: iocy,
    	Iogon: Iogon,
    	iogon: iogon,
    	Iopf: Iopf,
    	iopf: iopf,
    	Iota: Iota,
    	iota: iota,
    	iprod: iprod,
    	iquest: iquest,
    	iscr: iscr,
    	Iscr: Iscr,
    	isin: isin,
    	isindot: isindot,
    	isinE: isinE,
    	isins: isins,
    	isinsv: isinsv,
    	isinv: isinv,
    	it: it,
    	Itilde: Itilde,
    	itilde: itilde,
    	Iukcy: Iukcy,
    	iukcy: iukcy,
    	Iuml: Iuml,
    	iuml: iuml,
    	Jcirc: Jcirc,
    	jcirc: jcirc,
    	Jcy: Jcy,
    	jcy: jcy,
    	Jfr: Jfr,
    	jfr: jfr,
    	jmath: jmath,
    	Jopf: Jopf,
    	jopf: jopf,
    	Jscr: Jscr,
    	jscr: jscr,
    	Jsercy: Jsercy,
    	jsercy: jsercy,
    	Jukcy: Jukcy,
    	jukcy: jukcy,
    	Kappa: Kappa,
    	kappa: kappa,
    	kappav: kappav,
    	Kcedil: Kcedil,
    	kcedil: kcedil,
    	Kcy: Kcy,
    	kcy: kcy,
    	Kfr: Kfr,
    	kfr: kfr,
    	kgreen: kgreen,
    	KHcy: KHcy,
    	khcy: khcy,
    	KJcy: KJcy,
    	kjcy: kjcy,
    	Kopf: Kopf,
    	kopf: kopf,
    	Kscr: Kscr,
    	kscr: kscr,
    	lAarr: lAarr,
    	Lacute: Lacute,
    	lacute: lacute,
    	laemptyv: laemptyv,
    	lagran: lagran,
    	Lambda: Lambda,
    	lambda: lambda,
    	lang: lang,
    	Lang: Lang,
    	langd: langd,
    	langle: langle,
    	lap: lap,
    	Laplacetrf: Laplacetrf,
    	laquo: laquo,
    	larrb: larrb,
    	larrbfs: larrbfs,
    	larr: larr,
    	Larr: Larr,
    	lArr: lArr,
    	larrfs: larrfs,
    	larrhk: larrhk,
    	larrlp: larrlp,
    	larrpl: larrpl,
    	larrsim: larrsim,
    	larrtl: larrtl,
    	latail: latail,
    	lAtail: lAtail,
    	lat: lat,
    	late: late,
    	lates: lates,
    	lbarr: lbarr,
    	lBarr: lBarr,
    	lbbrk: lbbrk,
    	lbrace: lbrace,
    	lbrack: lbrack,
    	lbrke: lbrke,
    	lbrksld: lbrksld,
    	lbrkslu: lbrkslu,
    	Lcaron: Lcaron,
    	lcaron: lcaron,
    	Lcedil: Lcedil,
    	lcedil: lcedil,
    	lceil: lceil,
    	lcub: lcub,
    	Lcy: Lcy,
    	lcy: lcy,
    	ldca: ldca,
    	ldquo: ldquo,
    	ldquor: ldquor,
    	ldrdhar: ldrdhar,
    	ldrushar: ldrushar,
    	ldsh: ldsh,
    	le: le,
    	lE: lE,
    	LeftAngleBracket: LeftAngleBracket,
    	LeftArrowBar: LeftArrowBar,
    	leftarrow: leftarrow,
    	LeftArrow: LeftArrow,
    	Leftarrow: Leftarrow,
    	LeftArrowRightArrow: LeftArrowRightArrow,
    	leftarrowtail: leftarrowtail,
    	LeftCeiling: LeftCeiling,
    	LeftDoubleBracket: LeftDoubleBracket,
    	LeftDownTeeVector: LeftDownTeeVector,
    	LeftDownVectorBar: LeftDownVectorBar,
    	LeftDownVector: LeftDownVector,
    	LeftFloor: LeftFloor,
    	leftharpoondown: leftharpoondown,
    	leftharpoonup: leftharpoonup,
    	leftleftarrows: leftleftarrows,
    	leftrightarrow: leftrightarrow,
    	LeftRightArrow: LeftRightArrow,
    	Leftrightarrow: Leftrightarrow,
    	leftrightarrows: leftrightarrows,
    	leftrightharpoons: leftrightharpoons,
    	leftrightsquigarrow: leftrightsquigarrow,
    	LeftRightVector: LeftRightVector,
    	LeftTeeArrow: LeftTeeArrow,
    	LeftTee: LeftTee,
    	LeftTeeVector: LeftTeeVector,
    	leftthreetimes: leftthreetimes,
    	LeftTriangleBar: LeftTriangleBar,
    	LeftTriangle: LeftTriangle,
    	LeftTriangleEqual: LeftTriangleEqual,
    	LeftUpDownVector: LeftUpDownVector,
    	LeftUpTeeVector: LeftUpTeeVector,
    	LeftUpVectorBar: LeftUpVectorBar,
    	LeftUpVector: LeftUpVector,
    	LeftVectorBar: LeftVectorBar,
    	LeftVector: LeftVector,
    	lEg: lEg,
    	leg: leg,
    	leq: leq,
    	leqq: leqq,
    	leqslant: leqslant,
    	lescc: lescc,
    	les: les,
    	lesdot: lesdot,
    	lesdoto: lesdoto,
    	lesdotor: lesdotor,
    	lesg: lesg,
    	lesges: lesges,
    	lessapprox: lessapprox,
    	lessdot: lessdot,
    	lesseqgtr: lesseqgtr,
    	lesseqqgtr: lesseqqgtr,
    	LessEqualGreater: LessEqualGreater,
    	LessFullEqual: LessFullEqual,
    	LessGreater: LessGreater,
    	lessgtr: lessgtr,
    	LessLess: LessLess,
    	lesssim: lesssim,
    	LessSlantEqual: LessSlantEqual,
    	LessTilde: LessTilde,
    	lfisht: lfisht,
    	lfloor: lfloor,
    	Lfr: Lfr,
    	lfr: lfr,
    	lg: lg,
    	lgE: lgE,
    	lHar: lHar,
    	lhard: lhard,
    	lharu: lharu,
    	lharul: lharul,
    	lhblk: lhblk,
    	LJcy: LJcy,
    	ljcy: ljcy,
    	llarr: llarr,
    	ll: ll,
    	Ll: Ll,
    	llcorner: llcorner,
    	Lleftarrow: Lleftarrow,
    	llhard: llhard,
    	lltri: lltri,
    	Lmidot: Lmidot,
    	lmidot: lmidot,
    	lmoustache: lmoustache,
    	lmoust: lmoust,
    	lnap: lnap,
    	lnapprox: lnapprox,
    	lne: lne,
    	lnE: lnE,
    	lneq: lneq,
    	lneqq: lneqq,
    	lnsim: lnsim,
    	loang: loang,
    	loarr: loarr,
    	lobrk: lobrk,
    	longleftarrow: longleftarrow,
    	LongLeftArrow: LongLeftArrow,
    	Longleftarrow: Longleftarrow,
    	longleftrightarrow: longleftrightarrow,
    	LongLeftRightArrow: LongLeftRightArrow,
    	Longleftrightarrow: Longleftrightarrow,
    	longmapsto: longmapsto,
    	longrightarrow: longrightarrow,
    	LongRightArrow: LongRightArrow,
    	Longrightarrow: Longrightarrow,
    	looparrowleft: looparrowleft,
    	looparrowright: looparrowright,
    	lopar: lopar,
    	Lopf: Lopf,
    	lopf: lopf,
    	loplus: loplus,
    	lotimes: lotimes,
    	lowast: lowast,
    	lowbar: lowbar,
    	LowerLeftArrow: LowerLeftArrow,
    	LowerRightArrow: LowerRightArrow,
    	loz: loz,
    	lozenge: lozenge,
    	lozf: lozf,
    	lpar: lpar,
    	lparlt: lparlt,
    	lrarr: lrarr,
    	lrcorner: lrcorner,
    	lrhar: lrhar,
    	lrhard: lrhard,
    	lrm: lrm,
    	lrtri: lrtri,
    	lsaquo: lsaquo,
    	lscr: lscr,
    	Lscr: Lscr,
    	lsh: lsh,
    	Lsh: Lsh,
    	lsim: lsim,
    	lsime: lsime,
    	lsimg: lsimg,
    	lsqb: lsqb,
    	lsquo: lsquo,
    	lsquor: lsquor,
    	Lstrok: Lstrok,
    	lstrok: lstrok,
    	ltcc: ltcc,
    	ltcir: ltcir,
    	lt: lt,
    	LT: LT,
    	Lt: Lt,
    	ltdot: ltdot,
    	lthree: lthree,
    	ltimes: ltimes,
    	ltlarr: ltlarr,
    	ltquest: ltquest,
    	ltri: ltri,
    	ltrie: ltrie,
    	ltrif: ltrif,
    	ltrPar: ltrPar,
    	lurdshar: lurdshar,
    	luruhar: luruhar,
    	lvertneqq: lvertneqq,
    	lvnE: lvnE,
    	macr: macr,
    	male: male,
    	malt: malt,
    	maltese: maltese,
    	"Map": "⤅",
    	map: map,
    	mapsto: mapsto,
    	mapstodown: mapstodown,
    	mapstoleft: mapstoleft,
    	mapstoup: mapstoup,
    	marker: marker,
    	mcomma: mcomma,
    	Mcy: Mcy,
    	mcy: mcy,
    	mdash: mdash,
    	mDDot: mDDot,
    	measuredangle: measuredangle,
    	MediumSpace: MediumSpace,
    	Mellintrf: Mellintrf,
    	Mfr: Mfr,
    	mfr: mfr,
    	mho: mho,
    	micro: micro,
    	midast: midast,
    	midcir: midcir,
    	mid: mid,
    	middot: middot,
    	minusb: minusb,
    	minus: minus,
    	minusd: minusd,
    	minusdu: minusdu,
    	MinusPlus: MinusPlus,
    	mlcp: mlcp,
    	mldr: mldr,
    	mnplus: mnplus,
    	models: models,
    	Mopf: Mopf,
    	mopf: mopf,
    	mp: mp,
    	mscr: mscr,
    	Mscr: Mscr,
    	mstpos: mstpos,
    	Mu: Mu,
    	mu: mu,
    	multimap: multimap,
    	mumap: mumap,
    	nabla: nabla,
    	Nacute: Nacute,
    	nacute: nacute,
    	nang: nang,
    	nap: nap,
    	napE: napE,
    	napid: napid,
    	napos: napos,
    	napprox: napprox,
    	natural: natural,
    	naturals: naturals,
    	natur: natur,
    	nbsp: nbsp,
    	nbump: nbump,
    	nbumpe: nbumpe,
    	ncap: ncap,
    	Ncaron: Ncaron,
    	ncaron: ncaron,
    	Ncedil: Ncedil,
    	ncedil: ncedil,
    	ncong: ncong,
    	ncongdot: ncongdot,
    	ncup: ncup,
    	Ncy: Ncy,
    	ncy: ncy,
    	ndash: ndash,
    	nearhk: nearhk,
    	nearr: nearr,
    	neArr: neArr,
    	nearrow: nearrow,
    	ne: ne,
    	nedot: nedot,
    	NegativeMediumSpace: NegativeMediumSpace,
    	NegativeThickSpace: NegativeThickSpace,
    	NegativeThinSpace: NegativeThinSpace,
    	NegativeVeryThinSpace: NegativeVeryThinSpace,
    	nequiv: nequiv,
    	nesear: nesear,
    	nesim: nesim,
    	NestedGreaterGreater: NestedGreaterGreater,
    	NestedLessLess: NestedLessLess,
    	NewLine: NewLine,
    	nexist: nexist,
    	nexists: nexists,
    	Nfr: Nfr,
    	nfr: nfr,
    	ngE: ngE,
    	nge: nge,
    	ngeq: ngeq,
    	ngeqq: ngeqq,
    	ngeqslant: ngeqslant,
    	nges: nges,
    	nGg: nGg,
    	ngsim: ngsim,
    	nGt: nGt,
    	ngt: ngt,
    	ngtr: ngtr,
    	nGtv: nGtv,
    	nharr: nharr,
    	nhArr: nhArr,
    	nhpar: nhpar,
    	ni: ni,
    	nis: nis,
    	nisd: nisd,
    	niv: niv,
    	NJcy: NJcy,
    	njcy: njcy,
    	nlarr: nlarr,
    	nlArr: nlArr,
    	nldr: nldr,
    	nlE: nlE,
    	nle: nle,
    	nleftarrow: nleftarrow,
    	nLeftarrow: nLeftarrow,
    	nleftrightarrow: nleftrightarrow,
    	nLeftrightarrow: nLeftrightarrow,
    	nleq: nleq,
    	nleqq: nleqq,
    	nleqslant: nleqslant,
    	nles: nles,
    	nless: nless,
    	nLl: nLl,
    	nlsim: nlsim,
    	nLt: nLt,
    	nlt: nlt,
    	nltri: nltri,
    	nltrie: nltrie,
    	nLtv: nLtv,
    	nmid: nmid,
    	NoBreak: NoBreak,
    	NonBreakingSpace: NonBreakingSpace,
    	nopf: nopf,
    	Nopf: Nopf,
    	Not: Not,
    	not: not,
    	NotCongruent: NotCongruent,
    	NotCupCap: NotCupCap,
    	NotDoubleVerticalBar: NotDoubleVerticalBar,
    	NotElement: NotElement,
    	NotEqual: NotEqual,
    	NotEqualTilde: NotEqualTilde,
    	NotExists: NotExists,
    	NotGreater: NotGreater,
    	NotGreaterEqual: NotGreaterEqual,
    	NotGreaterFullEqual: NotGreaterFullEqual,
    	NotGreaterGreater: NotGreaterGreater,
    	NotGreaterLess: NotGreaterLess,
    	NotGreaterSlantEqual: NotGreaterSlantEqual,
    	NotGreaterTilde: NotGreaterTilde,
    	NotHumpDownHump: NotHumpDownHump,
    	NotHumpEqual: NotHumpEqual,
    	notin: notin,
    	notindot: notindot,
    	notinE: notinE,
    	notinva: notinva,
    	notinvb: notinvb,
    	notinvc: notinvc,
    	NotLeftTriangleBar: NotLeftTriangleBar,
    	NotLeftTriangle: NotLeftTriangle,
    	NotLeftTriangleEqual: NotLeftTriangleEqual,
    	NotLess: NotLess,
    	NotLessEqual: NotLessEqual,
    	NotLessGreater: NotLessGreater,
    	NotLessLess: NotLessLess,
    	NotLessSlantEqual: NotLessSlantEqual,
    	NotLessTilde: NotLessTilde,
    	NotNestedGreaterGreater: NotNestedGreaterGreater,
    	NotNestedLessLess: NotNestedLessLess,
    	notni: notni,
    	notniva: notniva,
    	notnivb: notnivb,
    	notnivc: notnivc,
    	NotPrecedes: NotPrecedes,
    	NotPrecedesEqual: NotPrecedesEqual,
    	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
    	NotReverseElement: NotReverseElement,
    	NotRightTriangleBar: NotRightTriangleBar,
    	NotRightTriangle: NotRightTriangle,
    	NotRightTriangleEqual: NotRightTriangleEqual,
    	NotSquareSubset: NotSquareSubset,
    	NotSquareSubsetEqual: NotSquareSubsetEqual,
    	NotSquareSuperset: NotSquareSuperset,
    	NotSquareSupersetEqual: NotSquareSupersetEqual,
    	NotSubset: NotSubset,
    	NotSubsetEqual: NotSubsetEqual,
    	NotSucceeds: NotSucceeds,
    	NotSucceedsEqual: NotSucceedsEqual,
    	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
    	NotSucceedsTilde: NotSucceedsTilde,
    	NotSuperset: NotSuperset,
    	NotSupersetEqual: NotSupersetEqual,
    	NotTilde: NotTilde,
    	NotTildeEqual: NotTildeEqual,
    	NotTildeFullEqual: NotTildeFullEqual,
    	NotTildeTilde: NotTildeTilde,
    	NotVerticalBar: NotVerticalBar,
    	nparallel: nparallel,
    	npar: npar,
    	nparsl: nparsl,
    	npart: npart,
    	npolint: npolint,
    	npr: npr,
    	nprcue: nprcue,
    	nprec: nprec,
    	npreceq: npreceq,
    	npre: npre,
    	nrarrc: nrarrc,
    	nrarr: nrarr,
    	nrArr: nrArr,
    	nrarrw: nrarrw,
    	nrightarrow: nrightarrow,
    	nRightarrow: nRightarrow,
    	nrtri: nrtri,
    	nrtrie: nrtrie,
    	nsc: nsc,
    	nsccue: nsccue,
    	nsce: nsce,
    	Nscr: Nscr,
    	nscr: nscr,
    	nshortmid: nshortmid,
    	nshortparallel: nshortparallel,
    	nsim: nsim,
    	nsime: nsime,
    	nsimeq: nsimeq,
    	nsmid: nsmid,
    	nspar: nspar,
    	nsqsube: nsqsube,
    	nsqsupe: nsqsupe,
    	nsub: nsub,
    	nsubE: nsubE,
    	nsube: nsube,
    	nsubset: nsubset,
    	nsubseteq: nsubseteq,
    	nsubseteqq: nsubseteqq,
    	nsucc: nsucc,
    	nsucceq: nsucceq,
    	nsup: nsup,
    	nsupE: nsupE,
    	nsupe: nsupe,
    	nsupset: nsupset,
    	nsupseteq: nsupseteq,
    	nsupseteqq: nsupseteqq,
    	ntgl: ntgl,
    	Ntilde: Ntilde,
    	ntilde: ntilde,
    	ntlg: ntlg,
    	ntriangleleft: ntriangleleft,
    	ntrianglelefteq: ntrianglelefteq,
    	ntriangleright: ntriangleright,
    	ntrianglerighteq: ntrianglerighteq,
    	Nu: Nu,
    	nu: nu,
    	num: num,
    	numero: numero,
    	numsp: numsp,
    	nvap: nvap,
    	nvdash: nvdash,
    	nvDash: nvDash,
    	nVdash: nVdash,
    	nVDash: nVDash,
    	nvge: nvge,
    	nvgt: nvgt,
    	nvHarr: nvHarr,
    	nvinfin: nvinfin,
    	nvlArr: nvlArr,
    	nvle: nvle,
    	nvlt: nvlt,
    	nvltrie: nvltrie,
    	nvrArr: nvrArr,
    	nvrtrie: nvrtrie,
    	nvsim: nvsim,
    	nwarhk: nwarhk,
    	nwarr: nwarr,
    	nwArr: nwArr,
    	nwarrow: nwarrow,
    	nwnear: nwnear,
    	Oacute: Oacute,
    	oacute: oacute,
    	oast: oast,
    	Ocirc: Ocirc,
    	ocirc: ocirc,
    	ocir: ocir,
    	Ocy: Ocy,
    	ocy: ocy,
    	odash: odash,
    	Odblac: Odblac,
    	odblac: odblac,
    	odiv: odiv,
    	odot: odot,
    	odsold: odsold,
    	OElig: OElig,
    	oelig: oelig,
    	ofcir: ofcir,
    	Ofr: Ofr,
    	ofr: ofr,
    	ogon: ogon,
    	Ograve: Ograve,
    	ograve: ograve,
    	ogt: ogt,
    	ohbar: ohbar,
    	ohm: ohm,
    	oint: oint,
    	olarr: olarr,
    	olcir: olcir,
    	olcross: olcross,
    	oline: oline,
    	olt: olt,
    	Omacr: Omacr,
    	omacr: omacr,
    	Omega: Omega,
    	omega: omega,
    	Omicron: Omicron,
    	omicron: omicron,
    	omid: omid,
    	ominus: ominus,
    	Oopf: Oopf,
    	oopf: oopf,
    	opar: opar,
    	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
    	OpenCurlyQuote: OpenCurlyQuote,
    	operp: operp,
    	oplus: oplus,
    	orarr: orarr,
    	Or: Or,
    	or: or,
    	ord: ord,
    	order: order,
    	orderof: orderof,
    	ordf: ordf,
    	ordm: ordm,
    	origof: origof,
    	oror: oror,
    	orslope: orslope,
    	orv: orv,
    	oS: oS,
    	Oscr: Oscr,
    	oscr: oscr,
    	Oslash: Oslash,
    	oslash: oslash,
    	osol: osol,
    	Otilde: Otilde,
    	otilde: otilde,
    	otimesas: otimesas,
    	Otimes: Otimes,
    	otimes: otimes,
    	Ouml: Ouml,
    	ouml: ouml,
    	ovbar: ovbar,
    	OverBar: OverBar,
    	OverBrace: OverBrace,
    	OverBracket: OverBracket,
    	OverParenthesis: OverParenthesis,
    	para: para,
    	parallel: parallel,
    	par: par,
    	parsim: parsim,
    	parsl: parsl,
    	part: part,
    	PartialD: PartialD,
    	Pcy: Pcy,
    	pcy: pcy,
    	percnt: percnt,
    	period: period,
    	permil: permil,
    	perp: perp,
    	pertenk: pertenk,
    	Pfr: Pfr,
    	pfr: pfr,
    	Phi: Phi,
    	phi: phi,
    	phiv: phiv,
    	phmmat: phmmat,
    	phone: phone,
    	Pi: Pi,
    	pi: pi,
    	pitchfork: pitchfork,
    	piv: piv,
    	planck: planck,
    	planckh: planckh,
    	plankv: plankv,
    	plusacir: plusacir,
    	plusb: plusb,
    	pluscir: pluscir,
    	plus: plus,
    	plusdo: plusdo,
    	plusdu: plusdu,
    	pluse: pluse,
    	PlusMinus: PlusMinus,
    	plusmn: plusmn,
    	plussim: plussim,
    	plustwo: plustwo,
    	pm: pm,
    	Poincareplane: Poincareplane,
    	pointint: pointint,
    	popf: popf,
    	Popf: Popf,
    	pound: pound,
    	prap: prap,
    	Pr: Pr,
    	pr: pr,
    	prcue: prcue,
    	precapprox: precapprox,
    	prec: prec,
    	preccurlyeq: preccurlyeq,
    	Precedes: Precedes,
    	PrecedesEqual: PrecedesEqual,
    	PrecedesSlantEqual: PrecedesSlantEqual,
    	PrecedesTilde: PrecedesTilde,
    	preceq: preceq,
    	precnapprox: precnapprox,
    	precneqq: precneqq,
    	precnsim: precnsim,
    	pre: pre,
    	prE: prE,
    	precsim: precsim,
    	prime: prime,
    	Prime: Prime,
    	primes: primes,
    	prnap: prnap,
    	prnE: prnE,
    	prnsim: prnsim,
    	prod: prod,
    	Product: Product,
    	profalar: profalar,
    	profline: profline,
    	profsurf: profsurf,
    	prop: prop,
    	Proportional: Proportional,
    	Proportion: Proportion,
    	propto: propto,
    	prsim: prsim,
    	prurel: prurel,
    	Pscr: Pscr,
    	pscr: pscr,
    	Psi: Psi,
    	psi: psi,
    	puncsp: puncsp,
    	Qfr: Qfr,
    	qfr: qfr,
    	qint: qint,
    	qopf: qopf,
    	Qopf: Qopf,
    	qprime: qprime,
    	Qscr: Qscr,
    	qscr: qscr,
    	quaternions: quaternions,
    	quatint: quatint,
    	quest: quest,
    	questeq: questeq,
    	quot: quot,
    	QUOT: QUOT,
    	rAarr: rAarr,
    	race: race,
    	Racute: Racute,
    	racute: racute,
    	radic: radic,
    	raemptyv: raemptyv,
    	rang: rang,
    	Rang: Rang,
    	rangd: rangd,
    	range: range,
    	rangle: rangle,
    	raquo: raquo,
    	rarrap: rarrap,
    	rarrb: rarrb,
    	rarrbfs: rarrbfs,
    	rarrc: rarrc,
    	rarr: rarr,
    	Rarr: Rarr,
    	rArr: rArr,
    	rarrfs: rarrfs,
    	rarrhk: rarrhk,
    	rarrlp: rarrlp,
    	rarrpl: rarrpl,
    	rarrsim: rarrsim,
    	Rarrtl: Rarrtl,
    	rarrtl: rarrtl,
    	rarrw: rarrw,
    	ratail: ratail,
    	rAtail: rAtail,
    	ratio: ratio,
    	rationals: rationals,
    	rbarr: rbarr,
    	rBarr: rBarr,
    	RBarr: RBarr,
    	rbbrk: rbbrk,
    	rbrace: rbrace,
    	rbrack: rbrack,
    	rbrke: rbrke,
    	rbrksld: rbrksld,
    	rbrkslu: rbrkslu,
    	Rcaron: Rcaron,
    	rcaron: rcaron,
    	Rcedil: Rcedil,
    	rcedil: rcedil,
    	rceil: rceil,
    	rcub: rcub,
    	Rcy: Rcy,
    	rcy: rcy,
    	rdca: rdca,
    	rdldhar: rdldhar,
    	rdquo: rdquo,
    	rdquor: rdquor,
    	rdsh: rdsh,
    	real: real,
    	realine: realine,
    	realpart: realpart,
    	reals: reals,
    	Re: Re,
    	rect: rect,
    	reg: reg,
    	REG: REG,
    	ReverseElement: ReverseElement,
    	ReverseEquilibrium: ReverseEquilibrium,
    	ReverseUpEquilibrium: ReverseUpEquilibrium,
    	rfisht: rfisht,
    	rfloor: rfloor,
    	rfr: rfr,
    	Rfr: Rfr,
    	rHar: rHar,
    	rhard: rhard,
    	rharu: rharu,
    	rharul: rharul,
    	Rho: Rho,
    	rho: rho,
    	rhov: rhov,
    	RightAngleBracket: RightAngleBracket,
    	RightArrowBar: RightArrowBar,
    	rightarrow: rightarrow,
    	RightArrow: RightArrow,
    	Rightarrow: Rightarrow,
    	RightArrowLeftArrow: RightArrowLeftArrow,
    	rightarrowtail: rightarrowtail,
    	RightCeiling: RightCeiling,
    	RightDoubleBracket: RightDoubleBracket,
    	RightDownTeeVector: RightDownTeeVector,
    	RightDownVectorBar: RightDownVectorBar,
    	RightDownVector: RightDownVector,
    	RightFloor: RightFloor,
    	rightharpoondown: rightharpoondown,
    	rightharpoonup: rightharpoonup,
    	rightleftarrows: rightleftarrows,
    	rightleftharpoons: rightleftharpoons,
    	rightrightarrows: rightrightarrows,
    	rightsquigarrow: rightsquigarrow,
    	RightTeeArrow: RightTeeArrow,
    	RightTee: RightTee,
    	RightTeeVector: RightTeeVector,
    	rightthreetimes: rightthreetimes,
    	RightTriangleBar: RightTriangleBar,
    	RightTriangle: RightTriangle,
    	RightTriangleEqual: RightTriangleEqual,
    	RightUpDownVector: RightUpDownVector,
    	RightUpTeeVector: RightUpTeeVector,
    	RightUpVectorBar: RightUpVectorBar,
    	RightUpVector: RightUpVector,
    	RightVectorBar: RightVectorBar,
    	RightVector: RightVector,
    	ring: ring,
    	risingdotseq: risingdotseq,
    	rlarr: rlarr,
    	rlhar: rlhar,
    	rlm: rlm,
    	rmoustache: rmoustache,
    	rmoust: rmoust,
    	rnmid: rnmid,
    	roang: roang,
    	roarr: roarr,
    	robrk: robrk,
    	ropar: ropar,
    	ropf: ropf,
    	Ropf: Ropf,
    	roplus: roplus,
    	rotimes: rotimes,
    	RoundImplies: RoundImplies,
    	rpar: rpar,
    	rpargt: rpargt,
    	rppolint: rppolint,
    	rrarr: rrarr,
    	Rrightarrow: Rrightarrow,
    	rsaquo: rsaquo,
    	rscr: rscr,
    	Rscr: Rscr,
    	rsh: rsh,
    	Rsh: Rsh,
    	rsqb: rsqb,
    	rsquo: rsquo,
    	rsquor: rsquor,
    	rthree: rthree,
    	rtimes: rtimes,
    	rtri: rtri,
    	rtrie: rtrie,
    	rtrif: rtrif,
    	rtriltri: rtriltri,
    	RuleDelayed: RuleDelayed,
    	ruluhar: ruluhar,
    	rx: rx,
    	Sacute: Sacute,
    	sacute: sacute,
    	sbquo: sbquo,
    	scap: scap,
    	Scaron: Scaron,
    	scaron: scaron,
    	Sc: Sc,
    	sc: sc,
    	sccue: sccue,
    	sce: sce,
    	scE: scE,
    	Scedil: Scedil,
    	scedil: scedil,
    	Scirc: Scirc,
    	scirc: scirc,
    	scnap: scnap,
    	scnE: scnE,
    	scnsim: scnsim,
    	scpolint: scpolint,
    	scsim: scsim,
    	Scy: Scy,
    	scy: scy,
    	sdotb: sdotb,
    	sdot: sdot,
    	sdote: sdote,
    	searhk: searhk,
    	searr: searr,
    	seArr: seArr,
    	searrow: searrow,
    	sect: sect,
    	semi: semi,
    	seswar: seswar,
    	setminus: setminus,
    	setmn: setmn,
    	sext: sext,
    	Sfr: Sfr,
    	sfr: sfr,
    	sfrown: sfrown,
    	sharp: sharp,
    	SHCHcy: SHCHcy,
    	shchcy: shchcy,
    	SHcy: SHcy,
    	shcy: shcy,
    	ShortDownArrow: ShortDownArrow,
    	ShortLeftArrow: ShortLeftArrow,
    	shortmid: shortmid,
    	shortparallel: shortparallel,
    	ShortRightArrow: ShortRightArrow,
    	ShortUpArrow: ShortUpArrow,
    	shy: shy,
    	Sigma: Sigma,
    	sigma: sigma,
    	sigmaf: sigmaf,
    	sigmav: sigmav,
    	sim: sim,
    	simdot: simdot,
    	sime: sime,
    	simeq: simeq,
    	simg: simg,
    	simgE: simgE,
    	siml: siml,
    	simlE: simlE,
    	simne: simne,
    	simplus: simplus,
    	simrarr: simrarr,
    	slarr: slarr,
    	SmallCircle: SmallCircle,
    	smallsetminus: smallsetminus,
    	smashp: smashp,
    	smeparsl: smeparsl,
    	smid: smid,
    	smile: smile,
    	smt: smt,
    	smte: smte,
    	smtes: smtes,
    	SOFTcy: SOFTcy,
    	softcy: softcy,
    	solbar: solbar,
    	solb: solb,
    	sol: sol,
    	Sopf: Sopf,
    	sopf: sopf,
    	spades: spades,
    	spadesuit: spadesuit,
    	spar: spar,
    	sqcap: sqcap,
    	sqcaps: sqcaps,
    	sqcup: sqcup,
    	sqcups: sqcups,
    	Sqrt: Sqrt,
    	sqsub: sqsub,
    	sqsube: sqsube,
    	sqsubset: sqsubset,
    	sqsubseteq: sqsubseteq,
    	sqsup: sqsup,
    	sqsupe: sqsupe,
    	sqsupset: sqsupset,
    	sqsupseteq: sqsupseteq,
    	square: square,
    	Square: Square,
    	SquareIntersection: SquareIntersection,
    	SquareSubset: SquareSubset,
    	SquareSubsetEqual: SquareSubsetEqual,
    	SquareSuperset: SquareSuperset,
    	SquareSupersetEqual: SquareSupersetEqual,
    	SquareUnion: SquareUnion,
    	squarf: squarf,
    	squ: squ,
    	squf: squf,
    	srarr: srarr,
    	Sscr: Sscr,
    	sscr: sscr,
    	ssetmn: ssetmn,
    	ssmile: ssmile,
    	sstarf: sstarf,
    	Star: Star,
    	star: star,
    	starf: starf,
    	straightepsilon: straightepsilon,
    	straightphi: straightphi,
    	strns: strns,
    	sub: sub,
    	Sub: Sub,
    	subdot: subdot,
    	subE: subE,
    	sube: sube,
    	subedot: subedot,
    	submult: submult,
    	subnE: subnE,
    	subne: subne,
    	subplus: subplus,
    	subrarr: subrarr,
    	subset: subset,
    	Subset: Subset,
    	subseteq: subseteq,
    	subseteqq: subseteqq,
    	SubsetEqual: SubsetEqual,
    	subsetneq: subsetneq,
    	subsetneqq: subsetneqq,
    	subsim: subsim,
    	subsub: subsub,
    	subsup: subsup,
    	succapprox: succapprox,
    	succ: succ,
    	succcurlyeq: succcurlyeq,
    	Succeeds: Succeeds,
    	SucceedsEqual: SucceedsEqual,
    	SucceedsSlantEqual: SucceedsSlantEqual,
    	SucceedsTilde: SucceedsTilde,
    	succeq: succeq,
    	succnapprox: succnapprox,
    	succneqq: succneqq,
    	succnsim: succnsim,
    	succsim: succsim,
    	SuchThat: SuchThat,
    	sum: sum,
    	Sum: Sum,
    	sung: sung,
    	sup1: sup1,
    	sup2: sup2,
    	sup3: sup3,
    	sup: sup,
    	Sup: Sup,
    	supdot: supdot,
    	supdsub: supdsub,
    	supE: supE,
    	supe: supe,
    	supedot: supedot,
    	Superset: Superset,
    	SupersetEqual: SupersetEqual,
    	suphsol: suphsol,
    	suphsub: suphsub,
    	suplarr: suplarr,
    	supmult: supmult,
    	supnE: supnE,
    	supne: supne,
    	supplus: supplus,
    	supset: supset,
    	Supset: Supset,
    	supseteq: supseteq,
    	supseteqq: supseteqq,
    	supsetneq: supsetneq,
    	supsetneqq: supsetneqq,
    	supsim: supsim,
    	supsub: supsub,
    	supsup: supsup,
    	swarhk: swarhk,
    	swarr: swarr,
    	swArr: swArr,
    	swarrow: swarrow,
    	swnwar: swnwar,
    	szlig: szlig,
    	Tab: Tab,
    	target: target,
    	Tau: Tau,
    	tau: tau,
    	tbrk: tbrk,
    	Tcaron: Tcaron,
    	tcaron: tcaron,
    	Tcedil: Tcedil,
    	tcedil: tcedil,
    	Tcy: Tcy,
    	tcy: tcy,
    	tdot: tdot,
    	telrec: telrec,
    	Tfr: Tfr,
    	tfr: tfr,
    	there4: there4,
    	therefore: therefore,
    	Therefore: Therefore,
    	Theta: Theta,
    	theta: theta,
    	thetasym: thetasym,
    	thetav: thetav,
    	thickapprox: thickapprox,
    	thicksim: thicksim,
    	ThickSpace: ThickSpace,
    	ThinSpace: ThinSpace,
    	thinsp: thinsp,
    	thkap: thkap,
    	thksim: thksim,
    	THORN: THORN,
    	thorn: thorn,
    	tilde: tilde,
    	Tilde: Tilde,
    	TildeEqual: TildeEqual,
    	TildeFullEqual: TildeFullEqual,
    	TildeTilde: TildeTilde,
    	timesbar: timesbar,
    	timesb: timesb,
    	times: times,
    	timesd: timesd,
    	tint: tint,
    	toea: toea,
    	topbot: topbot,
    	topcir: topcir,
    	top: top,
    	Topf: Topf,
    	topf: topf,
    	topfork: topfork,
    	tosa: tosa,
    	tprime: tprime,
    	trade: trade,
    	TRADE: TRADE,
    	triangle: triangle,
    	triangledown: triangledown,
    	triangleleft: triangleleft,
    	trianglelefteq: trianglelefteq,
    	triangleq: triangleq,
    	triangleright: triangleright,
    	trianglerighteq: trianglerighteq,
    	tridot: tridot,
    	trie: trie,
    	triminus: triminus,
    	TripleDot: TripleDot,
    	triplus: triplus,
    	trisb: trisb,
    	tritime: tritime,
    	trpezium: trpezium,
    	Tscr: Tscr,
    	tscr: tscr,
    	TScy: TScy,
    	tscy: tscy,
    	TSHcy: TSHcy,
    	tshcy: tshcy,
    	Tstrok: Tstrok,
    	tstrok: tstrok,
    	twixt: twixt,
    	twoheadleftarrow: twoheadleftarrow,
    	twoheadrightarrow: twoheadrightarrow,
    	Uacute: Uacute,
    	uacute: uacute,
    	uarr: uarr,
    	Uarr: Uarr,
    	uArr: uArr,
    	Uarrocir: Uarrocir,
    	Ubrcy: Ubrcy,
    	ubrcy: ubrcy,
    	Ubreve: Ubreve,
    	ubreve: ubreve,
    	Ucirc: Ucirc,
    	ucirc: ucirc,
    	Ucy: Ucy,
    	ucy: ucy,
    	udarr: udarr,
    	Udblac: Udblac,
    	udblac: udblac,
    	udhar: udhar,
    	ufisht: ufisht,
    	Ufr: Ufr,
    	ufr: ufr,
    	Ugrave: Ugrave,
    	ugrave: ugrave,
    	uHar: uHar,
    	uharl: uharl,
    	uharr: uharr,
    	uhblk: uhblk,
    	ulcorn: ulcorn,
    	ulcorner: ulcorner,
    	ulcrop: ulcrop,
    	ultri: ultri,
    	Umacr: Umacr,
    	umacr: umacr,
    	uml: uml,
    	UnderBar: UnderBar,
    	UnderBrace: UnderBrace,
    	UnderBracket: UnderBracket,
    	UnderParenthesis: UnderParenthesis,
    	Union: Union,
    	UnionPlus: UnionPlus,
    	Uogon: Uogon,
    	uogon: uogon,
    	Uopf: Uopf,
    	uopf: uopf,
    	UpArrowBar: UpArrowBar,
    	uparrow: uparrow,
    	UpArrow: UpArrow,
    	Uparrow: Uparrow,
    	UpArrowDownArrow: UpArrowDownArrow,
    	updownarrow: updownarrow,
    	UpDownArrow: UpDownArrow,
    	Updownarrow: Updownarrow,
    	UpEquilibrium: UpEquilibrium,
    	upharpoonleft: upharpoonleft,
    	upharpoonright: upharpoonright,
    	uplus: uplus,
    	UpperLeftArrow: UpperLeftArrow,
    	UpperRightArrow: UpperRightArrow,
    	upsi: upsi,
    	Upsi: Upsi,
    	upsih: upsih,
    	Upsilon: Upsilon,
    	upsilon: upsilon,
    	UpTeeArrow: UpTeeArrow,
    	UpTee: UpTee,
    	upuparrows: upuparrows,
    	urcorn: urcorn,
    	urcorner: urcorner,
    	urcrop: urcrop,
    	Uring: Uring,
    	uring: uring,
    	urtri: urtri,
    	Uscr: Uscr,
    	uscr: uscr,
    	utdot: utdot,
    	Utilde: Utilde,
    	utilde: utilde,
    	utri: utri,
    	utrif: utrif,
    	uuarr: uuarr,
    	Uuml: Uuml,
    	uuml: uuml,
    	uwangle: uwangle,
    	vangrt: vangrt,
    	varepsilon: varepsilon,
    	varkappa: varkappa,
    	varnothing: varnothing,
    	varphi: varphi,
    	varpi: varpi,
    	varpropto: varpropto,
    	varr: varr,
    	vArr: vArr,
    	varrho: varrho,
    	varsigma: varsigma,
    	varsubsetneq: varsubsetneq,
    	varsubsetneqq: varsubsetneqq,
    	varsupsetneq: varsupsetneq,
    	varsupsetneqq: varsupsetneqq,
    	vartheta: vartheta,
    	vartriangleleft: vartriangleleft,
    	vartriangleright: vartriangleright,
    	vBar: vBar,
    	Vbar: Vbar,
    	vBarv: vBarv,
    	Vcy: Vcy,
    	vcy: vcy,
    	vdash: vdash,
    	vDash: vDash,
    	Vdash: Vdash,
    	VDash: VDash,
    	Vdashl: Vdashl,
    	veebar: veebar,
    	vee: vee,
    	Vee: Vee,
    	veeeq: veeeq,
    	vellip: vellip,
    	verbar: verbar,
    	Verbar: Verbar,
    	vert: vert,
    	Vert: Vert,
    	VerticalBar: VerticalBar,
    	VerticalLine: VerticalLine,
    	VerticalSeparator: VerticalSeparator,
    	VerticalTilde: VerticalTilde,
    	VeryThinSpace: VeryThinSpace,
    	Vfr: Vfr,
    	vfr: vfr,
    	vltri: vltri,
    	vnsub: vnsub,
    	vnsup: vnsup,
    	Vopf: Vopf,
    	vopf: vopf,
    	vprop: vprop,
    	vrtri: vrtri,
    	Vscr: Vscr,
    	vscr: vscr,
    	vsubnE: vsubnE,
    	vsubne: vsubne,
    	vsupnE: vsupnE,
    	vsupne: vsupne,
    	Vvdash: Vvdash,
    	vzigzag: vzigzag,
    	Wcirc: Wcirc,
    	wcirc: wcirc,
    	wedbar: wedbar,
    	wedge: wedge,
    	Wedge: Wedge,
    	wedgeq: wedgeq,
    	weierp: weierp,
    	Wfr: Wfr,
    	wfr: wfr,
    	Wopf: Wopf,
    	wopf: wopf,
    	wp: wp,
    	wr: wr,
    	wreath: wreath,
    	Wscr: Wscr,
    	wscr: wscr,
    	xcap: xcap,
    	xcirc: xcirc,
    	xcup: xcup,
    	xdtri: xdtri,
    	Xfr: Xfr,
    	xfr: xfr,
    	xharr: xharr,
    	xhArr: xhArr,
    	Xi: Xi,
    	xi: xi,
    	xlarr: xlarr,
    	xlArr: xlArr,
    	xmap: xmap,
    	xnis: xnis,
    	xodot: xodot,
    	Xopf: Xopf,
    	xopf: xopf,
    	xoplus: xoplus,
    	xotime: xotime,
    	xrarr: xrarr,
    	xrArr: xrArr,
    	Xscr: Xscr,
    	xscr: xscr,
    	xsqcup: xsqcup,
    	xuplus: xuplus,
    	xutri: xutri,
    	xvee: xvee,
    	xwedge: xwedge,
    	Yacute: Yacute,
    	yacute: yacute,
    	YAcy: YAcy,
    	yacy: yacy,
    	Ycirc: Ycirc,
    	ycirc: ycirc,
    	Ycy: Ycy,
    	ycy: ycy,
    	yen: yen,
    	Yfr: Yfr,
    	yfr: yfr,
    	YIcy: YIcy,
    	yicy: yicy,
    	Yopf: Yopf,
    	yopf: yopf,
    	Yscr: Yscr,
    	yscr: yscr,
    	YUcy: YUcy,
    	yucy: yucy,
    	yuml: yuml,
    	Yuml: Yuml,
    	Zacute: Zacute,
    	zacute: zacute,
    	Zcaron: Zcaron,
    	zcaron: zcaron,
    	Zcy: Zcy,
    	zcy: zcy,
    	Zdot: Zdot,
    	zdot: zdot,
    	zeetrf: zeetrf,
    	ZeroWidthSpace: ZeroWidthSpace,
    	Zeta: Zeta,
    	zeta: zeta,
    	zfr: zfr,
    	Zfr: Zfr,
    	ZHcy: ZHcy,
    	zhcy: zhcy,
    	zigrarr: zigrarr,
    	zopf: zopf,
    	Zopf: Zopf,
    	Zscr: Zscr,
    	zscr: zscr,
    	zwj: zwj,
    	zwnj: zwnj
    };

    var entities$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Aacute: Aacute,
        aacute: aacute,
        Abreve: Abreve,
        abreve: abreve,
        ac: ac,
        acd: acd,
        acE: acE,
        Acirc: Acirc,
        acirc: acirc,
        acute: acute,
        Acy: Acy,
        acy: acy,
        AElig: AElig,
        aelig: aelig,
        af: af,
        Afr: Afr,
        afr: afr,
        Agrave: Agrave,
        agrave: agrave,
        alefsym: alefsym,
        aleph: aleph,
        Alpha: Alpha,
        alpha: alpha,
        Amacr: Amacr,
        amacr: amacr,
        amalg: amalg,
        amp: amp,
        AMP: AMP,
        andand: andand,
        And: And,
        and: and,
        andd: andd,
        andslope: andslope,
        andv: andv,
        ang: ang,
        ange: ange,
        angle: angle,
        angmsdaa: angmsdaa,
        angmsdab: angmsdab,
        angmsdac: angmsdac,
        angmsdad: angmsdad,
        angmsdae: angmsdae,
        angmsdaf: angmsdaf,
        angmsdag: angmsdag,
        angmsdah: angmsdah,
        angmsd: angmsd,
        angrt: angrt,
        angrtvb: angrtvb,
        angrtvbd: angrtvbd,
        angsph: angsph,
        angst: angst,
        angzarr: angzarr,
        Aogon: Aogon,
        aogon: aogon,
        Aopf: Aopf,
        aopf: aopf,
        apacir: apacir,
        ap: ap,
        apE: apE,
        ape: ape,
        apid: apid,
        apos: apos,
        ApplyFunction: ApplyFunction,
        approx: approx,
        approxeq: approxeq,
        Aring: Aring,
        aring: aring,
        Ascr: Ascr,
        ascr: ascr,
        Assign: Assign,
        ast: ast,
        asymp: asymp,
        asympeq: asympeq,
        Atilde: Atilde,
        atilde: atilde,
        Auml: Auml,
        auml: auml,
        awconint: awconint,
        awint: awint,
        backcong: backcong,
        backepsilon: backepsilon,
        backprime: backprime,
        backsim: backsim,
        backsimeq: backsimeq,
        Backslash: Backslash,
        Barv: Barv,
        barvee: barvee,
        barwed: barwed,
        Barwed: Barwed,
        barwedge: barwedge,
        bbrk: bbrk,
        bbrktbrk: bbrktbrk,
        bcong: bcong,
        Bcy: Bcy,
        bcy: bcy,
        bdquo: bdquo,
        becaus: becaus,
        because: because,
        Because: Because,
        bemptyv: bemptyv,
        bepsi: bepsi,
        bernou: bernou,
        Bernoullis: Bernoullis,
        Beta: Beta,
        beta: beta,
        beth: beth,
        between: between,
        Bfr: Bfr,
        bfr: bfr,
        bigcap: bigcap,
        bigcirc: bigcirc,
        bigcup: bigcup,
        bigodot: bigodot,
        bigoplus: bigoplus,
        bigotimes: bigotimes,
        bigsqcup: bigsqcup,
        bigstar: bigstar,
        bigtriangledown: bigtriangledown,
        bigtriangleup: bigtriangleup,
        biguplus: biguplus,
        bigvee: bigvee,
        bigwedge: bigwedge,
        bkarow: bkarow,
        blacklozenge: blacklozenge,
        blacksquare: blacksquare,
        blacktriangle: blacktriangle,
        blacktriangledown: blacktriangledown,
        blacktriangleleft: blacktriangleleft,
        blacktriangleright: blacktriangleright,
        blank: blank,
        blk12: blk12,
        blk14: blk14,
        blk34: blk34,
        block: block,
        bne: bne,
        bnequiv: bnequiv,
        bNot: bNot,
        bnot: bnot,
        Bopf: Bopf,
        bopf: bopf,
        bot: bot,
        bottom: bottom,
        bowtie: bowtie,
        boxbox: boxbox,
        boxdl: boxdl,
        boxdL: boxdL,
        boxDl: boxDl,
        boxDL: boxDL,
        boxdr: boxdr,
        boxdR: boxdR,
        boxDr: boxDr,
        boxDR: boxDR,
        boxh: boxh,
        boxH: boxH,
        boxhd: boxhd,
        boxHd: boxHd,
        boxhD: boxhD,
        boxHD: boxHD,
        boxhu: boxhu,
        boxHu: boxHu,
        boxhU: boxhU,
        boxHU: boxHU,
        boxminus: boxminus,
        boxplus: boxplus,
        boxtimes: boxtimes,
        boxul: boxul,
        boxuL: boxuL,
        boxUl: boxUl,
        boxUL: boxUL,
        boxur: boxur,
        boxuR: boxuR,
        boxUr: boxUr,
        boxUR: boxUR,
        boxv: boxv,
        boxV: boxV,
        boxvh: boxvh,
        boxvH: boxvH,
        boxVh: boxVh,
        boxVH: boxVH,
        boxvl: boxvl,
        boxvL: boxvL,
        boxVl: boxVl,
        boxVL: boxVL,
        boxvr: boxvr,
        boxvR: boxvR,
        boxVr: boxVr,
        boxVR: boxVR,
        bprime: bprime,
        breve: breve,
        Breve: Breve,
        brvbar: brvbar,
        bscr: bscr,
        Bscr: Bscr,
        bsemi: bsemi,
        bsim: bsim,
        bsime: bsime,
        bsolb: bsolb,
        bsol: bsol,
        bsolhsub: bsolhsub,
        bull: bull,
        bullet: bullet,
        bump: bump,
        bumpE: bumpE,
        bumpe: bumpe,
        Bumpeq: Bumpeq,
        bumpeq: bumpeq,
        Cacute: Cacute,
        cacute: cacute,
        capand: capand,
        capbrcup: capbrcup,
        capcap: capcap,
        cap: cap,
        Cap: Cap,
        capcup: capcup,
        capdot: capdot,
        CapitalDifferentialD: CapitalDifferentialD,
        caps: caps,
        caret: caret,
        caron: caron,
        Cayleys: Cayleys,
        ccaps: ccaps,
        Ccaron: Ccaron,
        ccaron: ccaron,
        Ccedil: Ccedil,
        ccedil: ccedil,
        Ccirc: Ccirc,
        ccirc: ccirc,
        Cconint: Cconint,
        ccups: ccups,
        ccupssm: ccupssm,
        Cdot: Cdot,
        cdot: cdot,
        cedil: cedil,
        Cedilla: Cedilla,
        cemptyv: cemptyv,
        cent: cent,
        centerdot: centerdot,
        CenterDot: CenterDot,
        cfr: cfr,
        Cfr: Cfr,
        CHcy: CHcy,
        chcy: chcy,
        check: check,
        checkmark: checkmark,
        Chi: Chi,
        chi: chi,
        circ: circ,
        circeq: circeq,
        circlearrowleft: circlearrowleft,
        circlearrowright: circlearrowright,
        circledast: circledast,
        circledcirc: circledcirc,
        circleddash: circleddash,
        CircleDot: CircleDot,
        circledR: circledR,
        circledS: circledS,
        CircleMinus: CircleMinus,
        CirclePlus: CirclePlus,
        CircleTimes: CircleTimes,
        cir: cir,
        cirE: cirE,
        cire: cire,
        cirfnint: cirfnint,
        cirmid: cirmid,
        cirscir: cirscir,
        ClockwiseContourIntegral: ClockwiseContourIntegral,
        CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
        CloseCurlyQuote: CloseCurlyQuote,
        clubs: clubs,
        clubsuit: clubsuit,
        colon: colon,
        Colon: Colon,
        Colone: Colone,
        colone: colone,
        coloneq: coloneq,
        comma: comma,
        commat: commat,
        comp: comp,
        compfn: compfn,
        complement: complement,
        complexes: complexes,
        cong: cong,
        congdot: congdot,
        Congruent: Congruent,
        conint: conint,
        Conint: Conint,
        ContourIntegral: ContourIntegral,
        copf: copf,
        Copf: Copf,
        coprod: coprod,
        Coproduct: Coproduct,
        copy: copy,
        COPY: COPY$1,
        copysr: copysr,
        CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
        crarr: crarr,
        cross: cross,
        Cross: Cross,
        Cscr: Cscr,
        cscr: cscr,
        csub: csub,
        csube: csube,
        csup: csup,
        csupe: csupe,
        ctdot: ctdot,
        cudarrl: cudarrl,
        cudarrr: cudarrr,
        cuepr: cuepr,
        cuesc: cuesc,
        cularr: cularr,
        cularrp: cularrp,
        cupbrcap: cupbrcap,
        cupcap: cupcap,
        CupCap: CupCap,
        cup: cup,
        Cup: Cup,
        cupcup: cupcup,
        cupdot: cupdot,
        cupor: cupor,
        cups: cups,
        curarr: curarr,
        curarrm: curarrm,
        curlyeqprec: curlyeqprec,
        curlyeqsucc: curlyeqsucc,
        curlyvee: curlyvee,
        curlywedge: curlywedge,
        curren: curren,
        curvearrowleft: curvearrowleft,
        curvearrowright: curvearrowright,
        cuvee: cuvee,
        cuwed: cuwed,
        cwconint: cwconint,
        cwint: cwint,
        cylcty: cylcty,
        dagger: dagger,
        Dagger: Dagger,
        daleth: daleth,
        darr: darr,
        Darr: Darr,
        dArr: dArr,
        dash: dash,
        Dashv: Dashv,
        dashv: dashv,
        dbkarow: dbkarow,
        dblac: dblac,
        Dcaron: Dcaron,
        dcaron: dcaron,
        Dcy: Dcy,
        dcy: dcy,
        ddagger: ddagger,
        ddarr: ddarr,
        DD: DD,
        dd: dd,
        DDotrahd: DDotrahd,
        ddotseq: ddotseq,
        deg: deg,
        Del: Del,
        Delta: Delta,
        delta: delta,
        demptyv: demptyv,
        dfisht: dfisht,
        Dfr: Dfr,
        dfr: dfr,
        dHar: dHar,
        dharl: dharl,
        dharr: dharr,
        DiacriticalAcute: DiacriticalAcute,
        DiacriticalDot: DiacriticalDot,
        DiacriticalDoubleAcute: DiacriticalDoubleAcute,
        DiacriticalGrave: DiacriticalGrave,
        DiacriticalTilde: DiacriticalTilde,
        diam: diam,
        diamond: diamond,
        Diamond: Diamond,
        diamondsuit: diamondsuit,
        diams: diams,
        die: die,
        DifferentialD: DifferentialD,
        digamma: digamma,
        disin: disin,
        div: div,
        divide: divide,
        divideontimes: divideontimes,
        divonx: divonx,
        DJcy: DJcy,
        djcy: djcy,
        dlcorn: dlcorn,
        dlcrop: dlcrop,
        dollar: dollar,
        Dopf: Dopf,
        dopf: dopf,
        Dot: Dot,
        dot: dot,
        DotDot: DotDot,
        doteq: doteq,
        doteqdot: doteqdot,
        DotEqual: DotEqual,
        dotminus: dotminus,
        dotplus: dotplus,
        dotsquare: dotsquare,
        doublebarwedge: doublebarwedge,
        DoubleContourIntegral: DoubleContourIntegral,
        DoubleDot: DoubleDot,
        DoubleDownArrow: DoubleDownArrow,
        DoubleLeftArrow: DoubleLeftArrow,
        DoubleLeftRightArrow: DoubleLeftRightArrow,
        DoubleLeftTee: DoubleLeftTee,
        DoubleLongLeftArrow: DoubleLongLeftArrow,
        DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
        DoubleLongRightArrow: DoubleLongRightArrow,
        DoubleRightArrow: DoubleRightArrow,
        DoubleRightTee: DoubleRightTee,
        DoubleUpArrow: DoubleUpArrow,
        DoubleUpDownArrow: DoubleUpDownArrow,
        DoubleVerticalBar: DoubleVerticalBar,
        DownArrowBar: DownArrowBar,
        downarrow: downarrow,
        DownArrow: DownArrow,
        Downarrow: Downarrow,
        DownArrowUpArrow: DownArrowUpArrow,
        DownBreve: DownBreve,
        downdownarrows: downdownarrows,
        downharpoonleft: downharpoonleft,
        downharpoonright: downharpoonright,
        DownLeftRightVector: DownLeftRightVector,
        DownLeftTeeVector: DownLeftTeeVector,
        DownLeftVectorBar: DownLeftVectorBar,
        DownLeftVector: DownLeftVector,
        DownRightTeeVector: DownRightTeeVector,
        DownRightVectorBar: DownRightVectorBar,
        DownRightVector: DownRightVector,
        DownTeeArrow: DownTeeArrow,
        DownTee: DownTee,
        drbkarow: drbkarow,
        drcorn: drcorn,
        drcrop: drcrop,
        Dscr: Dscr,
        dscr: dscr,
        DScy: DScy,
        dscy: dscy,
        dsol: dsol,
        Dstrok: Dstrok,
        dstrok: dstrok,
        dtdot: dtdot,
        dtri: dtri,
        dtrif: dtrif,
        duarr: duarr,
        duhar: duhar,
        dwangle: dwangle,
        DZcy: DZcy,
        dzcy: dzcy,
        dzigrarr: dzigrarr,
        Eacute: Eacute,
        eacute: eacute,
        easter: easter,
        Ecaron: Ecaron,
        ecaron: ecaron,
        Ecirc: Ecirc,
        ecirc: ecirc,
        ecir: ecir,
        ecolon: ecolon,
        Ecy: Ecy,
        ecy: ecy,
        eDDot: eDDot,
        Edot: Edot,
        edot: edot,
        eDot: eDot,
        ee: ee,
        efDot: efDot,
        Efr: Efr,
        efr: efr,
        eg: eg,
        Egrave: Egrave,
        egrave: egrave,
        egs: egs,
        egsdot: egsdot,
        el: el,
        Element: Element,
        elinters: elinters,
        ell: ell,
        els: els,
        elsdot: elsdot,
        Emacr: Emacr,
        emacr: emacr,
        empty: empty,
        emptyset: emptyset,
        EmptySmallSquare: EmptySmallSquare,
        emptyv: emptyv,
        EmptyVerySmallSquare: EmptyVerySmallSquare,
        emsp13: emsp13,
        emsp14: emsp14,
        emsp: emsp,
        ENG: ENG,
        eng: eng,
        ensp: ensp,
        Eogon: Eogon,
        eogon: eogon,
        Eopf: Eopf,
        eopf: eopf,
        epar: epar,
        eparsl: eparsl,
        eplus: eplus,
        epsi: epsi,
        Epsilon: Epsilon,
        epsilon: epsilon,
        epsiv: epsiv,
        eqcirc: eqcirc,
        eqcolon: eqcolon,
        eqsim: eqsim,
        eqslantgtr: eqslantgtr,
        eqslantless: eqslantless,
        Equal: Equal,
        equals: equals,
        EqualTilde: EqualTilde,
        equest: equest,
        Equilibrium: Equilibrium,
        equiv: equiv,
        equivDD: equivDD,
        eqvparsl: eqvparsl,
        erarr: erarr,
        erDot: erDot,
        escr: escr,
        Escr: Escr,
        esdot: esdot,
        Esim: Esim,
        esim: esim,
        Eta: Eta,
        eta: eta,
        ETH: ETH,
        eth: eth,
        Euml: Euml,
        euml: euml,
        euro: euro,
        excl: excl,
        exist: exist,
        Exists: Exists,
        expectation: expectation,
        exponentiale: exponentiale,
        ExponentialE: ExponentialE,
        fallingdotseq: fallingdotseq,
        Fcy: Fcy,
        fcy: fcy,
        female: female,
        ffilig: ffilig,
        fflig: fflig,
        ffllig: ffllig,
        Ffr: Ffr,
        ffr: ffr,
        filig: filig,
        FilledSmallSquare: FilledSmallSquare,
        FilledVerySmallSquare: FilledVerySmallSquare,
        fjlig: fjlig,
        flat: flat,
        fllig: fllig,
        fltns: fltns,
        fnof: fnof,
        Fopf: Fopf,
        fopf: fopf,
        forall: forall,
        ForAll: ForAll,
        fork: fork,
        forkv: forkv,
        Fouriertrf: Fouriertrf,
        fpartint: fpartint,
        frac12: frac12,
        frac13: frac13,
        frac14: frac14,
        frac15: frac15,
        frac16: frac16,
        frac18: frac18,
        frac23: frac23,
        frac25: frac25,
        frac34: frac34,
        frac35: frac35,
        frac38: frac38,
        frac45: frac45,
        frac56: frac56,
        frac58: frac58,
        frac78: frac78,
        frasl: frasl,
        frown: frown,
        fscr: fscr,
        Fscr: Fscr,
        gacute: gacute,
        Gamma: Gamma,
        gamma: gamma,
        Gammad: Gammad,
        gammad: gammad,
        gap: gap,
        Gbreve: Gbreve,
        gbreve: gbreve,
        Gcedil: Gcedil,
        Gcirc: Gcirc,
        gcirc: gcirc,
        Gcy: Gcy,
        gcy: gcy,
        Gdot: Gdot,
        gdot: gdot,
        ge: ge,
        gE: gE,
        gEl: gEl,
        gel: gel,
        geq: geq,
        geqq: geqq,
        geqslant: geqslant,
        gescc: gescc,
        ges: ges,
        gesdot: gesdot,
        gesdoto: gesdoto,
        gesdotol: gesdotol,
        gesl: gesl,
        gesles: gesles,
        Gfr: Gfr,
        gfr: gfr,
        gg: gg,
        Gg: Gg,
        ggg: ggg,
        gimel: gimel,
        GJcy: GJcy,
        gjcy: gjcy,
        gla: gla,
        gl: gl,
        glE: glE,
        glj: glj,
        gnap: gnap,
        gnapprox: gnapprox,
        gne: gne,
        gnE: gnE,
        gneq: gneq,
        gneqq: gneqq,
        gnsim: gnsim,
        Gopf: Gopf,
        gopf: gopf,
        grave: grave,
        GreaterEqual: GreaterEqual,
        GreaterEqualLess: GreaterEqualLess,
        GreaterFullEqual: GreaterFullEqual,
        GreaterGreater: GreaterGreater,
        GreaterLess: GreaterLess,
        GreaterSlantEqual: GreaterSlantEqual,
        GreaterTilde: GreaterTilde,
        Gscr: Gscr,
        gscr: gscr,
        gsim: gsim,
        gsime: gsime,
        gsiml: gsiml,
        gtcc: gtcc,
        gtcir: gtcir,
        gt: gt,
        GT: GT,
        Gt: Gt,
        gtdot: gtdot,
        gtlPar: gtlPar,
        gtquest: gtquest,
        gtrapprox: gtrapprox,
        gtrarr: gtrarr,
        gtrdot: gtrdot,
        gtreqless: gtreqless,
        gtreqqless: gtreqqless,
        gtrless: gtrless,
        gtrsim: gtrsim,
        gvertneqq: gvertneqq,
        gvnE: gvnE,
        Hacek: Hacek,
        hairsp: hairsp,
        half: half,
        hamilt: hamilt,
        HARDcy: HARDcy,
        hardcy: hardcy,
        harrcir: harrcir,
        harr: harr,
        hArr: hArr,
        harrw: harrw,
        Hat: Hat,
        hbar: hbar,
        Hcirc: Hcirc,
        hcirc: hcirc,
        hearts: hearts,
        heartsuit: heartsuit,
        hellip: hellip,
        hercon: hercon,
        hfr: hfr,
        Hfr: Hfr,
        HilbertSpace: HilbertSpace,
        hksearow: hksearow,
        hkswarow: hkswarow,
        hoarr: hoarr,
        homtht: homtht,
        hookleftarrow: hookleftarrow,
        hookrightarrow: hookrightarrow,
        hopf: hopf,
        Hopf: Hopf,
        horbar: horbar,
        HorizontalLine: HorizontalLine,
        hscr: hscr,
        Hscr: Hscr,
        hslash: hslash,
        Hstrok: Hstrok,
        hstrok: hstrok,
        HumpDownHump: HumpDownHump,
        HumpEqual: HumpEqual,
        hybull: hybull,
        hyphen: hyphen,
        Iacute: Iacute,
        iacute: iacute,
        ic: ic,
        Icirc: Icirc,
        icirc: icirc,
        Icy: Icy,
        icy: icy,
        Idot: Idot,
        IEcy: IEcy,
        iecy: iecy,
        iexcl: iexcl,
        iff: iff,
        ifr: ifr,
        Ifr: Ifr,
        Igrave: Igrave,
        igrave: igrave,
        ii: ii,
        iiiint: iiiint,
        iiint: iiint,
        iinfin: iinfin,
        iiota: iiota,
        IJlig: IJlig,
        ijlig: ijlig,
        Imacr: Imacr,
        imacr: imacr,
        image: image,
        ImaginaryI: ImaginaryI,
        imagline: imagline,
        imagpart: imagpart,
        imath: imath,
        Im: Im,
        imof: imof,
        imped: imped,
        Implies: Implies,
        incare: incare,
        infin: infin,
        infintie: infintie,
        inodot: inodot,
        intcal: intcal,
        int: int,
        Int: Int,
        integers: integers,
        Integral: Integral,
        intercal: intercal,
        Intersection: Intersection,
        intlarhk: intlarhk,
        intprod: intprod,
        InvisibleComma: InvisibleComma,
        InvisibleTimes: InvisibleTimes,
        IOcy: IOcy,
        iocy: iocy,
        Iogon: Iogon,
        iogon: iogon,
        Iopf: Iopf,
        iopf: iopf,
        Iota: Iota,
        iota: iota,
        iprod: iprod,
        iquest: iquest,
        iscr: iscr,
        Iscr: Iscr,
        isin: isin,
        isindot: isindot,
        isinE: isinE,
        isins: isins,
        isinsv: isinsv,
        isinv: isinv,
        it: it,
        Itilde: Itilde,
        itilde: itilde,
        Iukcy: Iukcy,
        iukcy: iukcy,
        Iuml: Iuml,
        iuml: iuml,
        Jcirc: Jcirc,
        jcirc: jcirc,
        Jcy: Jcy,
        jcy: jcy,
        Jfr: Jfr,
        jfr: jfr,
        jmath: jmath,
        Jopf: Jopf,
        jopf: jopf,
        Jscr: Jscr,
        jscr: jscr,
        Jsercy: Jsercy,
        jsercy: jsercy,
        Jukcy: Jukcy,
        jukcy: jukcy,
        Kappa: Kappa,
        kappa: kappa,
        kappav: kappav,
        Kcedil: Kcedil,
        kcedil: kcedil,
        Kcy: Kcy,
        kcy: kcy,
        Kfr: Kfr,
        kfr: kfr,
        kgreen: kgreen,
        KHcy: KHcy,
        khcy: khcy,
        KJcy: KJcy,
        kjcy: kjcy,
        Kopf: Kopf,
        kopf: kopf,
        Kscr: Kscr,
        kscr: kscr,
        lAarr: lAarr,
        Lacute: Lacute,
        lacute: lacute,
        laemptyv: laemptyv,
        lagran: lagran,
        Lambda: Lambda,
        lambda: lambda,
        lang: lang,
        Lang: Lang,
        langd: langd,
        langle: langle,
        lap: lap,
        Laplacetrf: Laplacetrf,
        laquo: laquo,
        larrb: larrb,
        larrbfs: larrbfs,
        larr: larr,
        Larr: Larr,
        lArr: lArr,
        larrfs: larrfs,
        larrhk: larrhk,
        larrlp: larrlp,
        larrpl: larrpl,
        larrsim: larrsim,
        larrtl: larrtl,
        latail: latail,
        lAtail: lAtail,
        lat: lat,
        late: late,
        lates: lates,
        lbarr: lbarr,
        lBarr: lBarr,
        lbbrk: lbbrk,
        lbrace: lbrace,
        lbrack: lbrack,
        lbrke: lbrke,
        lbrksld: lbrksld,
        lbrkslu: lbrkslu,
        Lcaron: Lcaron,
        lcaron: lcaron,
        Lcedil: Lcedil,
        lcedil: lcedil,
        lceil: lceil,
        lcub: lcub,
        Lcy: Lcy,
        lcy: lcy,
        ldca: ldca,
        ldquo: ldquo,
        ldquor: ldquor,
        ldrdhar: ldrdhar,
        ldrushar: ldrushar,
        ldsh: ldsh,
        le: le,
        lE: lE,
        LeftAngleBracket: LeftAngleBracket,
        LeftArrowBar: LeftArrowBar,
        leftarrow: leftarrow,
        LeftArrow: LeftArrow,
        Leftarrow: Leftarrow,
        LeftArrowRightArrow: LeftArrowRightArrow,
        leftarrowtail: leftarrowtail,
        LeftCeiling: LeftCeiling,
        LeftDoubleBracket: LeftDoubleBracket,
        LeftDownTeeVector: LeftDownTeeVector,
        LeftDownVectorBar: LeftDownVectorBar,
        LeftDownVector: LeftDownVector,
        LeftFloor: LeftFloor,
        leftharpoondown: leftharpoondown,
        leftharpoonup: leftharpoonup,
        leftleftarrows: leftleftarrows,
        leftrightarrow: leftrightarrow,
        LeftRightArrow: LeftRightArrow,
        Leftrightarrow: Leftrightarrow,
        leftrightarrows: leftrightarrows,
        leftrightharpoons: leftrightharpoons,
        leftrightsquigarrow: leftrightsquigarrow,
        LeftRightVector: LeftRightVector,
        LeftTeeArrow: LeftTeeArrow,
        LeftTee: LeftTee,
        LeftTeeVector: LeftTeeVector,
        leftthreetimes: leftthreetimes,
        LeftTriangleBar: LeftTriangleBar,
        LeftTriangle: LeftTriangle,
        LeftTriangleEqual: LeftTriangleEqual,
        LeftUpDownVector: LeftUpDownVector,
        LeftUpTeeVector: LeftUpTeeVector,
        LeftUpVectorBar: LeftUpVectorBar,
        LeftUpVector: LeftUpVector,
        LeftVectorBar: LeftVectorBar,
        LeftVector: LeftVector,
        lEg: lEg,
        leg: leg,
        leq: leq,
        leqq: leqq,
        leqslant: leqslant,
        lescc: lescc,
        les: les,
        lesdot: lesdot,
        lesdoto: lesdoto,
        lesdotor: lesdotor,
        lesg: lesg,
        lesges: lesges,
        lessapprox: lessapprox,
        lessdot: lessdot,
        lesseqgtr: lesseqgtr,
        lesseqqgtr: lesseqqgtr,
        LessEqualGreater: LessEqualGreater,
        LessFullEqual: LessFullEqual,
        LessGreater: LessGreater,
        lessgtr: lessgtr,
        LessLess: LessLess,
        lesssim: lesssim,
        LessSlantEqual: LessSlantEqual,
        LessTilde: LessTilde,
        lfisht: lfisht,
        lfloor: lfloor,
        Lfr: Lfr,
        lfr: lfr,
        lg: lg,
        lgE: lgE,
        lHar: lHar,
        lhard: lhard,
        lharu: lharu,
        lharul: lharul,
        lhblk: lhblk,
        LJcy: LJcy,
        ljcy: ljcy,
        llarr: llarr,
        ll: ll,
        Ll: Ll,
        llcorner: llcorner,
        Lleftarrow: Lleftarrow,
        llhard: llhard,
        lltri: lltri,
        Lmidot: Lmidot,
        lmidot: lmidot,
        lmoustache: lmoustache,
        lmoust: lmoust,
        lnap: lnap,
        lnapprox: lnapprox,
        lne: lne,
        lnE: lnE,
        lneq: lneq,
        lneqq: lneqq,
        lnsim: lnsim,
        loang: loang,
        loarr: loarr,
        lobrk: lobrk,
        longleftarrow: longleftarrow,
        LongLeftArrow: LongLeftArrow,
        Longleftarrow: Longleftarrow,
        longleftrightarrow: longleftrightarrow,
        LongLeftRightArrow: LongLeftRightArrow,
        Longleftrightarrow: Longleftrightarrow,
        longmapsto: longmapsto,
        longrightarrow: longrightarrow,
        LongRightArrow: LongRightArrow,
        Longrightarrow: Longrightarrow,
        looparrowleft: looparrowleft,
        looparrowright: looparrowright,
        lopar: lopar,
        Lopf: Lopf,
        lopf: lopf,
        loplus: loplus,
        lotimes: lotimes,
        lowast: lowast,
        lowbar: lowbar,
        LowerLeftArrow: LowerLeftArrow,
        LowerRightArrow: LowerRightArrow,
        loz: loz,
        lozenge: lozenge,
        lozf: lozf,
        lpar: lpar,
        lparlt: lparlt,
        lrarr: lrarr,
        lrcorner: lrcorner,
        lrhar: lrhar,
        lrhard: lrhard,
        lrm: lrm,
        lrtri: lrtri,
        lsaquo: lsaquo,
        lscr: lscr,
        Lscr: Lscr,
        lsh: lsh,
        Lsh: Lsh,
        lsim: lsim,
        lsime: lsime,
        lsimg: lsimg,
        lsqb: lsqb,
        lsquo: lsquo,
        lsquor: lsquor,
        Lstrok: Lstrok,
        lstrok: lstrok,
        ltcc: ltcc,
        ltcir: ltcir,
        lt: lt,
        LT: LT,
        Lt: Lt,
        ltdot: ltdot,
        lthree: lthree,
        ltimes: ltimes,
        ltlarr: ltlarr,
        ltquest: ltquest,
        ltri: ltri,
        ltrie: ltrie,
        ltrif: ltrif,
        ltrPar: ltrPar,
        lurdshar: lurdshar,
        luruhar: luruhar,
        lvertneqq: lvertneqq,
        lvnE: lvnE,
        macr: macr,
        male: male,
        malt: malt,
        maltese: maltese,
        map: map,
        mapsto: mapsto,
        mapstodown: mapstodown,
        mapstoleft: mapstoleft,
        mapstoup: mapstoup,
        marker: marker,
        mcomma: mcomma,
        Mcy: Mcy,
        mcy: mcy,
        mdash: mdash,
        mDDot: mDDot,
        measuredangle: measuredangle,
        MediumSpace: MediumSpace,
        Mellintrf: Mellintrf,
        Mfr: Mfr,
        mfr: mfr,
        mho: mho,
        micro: micro,
        midast: midast,
        midcir: midcir,
        mid: mid,
        middot: middot,
        minusb: minusb,
        minus: minus,
        minusd: minusd,
        minusdu: minusdu,
        MinusPlus: MinusPlus,
        mlcp: mlcp,
        mldr: mldr,
        mnplus: mnplus,
        models: models,
        Mopf: Mopf,
        mopf: mopf,
        mp: mp,
        mscr: mscr,
        Mscr: Mscr,
        mstpos: mstpos,
        Mu: Mu,
        mu: mu,
        multimap: multimap,
        mumap: mumap,
        nabla: nabla,
        Nacute: Nacute,
        nacute: nacute,
        nang: nang,
        nap: nap,
        napE: napE,
        napid: napid,
        napos: napos,
        napprox: napprox,
        natural: natural,
        naturals: naturals,
        natur: natur,
        nbsp: nbsp,
        nbump: nbump,
        nbumpe: nbumpe,
        ncap: ncap,
        Ncaron: Ncaron,
        ncaron: ncaron,
        Ncedil: Ncedil,
        ncedil: ncedil,
        ncong: ncong,
        ncongdot: ncongdot,
        ncup: ncup,
        Ncy: Ncy,
        ncy: ncy,
        ndash: ndash,
        nearhk: nearhk,
        nearr: nearr,
        neArr: neArr,
        nearrow: nearrow,
        ne: ne,
        nedot: nedot,
        NegativeMediumSpace: NegativeMediumSpace,
        NegativeThickSpace: NegativeThickSpace,
        NegativeThinSpace: NegativeThinSpace,
        NegativeVeryThinSpace: NegativeVeryThinSpace,
        nequiv: nequiv,
        nesear: nesear,
        nesim: nesim,
        NestedGreaterGreater: NestedGreaterGreater,
        NestedLessLess: NestedLessLess,
        NewLine: NewLine,
        nexist: nexist,
        nexists: nexists,
        Nfr: Nfr,
        nfr: nfr,
        ngE: ngE,
        nge: nge,
        ngeq: ngeq,
        ngeqq: ngeqq,
        ngeqslant: ngeqslant,
        nges: nges,
        nGg: nGg,
        ngsim: ngsim,
        nGt: nGt,
        ngt: ngt,
        ngtr: ngtr,
        nGtv: nGtv,
        nharr: nharr,
        nhArr: nhArr,
        nhpar: nhpar,
        ni: ni,
        nis: nis,
        nisd: nisd,
        niv: niv,
        NJcy: NJcy,
        njcy: njcy,
        nlarr: nlarr,
        nlArr: nlArr,
        nldr: nldr,
        nlE: nlE,
        nle: nle,
        nleftarrow: nleftarrow,
        nLeftarrow: nLeftarrow,
        nleftrightarrow: nleftrightarrow,
        nLeftrightarrow: nLeftrightarrow,
        nleq: nleq,
        nleqq: nleqq,
        nleqslant: nleqslant,
        nles: nles,
        nless: nless,
        nLl: nLl,
        nlsim: nlsim,
        nLt: nLt,
        nlt: nlt,
        nltri: nltri,
        nltrie: nltrie,
        nLtv: nLtv,
        nmid: nmid,
        NoBreak: NoBreak,
        NonBreakingSpace: NonBreakingSpace,
        nopf: nopf,
        Nopf: Nopf,
        Not: Not,
        not: not,
        NotCongruent: NotCongruent,
        NotCupCap: NotCupCap,
        NotDoubleVerticalBar: NotDoubleVerticalBar,
        NotElement: NotElement,
        NotEqual: NotEqual,
        NotEqualTilde: NotEqualTilde,
        NotExists: NotExists,
        NotGreater: NotGreater,
        NotGreaterEqual: NotGreaterEqual,
        NotGreaterFullEqual: NotGreaterFullEqual,
        NotGreaterGreater: NotGreaterGreater,
        NotGreaterLess: NotGreaterLess,
        NotGreaterSlantEqual: NotGreaterSlantEqual,
        NotGreaterTilde: NotGreaterTilde,
        NotHumpDownHump: NotHumpDownHump,
        NotHumpEqual: NotHumpEqual,
        notin: notin,
        notindot: notindot,
        notinE: notinE,
        notinva: notinva,
        notinvb: notinvb,
        notinvc: notinvc,
        NotLeftTriangleBar: NotLeftTriangleBar,
        NotLeftTriangle: NotLeftTriangle,
        NotLeftTriangleEqual: NotLeftTriangleEqual,
        NotLess: NotLess,
        NotLessEqual: NotLessEqual,
        NotLessGreater: NotLessGreater,
        NotLessLess: NotLessLess,
        NotLessSlantEqual: NotLessSlantEqual,
        NotLessTilde: NotLessTilde,
        NotNestedGreaterGreater: NotNestedGreaterGreater,
        NotNestedLessLess: NotNestedLessLess,
        notni: notni,
        notniva: notniva,
        notnivb: notnivb,
        notnivc: notnivc,
        NotPrecedes: NotPrecedes,
        NotPrecedesEqual: NotPrecedesEqual,
        NotPrecedesSlantEqual: NotPrecedesSlantEqual,
        NotReverseElement: NotReverseElement,
        NotRightTriangleBar: NotRightTriangleBar,
        NotRightTriangle: NotRightTriangle,
        NotRightTriangleEqual: NotRightTriangleEqual,
        NotSquareSubset: NotSquareSubset,
        NotSquareSubsetEqual: NotSquareSubsetEqual,
        NotSquareSuperset: NotSquareSuperset,
        NotSquareSupersetEqual: NotSquareSupersetEqual,
        NotSubset: NotSubset,
        NotSubsetEqual: NotSubsetEqual,
        NotSucceeds: NotSucceeds,
        NotSucceedsEqual: NotSucceedsEqual,
        NotSucceedsSlantEqual: NotSucceedsSlantEqual,
        NotSucceedsTilde: NotSucceedsTilde,
        NotSuperset: NotSuperset,
        NotSupersetEqual: NotSupersetEqual,
        NotTilde: NotTilde,
        NotTildeEqual: NotTildeEqual,
        NotTildeFullEqual: NotTildeFullEqual,
        NotTildeTilde: NotTildeTilde,
        NotVerticalBar: NotVerticalBar,
        nparallel: nparallel,
        npar: npar,
        nparsl: nparsl,
        npart: npart,
        npolint: npolint,
        npr: npr,
        nprcue: nprcue,
        nprec: nprec,
        npreceq: npreceq,
        npre: npre,
        nrarrc: nrarrc,
        nrarr: nrarr,
        nrArr: nrArr,
        nrarrw: nrarrw,
        nrightarrow: nrightarrow,
        nRightarrow: nRightarrow,
        nrtri: nrtri,
        nrtrie: nrtrie,
        nsc: nsc,
        nsccue: nsccue,
        nsce: nsce,
        Nscr: Nscr,
        nscr: nscr,
        nshortmid: nshortmid,
        nshortparallel: nshortparallel,
        nsim: nsim,
        nsime: nsime,
        nsimeq: nsimeq,
        nsmid: nsmid,
        nspar: nspar,
        nsqsube: nsqsube,
        nsqsupe: nsqsupe,
        nsub: nsub,
        nsubE: nsubE,
        nsube: nsube,
        nsubset: nsubset,
        nsubseteq: nsubseteq,
        nsubseteqq: nsubseteqq,
        nsucc: nsucc,
        nsucceq: nsucceq,
        nsup: nsup,
        nsupE: nsupE,
        nsupe: nsupe,
        nsupset: nsupset,
        nsupseteq: nsupseteq,
        nsupseteqq: nsupseteqq,
        ntgl: ntgl,
        Ntilde: Ntilde,
        ntilde: ntilde,
        ntlg: ntlg,
        ntriangleleft: ntriangleleft,
        ntrianglelefteq: ntrianglelefteq,
        ntriangleright: ntriangleright,
        ntrianglerighteq: ntrianglerighteq,
        Nu: Nu,
        nu: nu,
        num: num,
        numero: numero,
        numsp: numsp,
        nvap: nvap,
        nvdash: nvdash,
        nvDash: nvDash,
        nVdash: nVdash,
        nVDash: nVDash,
        nvge: nvge,
        nvgt: nvgt,
        nvHarr: nvHarr,
        nvinfin: nvinfin,
        nvlArr: nvlArr,
        nvle: nvle,
        nvlt: nvlt,
        nvltrie: nvltrie,
        nvrArr: nvrArr,
        nvrtrie: nvrtrie,
        nvsim: nvsim,
        nwarhk: nwarhk,
        nwarr: nwarr,
        nwArr: nwArr,
        nwarrow: nwarrow,
        nwnear: nwnear,
        Oacute: Oacute,
        oacute: oacute,
        oast: oast,
        Ocirc: Ocirc,
        ocirc: ocirc,
        ocir: ocir,
        Ocy: Ocy,
        ocy: ocy,
        odash: odash,
        Odblac: Odblac,
        odblac: odblac,
        odiv: odiv,
        odot: odot,
        odsold: odsold,
        OElig: OElig,
        oelig: oelig,
        ofcir: ofcir,
        Ofr: Ofr,
        ofr: ofr,
        ogon: ogon,
        Ograve: Ograve,
        ograve: ograve,
        ogt: ogt,
        ohbar: ohbar,
        ohm: ohm,
        oint: oint,
        olarr: olarr,
        olcir: olcir,
        olcross: olcross,
        oline: oline,
        olt: olt,
        Omacr: Omacr,
        omacr: omacr,
        Omega: Omega,
        omega: omega,
        Omicron: Omicron,
        omicron: omicron,
        omid: omid,
        ominus: ominus,
        Oopf: Oopf,
        oopf: oopf,
        opar: opar,
        OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
        OpenCurlyQuote: OpenCurlyQuote,
        operp: operp,
        oplus: oplus,
        orarr: orarr,
        Or: Or,
        or: or,
        ord: ord,
        order: order,
        orderof: orderof,
        ordf: ordf,
        ordm: ordm,
        origof: origof,
        oror: oror,
        orslope: orslope,
        orv: orv,
        oS: oS,
        Oscr: Oscr,
        oscr: oscr,
        Oslash: Oslash,
        oslash: oslash,
        osol: osol,
        Otilde: Otilde,
        otilde: otilde,
        otimesas: otimesas,
        Otimes: Otimes,
        otimes: otimes,
        Ouml: Ouml,
        ouml: ouml,
        ovbar: ovbar,
        OverBar: OverBar,
        OverBrace: OverBrace,
        OverBracket: OverBracket,
        OverParenthesis: OverParenthesis,
        para: para,
        parallel: parallel,
        par: par,
        parsim: parsim,
        parsl: parsl,
        part: part,
        PartialD: PartialD,
        Pcy: Pcy,
        pcy: pcy,
        percnt: percnt,
        period: period,
        permil: permil,
        perp: perp,
        pertenk: pertenk,
        Pfr: Pfr,
        pfr: pfr,
        Phi: Phi,
        phi: phi,
        phiv: phiv,
        phmmat: phmmat,
        phone: phone,
        Pi: Pi,
        pi: pi,
        pitchfork: pitchfork,
        piv: piv,
        planck: planck,
        planckh: planckh,
        plankv: plankv,
        plusacir: plusacir,
        plusb: plusb,
        pluscir: pluscir,
        plus: plus,
        plusdo: plusdo,
        plusdu: plusdu,
        pluse: pluse,
        PlusMinus: PlusMinus,
        plusmn: plusmn,
        plussim: plussim,
        plustwo: plustwo,
        pm: pm,
        Poincareplane: Poincareplane,
        pointint: pointint,
        popf: popf,
        Popf: Popf,
        pound: pound,
        prap: prap,
        Pr: Pr,
        pr: pr,
        prcue: prcue,
        precapprox: precapprox,
        prec: prec,
        preccurlyeq: preccurlyeq,
        Precedes: Precedes,
        PrecedesEqual: PrecedesEqual,
        PrecedesSlantEqual: PrecedesSlantEqual,
        PrecedesTilde: PrecedesTilde,
        preceq: preceq,
        precnapprox: precnapprox,
        precneqq: precneqq,
        precnsim: precnsim,
        pre: pre,
        prE: prE,
        precsim: precsim,
        prime: prime,
        Prime: Prime,
        primes: primes,
        prnap: prnap,
        prnE: prnE,
        prnsim: prnsim,
        prod: prod,
        Product: Product,
        profalar: profalar,
        profline: profline,
        profsurf: profsurf,
        prop: prop,
        Proportional: Proportional,
        Proportion: Proportion,
        propto: propto,
        prsim: prsim,
        prurel: prurel,
        Pscr: Pscr,
        pscr: pscr,
        Psi: Psi,
        psi: psi,
        puncsp: puncsp,
        Qfr: Qfr,
        qfr: qfr,
        qint: qint,
        qopf: qopf,
        Qopf: Qopf,
        qprime: qprime,
        Qscr: Qscr,
        qscr: qscr,
        quaternions: quaternions,
        quatint: quatint,
        quest: quest,
        questeq: questeq,
        quot: quot,
        QUOT: QUOT,
        rAarr: rAarr,
        race: race,
        Racute: Racute,
        racute: racute,
        radic: radic,
        raemptyv: raemptyv,
        rang: rang,
        Rang: Rang,
        rangd: rangd,
        range: range,
        rangle: rangle,
        raquo: raquo,
        rarrap: rarrap,
        rarrb: rarrb,
        rarrbfs: rarrbfs,
        rarrc: rarrc,
        rarr: rarr,
        Rarr: Rarr,
        rArr: rArr,
        rarrfs: rarrfs,
        rarrhk: rarrhk,
        rarrlp: rarrlp,
        rarrpl: rarrpl,
        rarrsim: rarrsim,
        Rarrtl: Rarrtl,
        rarrtl: rarrtl,
        rarrw: rarrw,
        ratail: ratail,
        rAtail: rAtail,
        ratio: ratio,
        rationals: rationals,
        rbarr: rbarr,
        rBarr: rBarr,
        RBarr: RBarr,
        rbbrk: rbbrk,
        rbrace: rbrace,
        rbrack: rbrack,
        rbrke: rbrke,
        rbrksld: rbrksld,
        rbrkslu: rbrkslu,
        Rcaron: Rcaron,
        rcaron: rcaron,
        Rcedil: Rcedil,
        rcedil: rcedil,
        rceil: rceil,
        rcub: rcub,
        Rcy: Rcy,
        rcy: rcy,
        rdca: rdca,
        rdldhar: rdldhar,
        rdquo: rdquo,
        rdquor: rdquor,
        rdsh: rdsh,
        real: real,
        realine: realine,
        realpart: realpart,
        reals: reals,
        Re: Re,
        rect: rect,
        reg: reg,
        REG: REG,
        ReverseElement: ReverseElement,
        ReverseEquilibrium: ReverseEquilibrium,
        ReverseUpEquilibrium: ReverseUpEquilibrium,
        rfisht: rfisht,
        rfloor: rfloor,
        rfr: rfr,
        Rfr: Rfr,
        rHar: rHar,
        rhard: rhard,
        rharu: rharu,
        rharul: rharul,
        Rho: Rho,
        rho: rho,
        rhov: rhov,
        RightAngleBracket: RightAngleBracket,
        RightArrowBar: RightArrowBar,
        rightarrow: rightarrow,
        RightArrow: RightArrow,
        Rightarrow: Rightarrow,
        RightArrowLeftArrow: RightArrowLeftArrow,
        rightarrowtail: rightarrowtail,
        RightCeiling: RightCeiling,
        RightDoubleBracket: RightDoubleBracket,
        RightDownTeeVector: RightDownTeeVector,
        RightDownVectorBar: RightDownVectorBar,
        RightDownVector: RightDownVector,
        RightFloor: RightFloor,
        rightharpoondown: rightharpoondown,
        rightharpoonup: rightharpoonup,
        rightleftarrows: rightleftarrows,
        rightleftharpoons: rightleftharpoons,
        rightrightarrows: rightrightarrows,
        rightsquigarrow: rightsquigarrow,
        RightTeeArrow: RightTeeArrow,
        RightTee: RightTee,
        RightTeeVector: RightTeeVector,
        rightthreetimes: rightthreetimes,
        RightTriangleBar: RightTriangleBar,
        RightTriangle: RightTriangle,
        RightTriangleEqual: RightTriangleEqual,
        RightUpDownVector: RightUpDownVector,
        RightUpTeeVector: RightUpTeeVector,
        RightUpVectorBar: RightUpVectorBar,
        RightUpVector: RightUpVector,
        RightVectorBar: RightVectorBar,
        RightVector: RightVector,
        ring: ring,
        risingdotseq: risingdotseq,
        rlarr: rlarr,
        rlhar: rlhar,
        rlm: rlm,
        rmoustache: rmoustache,
        rmoust: rmoust,
        rnmid: rnmid,
        roang: roang,
        roarr: roarr,
        robrk: robrk,
        ropar: ropar,
        ropf: ropf,
        Ropf: Ropf,
        roplus: roplus,
        rotimes: rotimes,
        RoundImplies: RoundImplies,
        rpar: rpar,
        rpargt: rpargt,
        rppolint: rppolint,
        rrarr: rrarr,
        Rrightarrow: Rrightarrow,
        rsaquo: rsaquo,
        rscr: rscr,
        Rscr: Rscr,
        rsh: rsh,
        Rsh: Rsh,
        rsqb: rsqb,
        rsquo: rsquo,
        rsquor: rsquor,
        rthree: rthree,
        rtimes: rtimes,
        rtri: rtri,
        rtrie: rtrie,
        rtrif: rtrif,
        rtriltri: rtriltri,
        RuleDelayed: RuleDelayed,
        ruluhar: ruluhar,
        rx: rx,
        Sacute: Sacute,
        sacute: sacute,
        sbquo: sbquo,
        scap: scap,
        Scaron: Scaron,
        scaron: scaron,
        Sc: Sc,
        sc: sc,
        sccue: sccue,
        sce: sce,
        scE: scE,
        Scedil: Scedil,
        scedil: scedil,
        Scirc: Scirc,
        scirc: scirc,
        scnap: scnap,
        scnE: scnE,
        scnsim: scnsim,
        scpolint: scpolint,
        scsim: scsim,
        Scy: Scy,
        scy: scy,
        sdotb: sdotb,
        sdot: sdot,
        sdote: sdote,
        searhk: searhk,
        searr: searr,
        seArr: seArr,
        searrow: searrow,
        sect: sect,
        semi: semi,
        seswar: seswar,
        setminus: setminus,
        setmn: setmn,
        sext: sext,
        Sfr: Sfr,
        sfr: sfr,
        sfrown: sfrown,
        sharp: sharp,
        SHCHcy: SHCHcy,
        shchcy: shchcy,
        SHcy: SHcy,
        shcy: shcy,
        ShortDownArrow: ShortDownArrow,
        ShortLeftArrow: ShortLeftArrow,
        shortmid: shortmid,
        shortparallel: shortparallel,
        ShortRightArrow: ShortRightArrow,
        ShortUpArrow: ShortUpArrow,
        shy: shy,
        Sigma: Sigma,
        sigma: sigma,
        sigmaf: sigmaf,
        sigmav: sigmav,
        sim: sim,
        simdot: simdot,
        sime: sime,
        simeq: simeq,
        simg: simg,
        simgE: simgE,
        siml: siml,
        simlE: simlE,
        simne: simne,
        simplus: simplus,
        simrarr: simrarr,
        slarr: slarr,
        SmallCircle: SmallCircle,
        smallsetminus: smallsetminus,
        smashp: smashp,
        smeparsl: smeparsl,
        smid: smid,
        smile: smile,
        smt: smt,
        smte: smte,
        smtes: smtes,
        SOFTcy: SOFTcy,
        softcy: softcy,
        solbar: solbar,
        solb: solb,
        sol: sol,
        Sopf: Sopf,
        sopf: sopf,
        spades: spades,
        spadesuit: spadesuit,
        spar: spar,
        sqcap: sqcap,
        sqcaps: sqcaps,
        sqcup: sqcup,
        sqcups: sqcups,
        Sqrt: Sqrt,
        sqsub: sqsub,
        sqsube: sqsube,
        sqsubset: sqsubset,
        sqsubseteq: sqsubseteq,
        sqsup: sqsup,
        sqsupe: sqsupe,
        sqsupset: sqsupset,
        sqsupseteq: sqsupseteq,
        square: square,
        Square: Square,
        SquareIntersection: SquareIntersection,
        SquareSubset: SquareSubset,
        SquareSubsetEqual: SquareSubsetEqual,
        SquareSuperset: SquareSuperset,
        SquareSupersetEqual: SquareSupersetEqual,
        SquareUnion: SquareUnion,
        squarf: squarf,
        squ: squ,
        squf: squf,
        srarr: srarr,
        Sscr: Sscr,
        sscr: sscr,
        ssetmn: ssetmn,
        ssmile: ssmile,
        sstarf: sstarf,
        Star: Star,
        star: star,
        starf: starf,
        straightepsilon: straightepsilon,
        straightphi: straightphi,
        strns: strns,
        sub: sub,
        Sub: Sub,
        subdot: subdot,
        subE: subE,
        sube: sube,
        subedot: subedot,
        submult: submult,
        subnE: subnE,
        subne: subne,
        subplus: subplus,
        subrarr: subrarr,
        subset: subset,
        Subset: Subset,
        subseteq: subseteq,
        subseteqq: subseteqq,
        SubsetEqual: SubsetEqual,
        subsetneq: subsetneq,
        subsetneqq: subsetneqq,
        subsim: subsim,
        subsub: subsub,
        subsup: subsup,
        succapprox: succapprox,
        succ: succ,
        succcurlyeq: succcurlyeq,
        Succeeds: Succeeds,
        SucceedsEqual: SucceedsEqual,
        SucceedsSlantEqual: SucceedsSlantEqual,
        SucceedsTilde: SucceedsTilde,
        succeq: succeq,
        succnapprox: succnapprox,
        succneqq: succneqq,
        succnsim: succnsim,
        succsim: succsim,
        SuchThat: SuchThat,
        sum: sum,
        Sum: Sum,
        sung: sung,
        sup1: sup1,
        sup2: sup2,
        sup3: sup3,
        sup: sup,
        Sup: Sup,
        supdot: supdot,
        supdsub: supdsub,
        supE: supE,
        supe: supe,
        supedot: supedot,
        Superset: Superset,
        SupersetEqual: SupersetEqual,
        suphsol: suphsol,
        suphsub: suphsub,
        suplarr: suplarr,
        supmult: supmult,
        supnE: supnE,
        supne: supne,
        supplus: supplus,
        supset: supset,
        Supset: Supset,
        supseteq: supseteq,
        supseteqq: supseteqq,
        supsetneq: supsetneq,
        supsetneqq: supsetneqq,
        supsim: supsim,
        supsub: supsub,
        supsup: supsup,
        swarhk: swarhk,
        swarr: swarr,
        swArr: swArr,
        swarrow: swarrow,
        swnwar: swnwar,
        szlig: szlig,
        Tab: Tab,
        target: target,
        Tau: Tau,
        tau: tau,
        tbrk: tbrk,
        Tcaron: Tcaron,
        tcaron: tcaron,
        Tcedil: Tcedil,
        tcedil: tcedil,
        Tcy: Tcy,
        tcy: tcy,
        tdot: tdot,
        telrec: telrec,
        Tfr: Tfr,
        tfr: tfr,
        there4: there4,
        therefore: therefore,
        Therefore: Therefore,
        Theta: Theta,
        theta: theta,
        thetasym: thetasym,
        thetav: thetav,
        thickapprox: thickapprox,
        thicksim: thicksim,
        ThickSpace: ThickSpace,
        ThinSpace: ThinSpace,
        thinsp: thinsp,
        thkap: thkap,
        thksim: thksim,
        THORN: THORN,
        thorn: thorn,
        tilde: tilde,
        Tilde: Tilde,
        TildeEqual: TildeEqual,
        TildeFullEqual: TildeFullEqual,
        TildeTilde: TildeTilde,
        timesbar: timesbar,
        timesb: timesb,
        times: times,
        timesd: timesd,
        tint: tint,
        toea: toea,
        topbot: topbot,
        topcir: topcir,
        top: top,
        Topf: Topf,
        topf: topf,
        topfork: topfork,
        tosa: tosa,
        tprime: tprime,
        trade: trade,
        TRADE: TRADE,
        triangle: triangle,
        triangledown: triangledown,
        triangleleft: triangleleft,
        trianglelefteq: trianglelefteq,
        triangleq: triangleq,
        triangleright: triangleright,
        trianglerighteq: trianglerighteq,
        tridot: tridot,
        trie: trie,
        triminus: triminus,
        TripleDot: TripleDot,
        triplus: triplus,
        trisb: trisb,
        tritime: tritime,
        trpezium: trpezium,
        Tscr: Tscr,
        tscr: tscr,
        TScy: TScy,
        tscy: tscy,
        TSHcy: TSHcy,
        tshcy: tshcy,
        Tstrok: Tstrok,
        tstrok: tstrok,
        twixt: twixt,
        twoheadleftarrow: twoheadleftarrow,
        twoheadrightarrow: twoheadrightarrow,
        Uacute: Uacute,
        uacute: uacute,
        uarr: uarr,
        Uarr: Uarr,
        uArr: uArr,
        Uarrocir: Uarrocir,
        Ubrcy: Ubrcy,
        ubrcy: ubrcy,
        Ubreve: Ubreve,
        ubreve: ubreve,
        Ucirc: Ucirc,
        ucirc: ucirc,
        Ucy: Ucy,
        ucy: ucy,
        udarr: udarr,
        Udblac: Udblac,
        udblac: udblac,
        udhar: udhar,
        ufisht: ufisht,
        Ufr: Ufr,
        ufr: ufr,
        Ugrave: Ugrave,
        ugrave: ugrave,
        uHar: uHar,
        uharl: uharl,
        uharr: uharr,
        uhblk: uhblk,
        ulcorn: ulcorn,
        ulcorner: ulcorner,
        ulcrop: ulcrop,
        ultri: ultri,
        Umacr: Umacr,
        umacr: umacr,
        uml: uml,
        UnderBar: UnderBar,
        UnderBrace: UnderBrace,
        UnderBracket: UnderBracket,
        UnderParenthesis: UnderParenthesis,
        Union: Union,
        UnionPlus: UnionPlus,
        Uogon: Uogon,
        uogon: uogon,
        Uopf: Uopf,
        uopf: uopf,
        UpArrowBar: UpArrowBar,
        uparrow: uparrow,
        UpArrow: UpArrow,
        Uparrow: Uparrow,
        UpArrowDownArrow: UpArrowDownArrow,
        updownarrow: updownarrow,
        UpDownArrow: UpDownArrow,
        Updownarrow: Updownarrow,
        UpEquilibrium: UpEquilibrium,
        upharpoonleft: upharpoonleft,
        upharpoonright: upharpoonright,
        uplus: uplus,
        UpperLeftArrow: UpperLeftArrow,
        UpperRightArrow: UpperRightArrow,
        upsi: upsi,
        Upsi: Upsi,
        upsih: upsih,
        Upsilon: Upsilon,
        upsilon: upsilon,
        UpTeeArrow: UpTeeArrow,
        UpTee: UpTee,
        upuparrows: upuparrows,
        urcorn: urcorn,
        urcorner: urcorner,
        urcrop: urcrop,
        Uring: Uring,
        uring: uring,
        urtri: urtri,
        Uscr: Uscr,
        uscr: uscr,
        utdot: utdot,
        Utilde: Utilde,
        utilde: utilde,
        utri: utri,
        utrif: utrif,
        uuarr: uuarr,
        Uuml: Uuml,
        uuml: uuml,
        uwangle: uwangle,
        vangrt: vangrt,
        varepsilon: varepsilon,
        varkappa: varkappa,
        varnothing: varnothing,
        varphi: varphi,
        varpi: varpi,
        varpropto: varpropto,
        varr: varr,
        vArr: vArr,
        varrho: varrho,
        varsigma: varsigma,
        varsubsetneq: varsubsetneq,
        varsubsetneqq: varsubsetneqq,
        varsupsetneq: varsupsetneq,
        varsupsetneqq: varsupsetneqq,
        vartheta: vartheta,
        vartriangleleft: vartriangleleft,
        vartriangleright: vartriangleright,
        vBar: vBar,
        Vbar: Vbar,
        vBarv: vBarv,
        Vcy: Vcy,
        vcy: vcy,
        vdash: vdash,
        vDash: vDash,
        Vdash: Vdash,
        VDash: VDash,
        Vdashl: Vdashl,
        veebar: veebar,
        vee: vee,
        Vee: Vee,
        veeeq: veeeq,
        vellip: vellip,
        verbar: verbar,
        Verbar: Verbar,
        vert: vert,
        Vert: Vert,
        VerticalBar: VerticalBar,
        VerticalLine: VerticalLine,
        VerticalSeparator: VerticalSeparator,
        VerticalTilde: VerticalTilde,
        VeryThinSpace: VeryThinSpace,
        Vfr: Vfr,
        vfr: vfr,
        vltri: vltri,
        vnsub: vnsub,
        vnsup: vnsup,
        Vopf: Vopf,
        vopf: vopf,
        vprop: vprop,
        vrtri: vrtri,
        Vscr: Vscr,
        vscr: vscr,
        vsubnE: vsubnE,
        vsubne: vsubne,
        vsupnE: vsupnE,
        vsupne: vsupne,
        Vvdash: Vvdash,
        vzigzag: vzigzag,
        Wcirc: Wcirc,
        wcirc: wcirc,
        wedbar: wedbar,
        wedge: wedge,
        Wedge: Wedge,
        wedgeq: wedgeq,
        weierp: weierp,
        Wfr: Wfr,
        wfr: wfr,
        Wopf: Wopf,
        wopf: wopf,
        wp: wp,
        wr: wr,
        wreath: wreath,
        Wscr: Wscr,
        wscr: wscr,
        xcap: xcap,
        xcirc: xcirc,
        xcup: xcup,
        xdtri: xdtri,
        Xfr: Xfr,
        xfr: xfr,
        xharr: xharr,
        xhArr: xhArr,
        Xi: Xi,
        xi: xi,
        xlarr: xlarr,
        xlArr: xlArr,
        xmap: xmap,
        xnis: xnis,
        xodot: xodot,
        Xopf: Xopf,
        xopf: xopf,
        xoplus: xoplus,
        xotime: xotime,
        xrarr: xrarr,
        xrArr: xrArr,
        Xscr: Xscr,
        xscr: xscr,
        xsqcup: xsqcup,
        xuplus: xuplus,
        xutri: xutri,
        xvee: xvee,
        xwedge: xwedge,
        Yacute: Yacute,
        yacute: yacute,
        YAcy: YAcy,
        yacy: yacy,
        Ycirc: Ycirc,
        ycirc: ycirc,
        Ycy: Ycy,
        ycy: ycy,
        yen: yen,
        Yfr: Yfr,
        yfr: yfr,
        YIcy: YIcy,
        yicy: yicy,
        Yopf: Yopf,
        yopf: yopf,
        Yscr: Yscr,
        yscr: yscr,
        YUcy: YUcy,
        yucy: yucy,
        yuml: yuml,
        Yuml: Yuml,
        Zacute: Zacute,
        zacute: zacute,
        Zcaron: Zcaron,
        zcaron: zcaron,
        Zcy: Zcy,
        zcy: zcy,
        Zdot: Zdot,
        zdot: zdot,
        zeetrf: zeetrf,
        ZeroWidthSpace: ZeroWidthSpace,
        Zeta: Zeta,
        zeta: zeta,
        zfr: zfr,
        Zfr: Zfr,
        ZHcy: ZHcy,
        zhcy: zhcy,
        zigrarr: zigrarr,
        zopf: zopf,
        Zopf: Zopf,
        Zscr: Zscr,
        zscr: zscr,
        zwj: zwj,
        zwnj: zwnj,
        'default': entities
    });

    var require$$0 = getCjsExportFromNamespace(entities$1);

    /*eslint quotes:0*/
    var entities$2 = require$$0;

    var regex=/[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

    var encodeCache = {};


    // Create a lookup array where anything but characters in `chars` string
    // and alphanumeric chars is percent-encoded.
    //
    function getEncodeCache(exclude) {
      var i, ch, cache = encodeCache[exclude];
      if (cache) { return cache; }

      cache = encodeCache[exclude] = [];

      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);

        if (/^[0-9a-z]$/i.test(ch)) {
          // always allow unencoded alphanumeric characters
          cache.push(ch);
        } else {
          cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
        }
      }

      for (i = 0; i < exclude.length; i++) {
        cache[exclude.charCodeAt(i)] = exclude[i];
      }

      return cache;
    }


    // Encode unsafe characters with percent-encoding, skipping already
    // encoded sequences.
    //
    //  - string       - string to encode
    //  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
    //  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
    //
    function encode(string, exclude, keepEscaped) {
      var i, l, code, nextCode, cache,
          result = '';

      if (typeof exclude !== 'string') {
        // encode(string, keepEscaped)
        keepEscaped  = exclude;
        exclude = encode.defaultChars;
      }

      if (typeof keepEscaped === 'undefined') {
        keepEscaped = true;
      }

      cache = getEncodeCache(exclude);

      for (i = 0, l = string.length; i < l; i++) {
        code = string.charCodeAt(i);

        if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
          if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
            result += string.slice(i, i + 3);
            i += 2;
            continue;
          }
        }

        if (code < 128) {
          result += cache[code];
          continue;
        }

        if (code >= 0xD800 && code <= 0xDFFF) {
          if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
            nextCode = string.charCodeAt(i + 1);
            if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
              result += encodeURIComponent(string[i] + string[i + 1]);
              i++;
              continue;
            }
          }
          result += '%EF%BF%BD';
          continue;
        }

        result += encodeURIComponent(string[i]);
      }

      return result;
    }

    encode.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
    encode.componentChars = "-_.!~*'()";


    var encode_1 = encode;

    /* eslint-disable no-bitwise */

    var decodeCache = {};

    function getDecodeCache(exclude) {
      var i, ch, cache = decodeCache[exclude];
      if (cache) { return cache; }

      cache = decodeCache[exclude] = [];

      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        cache.push(ch);
      }

      for (i = 0; i < exclude.length; i++) {
        ch = exclude.charCodeAt(i);
        cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
      }

      return cache;
    }


    // Decode percent-encoded string.
    //
    function decode(string, exclude) {
      var cache;

      if (typeof exclude !== 'string') {
        exclude = decode.defaultChars;
      }

      cache = getDecodeCache(exclude);

      return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
        var i, l, b1, b2, b3, b4, chr,
            result = '';

        for (i = 0, l = seq.length; i < l; i += 3) {
          b1 = parseInt(seq.slice(i + 1, i + 3), 16);

          if (b1 < 0x80) {
            result += cache[b1];
            continue;
          }

          if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {
            // 110xxxxx 10xxxxxx
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);

            if ((b2 & 0xC0) === 0x80) {
              chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);

              if (chr < 0x80) {
                result += '\ufffd\ufffd';
              } else {
                result += String.fromCharCode(chr);
              }

              i += 3;
              continue;
            }
          }

          if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {
            // 1110xxxx 10xxxxxx 10xxxxxx
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq.slice(i + 7, i + 9), 16);

            if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
              chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);

              if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {
                result += '\ufffd\ufffd\ufffd';
              } else {
                result += String.fromCharCode(chr);
              }

              i += 6;
              continue;
            }
          }

          if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {
            // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq.slice(i + 7, i + 9), 16);
            b4 = parseInt(seq.slice(i + 10, i + 12), 16);

            if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
              chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);

              if (chr < 0x10000 || chr > 0x10FFFF) {
                result += '\ufffd\ufffd\ufffd\ufffd';
              } else {
                chr -= 0x10000;
                result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
              }

              i += 9;
              continue;
            }
          }

          result += '\ufffd';
        }

        return result;
      });
    }


    decode.defaultChars   = ';/?:@&=+$,#';
    decode.componentChars = '';


    var decode_1 = decode;

    var format = function format(url) {
      var result = '';

      result += url.protocol || '';
      result += url.slashes ? '//' : '';
      result += url.auth ? url.auth + '@' : '';

      if (url.hostname && url.hostname.indexOf(':') !== -1) {
        // ipv6 address
        result += '[' + url.hostname + ']';
      } else {
        result += url.hostname || '';
      }

      result += url.port ? ':' + url.port : '';
      result += url.pathname || '';
      result += url.search || '';
      result += url.hash || '';

      return result;
    };

    // Copyright Joyent, Inc. and other Node contributors.

    //
    // Changes from joyent/node:
    //
    // 1. No leading slash in paths,
    //    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
    //
    // 2. Backslashes are not replaced with slashes,
    //    so `http:\\example.org\` is treated like a relative path
    //
    // 3. Trailing colon is treated like a part of the path,
    //    i.e. in `http://example.org:foo` pathname is `:foo`
    //
    // 4. Nothing is URL-encoded in the resulting object,
    //    (in joyent/node some chars in auth and paths are encoded)
    //
    // 5. `url.parse()` does not have `parseQueryString` argument
    //
    // 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
    //    which can be constructed using other parts of the url.
    //


    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }

    // Reference: RFC 3986, RFC 1808, RFC 2396

    // define these here so at least they only have to be
    // compiled once on the first module load.
    var protocolPattern = /^([a-z0-9.+-]+:)/i,
        portPattern = /:[0-9]*$/,

        // Special case for a simple path URL
        simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

        // RFC 2396: characters reserved for delimiting URLs.
        // We actually just auto-escape these.
        delims = [ '<', '>', '"', '`', ' ', '\r', '\n', '\t' ],

        // RFC 2396: characters not allowed for various reasons.
        unwise = [ '{', '}', '|', '\\', '^', '`' ].concat(delims),

        // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
        autoEscape = [ '\'' ].concat(unwise),
        // Characters that are never ever allowed in a hostname.
        // Note that any invalid chars are also handled, but these
        // are the ones that are *expected* to be seen, so we fast-path
        // them.
        nonHostChars = [ '%', '/', '?', ';', '#' ].concat(autoEscape),
        hostEndingChars = [ '/', '?', '#' ],
        hostnameMaxLen = 255,
        hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
        hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
        // protocols that can allow "unsafe" and "unwise" chars.
        /* eslint-disable no-script-url */
        // protocols that never have a hostname.
        hostlessProtocol = {
          'javascript': true,
          'javascript:': true
        },
        // protocols that always contain a // bit.
        slashedProtocol = {
          'http': true,
          'https': true,
          'ftp': true,
          'gopher': true,
          'file': true,
          'http:': true,
          'https:': true,
          'ftp:': true,
          'gopher:': true,
          'file:': true
        };
        /* eslint-enable no-script-url */

    function urlParse(url, slashesDenoteHost) {
      if (url && url instanceof Url) { return url; }

      var u = new Url();
      u.parse(url, slashesDenoteHost);
      return u;
    }

    Url.prototype.parse = function(url, slashesDenoteHost) {
      var i, l, lowerProto, hec, slashes,
          rest = url;

      // trim before proceeding.
      // This is to support parse stuff like "  http://foo.com  \n"
      rest = rest.trim();

      if (!slashesDenoteHost && url.split('#').length === 1) {
        // Try fast path regexp
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }

      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        lowerProto = proto.toLowerCase();
        this.protocol = proto;
        rest = rest.substr(proto.length);
      }

      // figure out if it's got a host
      // user@server is *always* interpreted as a hostname, and url
      // resolution will treat //foo/bar as host=foo,path=bar because that's
      // how the browser resolves relative URLs.
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest.substr(0, 2) === '//';
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }

      if (!hostlessProtocol[proto] &&
          (slashes || (proto && !slashedProtocol[proto]))) {

        // there's a hostname.
        // the first instance of /, ?, ;, or # ends the host.
        //
        // If there is an @ in the hostname, then non-host chars *are* allowed
        // to the left of the last @ sign, unless some host-ending character
        // comes *before* the @-sign.
        // URLs are obnoxious.
        //
        // ex:
        // http://a@b@c/ => user:a@b host:c
        // http://a@b?@c => user:a host:c path:/?@c

        // v0.12 TODO(isaacs): This is not quite how Chrome does things.
        // Review our test case against browsers more comprehensively.

        // find the first instance of any hostEndingChars
        var hostEnd = -1;
        for (i = 0; i < hostEndingChars.length; i++) {
          hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }

        // at this point, either we have an explicit point where the
        // auth portion cannot go past, or the last @ char is the decider.
        var auth, atSign;
        if (hostEnd === -1) {
          // atSign can be anywhere.
          atSign = rest.lastIndexOf('@');
        } else {
          // atSign must be in auth portion.
          // http://a@b/c@d => host:b auth:a path:/c@d
          atSign = rest.lastIndexOf('@', hostEnd);
        }

        // Now we have a portion which is definitely the auth.
        // Pull that off.
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = auth;
        }

        // the host is the remaining to the left of the first non-host char
        hostEnd = -1;
        for (i = 0; i < nonHostChars.length; i++) {
          hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        // if we still have not hit it, then the entire thing is a host.
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }

        if (rest[hostEnd - 1] === ':') { hostEnd--; }
        var host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);

        // pull out port.
        this.parseHost(host);

        // we've indicated that there is a hostname,
        // so even if it's empty, it has to be present.
        this.hostname = this.hostname || '';

        // if hostname begins with [ and ends with ]
        // assume that it's an IPv6 address.
        var ipv6Hostname = this.hostname[0] === '[' &&
            this.hostname[this.hostname.length - 1] === ']';

        // validate a little.
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) { continue; }
            if (!part.match(hostnamePartPattern)) {
              var newpart = '';
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  // we replace non-ASCII char with a temporary placeholder
                  // we need this to make sure size of hostname is not
                  // broken by replacing non-ASCII by nothing
                  newpart += 'x';
                } else {
                  newpart += part[j];
                }
              }
              // we test again with ASCII char only
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = notHost.join('.') + rest;
                }
                this.hostname = validParts.join('.');
                break;
              }
            }
          }
        }

        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = '';
        }

        // strip [ and ] from the hostname
        // the host field still retains them, though
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }

      // chop off from the tail first.
      var hash = rest.indexOf('#');
      if (hash !== -1) {
        // got a fragment string.
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf('?');
      if (qm !== -1) {
        this.search = rest.substr(qm);
        rest = rest.slice(0, qm);
      }
      if (rest) { this.pathname = rest; }
      if (slashedProtocol[lowerProto] &&
          this.hostname && !this.pathname) {
        this.pathname = '';
      }

      return this;
    };

    Url.prototype.parseHost = function(host) {
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ':') {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) { this.hostname = host; }
    };

    var parse = urlParse;

    var encode$1 = encode_1;
    var decode$1 = decode_1;
    var format$1 = format;
    var parse$1  = parse;

    var mdurl = {
    	encode: encode$1,
    	decode: decode$1,
    	format: format$1,
    	parse: parse$1
    };

    var regex$1=/[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

    var regex$2=/[\0-\x1F\x7F-\x9F]/;

    var regex$3=/[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

    var regex$4=/[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;

    var Any = regex$1;
    var Cc  = regex$2;
    var Cf  = regex$3;
    var P   = regex;
    var Z   = regex$4;

    var uc_micro = {
    	Any: Any,
    	Cc: Cc,
    	Cf: Cf,
    	P: P,
    	Z: Z
    };

    var utils = createCommonjsModule(function (module, exports) {


    function _class(obj) { return Object.prototype.toString.call(obj); }

    function isString(obj) { return _class(obj) === '[object String]'; }

    var _hasOwnProperty = Object.prototype.hasOwnProperty;

    function has(object, key) {
      return _hasOwnProperty.call(object, key);
    }

    // Merge objects
    //
    function assign(obj /*from1, from2, from3, ...*/) {
      var sources = Array.prototype.slice.call(arguments, 1);

      sources.forEach(function (source) {
        if (!source) { return; }

        if (typeof source !== 'object') {
          throw new TypeError(source + 'must be object');
        }

        Object.keys(source).forEach(function (key) {
          obj[key] = source[key];
        });
      });

      return obj;
    }

    // Remove element from array and put another array at those position.
    // Useful for some operations with tokens
    function arrayReplaceAt(src, pos, newElements) {
      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
    }

    ////////////////////////////////////////////////////////////////////////////////

    function isValidEntityCode(c) {
      /*eslint no-bitwise:0*/
      // broken sequence
      if (c >= 0xD800 && c <= 0xDFFF) { return false; }
      // never used
      if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }
      if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }
      // control codes
      if (c >= 0x00 && c <= 0x08) { return false; }
      if (c === 0x0B) { return false; }
      if (c >= 0x0E && c <= 0x1F) { return false; }
      if (c >= 0x7F && c <= 0x9F) { return false; }
      // out of range
      if (c > 0x10FFFF) { return false; }
      return true;
    }

    function fromCodePoint(c) {
      /*eslint no-bitwise:0*/
      if (c > 0xffff) {
        c -= 0x10000;
        var surrogate1 = 0xd800 + (c >> 10),
            surrogate2 = 0xdc00 + (c & 0x3ff);

        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c);
    }


    var UNESCAPE_MD_RE  = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;



    function replaceEntityPattern(match, name) {
      var code = 0;

      if (has(entities$2, name)) {
        return entities$2[name];
      }

      if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
        code = name[1].toLowerCase() === 'x' ?
          parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);

        if (isValidEntityCode(code)) {
          return fromCodePoint(code);
        }
      }

      return match;
    }

    /*function replaceEntities(str) {
      if (str.indexOf('&') < 0) { return str; }

      return str.replace(ENTITY_RE, replaceEntityPattern);
    }*/

    function unescapeMd(str) {
      if (str.indexOf('\\') < 0) { return str; }
      return str.replace(UNESCAPE_MD_RE, '$1');
    }

    function unescapeAll(str) {
      if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) { return str; }

      return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
        if (escaped) { return escaped; }
        return replaceEntityPattern(match, entity);
      });
    }

    ////////////////////////////////////////////////////////////////////////////////

    var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;'
    };

    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }

    function escapeHtml(str) {
      if (HTML_ESCAPE_TEST_RE.test(str)) {
        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }
      return str;
    }

    ////////////////////////////////////////////////////////////////////////////////

    var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

    function escapeRE(str) {
      return str.replace(REGEXP_ESCAPE_RE, '\\$&');
    }

    ////////////////////////////////////////////////////////////////////////////////

    function isSpace(code) {
      switch (code) {
        case 0x09:
        case 0x20:
          return true;
      }
      return false;
    }

    // Zs (unicode class) || [\t\f\v\r\n]
    function isWhiteSpace(code) {
      if (code >= 0x2000 && code <= 0x200A) { return true; }
      switch (code) {
        case 0x09: // \t
        case 0x0A: // \n
        case 0x0B: // \v
        case 0x0C: // \f
        case 0x0D: // \r
        case 0x20:
        case 0xA0:
        case 0x1680:
        case 0x202F:
        case 0x205F:
        case 0x3000:
          return true;
      }
      return false;
    }

    ////////////////////////////////////////////////////////////////////////////////

    /*eslint-disable max-len*/


    // Currently without astral characters support.
    function isPunctChar(ch) {
      return regex.test(ch);
    }


    // Markdown ASCII punctuation characters.
    //
    // !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
    // http://spec.commonmark.org/0.15/#ascii-punctuation-character
    //
    // Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
    //
    function isMdAsciiPunct(ch) {
      switch (ch) {
        case 0x21/* ! */:
        case 0x22/* " */:
        case 0x23/* # */:
        case 0x24/* $ */:
        case 0x25/* % */:
        case 0x26/* & */:
        case 0x27/* ' */:
        case 0x28/* ( */:
        case 0x29/* ) */:
        case 0x2A/* * */:
        case 0x2B/* + */:
        case 0x2C/* , */:
        case 0x2D/* - */:
        case 0x2E/* . */:
        case 0x2F/* / */:
        case 0x3A/* : */:
        case 0x3B/* ; */:
        case 0x3C/* < */:
        case 0x3D/* = */:
        case 0x3E/* > */:
        case 0x3F/* ? */:
        case 0x40/* @ */:
        case 0x5B/* [ */:
        case 0x5C/* \ */:
        case 0x5D/* ] */:
        case 0x5E/* ^ */:
        case 0x5F/* _ */:
        case 0x60/* ` */:
        case 0x7B/* { */:
        case 0x7C/* | */:
        case 0x7D/* } */:
        case 0x7E/* ~ */:
          return true;
        default:
          return false;
      }
    }

    // Hepler to unify [reference labels].
    //
    function normalizeReference(str) {
      // Trim and collapse whitespace
      //
      str = str.trim().replace(/\s+/g, ' ');

      // In node v10 'ẞ'.toLowerCase() === 'Ṿ', which is presumed to be a bug
      // fixed in v12 (couldn't find any details).
      //
      // So treat this one as a special case
      // (remove this when node v10 is no longer supported).
      //
      if ('ẞ'.toLowerCase() === 'Ṿ') {
        str = str.replace(/ẞ/g, 'ß');
      }

      // .toLowerCase().toUpperCase() should get rid of all differences
      // between letter variants.
      //
      // Simple .toLowerCase() doesn't normalize 125 code points correctly,
      // and .toUpperCase doesn't normalize 6 of them (list of exceptions:
      // İ, ϴ, ẞ, Ω, K, Å - those are already uppercased, but have differently
      // uppercased versions).
      //
      // Here's an example showing how it happens. Lets take greek letter omega:
      // uppercase U+0398 (Θ), U+03f4 (ϴ) and lowercase U+03b8 (θ), U+03d1 (ϑ)
      //
      // Unicode entries:
      // 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;
      // 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398
      // 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398
      // 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;
      //
      // Case-insensitive comparison should treat all of them as equivalent.
      //
      // But .toLowerCase() doesn't change ϑ (it's already lowercase),
      // and .toUpperCase() doesn't change ϴ (already uppercase).
      //
      // Applying first lower then upper case normalizes any character:
      // '\u0398\u03f4\u03b8\u03d1'.toLowerCase().toUpperCase() === '\u0398\u0398\u0398\u0398'
      //
      // Note: this is equivalent to unicode case folding; unicode normalization
      // is a different step that is not required here.
      //
      // Final result should be uppercased, because it's later stored in an object
      // (this avoid a conflict with Object.prototype members,
      // most notably, `__proto__`)
      //
      return str.toLowerCase().toUpperCase();
    }

    ////////////////////////////////////////////////////////////////////////////////

    // Re-export libraries commonly used in both markdown-it and its plugins,
    // so plugins won't have to depend on them explicitly, which reduces their
    // bundled size (e.g. a browser build).
    //
    exports.lib                 = {};
    exports.lib.mdurl           = mdurl;
    exports.lib.ucmicro         = uc_micro;

    exports.assign              = assign;
    exports.isString            = isString;
    exports.has                 = has;
    exports.unescapeMd          = unescapeMd;
    exports.unescapeAll         = unescapeAll;
    exports.isValidEntityCode   = isValidEntityCode;
    exports.fromCodePoint       = fromCodePoint;
    // exports.replaceEntities     = replaceEntities;
    exports.escapeHtml          = escapeHtml;
    exports.arrayReplaceAt      = arrayReplaceAt;
    exports.isSpace             = isSpace;
    exports.isWhiteSpace        = isWhiteSpace;
    exports.isMdAsciiPunct      = isMdAsciiPunct;
    exports.isPunctChar         = isPunctChar;
    exports.escapeRE            = escapeRE;
    exports.normalizeReference  = normalizeReference;
    });
    var utils_1 = utils.lib;
    var utils_2 = utils.assign;
    var utils_3 = utils.isString;
    var utils_4 = utils.has;
    var utils_5 = utils.unescapeMd;
    var utils_6 = utils.unescapeAll;
    var utils_7 = utils.isValidEntityCode;
    var utils_8 = utils.fromCodePoint;
    var utils_9 = utils.escapeHtml;
    var utils_10 = utils.arrayReplaceAt;
    var utils_11 = utils.isSpace;
    var utils_12 = utils.isWhiteSpace;
    var utils_13 = utils.isMdAsciiPunct;
    var utils_14 = utils.isPunctChar;
    var utils_15 = utils.escapeRE;
    var utils_16 = utils.normalizeReference;

    // Parse link label

    var parse_link_label = function parseLinkLabel(state, start, disableNested) {
      var level, found, marker, prevPos,
          labelEnd = -1,
          max = state.posMax,
          oldPos = state.pos;

      state.pos = start + 1;
      level = 1;

      while (state.pos < max) {
        marker = state.src.charCodeAt(state.pos);
        if (marker === 0x5D /* ] */) {
          level--;
          if (level === 0) {
            found = true;
            break;
          }
        }

        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker === 0x5B /* [ */) {
          if (prevPos === state.pos - 1) {
            // increase level if we find text `[`, which is not a part of any token
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }

      if (found) {
        labelEnd = state.pos;
      }

      // restore old state
      state.pos = oldPos;

      return labelEnd;
    };

    var unescapeAll = utils.unescapeAll;


    var parse_link_destination = function parseLinkDestination(str, pos, max) {
      var code, level,
          lines = 0,
          start = pos,
          result = {
            ok: false,
            pos: 0,
            lines: 0,
            str: ''
          };

      if (str.charCodeAt(pos) === 0x3C /* < */) {
        pos++;
        while (pos < max) {
          code = str.charCodeAt(pos);
          if (code === 0x0A /* \n */) { return result; }
          if (code === 0x3E /* > */) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
          if (code === 0x5C /* \ */ && pos + 1 < max) {
            pos += 2;
            continue;
          }

          pos++;
        }

        // no closing '>'
        return result;
      }

      // this should be ... } else { ... branch

      level = 0;
      while (pos < max) {
        code = str.charCodeAt(pos);

        if (code === 0x20) { break; }

        // ascii control characters
        if (code < 0x20 || code === 0x7F) { break; }

        if (code === 0x5C /* \ */ && pos + 1 < max) {
          pos += 2;
          continue;
        }

        if (code === 0x28 /* ( */) {
          level++;
        }

        if (code === 0x29 /* ) */) {
          if (level === 0) { break; }
          level--;
        }

        pos++;
      }

      if (start === pos) { return result; }
      if (level !== 0) { return result; }

      result.str = unescapeAll(str.slice(start, pos));
      result.lines = lines;
      result.pos = pos;
      result.ok = true;
      return result;
    };

    var unescapeAll$1 = utils.unescapeAll;


    var parse_link_title = function parseLinkTitle(str, pos, max) {
      var code,
          marker,
          lines = 0,
          start = pos,
          result = {
            ok: false,
            pos: 0,
            lines: 0,
            str: ''
          };

      if (pos >= max) { return result; }

      marker = str.charCodeAt(pos);

      if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return result; }

      pos++;

      // if opening marker is "(", switch it to closing marker ")"
      if (marker === 0x28) { marker = 0x29; }

      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === marker) {
          result.pos = pos + 1;
          result.lines = lines;
          result.str = unescapeAll$1(str.slice(start + 1, pos));
          result.ok = true;
          return result;
        } else if (code === 0x0A) {
          lines++;
        } else if (code === 0x5C /* \ */ && pos + 1 < max) {
          pos++;
          if (str.charCodeAt(pos) === 0x0A) {
            lines++;
          }
        }

        pos++;
      }

      return result;
    };

    var parseLinkLabel       = parse_link_label;
    var parseLinkDestination = parse_link_destination;
    var parseLinkTitle       = parse_link_title;

    var helpers = {
    	parseLinkLabel: parseLinkLabel,
    	parseLinkDestination: parseLinkDestination,
    	parseLinkTitle: parseLinkTitle
    };

    var assign$1          = utils.assign;
    var unescapeAll$2     = utils.unescapeAll;
    var escapeHtml      = utils.escapeHtml;


    ////////////////////////////////////////////////////////////////////////////////

    var default_rules = {};


    default_rules.code_inline = function (tokens, idx, options, env, slf) {
      var token = tokens[idx];

      return  '<code' + slf.renderAttrs(token) + '>' +
              escapeHtml(tokens[idx].content) +
              '</code>';
    };


    default_rules.code_block = function (tokens, idx, options, env, slf) {
      var token = tokens[idx];

      return  '<pre' + slf.renderAttrs(token) + '><code>' +
              escapeHtml(tokens[idx].content) +
              '</code></pre>\n';
    };


    default_rules.fence = function (tokens, idx, options, env, slf) {
      var token = tokens[idx],
          info = token.info ? unescapeAll$2(token.info).trim() : '',
          langName = '',
          langAttrs = '',
          highlighted, i, arr, tmpAttrs, tmpToken;

      if (info) {
        arr = info.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join('');
      }

      if (options.highlight) {
        highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
      } else {
        highlighted = escapeHtml(token.content);
      }

      if (highlighted.indexOf('<pre') === 0) {
        return highlighted + '\n';
      }

      // If language exists, inject class gently, without modifying original token.
      // May be, one day we will add .clone() for token and simplify this part, but
      // now we prefer to keep things local.
      if (info) {
        i        = token.attrIndex('class');
        tmpAttrs = token.attrs ? token.attrs.slice() : [];

        if (i < 0) {
          tmpAttrs.push([ 'class', options.langPrefix + langName ]);
        } else {
          tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
        }

        // Fake token just to render attributes
        tmpToken = {
          attrs: tmpAttrs
        };

        return  '<pre><code' + slf.renderAttrs(tmpToken) + '>'
              + highlighted
              + '</code></pre>\n';
      }


      return  '<pre><code' + slf.renderAttrs(token) + '>'
            + highlighted
            + '</code></pre>\n';
    };


    default_rules.image = function (tokens, idx, options, env, slf) {
      var token = tokens[idx];

      // "alt" attr MUST be set, even if empty. Because it's mandatory and
      // should be placed on proper position for tests.
      //
      // Replace content with actual value

      token.attrs[token.attrIndex('alt')][1] =
        slf.renderInlineAsText(token.children, options, env);

      return slf.renderToken(tokens, idx, options);
    };


    default_rules.hardbreak = function (tokens, idx, options /*, env */) {
      return options.xhtmlOut ? '<br />\n' : '<br>\n';
    };
    default_rules.softbreak = function (tokens, idx, options /*, env */) {
      return options.breaks ? (options.xhtmlOut ? '<br />\n' : '<br>\n') : '\n';
    };


    default_rules.text = function (tokens, idx /*, options, env */) {
      return escapeHtml(tokens[idx].content);
    };


    default_rules.html_block = function (tokens, idx /*, options, env */) {
      return tokens[idx].content;
    };
    default_rules.html_inline = function (tokens, idx /*, options, env */) {
      return tokens[idx].content;
    };


    /**
     * new Renderer()
     *
     * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
     **/
    function Renderer() {

      /**
       * Renderer#rules -> Object
       *
       * Contains render rules for tokens. Can be updated and extended.
       *
       * ##### Example
       *
       * ```javascript
       * var md = require('markdown-it')();
       *
       * md.renderer.rules.strong_open  = function () { return '<b>'; };
       * md.renderer.rules.strong_close = function () { return '</b>'; };
       *
       * var result = md.renderInline(...);
       * ```
       *
       * Each rule is called as independent static function with fixed signature:
       *
       * ```javascript
       * function my_token_render(tokens, idx, options, env, renderer) {
       *   // ...
       *   return renderedHTML;
       * }
       * ```
       *
       * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
       * for more details and examples.
       **/
      this.rules = assign$1({}, default_rules);
    }


    /**
     * Renderer.renderAttrs(token) -> String
     *
     * Render token attributes to string.
     **/
    Renderer.prototype.renderAttrs = function renderAttrs(token) {
      var i, l, result;

      if (!token.attrs) { return ''; }

      result = '';

      for (i = 0, l = token.attrs.length; i < l; i++) {
        result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
      }

      return result;
    };


    /**
     * Renderer.renderToken(tokens, idx, options) -> String
     * - tokens (Array): list of tokens
     * - idx (Numbed): token index to render
     * - options (Object): params of parser instance
     *
     * Default token renderer. Can be overriden by custom function
     * in [[Renderer#rules]].
     **/
    Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
      var nextToken,
          result = '',
          needLf = false,
          token = tokens[idx];

      // Tight list paragraphs
      if (token.hidden) {
        return '';
      }

      // Insert a newline between hidden paragraph and subsequent opening
      // block-level tag.
      //
      // For example, here we should insert a newline before blockquote:
      //  - a
      //    >
      //
      if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result += '\n';
      }

      // Add token name, e.g. `<img`
      result += (token.nesting === -1 ? '</' : '<') + token.tag;

      // Encode attributes, e.g. `<img src="foo"`
      result += this.renderAttrs(token);

      // Add a slash for self-closing tags, e.g. `<img src="foo" /`
      if (token.nesting === 0 && options.xhtmlOut) {
        result += ' /';
      }

      // Check if we need to add a newline after this tag
      if (token.block) {
        needLf = true;

        if (token.nesting === 1) {
          if (idx + 1 < tokens.length) {
            nextToken = tokens[idx + 1];

            if (nextToken.type === 'inline' || nextToken.hidden) {
              // Block-level tag containing an inline tag.
              //
              needLf = false;

            } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
              // Opening tag + closing tag of the same type. E.g. `<li></li>`.
              //
              needLf = false;
            }
          }
        }
      }

      result += needLf ? '>\n' : '>';

      return result;
    };


    /**
     * Renderer.renderInline(tokens, options, env) -> String
     * - tokens (Array): list on block tokens to renter
     * - options (Object): params of parser instance
     * - env (Object): additional data from parsed input (references, for example)
     *
     * The same as [[Renderer.render]], but for single token of `inline` type.
     **/
    Renderer.prototype.renderInline = function (tokens, options, env) {
      var type,
          result = '',
          rules = this.rules;

      for (var i = 0, len = tokens.length; i < len; i++) {
        type = tokens[i].type;

        if (typeof rules[type] !== 'undefined') {
          result += rules[type](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options);
        }
      }

      return result;
    };


    /** internal
     * Renderer.renderInlineAsText(tokens, options, env) -> String
     * - tokens (Array): list on block tokens to renter
     * - options (Object): params of parser instance
     * - env (Object): additional data from parsed input (references, for example)
     *
     * Special kludge for image `alt` attributes to conform CommonMark spec.
     * Don't try to use it! Spec requires to show `alt` content with stripped markup,
     * instead of simple escaping.
     **/
    Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
      var result = '';

      for (var i = 0, len = tokens.length; i < len; i++) {
        if (tokens[i].type === 'text') {
          result += tokens[i].content;
        } else if (tokens[i].type === 'image') {
          result += this.renderInlineAsText(tokens[i].children, options, env);
        }
      }

      return result;
    };


    /**
     * Renderer.render(tokens, options, env) -> String
     * - tokens (Array): list on block tokens to renter
     * - options (Object): params of parser instance
     * - env (Object): additional data from parsed input (references, for example)
     *
     * Takes token stream and generates HTML. Probably, you will never need to call
     * this method directly.
     **/
    Renderer.prototype.render = function (tokens, options, env) {
      var i, len, type,
          result = '',
          rules = this.rules;

      for (i = 0, len = tokens.length; i < len; i++) {
        type = tokens[i].type;

        if (type === 'inline') {
          result += this.renderInline(tokens[i].children, options, env);
        } else if (typeof rules[type] !== 'undefined') {
          result += rules[tokens[i].type](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options, env);
        }
      }

      return result;
    };

    var renderer = Renderer;

    /**
     * class Ruler
     *
     * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
     * [[MarkdownIt#inline]] to manage sequences of functions (rules):
     *
     * - keep rules in defined order
     * - assign the name to each rule
     * - enable/disable rules
     * - add/replace rules
     * - allow assign rules to additional named chains (in the same)
     * - cacheing lists of active rules
     *
     * You will not need use this class directly until write plugins. For simple
     * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
     * [[MarkdownIt.use]].
     **/


    /**
     * new Ruler()
     **/
    function Ruler() {
      // List of added rules. Each element is:
      //
      // {
      //   name: XXX,
      //   enabled: Boolean,
      //   fn: Function(),
      //   alt: [ name2, name3 ]
      // }
      //
      this.__rules__ = [];

      // Cached rule chains.
      //
      // First level - chain name, '' for default.
      // Second level - diginal anchor for fast filtering by charcodes.
      //
      this.__cache__ = null;
    }

    ////////////////////////////////////////////////////////////////////////////////
    // Helper methods, should not be used directly


    // Find rule index by name
    //
    Ruler.prototype.__find__ = function (name) {
      for (var i = 0; i < this.__rules__.length; i++) {
        if (this.__rules__[i].name === name) {
          return i;
        }
      }
      return -1;
    };


    // Build rules lookup cache
    //
    Ruler.prototype.__compile__ = function () {
      var self = this;
      var chains = [ '' ];

      // collect unique names
      self.__rules__.forEach(function (rule) {
        if (!rule.enabled) { return; }

        rule.alt.forEach(function (altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });

      self.__cache__ = {};

      chains.forEach(function (chain) {
        self.__cache__[chain] = [];
        self.__rules__.forEach(function (rule) {
          if (!rule.enabled) { return; }

          if (chain && rule.alt.indexOf(chain) < 0) { return; }

          self.__cache__[chain].push(rule.fn);
        });
      });
    };


    /**
     * Ruler.at(name, fn [, options])
     * - name (String): rule name to replace.
     * - fn (Function): new rule function.
     * - options (Object): new rule options (not mandatory).
     *
     * Replace rule by name with new function & options. Throws error if name not
     * found.
     *
     * ##### Options:
     *
     * - __alt__ - array with names of "alternate" chains.
     *
     * ##### Example
     *
     * Replace existing typographer replacement rule with new one:
     *
     * ```javascript
     * var md = require('markdown-it')();
     *
     * md.core.ruler.at('replacements', function replace(state) {
     *   //...
     * });
     * ```
     **/
    Ruler.prototype.at = function (name, fn, options) {
      var index = this.__find__(name);
      var opt = options || {};

      if (index === -1) { throw new Error('Parser rule not found: ' + name); }

      this.__rules__[index].fn = fn;
      this.__rules__[index].alt = opt.alt || [];
      this.__cache__ = null;
    };


    /**
     * Ruler.before(beforeName, ruleName, fn [, options])
     * - beforeName (String): new rule will be added before this one.
     * - ruleName (String): name of added rule.
     * - fn (Function): rule function.
     * - options (Object): rule options (not mandatory).
     *
     * Add new rule to chain before one with given name. See also
     * [[Ruler.after]], [[Ruler.push]].
     *
     * ##### Options:
     *
     * - __alt__ - array with names of "alternate" chains.
     *
     * ##### Example
     *
     * ```javascript
     * var md = require('markdown-it')();
     *
     * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
     *   //...
     * });
     * ```
     **/
    Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
      var index = this.__find__(beforeName);
      var opt = options || {};

      if (index === -1) { throw new Error('Parser rule not found: ' + beforeName); }

      this.__rules__.splice(index, 0, {
        name: ruleName,
        enabled: true,
        fn: fn,
        alt: opt.alt || []
      });

      this.__cache__ = null;
    };


    /**
     * Ruler.after(afterName, ruleName, fn [, options])
     * - afterName (String): new rule will be added after this one.
     * - ruleName (String): name of added rule.
     * - fn (Function): rule function.
     * - options (Object): rule options (not mandatory).
     *
     * Add new rule to chain after one with given name. See also
     * [[Ruler.before]], [[Ruler.push]].
     *
     * ##### Options:
     *
     * - __alt__ - array with names of "alternate" chains.
     *
     * ##### Example
     *
     * ```javascript
     * var md = require('markdown-it')();
     *
     * md.inline.ruler.after('text', 'my_rule', function replace(state) {
     *   //...
     * });
     * ```
     **/
    Ruler.prototype.after = function (afterName, ruleName, fn, options) {
      var index = this.__find__(afterName);
      var opt = options || {};

      if (index === -1) { throw new Error('Parser rule not found: ' + afterName); }

      this.__rules__.splice(index + 1, 0, {
        name: ruleName,
        enabled: true,
        fn: fn,
        alt: opt.alt || []
      });

      this.__cache__ = null;
    };

    /**
     * Ruler.push(ruleName, fn [, options])
     * - ruleName (String): name of added rule.
     * - fn (Function): rule function.
     * - options (Object): rule options (not mandatory).
     *
     * Push new rule to the end of chain. See also
     * [[Ruler.before]], [[Ruler.after]].
     *
     * ##### Options:
     *
     * - __alt__ - array with names of "alternate" chains.
     *
     * ##### Example
     *
     * ```javascript
     * var md = require('markdown-it')();
     *
     * md.core.ruler.push('my_rule', function replace(state) {
     *   //...
     * });
     * ```
     **/
    Ruler.prototype.push = function (ruleName, fn, options) {
      var opt = options || {};

      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn: fn,
        alt: opt.alt || []
      });

      this.__cache__ = null;
    };


    /**
     * Ruler.enable(list [, ignoreInvalid]) -> Array
     * - list (String|Array): list of rule names to enable.
     * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
     *
     * Enable rules with given names. If any rule name not found - throw Error.
     * Errors can be disabled by second param.
     *
     * Returns list of found rule names (if no exception happened).
     *
     * See also [[Ruler.disable]], [[Ruler.enableOnly]].
     **/
    Ruler.prototype.enable = function (list, ignoreInvalid) {
      if (!Array.isArray(list)) { list = [ list ]; }

      var result = [];

      // Search by name and enable
      list.forEach(function (name) {
        var idx = this.__find__(name);

        if (idx < 0) {
          if (ignoreInvalid) { return; }
          throw new Error('Rules manager: invalid rule name ' + name);
        }
        this.__rules__[idx].enabled = true;
        result.push(name);
      }, this);

      this.__cache__ = null;
      return result;
    };


    /**
     * Ruler.enableOnly(list [, ignoreInvalid])
     * - list (String|Array): list of rule names to enable (whitelist).
     * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
     *
     * Enable rules with given names, and disable everything else. If any rule name
     * not found - throw Error. Errors can be disabled by second param.
     *
     * See also [[Ruler.disable]], [[Ruler.enable]].
     **/
    Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
      if (!Array.isArray(list)) { list = [ list ]; }

      this.__rules__.forEach(function (rule) { rule.enabled = false; });

      this.enable(list, ignoreInvalid);
    };


    /**
     * Ruler.disable(list [, ignoreInvalid]) -> Array
     * - list (String|Array): list of rule names to disable.
     * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
     *
     * Disable rules with given names. If any rule name not found - throw Error.
     * Errors can be disabled by second param.
     *
     * Returns list of found rule names (if no exception happened).
     *
     * See also [[Ruler.enable]], [[Ruler.enableOnly]].
     **/
    Ruler.prototype.disable = function (list, ignoreInvalid) {
      if (!Array.isArray(list)) { list = [ list ]; }

      var result = [];

      // Search by name and disable
      list.forEach(function (name) {
        var idx = this.__find__(name);

        if (idx < 0) {
          if (ignoreInvalid) { return; }
          throw new Error('Rules manager: invalid rule name ' + name);
        }
        this.__rules__[idx].enabled = false;
        result.push(name);
      }, this);

      this.__cache__ = null;
      return result;
    };


    /**
     * Ruler.getRules(chainName) -> Array
     *
     * Return array of active functions (rules) for given chain name. It analyzes
     * rules configuration, compiles caches if not exists and returns result.
     *
     * Default chain name is `''` (empty string). It can't be skipped. That's
     * done intentionally, to keep signature monomorphic for high speed.
     **/
    Ruler.prototype.getRules = function (chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }

      // Chain can be empty, if rules disabled. But we still have to return Array.
      return this.__cache__[chainName] || [];
    };

    var ruler = Ruler;

    // Normalize input string


    // https://spec.commonmark.org/0.29/#line-ending
    var NEWLINES_RE  = /\r\n?|\n/g;
    var NULL_RE      = /\0/g;


    var normalize = function normalize(state) {
      var str;

      // Normalize newlines
      str = state.src.replace(NEWLINES_RE, '\n');

      // Replace NULL characters
      str = str.replace(NULL_RE, '\uFFFD');

      state.src = str;
    };

    var block$1 = function block(state) {
      var token;

      if (state.inlineMode) {
        token          = new state.Token('inline', '', 0);
        token.content  = state.src;
        token.map      = [ 0, 1 ];
        token.children = [];
        state.tokens.push(token);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    };

    var inline = function inline(state) {
      var tokens = state.tokens, tok, i, l;

      // Parse inlines
      for (i = 0, l = tokens.length; i < l; i++) {
        tok = tokens[i];
        if (tok.type === 'inline') {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    };

    var arrayReplaceAt = utils.arrayReplaceAt;


    function isLinkOpen(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose(str) {
      return /^<\/a\s*>/i.test(str);
    }


    var linkify = function linkify(state) {
      var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,
          level, htmlLinkLevel, url, fullUrl, urlText,
          blockTokens = state.tokens,
          links;

      if (!state.md.options.linkify) { return; }

      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== 'inline' ||
            !state.md.linkify.pretest(blockTokens[j].content)) {
          continue;
        }

        tokens = blockTokens[j].children;

        htmlLinkLevel = 0;

        // We scan from the end, to keep position when new tags added.
        // Use reversed logic in links start/end match
        for (i = tokens.length - 1; i >= 0; i--) {
          currentToken = tokens[i];

          // Skip content of markdown links
          if (currentToken.type === 'link_close') {
            i--;
            while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
              i--;
            }
            continue;
          }

          // Skip content of html tag links
          if (currentToken.type === 'html_inline') {
            if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) { continue; }

          if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

            text = currentToken.content;
            links = state.md.linkify.match(text);

            // Now split string to nodes
            nodes = [];
            level = currentToken.level;
            lastPos = 0;

            for (ln = 0; ln < links.length; ln++) {

              url = links[ln].url;
              fullUrl = state.md.normalizeLink(url);
              if (!state.md.validateLink(fullUrl)) { continue; }

              urlText = links[ln].text;

              // Linkifier might send raw hostnames like "example.com", where url
              // starts with domain name. So we prepend http:// in those cases,
              // and remove it afterwards.
              //
              if (!links[ln].schema) {
                urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
              } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }

              pos = links[ln].index;

              if (pos > lastPos) {
                token         = new state.Token('text', '', 0);
                token.content = text.slice(lastPos, pos);
                token.level   = level;
                nodes.push(token);
              }

              token         = new state.Token('link_open', 'a', 1);
              token.attrs   = [ [ 'href', fullUrl ] ];
              token.level   = level++;
              token.markup  = 'linkify';
              token.info    = 'auto';
              nodes.push(token);

              token         = new state.Token('text', '', 0);
              token.content = urlText;
              token.level   = level;
              nodes.push(token);

              token         = new state.Token('link_close', 'a', -1);
              token.level   = --level;
              token.markup  = 'linkify';
              token.info    = 'auto';
              nodes.push(token);

              lastPos = links[ln].lastIndex;
            }
            if (lastPos < text.length) {
              token         = new state.Token('text', '', 0);
              token.content = text.slice(lastPos);
              token.level   = level;
              nodes.push(token);
            }

            // replace current node
            blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
          }
        }
      }
    };

    // Simple typographic replacements

    // TODO:
    // - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
    // - miltiplication 2 x 4 -> 2 × 4

    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

    // Workaround for phantomjs - need regex without /g flag,
    // or root check will fail every second time
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

    var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
    var SCOPED_ABBR = {
      c: '©',
      r: '®',
      p: '§',
      tm: '™'
    };

    function replaceFn(match, name) {
      return SCOPED_ABBR[name.toLowerCase()];
    }

    function replace_scoped(inlineTokens) {
      var i, token, inside_autolink = 0;

      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];

        if (token.type === 'text' && !inside_autolink) {
          token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
        }

        if (token.type === 'link_open' && token.info === 'auto') {
          inside_autolink--;
        }

        if (token.type === 'link_close' && token.info === 'auto') {
          inside_autolink++;
        }
      }
    }

    function replace_rare(inlineTokens) {
      var i, token, inside_autolink = 0;

      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];

        if (token.type === 'text' && !inside_autolink) {
          if (RARE_RE.test(token.content)) {
            token.content = token.content
              .replace(/\+-/g, '±')
              // .., ..., ....... -> …
              // but ?..... & !..... -> ?.. & !..
              .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..')
              .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
              // em-dash
              .replace(/(^|[^-])---(?=[^-]|$)/mg, '$1\u2014')
              // en-dash
              .replace(/(^|\s)--(?=\s|$)/mg, '$1\u2013')
              .replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, '$1\u2013');
          }
        }

        if (token.type === 'link_open' && token.info === 'auto') {
          inside_autolink--;
        }

        if (token.type === 'link_close' && token.info === 'auto') {
          inside_autolink++;
        }
      }
    }


    var replacements = function replace(state) {
      var blkIdx;

      if (!state.md.options.typographer) { return; }

      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

        if (state.tokens[blkIdx].type !== 'inline') { continue; }

        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
          replace_scoped(state.tokens[blkIdx].children);
        }

        if (RARE_RE.test(state.tokens[blkIdx].content)) {
          replace_rare(state.tokens[blkIdx].children);
        }

      }
    };

    var isWhiteSpace   = utils.isWhiteSpace;
    var isPunctChar    = utils.isPunctChar;
    var isMdAsciiPunct = utils.isMdAsciiPunct;

    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE = '\u2019'; /* ’ */


    function replaceAt(str, index, ch) {
      return str.substr(0, index) + ch + str.substr(index + 1);
    }

    function process_inlines(tokens, state) {
      var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,
          isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,
          canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

      stack = [];

      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];

        thisLevel = tokens[i].level;

        for (j = stack.length - 1; j >= 0; j--) {
          if (stack[j].level <= thisLevel) { break; }
        }
        stack.length = j + 1;

        if (token.type !== 'text') { continue; }

        text = token.content;
        pos = 0;
        max = text.length;

        /*eslint no-labels:0,block-scoped-var:0*/
        OUTER:
        while (pos < max) {
          QUOTE_RE.lastIndex = pos;
          t = QUOTE_RE.exec(text);
          if (!t) { break; }

          canOpen = canClose = true;
          pos = t.index + 1;
          isSingle = (t[0] === "'");

          // Find previous character,
          // default to space if it's the beginning of the line
          //
          lastChar = 0x20;

          if (t.index - 1 >= 0) {
            lastChar = text.charCodeAt(t.index - 1);
          } else {
            for (j = i - 1; j >= 0; j--) {
              if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20
              if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'

              lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
              break;
            }
          }

          // Find next character,
          // default to space if it's the end of the line
          //
          nextChar = 0x20;

          if (pos < max) {
            nextChar = text.charCodeAt(pos);
          } else {
            for (j = i + 1; j < tokens.length; j++) {
              if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20
              if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'

              nextChar = tokens[j].content.charCodeAt(0);
              break;
            }
          }

          isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
          isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

          isLastWhiteSpace = isWhiteSpace(lastChar);
          isNextWhiteSpace = isWhiteSpace(nextChar);

          if (isNextWhiteSpace) {
            canOpen = false;
          } else if (isNextPunctChar) {
            if (!(isLastWhiteSpace || isLastPunctChar)) {
              canOpen = false;
            }
          }

          if (isLastWhiteSpace) {
            canClose = false;
          } else if (isLastPunctChar) {
            if (!(isNextWhiteSpace || isNextPunctChar)) {
              canClose = false;
            }
          }

          if (nextChar === 0x22 /* " */ && t[0] === '"') {
            if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
              // special case: 1"" - count first quote as an inch
              canClose = canOpen = false;
            }
          }

          if (canOpen && canClose) {
            // Replace quotes in the middle of punctuation sequence, but not
            // in the middle of the words, i.e.:
            //
            // 1. foo " bar " baz - not replaced
            // 2. foo-"-bar-"-baz - replaced
            // 3. foo"bar"baz     - not replaced
            //
            canOpen = isLastPunctChar;
            canClose = isNextPunctChar;
          }

          if (!canOpen && !canClose) {
            // middle of word
            if (isSingle) {
              token.content = replaceAt(token.content, t.index, APOSTROPHE);
            }
            continue;
          }

          if (canClose) {
            // this could be a closing quote, rewind the stack to get a match
            for (j = stack.length - 1; j >= 0; j--) {
              item = stack[j];
              if (stack[j].level < thisLevel) { break; }
              if (item.single === isSingle && stack[j].level === thisLevel) {
                item = stack[j];

                if (isSingle) {
                  openQuote = state.md.options.quotes[2];
                  closeQuote = state.md.options.quotes[3];
                } else {
                  openQuote = state.md.options.quotes[0];
                  closeQuote = state.md.options.quotes[1];
                }

                // replace token.content *before* tokens[item.token].content,
                // because, if they are pointing at the same token, replaceAt
                // could mess up indices when quote length != 1
                token.content = replaceAt(token.content, t.index, closeQuote);
                tokens[item.token].content = replaceAt(
                  tokens[item.token].content, item.pos, openQuote);

                pos += closeQuote.length - 1;
                if (item.token === i) { pos += openQuote.length - 1; }

                text = token.content;
                max = text.length;

                stack.length = j;
                continue OUTER;
              }
            }
          }

          if (canOpen) {
            stack.push({
              token: i,
              pos: t.index,
              single: isSingle,
              level: thisLevel
            });
          } else if (canClose && isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE);
          }
        }
      }
    }


    var smartquotes = function smartquotes(state) {
      /*eslint max-depth:0*/
      var blkIdx;

      if (!state.md.options.typographer) { return; }

      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

        if (state.tokens[blkIdx].type !== 'inline' ||
            !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
          continue;
        }

        process_inlines(state.tokens[blkIdx].children, state);
      }
    };

    // Token class


    /**
     * class Token
     **/

    /**
     * new Token(type, tag, nesting)
     *
     * Create new token and fill passed properties.
     **/
    function Token(type, tag, nesting) {
      /**
       * Token#type -> String
       *
       * Type of the token (string, e.g. "paragraph_open")
       **/
      this.type     = type;

      /**
       * Token#tag -> String
       *
       * html tag name, e.g. "p"
       **/
      this.tag      = tag;

      /**
       * Token#attrs -> Array
       *
       * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
       **/
      this.attrs    = null;

      /**
       * Token#map -> Array
       *
       * Source map info. Format: `[ line_begin, line_end ]`
       **/
      this.map      = null;

      /**
       * Token#nesting -> Number
       *
       * Level change (number in {-1, 0, 1} set), where:
       *
       * -  `1` means the tag is opening
       * -  `0` means the tag is self-closing
       * - `-1` means the tag is closing
       **/
      this.nesting  = nesting;

      /**
       * Token#level -> Number
       *
       * nesting level, the same as `state.level`
       **/
      this.level    = 0;

      /**
       * Token#children -> Array
       *
       * An array of child nodes (inline and img tokens)
       **/
      this.children = null;

      /**
       * Token#content -> String
       *
       * In a case of self-closing tag (code, html, fence, etc.),
       * it has contents of this tag.
       **/
      this.content  = '';

      /**
       * Token#markup -> String
       *
       * '*' or '_' for emphasis, fence string for fence, etc.
       **/
      this.markup   = '';

      /**
       * Token#info -> String
       *
       * fence infostring
       **/
      this.info     = '';

      /**
       * Token#meta -> Object
       *
       * A place for plugins to store an arbitrary data
       **/
      this.meta     = null;

      /**
       * Token#block -> Boolean
       *
       * True for block-level tokens, false for inline tokens.
       * Used in renderer to calculate line breaks
       **/
      this.block    = false;

      /**
       * Token#hidden -> Boolean
       *
       * If it's true, ignore this element when rendering. Used for tight lists
       * to hide paragraphs.
       **/
      this.hidden   = false;
    }


    /**
     * Token.attrIndex(name) -> Number
     *
     * Search attribute index by name.
     **/
    Token.prototype.attrIndex = function attrIndex(name) {
      var attrs, i, len;

      if (!this.attrs) { return -1; }

      attrs = this.attrs;

      for (i = 0, len = attrs.length; i < len; i++) {
        if (attrs[i][0] === name) { return i; }
      }
      return -1;
    };


    /**
     * Token.attrPush(attrData)
     *
     * Add `[ name, value ]` attribute to list. Init attrs if necessary
     **/
    Token.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [ attrData ];
      }
    };


    /**
     * Token.attrSet(name, value)
     *
     * Set `name` attribute to `value`. Override old value if exists.
     **/
    Token.prototype.attrSet = function attrSet(name, value) {
      var idx = this.attrIndex(name),
          attrData = [ name, value ];

      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };


    /**
     * Token.attrGet(name)
     *
     * Get the value of attribute `name`, or null if it does not exist.
     **/
    Token.prototype.attrGet = function attrGet(name) {
      var idx = this.attrIndex(name), value = null;
      if (idx >= 0) {
        value = this.attrs[idx][1];
      }
      return value;
    };


    /**
     * Token.attrJoin(name, value)
     *
     * Join value to existing attribute via space. Or create new attribute if not
     * exists. Useful to operate with token classes.
     **/
    Token.prototype.attrJoin = function attrJoin(name, value) {
      var idx = this.attrIndex(name);

      if (idx < 0) {
        this.attrPush([ name, value ]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
      }
    };


    var token = Token;

    function StateCore(src, md, env) {
      this.src = src;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md; // link to parser instance
    }

    // re-export Token class to use in core rules
    StateCore.prototype.Token = token;


    var state_core = StateCore;

    var _rules = [
      [ 'normalize',      normalize      ],
      [ 'block',          block$1          ],
      [ 'inline',         inline         ],
      [ 'linkify',        linkify        ],
      [ 'replacements',   replacements   ],
      [ 'smartquotes',    smartquotes    ]
    ];


    /**
     * new Core()
     **/
    function Core() {
      /**
       * Core#ruler -> Ruler
       *
       * [[Ruler]] instance. Keep configuration of core rules.
       **/
      this.ruler = new ruler();

      for (var i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
    }


    /**
     * Core.process(state)
     *
     * Executes core chain rules.
     **/
    Core.prototype.process = function (state) {
      var i, l, rules;

      rules = this.ruler.getRules('');

      for (i = 0, l = rules.length; i < l; i++) {
        rules[i](state);
      }
    };

    Core.prototype.State = state_core;


    var parser_core = Core;

    var isSpace = utils.isSpace;


    function getLine(state, line) {
      var pos = state.bMarks[line] + state.tShift[line],
          max = state.eMarks[line];

      return state.src.substr(pos, max - pos);
    }

    function escapedSplit(str) {
      var result = [],
          pos = 0,
          max = str.length,
          ch,
          isEscaped = false,
          lastPos = 0,
          current = '';

      ch  = str.charCodeAt(pos);

      while (pos < max) {
        if (ch === 0x7c/* | */) {
          if (!isEscaped) {
            // pipe separating cells, '|'
            result.push(current + str.substring(lastPos, pos));
            current = '';
            lastPos = pos + 1;
          } else {
            // escaped pipe, '\|'
            current += str.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }

        isEscaped = (ch === 0x5c/* \ */);
        pos++;

        ch = str.charCodeAt(pos);
      }

      result.push(current + str.substring(lastPos));

      return result;
    }


    var table = function table(state, startLine, endLine, silent) {
      var ch, lineText, pos, i, l, nextLine, columns, columnCount, token,
          aligns, t, tableLines, tbodyLines, oldParentType, terminate,
          terminatorRules;

      // should have at least two lines
      if (startLine + 2 > endLine) { return false; }

      nextLine = startLine + 1;

      if (state.sCount[nextLine] < state.blkIndent) { return false; }

      // if it's indented more than 3 spaces, it should be a code block
      if (state.sCount[nextLine] - state.blkIndent >= 4) { return false; }

      // first character of the second line should be '|', '-', ':',
      // and no other characters are allowed but spaces;
      // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) { return false; }

      ch = state.src.charCodeAt(pos++);
      if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */) { return false; }

      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);

        if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */ && !isSpace(ch)) { return false; }

        pos++;
      }

      lineText = getLine(state, startLine + 1);

      columns = lineText.split('|');
      aligns = [];
      for (i = 0; i < columns.length; i++) {
        t = columns[i].trim();
        if (!t) {
          // allow empty columns before and after table, but not in between columns;
          // e.g. allow ` |---| `, disallow ` ---||--- `
          if (i === 0 || i === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }

        if (!/^:?-+:?$/.test(t)) { return false; }
        if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {
          aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');
        } else if (t.charCodeAt(0) === 0x3A/* : */) {
          aligns.push('left');
        } else {
          aligns.push('');
        }
      }

      lineText = getLine(state, startLine).trim();
      if (lineText.indexOf('|') === -1) { return false; }
      if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === '') columns.shift();
      if (columns.length && columns[columns.length - 1] === '') columns.pop();

      // header row will define an amount of columns in the entire table,
      // and align row should be exactly the same (the rest of the rows can differ)
      columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) { return false; }

      if (silent) { return true; }

      oldParentType = state.parentType;
      state.parentType = 'table';

      // use 'blockquote' lists for termination because it's
      // the most similar to tables
      terminatorRules = state.md.block.ruler.getRules('blockquote');

      token     = state.push('table_open', 'table', 1);
      token.map = tableLines = [ startLine, 0 ];

      token     = state.push('thead_open', 'thead', 1);
      token.map = [ startLine, startLine + 1 ];

      token     = state.push('tr_open', 'tr', 1);
      token.map = [ startLine, startLine + 1 ];

      for (i = 0; i < columns.length; i++) {
        token          = state.push('th_open', 'th', 1);
        if (aligns[i]) {
          token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];
        }

        token          = state.push('inline', '', 0);
        token.content  = columns[i].trim();
        token.children = [];

        token          = state.push('th_close', 'th', -1);
      }

      token     = state.push('tr_close', 'tr', -1);
      token     = state.push('thead_close', 'thead', -1);

      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) { break; }

        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }

        if (terminate) { break; }
        lineText = getLine(state, nextLine).trim();
        if (!lineText) { break; }
        if (state.sCount[nextLine] - state.blkIndent >= 4) { break; }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === '') columns.shift();
        if (columns.length && columns[columns.length - 1] === '') columns.pop();

        if (nextLine === startLine + 2) {
          token     = state.push('tbody_open', 'tbody', 1);
          token.map = tbodyLines = [ startLine + 2, 0 ];
        }

        token     = state.push('tr_open', 'tr', 1);
        token.map = [ nextLine, nextLine + 1 ];

        for (i = 0; i < columnCount; i++) {
          token          = state.push('td_open', 'td', 1);
          if (aligns[i]) {
            token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];
          }

          token          = state.push('inline', '', 0);
          token.content  = columns[i] ? columns[i].trim() : '';
          token.children = [];

          token          = state.push('td_close', 'td', -1);
        }
        token = state.push('tr_close', 'tr', -1);
      }

      if (tbodyLines) {
        token = state.push('tbody_close', 'tbody', -1);
        tbodyLines[1] = nextLine;
      }

      token = state.push('table_close', 'table', -1);
      tableLines[1] = nextLine;

      state.parentType = oldParentType;
      state.line = nextLine;
      return true;
    };

    // Code block (4 spaces padded)


    var code = function code(state, startLine, endLine/*, silent*/) {
      var nextLine, last, token;

      if (state.sCount[startLine] - state.blkIndent < 4) { return false; }

      last = nextLine = startLine + 1;

      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }

        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last = nextLine;
          continue;
        }
        break;
      }

      state.line = last;

      token         = state.push('code_block', 'code', 0);
      token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
      token.map     = [ startLine, state.line ];

      return true;
    };

    // fences (``` lang, ~~~ lang)


    var fence = function fence(state, startLine, endLine, silent) {
      var marker, len, params, nextLine, mem, token, markup,
          haveEndMarker = false,
          pos = state.bMarks[startLine] + state.tShift[startLine],
          max = state.eMarks[startLine];

      // if it's indented more than 3 spaces, it should be a code block
      if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

      if (pos + 3 > max) { return false; }

      marker = state.src.charCodeAt(pos);

      if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {
        return false;
      }

      // scan marker length
      mem = pos;
      pos = state.skipChars(pos, marker);

      len = pos - mem;

      if (len < 3) { return false; }

      markup = state.src.slice(mem, pos);
      params = state.src.slice(pos, max);

      if (marker === 0x60 /* ` */) {
        if (params.indexOf(String.fromCharCode(marker)) >= 0) {
          return false;
        }
      }

      // Since start is found, we can report success here in validation mode
      if (silent) { return true; }

      // search end of block
      nextLine = startLine;

      for (;;) {
        nextLine++;
        if (nextLine >= endLine) {
          // unclosed block should be autoclosed by end of document.
          // also block seems to be autoclosed by end of parent
          break;
        }

        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];

        if (pos < max && state.sCount[nextLine] < state.blkIndent) {
          // non-empty line with negative indent should stop the list:
          // - ```
          //  test
          break;
        }

        if (state.src.charCodeAt(pos) !== marker) { continue; }

        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          // closing fence should be indented less than 4 spaces
          continue;
        }

        pos = state.skipChars(pos, marker);

        // closing code fence must be at least as long as the opening one
        if (pos - mem < len) { continue; }

        // make sure tail has spaces only
        pos = state.skipSpaces(pos);

        if (pos < max) { continue; }

        haveEndMarker = true;
        // found!
        break;
      }

      // If a fence has heading spaces, they should be removed from its inner block
      len = state.sCount[startLine];

      state.line = nextLine + (haveEndMarker ? 1 : 0);

      token         = state.push('fence', 'code', 0);
      token.info    = params;
      token.content = state.getLines(startLine + 1, nextLine, len, true);
      token.markup  = markup;
      token.map     = [ startLine, state.line ];

      return true;
    };

    var isSpace$1 = utils.isSpace;


    var blockquote = function blockquote(state, startLine, endLine, silent) {
      var adjustTab,
          ch,
          i,
          initial,
          l,
          lastLineEmpty,
          lines,
          nextLine,
          offset,
          oldBMarks,
          oldBSCount,
          oldIndent,
          oldParentType,
          oldSCount,
          oldTShift,
          spaceAfterMarker,
          terminate,
          terminatorRules,
          token,
          isOutdented,
          oldLineMax = state.lineMax,
          pos = state.bMarks[startLine] + state.tShift[startLine],
          max = state.eMarks[startLine];

      // if it's indented more than 3 spaces, it should be a code block
      if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

      // check the block quote marker
      if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }

      // we know that it's going to be a valid blockquote,
      // so no point trying to find the end of it in silent mode
      if (silent) { return true; }

      // set offset past spaces and ">"
      initial = offset = state.sCount[startLine] + 1;

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
        // ' >   test '
        //     ^ -- position start of line here:
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
        spaceAfterMarker = true;

        if ((state.bsCount[startLine] + offset) % 4 === 3) {
          // '  >\t  test '
          //       ^ -- position start of line here (tab has width===1)
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          // ' >\t  test '
          //    ^ -- position start of line here + shift bsCount slightly
          //         to make extra space appear
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }

      oldBMarks = [ state.bMarks[startLine] ];
      state.bMarks[startLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace$1(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      oldBSCount = [ state.bsCount[startLine] ];
      state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

      lastLineEmpty = pos >= max;

      oldSCount = [ state.sCount[startLine] ];
      state.sCount[startLine] = offset - initial;

      oldTShift = [ state.tShift[startLine] ];
      state.tShift[startLine] = pos - state.bMarks[startLine];

      terminatorRules = state.md.block.ruler.getRules('blockquote');

      oldParentType = state.parentType;
      state.parentType = 'blockquote';

      // Search the end of the block
      //
      // Block ends with either:
      //  1. an empty line outside:
      //     ```
      //     > test
      //
      //     ```
      //  2. an empty line inside:
      //     ```
      //     >
      //     test
      //     ```
      //  3. another tag:
      //     ```
      //     > test
      //      - - -
      //     ```
      for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
        // check if it's outdented, i.e. it's inside list item and indented
        // less than said list item:
        //
        // ```
        // 1. anything
        //    > current blockquote
        // 2. checking this line
        // ```
        isOutdented = state.sCount[nextLine] < state.blkIndent;

        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];

        if (pos >= max) {
          // Case 1: line is not inside the blockquote, and this line is empty.
          break;
        }

        if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !isOutdented) {
          // This line is inside the blockquote.

          // set offset past spaces and ">"
          initial = offset = state.sCount[nextLine] + 1;

          // skip one optional space after '>'
          if (state.src.charCodeAt(pos) === 0x20 /* space */) {
            // ' >   test '
            //     ^ -- position start of line here:
            pos++;
            initial++;
            offset++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
            spaceAfterMarker = true;

            if ((state.bsCount[nextLine] + offset) % 4 === 3) {
              // '  >\t  test '
              //       ^ -- position start of line here (tab has width===1)
              pos++;
              initial++;
              offset++;
              adjustTab = false;
            } else {
              // ' >\t  test '
              //    ^ -- position start of line here + shift bsCount slightly
              //         to make extra space appear
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }

          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;

          while (pos < max) {
            ch = state.src.charCodeAt(pos);

            if (isSpace$1(ch)) {
              if (ch === 0x09) {
                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset++;
              }
            } else {
              break;
            }

            pos++;
          }

          lastLineEmpty = pos >= max;

          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset - initial;

          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }

        // Case 2: line is not inside the blockquote, and the last line was empty.
        if (lastLineEmpty) { break; }

        // Case 3: another tag found.
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }

        if (terminate) {
          // Quirk to enforce "hard termination mode" for paragraphs;
          // normally if you call `tokenize(state, startLine, nextLine)`,
          // paragraphs will look below nextLine for paragraph continuation,
          // but if blockquote is terminated by another tag, they shouldn't
          state.lineMax = nextLine;

          if (state.blkIndent !== 0) {
            // state.blkIndent was non-zero, we now set it to zero,
            // so we need to re-calculate all offsets to appear as
            // if indent wasn't changed
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }

          break;
        }

        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);

        // A negative indentation means that this is a paragraph continuation
        //
        state.sCount[nextLine] = -1;
      }

      oldIndent = state.blkIndent;
      state.blkIndent = 0;

      token        = state.push('blockquote_open', 'blockquote', 1);
      token.markup = '>';
      token.map    = lines = [ startLine, 0 ];

      state.md.block.tokenize(state, startLine, nextLine);

      token        = state.push('blockquote_close', 'blockquote', -1);
      token.markup = '>';

      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;

      // Restore original tShift; this might not be necessary since the parser
      // has already been here, but just to make sure we can do that.
      for (i = 0; i < oldTShift.length; i++) {
        state.bMarks[i + startLine] = oldBMarks[i];
        state.tShift[i + startLine] = oldTShift[i];
        state.sCount[i + startLine] = oldSCount[i];
        state.bsCount[i + startLine] = oldBSCount[i];
      }
      state.blkIndent = oldIndent;

      return true;
    };

    var isSpace$2 = utils.isSpace;


    var hr = function hr(state, startLine, endLine, silent) {
      var marker, cnt, ch, token,
          pos = state.bMarks[startLine] + state.tShift[startLine],
          max = state.eMarks[startLine];

      // if it's indented more than 3 spaces, it should be a code block
      if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

      marker = state.src.charCodeAt(pos++);

      // Check hr marker
      if (marker !== 0x2A/* * */ &&
          marker !== 0x2D/* - */ &&
          marker !== 0x5F/* _ */) {
        return false;
      }

      // markers can be mixed with spaces, but there should be at least 3 of them

      cnt = 1;
      while (pos < max) {
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker && !isSpace$2(ch)) { return false; }
        if (ch === marker) { cnt++; }
      }

      if (cnt < 3) { return false; }

      if (silent) { return true; }

      state.line = startLine + 1;

      token        = state.push('hr', 'hr', 0);
      token.map    = [ startLine, state.line ];
      token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

      return true;
    };

    var isSpace$3 = utils.isSpace;


    // Search `[-+*][\n ]`, returns next pos after marker on success
    // or -1 on fail.
    function skipBulletListMarker(state, startLine) {
      var marker, pos, max, ch;

      pos = state.bMarks[startLine] + state.tShift[startLine];
      max = state.eMarks[startLine];

      marker = state.src.charCodeAt(pos++);
      // Check bullet
      if (marker !== 0x2A/* * */ &&
          marker !== 0x2D/* - */ &&
          marker !== 0x2B/* + */) {
        return -1;
      }

      if (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (!isSpace$3(ch)) {
          // " -test " - is not a list item
          return -1;
        }
      }

      return pos;
    }

    // Search `\d+[.)][\n ]`, returns next pos after marker on success
    // or -1 on fail.
    function skipOrderedListMarker(state, startLine) {
      var ch,
          start = state.bMarks[startLine] + state.tShift[startLine],
          pos = start,
          max = state.eMarks[startLine];

      // List marker should have at least 2 chars (digit + dot)
      if (pos + 1 >= max) { return -1; }

      ch = state.src.charCodeAt(pos++);

      if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }

      for (;;) {
        // EOL -> fail
        if (pos >= max) { return -1; }

        ch = state.src.charCodeAt(pos++);

        if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {

          // List marker should have no more than 9 digits
          // (prevents integer overflow in browsers)
          if (pos - start >= 10) { return -1; }

          continue;
        }

        // found valid marker
        if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {
          break;
        }

        return -1;
      }


      if (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (!isSpace$3(ch)) {
          // " 1.test " - is not a list item
          return -1;
        }
      }
      return pos;
    }

    function markTightParagraphs(state, idx) {
      var i, l,
          level = state.level + 2;

      for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
        if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
          state.tokens[i + 2].hidden = true;
          state.tokens[i].hidden = true;
          i += 2;
        }
      }
    }


    var list = function list(state, startLine, endLine, silent) {
      var ch,
          contentStart,
          i,
          indent,
          indentAfterMarker,
          initial,
          isOrdered,
          itemLines,
          l,
          listLines,
          listTokIdx,
          markerCharCode,
          markerValue,
          max,
          nextLine,
          offset,
          oldListIndent,
          oldParentType,
          oldSCount,
          oldTShift,
          oldTight,
          pos,
          posAfterMarker,
          prevEmptyEnd,
          start,
          terminate,
          terminatorRules,
          token,
          isTerminatingParagraph = false,
          tight = true;

      // if it's indented more than 3 spaces, it should be a code block
      if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

      // Special case:
      //  - item 1
      //   - item 2
      //    - item 3
      //     - item 4
      //      - this one is a paragraph continuation
      if (state.listIndent >= 0 &&
          state.sCount[startLine] - state.listIndent >= 4 &&
          state.sCount[startLine] < state.blkIndent) {
        return false;
      }

      // limit conditions when list can interrupt
      // a paragraph (validation mode only)
      if (silent && state.parentType === 'paragraph') {
        // Next list item should still terminate previous list item;
        //
        // This code can fail if plugins use blkIndent as well as lists,
        // but I hope the spec gets fixed long before that happens.
        //
        if (state.tShift[startLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }

      // Detect list type and position after marker
      if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
        isOrdered = true;
        start = state.bMarks[startLine] + state.tShift[startLine];
        markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

        // If we're starting a new ordered list right after
        // a paragraph, it should start with 1.
        if (isTerminatingParagraph && markerValue !== 1) return false;

      } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
        isOrdered = false;

      } else {
        return false;
      }

      // If we're starting a new unordered list right after
      // a paragraph, first line should not be empty.
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
      }

      // We should terminate list on style change. Remember first one to compare.
      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

      // For validation mode we can terminate immediately
      if (silent) { return true; }

      // Start list
      listTokIdx = state.tokens.length;

      if (isOrdered) {
        token       = state.push('ordered_list_open', 'ol', 1);
        if (markerValue !== 1) {
          token.attrs = [ [ 'start', markerValue ] ];
        }

      } else {
        token       = state.push('bullet_list_open', 'ul', 1);
      }

      token.map    = listLines = [ startLine, 0 ];
      token.markup = String.fromCharCode(markerCharCode);

      //
      // Iterate list items
      //

      nextLine = startLine;
      prevEmptyEnd = false;
      terminatorRules = state.md.block.ruler.getRules('list');

      oldParentType = state.parentType;
      state.parentType = 'list';

      while (nextLine < endLine) {
        pos = posAfterMarker;
        max = state.eMarks[nextLine];

        initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

        while (pos < max) {
          ch = state.src.charCodeAt(pos);

          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine]) % 4;
          } else if (ch === 0x20) {
            offset++;
          } else {
            break;
          }

          pos++;
        }

        contentStart = pos;

        if (contentStart >= max) {
          // trimming space in "-    \n  3" case, indent is 1 here
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset - initial;
        }

        // If we have more than 4 spaces, the indent is 1
        // (the rest is just indented code block)
        if (indentAfterMarker > 4) { indentAfterMarker = 1; }

        // "  -  test"
        //  ^^^^^ - calculating total length of this thing
        indent = initial + indentAfterMarker;

        // Run subparser & write tokens
        token        = state.push('list_item_open', 'li', 1);
        token.markup = String.fromCharCode(markerCharCode);
        token.map    = itemLines = [ startLine, 0 ];

        // change current state, then restore it after parser subcall
        oldTight = state.tight;
        oldTShift = state.tShift[startLine];
        oldSCount = state.sCount[startLine];

        //  - example list
        // ^ listIndent position will be here
        //   ^ blkIndent position will be here
        //
        oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent;

        state.tight = true;
        state.tShift[startLine] = contentStart - state.bMarks[startLine];
        state.sCount[startLine] = offset;

        if (contentStart >= max && state.isEmpty(startLine + 1)) {
          // workaround for this case
          // (list item is empty, list terminates before "foo"):
          // ~~~~~~~~
          //   -
          //
          //     foo
          // ~~~~~~~~
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, startLine, endLine, true);
        }

        // If any of list item is tight, mark list as tight
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        // Item become loose if finish with empty line,
        // but we should filter last element, because it means list finish
        prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);

        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[startLine] = oldTShift;
        state.sCount[startLine] = oldSCount;
        state.tight = oldTight;

        token        = state.push('list_item_close', 'li', -1);
        token.markup = String.fromCharCode(markerCharCode);

        nextLine = startLine = state.line;
        itemLines[1] = nextLine;
        contentStart = state.bMarks[startLine];

        if (nextLine >= endLine) { break; }

        //
        // Try to check if list is terminated or continued.
        //
        if (state.sCount[nextLine] < state.blkIndent) { break; }

        // if it's indented more than 3 spaces, it should be a code block
        if (state.sCount[startLine] - state.blkIndent >= 4) { break; }

        // fail if terminating block found
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) { break; }

        // fail if list has another type
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state, nextLine);
          if (posAfterMarker < 0) { break; }
        } else {
          posAfterMarker = skipBulletListMarker(state, nextLine);
          if (posAfterMarker < 0) { break; }
        }

        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }
      }

      // Finalize list
      if (isOrdered) {
        token = state.push('ordered_list_close', 'ol', -1);
      } else {
        token = state.push('bullet_list_close', 'ul', -1);
      }
      token.markup = String.fromCharCode(markerCharCode);

      listLines[1] = nextLine;
      state.line = nextLine;

      state.parentType = oldParentType;

      // mark paragraphs tight if needed
      if (tight) {
        markTightParagraphs(state, listTokIdx);
      }

      return true;
    };

    var normalizeReference   = utils.normalizeReference;
    var isSpace$4              = utils.isSpace;


    var reference = function reference(state, startLine, _endLine, silent) {
      var ch,
          destEndPos,
          destEndLineNo,
          endLine,
          href,
          i,
          l,
          label,
          labelEnd,
          oldParentType,
          res,
          start,
          str,
          terminate,
          terminatorRules,
          title,
          lines = 0,
          pos = state.bMarks[startLine] + state.tShift[startLine],
          max = state.eMarks[startLine],
          nextLine = startLine + 1;

      // if it's indented more than 3 spaces, it should be a code block
      if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

      if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }

      // Simple check to quickly interrupt scan on [link](url) at the start of line.
      // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
      while (++pos < max) {
        if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&
            state.src.charCodeAt(pos - 1) !== 0x5C/* \ */) {
          if (pos + 1 === max) { return false; }
          if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }
          break;
        }
      }

      endLine = state.lineMax;

      // jump line-by-line until empty one or EOF
      terminatorRules = state.md.block.ruler.getRules('reference');

      oldParentType = state.parentType;
      state.parentType = 'reference';

      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        // this would be a code block normally, but after paragraph
        // it's considered a lazy continuation regardless of what's there
        if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

        // quirk for blockquotes, this line should already be checked by that rule
        if (state.sCount[nextLine] < 0) { continue; }

        // Some tags can terminate paragraph without empty line.
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) { break; }
      }

      str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      max = str.length;

      for (pos = 1; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 0x5B /* [ */) {
          return false;
        } else if (ch === 0x5D /* ] */) {
          labelEnd = pos;
          break;
        } else if (ch === 0x0A /* \n */) {
          lines++;
        } else if (ch === 0x5C /* \ */) {
          pos++;
          if (pos < max && str.charCodeAt(pos) === 0x0A) {
            lines++;
          }
        }
      }

      if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }

      // [label]:   destination   'title'
      //         ^^^ skip optional whitespace here
      for (pos = labelEnd + 2; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 0x0A) {
          lines++;
        } else if (isSpace$4(ch)) ; else {
          break;
        }
      }

      // [label]:   destination   'title'
      //            ^^^^^^^^^^^ parse this
      res = state.md.helpers.parseLinkDestination(str, pos, max);
      if (!res.ok) { return false; }

      href = state.md.normalizeLink(res.str);
      if (!state.md.validateLink(href)) { return false; }

      pos = res.pos;
      lines += res.lines;

      // save cursor state, we could require to rollback later
      destEndPos = pos;
      destEndLineNo = lines;

      // [label]:   destination   'title'
      //                       ^^^ skipping those spaces
      start = pos;
      for (; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 0x0A) {
          lines++;
        } else if (isSpace$4(ch)) ; else {
          break;
        }
      }

      // [label]:   destination   'title'
      //                          ^^^^^^^ parse this
      res = state.md.helpers.parseLinkTitle(str, pos, max);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title = '';
        pos = destEndPos;
        lines = destEndLineNo;
      }

      // skip trailing spaces until the rest of the line
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace$4(ch)) { break; }
        pos++;
      }

      if (pos < max && str.charCodeAt(pos) !== 0x0A) {
        if (title) {
          // garbage at the end of the line after title,
          // but it could still be a valid reference if we roll back
          title = '';
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max) {
            ch = str.charCodeAt(pos);
            if (!isSpace$4(ch)) { break; }
            pos++;
          }
        }
      }

      if (pos < max && str.charCodeAt(pos) !== 0x0A) {
        // garbage at the end of the line
        return false;
      }

      label = normalizeReference(str.slice(1, labelEnd));
      if (!label) {
        // CommonMark 0.20 disallows empty labels
        return false;
      }

      // Reference can not terminate anything. This check is for safety only.
      /*istanbul ignore if*/
      if (silent) { return true; }

      if (typeof state.env.references === 'undefined') {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === 'undefined') {
        state.env.references[label] = { title: title, href: href };
      }

      state.parentType = oldParentType;

      state.line = startLine + lines + 1;
      return true;
    };

    var isSpace$5 = utils.isSpace;


    var heading = function heading(state, startLine, endLine, silent) {
      var ch, level, tmp, token,
          pos = state.bMarks[startLine] + state.tShift[startLine],
          max = state.eMarks[startLine];

      // if it's indented more than 3 spaces, it should be a code block
      if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

      ch  = state.src.charCodeAt(pos);

      if (ch !== 0x23/* # */ || pos >= max) { return false; }

      // count heading level
      level = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 0x23/* # */ && pos < max && level <= 6) {
        level++;
        ch = state.src.charCodeAt(++pos);
      }

      if (level > 6 || (pos < max && !isSpace$5(ch))) { return false; }

      if (silent) { return true; }

      // Let's cut tails like '    ###  ' from the end of string

      max = state.skipSpacesBack(max, pos);
      tmp = state.skipCharsBack(max, 0x23, pos); // #
      if (tmp > pos && isSpace$5(state.src.charCodeAt(tmp - 1))) {
        max = tmp;
      }

      state.line = startLine + 1;

      token        = state.push('heading_open', 'h' + String(level), 1);
      token.markup = '########'.slice(0, level);
      token.map    = [ startLine, state.line ];

      token          = state.push('inline', '', 0);
      token.content  = state.src.slice(pos, max).trim();
      token.map      = [ startLine, state.line ];
      token.children = [];

      token        = state.push('heading_close', 'h' + String(level), -1);
      token.markup = '########'.slice(0, level);

      return true;
    };

    // lheading (---, ===)


    var lheading = function lheading(state, startLine, endLine/*, silent*/) {
      var content, terminate, i, l, token, pos, max, level, marker,
          nextLine = startLine + 1, oldParentType,
          terminatorRules = state.md.block.ruler.getRules('paragraph');

      // if it's indented more than 3 spaces, it should be a code block
      if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

      oldParentType = state.parentType;
      state.parentType = 'paragraph'; // use paragraph to match terminatorRules

      // jump line-by-line until empty one or EOF
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        // this would be a code block normally, but after paragraph
        // it's considered a lazy continuation regardless of what's there
        if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

        //
        // Check for underline in setext header
        //
        if (state.sCount[nextLine] >= state.blkIndent) {
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];

          if (pos < max) {
            marker = state.src.charCodeAt(pos);

            if (marker === 0x2D/* - */ || marker === 0x3D/* = */) {
              pos = state.skipChars(pos, marker);
              pos = state.skipSpaces(pos);

              if (pos >= max) {
                level = (marker === 0x3D/* = */ ? 1 : 2);
                break;
              }
            }
          }
        }

        // quirk for blockquotes, this line should already be checked by that rule
        if (state.sCount[nextLine] < 0) { continue; }

        // Some tags can terminate paragraph without empty line.
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) { break; }
      }

      if (!level) {
        // Didn't find valid underline
        return false;
      }

      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

      state.line = nextLine + 1;

      token          = state.push('heading_open', 'h' + String(level), 1);
      token.markup   = String.fromCharCode(marker);
      token.map      = [ startLine, state.line ];

      token          = state.push('inline', '', 0);
      token.content  = content;
      token.map      = [ startLine, state.line - 1 ];
      token.children = [];

      token          = state.push('heading_close', 'h' + String(level), -1);
      token.markup   = String.fromCharCode(marker);

      state.parentType = oldParentType;

      return true;
    };

    // List of valid html blocks names, accorting to commonmark spec


    var html_blocks = [
      'address',
      'article',
      'aside',
      'base',
      'basefont',
      'blockquote',
      'body',
      'caption',
      'center',
      'col',
      'colgroup',
      'dd',
      'details',
      'dialog',
      'dir',
      'div',
      'dl',
      'dt',
      'fieldset',
      'figcaption',
      'figure',
      'footer',
      'form',
      'frame',
      'frameset',
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6',
      'head',
      'header',
      'hr',
      'html',
      'iframe',
      'legend',
      'li',
      'link',
      'main',
      'menu',
      'menuitem',
      'meta',
      'nav',
      'noframes',
      'ol',
      'optgroup',
      'option',
      'p',
      'param',
      'section',
      'source',
      'summary',
      'table',
      'tbody',
      'td',
      'tfoot',
      'th',
      'thead',
      'title',
      'tr',
      'track',
      'ul'
    ];

    // Regexps to match html elements

    var attr_name     = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

    var unquoted      = '[^"\'=<>`\\x00-\\x20]+';
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';

    var attr_value  = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

    var attribute   = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

    var open_tag    = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

    var close_tag   = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
    var comment     = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
    var processing  = '<[?].*?[?]>';
    var declaration = '<![A-Z]+\\s+[^>]*>';
    var cdata       = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

    var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment +
                            '|' + processing + '|' + declaration + '|' + cdata + ')');
    var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

    var HTML_TAG_RE_1 = HTML_TAG_RE;
    var HTML_OPEN_CLOSE_TAG_RE_1 = HTML_OPEN_CLOSE_TAG_RE;

    var html_re = {
    	HTML_TAG_RE: HTML_TAG_RE_1,
    	HTML_OPEN_CLOSE_TAG_RE: HTML_OPEN_CLOSE_TAG_RE_1
    };

    var HTML_OPEN_CLOSE_TAG_RE$1 = html_re.HTML_OPEN_CLOSE_TAG_RE;

    // An array of opening and corresponding closing sequences for html tags,
    // last argument defines whether it can terminate a paragraph or not
    //
    var HTML_SEQUENCES = [
      [ /^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true ],
      [ /^<!--/,        /-->/,   true ],
      [ /^<\?/,         /\?>/,   true ],
      [ /^<![A-Z]/,     />/,     true ],
      [ /^<!\[CDATA\[/, /\]\]>/, true ],
      [ new RegExp('^</?(' + html_blocks.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true ],
      [ new RegExp(HTML_OPEN_CLOSE_TAG_RE$1.source + '\\s*$'),  /^$/, false ]
    ];


    var html_block = function html_block(state, startLine, endLine, silent) {
      var i, nextLine, token, lineText,
          pos = state.bMarks[startLine] + state.tShift[startLine],
          max = state.eMarks[startLine];

      // if it's indented more than 3 spaces, it should be a code block
      if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

      if (!state.md.options.html) { return false; }

      if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

      lineText = state.src.slice(pos, max);

      for (i = 0; i < HTML_SEQUENCES.length; i++) {
        if (HTML_SEQUENCES[i][0].test(lineText)) { break; }
      }

      if (i === HTML_SEQUENCES.length) { return false; }

      if (silent) {
        // true if this sequence can be a terminator, false otherwise
        return HTML_SEQUENCES[i][2];
      }

      nextLine = startLine + 1;

      // If we are here - we detected HTML block.
      // Let's roll down till block end.
      if (!HTML_SEQUENCES[i][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) { break; }

          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max);

          if (HTML_SEQUENCES[i][1].test(lineText)) {
            if (lineText.length !== 0) { nextLine++; }
            break;
          }
        }
      }

      state.line = nextLine;

      token         = state.push('html_block', '', 0);
      token.map     = [ startLine, nextLine ];
      token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

      return true;
    };

    // Paragraph


    var paragraph = function paragraph(state, startLine/*, endLine*/) {
      var content, terminate, i, l, token, oldParentType,
          nextLine = startLine + 1,
          terminatorRules = state.md.block.ruler.getRules('paragraph'),
          endLine = state.lineMax;

      oldParentType = state.parentType;
      state.parentType = 'paragraph';

      // jump line-by-line until empty one or EOF
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        // this would be a code block normally, but after paragraph
        // it's considered a lazy continuation regardless of what's there
        if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

        // quirk for blockquotes, this line should already be checked by that rule
        if (state.sCount[nextLine] < 0) { continue; }

        // Some tags can terminate paragraph without empty line.
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) { break; }
      }

      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

      state.line = nextLine;

      token          = state.push('paragraph_open', 'p', 1);
      token.map      = [ startLine, state.line ];

      token          = state.push('inline', '', 0);
      token.content  = content;
      token.map      = [ startLine, state.line ];
      token.children = [];

      token          = state.push('paragraph_close', 'p', -1);

      state.parentType = oldParentType;

      return true;
    };

    var isSpace$6 = utils.isSpace;


    function StateBlock(src, md, env, tokens) {
      var ch, s, start, pos, len, indent, offset, indent_found;

      this.src = src;

      // link to parser instance
      this.md     = md;

      this.env = env;

      //
      // Internal state vartiables
      //

      this.tokens = tokens;

      this.bMarks = [];  // line begin offsets for fast jumps
      this.eMarks = [];  // line end offsets for fast jumps
      this.tShift = [];  // offsets of the first non-space characters (tabs not expanded)
      this.sCount = [];  // indents for each line (tabs expanded)

      // An amount of virtual spaces (tabs expanded) between beginning
      // of each line (bMarks) and real beginning of that line.
      //
      // It exists only as a hack because blockquotes override bMarks
      // losing information in the process.
      //
      // It's used only when expanding tabs, you can think about it as
      // an initial tab length, e.g. bsCount=21 applied to string `\t123`
      // means first tab should be expanded to 4-21%4 === 3 spaces.
      //
      this.bsCount = [];

      // block parser variables
      this.blkIndent  = 0; // required block content indent (for example, if we are
                           // inside a list, it would be positioned after list marker)
      this.line       = 0; // line index in src
      this.lineMax    = 0; // lines count
      this.tight      = false;  // loose/tight mode for lists
      this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)
      this.listIndent = -1; // indent of the current list block (-1 if there isn't any)

      // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
      // used in lists to determine if they interrupt a paragraph
      this.parentType = 'root';

      this.level = 0;

      // renderer
      this.result = '';

      // Create caches
      // Generate markers.
      s = this.src;
      indent_found = false;

      for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
        ch = s.charCodeAt(pos);

        if (!indent_found) {
          if (isSpace$6(ch)) {
            indent++;

            if (ch === 0x09) {
              offset += 4 - offset % 4;
            } else {
              offset++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }

        if (ch === 0x0A || pos === len - 1) {
          if (ch !== 0x0A) { pos++; }
          this.bMarks.push(start);
          this.eMarks.push(pos);
          this.tShift.push(indent);
          this.sCount.push(offset);
          this.bsCount.push(0);

          indent_found = false;
          indent = 0;
          offset = 0;
          start = pos + 1;
        }
      }

      // Push fake entry to simplify cache bounds checks
      this.bMarks.push(s.length);
      this.eMarks.push(s.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);

      this.lineMax = this.bMarks.length - 1; // don't count last fake line
    }

    // Push new token to "stream".
    //
    StateBlock.prototype.push = function (type, tag, nesting) {
      var token$1 = new token(type, tag, nesting);
      token$1.block = true;

      if (nesting < 0) this.level--; // closing tag
      token$1.level = this.level;
      if (nesting > 0) this.level++; // opening tag

      this.tokens.push(token$1);
      return token$1;
    };

    StateBlock.prototype.isEmpty = function isEmpty(line) {
      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
    };

    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
      for (var max = this.lineMax; from < max; from++) {
        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
          break;
        }
      }
      return from;
    };

    // Skip spaces from given position.
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      var ch;

      for (var max = this.src.length; pos < max; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace$6(ch)) { break; }
      }
      return pos;
    };

    // Skip spaces from given position in reverse.
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
      if (pos <= min) { return pos; }

      while (pos > min) {
        if (!isSpace$6(this.src.charCodeAt(--pos))) { return pos + 1; }
      }
      return pos;
    };

    // Skip char codes from given position
    StateBlock.prototype.skipChars = function skipChars(pos, code) {
      for (var max = this.src.length; pos < max; pos++) {
        if (this.src.charCodeAt(pos) !== code) { break; }
      }
      return pos;
    };

    // Skip char codes reverse from given position - 1
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
      if (pos <= min) { return pos; }

      while (pos > min) {
        if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }
      }
      return pos;
    };

    // cut lines range from source.
    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
      var i, lineIndent, ch, first, last, queue, lineStart,
          line = begin;

      if (begin >= end) {
        return '';
      }

      queue = new Array(end - begin);

      for (i = 0; line < end; line++, i++) {
        lineIndent = 0;
        lineStart = first = this.bMarks[line];

        if (line + 1 < end || keepLastLF) {
          // No need for bounds check because we have fake entry on tail.
          last = this.eMarks[line] + 1;
        } else {
          last = this.eMarks[line];
        }

        while (first < last && lineIndent < indent) {
          ch = this.src.charCodeAt(first);

          if (isSpace$6(ch)) {
            if (ch === 0x09) {
              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first - lineStart < this.tShift[line]) {
            // patched tShift masked characters to look like spaces (blockquotes, list markers)
            lineIndent++;
          } else {
            break;
          }

          first++;
        }

        if (lineIndent > indent) {
          // partially expanding tabs in code blocks, e.g '\t\tfoobar'
          // with indent=2 becomes '  \tfoobar'
          queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
        } else {
          queue[i] = this.src.slice(first, last);
        }
      }

      return queue.join('');
    };

    // re-export Token class to use in block rules
    StateBlock.prototype.Token = token;


    var state_block = StateBlock;

    var _rules$1 = [
      // First 2 params - rule name & source. Secondary array - list of rules,
      // which can be terminated by this one.
      [ 'table',      table,      [ 'paragraph', 'reference' ] ],
      [ 'code',       code ],
      [ 'fence',      fence,      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
      [ 'blockquote', blockquote, [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
      [ 'hr',         hr,         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
      [ 'list',       list,       [ 'paragraph', 'reference', 'blockquote' ] ],
      [ 'reference',  reference ],
      [ 'heading',    heading,    [ 'paragraph', 'reference', 'blockquote' ] ],
      [ 'lheading',   lheading ],
      [ 'html_block', html_block, [ 'paragraph', 'reference', 'blockquote' ] ],
      [ 'paragraph',  paragraph ]
    ];


    /**
     * new ParserBlock()
     **/
    function ParserBlock() {
      /**
       * ParserBlock#ruler -> Ruler
       *
       * [[Ruler]] instance. Keep configuration of block rules.
       **/
      this.ruler = new ruler();

      for (var i = 0; i < _rules$1.length; i++) {
        this.ruler.push(_rules$1[i][0], _rules$1[i][1], { alt: (_rules$1[i][2] || []).slice() });
      }
    }


    // Generate tokens for input range
    //
    ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
      var ok, i,
          rules = this.ruler.getRules(''),
          len = rules.length,
          line = startLine,
          hasEmptyLines = false,
          maxNesting = state.md.options.maxNesting;

      while (line < endLine) {
        state.line = line = state.skipEmptyLines(line);
        if (line >= endLine) { break; }

        // Termination condition for nested calls.
        // Nested calls currently used for blockquotes & lists
        if (state.sCount[line] < state.blkIndent) { break; }

        // If nesting level exceeded - skip tail to the end. That's not ordinary
        // situation and we should not care about content.
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }

        // Try all possible rules.
        // On success, rule should:
        //
        // - update `state.line`
        // - update `state.tokens`
        // - return true

        for (i = 0; i < len; i++) {
          ok = rules[i](state, line, endLine, false);
          if (ok) { break; }
        }

        // set state.tight if we had an empty line before current tag
        // i.e. latest empty line should not count
        state.tight = !hasEmptyLines;

        // paragraph might "eat" one newline after it in nested lists
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }

        line = state.line;

        if (line < endLine && state.isEmpty(line)) {
          hasEmptyLines = true;
          line++;
          state.line = line;
        }
      }
    };


    /**
     * ParserBlock.parse(str, md, env, outTokens)
     *
     * Process input string and push block tokens into `outTokens`
     **/
    ParserBlock.prototype.parse = function (src, md, env, outTokens) {
      var state;

      if (!src) { return; }

      state = new this.State(src, md, env, outTokens);

      this.tokenize(state, state.line, state.lineMax);
    };


    ParserBlock.prototype.State = state_block;


    var parser_block = ParserBlock;

    // Skip text characters for text token, place those to pending buffer


    // Rule to skip pure text
    // '{}$%@~+=:' reserved for extentions

    // !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

    // !!!! Don't confuse with "Markdown ASCII Punctuation" chars
    // http://spec.commonmark.org/0.15/#ascii-punctuation-character
    function isTerminatorChar(ch) {
      switch (ch) {
        case 0x0A/* \n */:
        case 0x21/* ! */:
        case 0x23/* # */:
        case 0x24/* $ */:
        case 0x25/* % */:
        case 0x26/* & */:
        case 0x2A/* * */:
        case 0x2B/* + */:
        case 0x2D/* - */:
        case 0x3A/* : */:
        case 0x3C/* < */:
        case 0x3D/* = */:
        case 0x3E/* > */:
        case 0x40/* @ */:
        case 0x5B/* [ */:
        case 0x5C/* \ */:
        case 0x5D/* ] */:
        case 0x5E/* ^ */:
        case 0x5F/* _ */:
        case 0x60/* ` */:
        case 0x7B/* { */:
        case 0x7D/* } */:
        case 0x7E/* ~ */:
          return true;
        default:
          return false;
      }
    }

    var text = function text(state, silent) {
      var pos = state.pos;

      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
        pos++;
      }

      if (pos === state.pos) { return false; }

      if (!silent) { state.pending += state.src.slice(state.pos, pos); }

      state.pos = pos;

      return true;
    };

    var isSpace$7 = utils.isSpace;


    var newline = function newline(state, silent) {
      var pmax, max, pos = state.pos;

      if (state.src.charCodeAt(pos) !== 0x0A/* \n */) { return false; }

      pmax = state.pending.length - 1;
      max = state.posMax;

      // '  \n' -> hardbreak
      // Lookup in pending chars is bad practice! Don't copy to other rules!
      // Pending string is stored in concat mode, indexed lookups will cause
      // convertion to flat mode.
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
            state.pending = state.pending.replace(/ +$/, '');
            state.push('hardbreak', 'br', 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push('softbreak', 'br', 0);
          }

        } else {
          state.push('softbreak', 'br', 0);
        }
      }

      pos++;

      // skip heading spaces for next line
      while (pos < max && isSpace$7(state.src.charCodeAt(pos))) { pos++; }

      state.pos = pos;
      return true;
    };

    var isSpace$8 = utils.isSpace;

    var ESCAPED = [];

    for (var i = 0; i < 256; i++) { ESCAPED.push(0); }

    '\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'
      .split('').forEach(function (ch) { ESCAPED[ch.charCodeAt(0)] = 1; });


    var _escape = function escape(state, silent) {
      var ch, pos = state.pos, max = state.posMax;

      if (state.src.charCodeAt(pos) !== 0x5C/* \ */) { return false; }

      pos++;

      if (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (ch < 256 && ESCAPED[ch] !== 0) {
          if (!silent) { state.pending += state.src[pos]; }
          state.pos += 2;
          return true;
        }

        if (ch === 0x0A) {
          if (!silent) {
            state.push('hardbreak', 'br', 0);
          }

          pos++;
          // skip leading whitespaces from next line
          while (pos < max) {
            ch = state.src.charCodeAt(pos);
            if (!isSpace$8(ch)) { break; }
            pos++;
          }

          state.pos = pos;
          return true;
        }
      }

      if (!silent) { state.pending += '\\'; }
      state.pos++;
      return true;
    };

    // Parse backticks

    var backticks = function backtick(state, silent) {
      var start, max, marker, matchStart, matchEnd, token,
          pos = state.pos,
          ch = state.src.charCodeAt(pos);

      if (ch !== 0x60/* ` */) { return false; }

      start = pos;
      pos++;
      max = state.posMax;

      while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }

      marker = state.src.slice(start, pos);

      matchStart = matchEnd = pos;

      while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
        matchEnd = matchStart + 1;

        while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }

        if (matchEnd - matchStart === marker.length) {
          if (!silent) {
            token         = state.push('code_inline', 'code', 0);
            token.markup  = marker;
            token.content = state.src.slice(pos, matchStart)
              .replace(/\n/g, ' ')
              .replace(/^ (.+) $/, '$1');
          }
          state.pos = matchEnd;
          return true;
        }
      }

      if (!silent) { state.pending += marker; }
      state.pos += marker.length;
      return true;
    };

    // ~~strike through~~


    // Insert each marker as a separate text token, and add it to delimiter list
    //
    var tokenize = function strikethrough(state, silent) {
      var i, scanned, token, len, ch,
          start = state.pos,
          marker = state.src.charCodeAt(start);

      if (silent) { return false; }

      if (marker !== 0x7E/* ~ */) { return false; }

      scanned = state.scanDelims(state.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker);

      if (len < 2) { return false; }

      if (len % 2) {
        token         = state.push('text', '', 0);
        token.content = ch;
        len--;
      }

      for (i = 0; i < len; i += 2) {
        token         = state.push('text', '', 0);
        token.content = ch + ch;

        state.delimiters.push({
          marker: marker,
          length: 0, // disable "rule of 3" length checks meant for emphasis
          jump:   i,
          token:  state.tokens.length - 1,
          end:    -1,
          open:   scanned.can_open,
          close:  scanned.can_close
        });
      }

      state.pos += scanned.length;

      return true;
    };


    function postProcess(state, delimiters) {
      var i, j,
          startDelim,
          endDelim,
          token,
          loneMarkers = [],
          max = delimiters.length;

      for (i = 0; i < max; i++) {
        startDelim = delimiters[i];

        if (startDelim.marker !== 0x7E/* ~ */) {
          continue;
        }

        if (startDelim.end === -1) {
          continue;
        }

        endDelim = delimiters[startDelim.end];

        token         = state.tokens[startDelim.token];
        token.type    = 's_open';
        token.tag     = 's';
        token.nesting = 1;
        token.markup  = '~~';
        token.content = '';

        token         = state.tokens[endDelim.token];
        token.type    = 's_close';
        token.tag     = 's';
        token.nesting = -1;
        token.markup  = '~~';
        token.content = '';

        if (state.tokens[endDelim.token - 1].type === 'text' &&
            state.tokens[endDelim.token - 1].content === '~') {

          loneMarkers.push(endDelim.token - 1);
        }
      }

      // If a marker sequence has an odd number of characters, it's splitted
      // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
      // start of the sequence.
      //
      // So, we have to move all those markers after subsequent s_close tags.
      //
      while (loneMarkers.length) {
        i = loneMarkers.pop();
        j = i + 1;

        while (j < state.tokens.length && state.tokens[j].type === 's_close') {
          j++;
        }

        j--;

        if (i !== j) {
          token = state.tokens[j];
          state.tokens[j] = state.tokens[i];
          state.tokens[i] = token;
        }
      }
    }


    // Walk through delimiter list and replace text tokens with tags
    //
    var postProcess_1 = function strikethrough(state) {
      var curr,
          tokens_meta = state.tokens_meta,
          max = state.tokens_meta.length;

      postProcess(state, state.delimiters);

      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };

    var strikethrough = {
    	tokenize: tokenize,
    	postProcess: postProcess_1
    };

    // Process *this* and _that_


    // Insert each marker as a separate text token, and add it to delimiter list
    //
    var tokenize$1 = function emphasis(state, silent) {
      var i, scanned, token,
          start = state.pos,
          marker = state.src.charCodeAt(start);

      if (silent) { return false; }

      if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false; }

      scanned = state.scanDelims(state.pos, marker === 0x2A);

      for (i = 0; i < scanned.length; i++) {
        token         = state.push('text', '', 0);
        token.content = String.fromCharCode(marker);

        state.delimiters.push({
          // Char code of the starting marker (number).
          //
          marker: marker,

          // Total length of these series of delimiters.
          //
          length: scanned.length,

          // An amount of characters before this one that's equivalent to
          // current one. In plain English: if this delimiter does not open
          // an emphasis, neither do previous `jump` characters.
          //
          // Used to skip sequences like "*****" in one step, for 1st asterisk
          // value will be 0, for 2nd it's 1 and so on.
          //
          jump:   i,

          // A position of the token this delimiter corresponds to.
          //
          token:  state.tokens.length - 1,

          // If this delimiter is matched as a valid opener, `end` will be
          // equal to its position, otherwise it's `-1`.
          //
          end:    -1,

          // Boolean flags that determine if this delimiter could open or close
          // an emphasis.
          //
          open:   scanned.can_open,
          close:  scanned.can_close
        });
      }

      state.pos += scanned.length;

      return true;
    };


    function postProcess$1(state, delimiters) {
      var i,
          startDelim,
          endDelim,
          token,
          ch,
          isStrong,
          max = delimiters.length;

      for (i = max - 1; i >= 0; i--) {
        startDelim = delimiters[i];

        if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {
          continue;
        }

        // Process only opening markers
        if (startDelim.end === -1) {
          continue;
        }

        endDelim = delimiters[startDelim.end];

        // If the previous delimiter has the same marker and is adjacent to this one,
        // merge those into one strong delimiter.
        //
        // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
        //
        isStrong = i > 0 &&
                   delimiters[i - 1].end === startDelim.end + 1 &&
                   delimiters[i - 1].token === startDelim.token - 1 &&
                   delimiters[startDelim.end + 1].token === endDelim.token + 1 &&
                   delimiters[i - 1].marker === startDelim.marker;

        ch = String.fromCharCode(startDelim.marker);

        token         = state.tokens[startDelim.token];
        token.type    = isStrong ? 'strong_open' : 'em_open';
        token.tag     = isStrong ? 'strong' : 'em';
        token.nesting = 1;
        token.markup  = isStrong ? ch + ch : ch;
        token.content = '';

        token         = state.tokens[endDelim.token];
        token.type    = isStrong ? 'strong_close' : 'em_close';
        token.tag     = isStrong ? 'strong' : 'em';
        token.nesting = -1;
        token.markup  = isStrong ? ch + ch : ch;
        token.content = '';

        if (isStrong) {
          state.tokens[delimiters[i - 1].token].content = '';
          state.tokens[delimiters[startDelim.end + 1].token].content = '';
          i--;
        }
      }
    }


    // Walk through delimiter list and replace text tokens with tags
    //
    var postProcess_1$1 = function emphasis(state) {
      var curr,
          tokens_meta = state.tokens_meta,
          max = state.tokens_meta.length;

      postProcess$1(state, state.delimiters);

      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess$1(state, tokens_meta[curr].delimiters);
        }
      }
    };

    var emphasis = {
    	tokenize: tokenize$1,
    	postProcess: postProcess_1$1
    };

    var normalizeReference$1   = utils.normalizeReference;
    var isSpace$9              = utils.isSpace;


    var link = function link(state, silent) {
      var attrs,
          code,
          label,
          labelEnd,
          labelStart,
          pos,
          res,
          ref,
          title,
          token,
          href = '',
          oldPos = state.pos,
          max = state.posMax,
          start = state.pos,
          parseReference = true;

      if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false; }

      labelStart = state.pos + 1;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

      // parser failed to find ']', so it's not a valid link
      if (labelEnd < 0) { return false; }

      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
        //
        // Inline link
        //

        // might have found a valid shortcut link, disable reference parsing
        parseReference = false;

        // [link](  <href>  "title"  )
        //        ^^ skipping these spaces
        pos++;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace$9(code) && code !== 0x0A) { break; }
        }
        if (pos >= max) { return false; }

        // [link](  <href>  "title"  )
        //          ^^^^^^ parsing link destination
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = '';
          }
        }

        // [link](  <href>  "title"  )
        //                ^^ skipping these spaces
        start = pos;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace$9(code) && code !== 0x0A) { break; }
        }

        // [link](  <href>  "title"  )
        //                  ^^^^^^^ parsing link title
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;

          // [link](  <href>  "title"  )
          //                         ^^ skipping these spaces
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace$9(code) && code !== 0x0A) { break; }
          }
        } else {
          title = '';
        }

        if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
          // parsing a valid shortcut link failed, fallback to reference
          parseReference = true;
        }
        pos++;
      }

      if (parseReference) {
        //
        // Link reference
        //
        if (typeof state.env.references === 'undefined') { return false; }

        if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }

        // covers label === '' and label === undefined
        // (collapsed reference link and shortcut reference link respectively)
        if (!label) { label = state.src.slice(labelStart, labelEnd); }

        ref = state.env.references[normalizeReference$1(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }

      //
      // We found the end of the link, and know for a fact it's a valid link;
      // so all that's left to do is to call tokenizer.
      //
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;

        token        = state.push('link_open', 'a', 1);
        token.attrs  = attrs = [ [ 'href', href ] ];
        if (title) {
          attrs.push([ 'title', title ]);
        }

        state.md.inline.tokenize(state);

        token        = state.push('link_close', 'a', -1);
      }

      state.pos = pos;
      state.posMax = max;
      return true;
    };

    var normalizeReference$2   = utils.normalizeReference;
    var isSpace$a              = utils.isSpace;


    var image$1 = function image(state, silent) {
      var attrs,
          code,
          content,
          label,
          labelEnd,
          labelStart,
          pos,
          ref,
          res,
          title,
          token,
          tokens,
          start,
          href = '',
          oldPos = state.pos,
          max = state.posMax;

      if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false; }
      if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false; }

      labelStart = state.pos + 2;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

      // parser failed to find ']', so it's not a valid link
      if (labelEnd < 0) { return false; }

      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
        //
        // Inline link
        //

        // [link](  <href>  "title"  )
        //        ^^ skipping these spaces
        pos++;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace$a(code) && code !== 0x0A) { break; }
        }
        if (pos >= max) { return false; }

        // [link](  <href>  "title"  )
        //          ^^^^^^ parsing link destination
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = '';
          }
        }

        // [link](  <href>  "title"  )
        //                ^^ skipping these spaces
        start = pos;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace$a(code) && code !== 0x0A) { break; }
        }

        // [link](  <href>  "title"  )
        //                  ^^^^^^^ parsing link title
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;

          // [link](  <href>  "title"  )
          //                         ^^ skipping these spaces
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace$a(code) && code !== 0x0A) { break; }
          }
        } else {
          title = '';
        }

        if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        //
        // Link reference
        //
        if (typeof state.env.references === 'undefined') { return false; }

        if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }

        // covers label === '' and label === undefined
        // (collapsed reference link and shortcut reference link respectively)
        if (!label) { label = state.src.slice(labelStart, labelEnd); }

        ref = state.env.references[normalizeReference$2(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }

      //
      // We found the end of the link, and know for a fact it's a valid link;
      // so all that's left to do is to call tokenizer.
      //
      if (!silent) {
        content = state.src.slice(labelStart, labelEnd);

        state.md.inline.parse(
          content,
          state.md,
          state.env,
          tokens = []
        );

        token          = state.push('image', 'img', 0);
        token.attrs    = attrs = [ [ 'src', href ], [ 'alt', '' ] ];
        token.children = tokens;
        token.content  = content;

        if (title) {
          attrs.push([ 'title', title ]);
        }
      }

      state.pos = pos;
      state.posMax = max;
      return true;
    };

    // Process autolinks '<protocol:...>'


    /*eslint max-len:0*/
    var EMAIL_RE    = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
    var AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;


    var autolink = function autolink(state, silent) {
      var tail, linkMatch, emailMatch, url, fullUrl, token,
          pos = state.pos;

      if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

      tail = state.src.slice(pos);

      if (tail.indexOf('>') < 0) { return false; }

      if (AUTOLINK_RE.test(tail)) {
        linkMatch = tail.match(AUTOLINK_RE);

        url = linkMatch[0].slice(1, -1);
        fullUrl = state.md.normalizeLink(url);
        if (!state.md.validateLink(fullUrl)) { return false; }

        if (!silent) {
          token         = state.push('link_open', 'a', 1);
          token.attrs   = [ [ 'href', fullUrl ] ];
          token.markup  = 'autolink';
          token.info    = 'auto';

          token         = state.push('text', '', 0);
          token.content = state.md.normalizeLinkText(url);

          token         = state.push('link_close', 'a', -1);
          token.markup  = 'autolink';
          token.info    = 'auto';
        }

        state.pos += linkMatch[0].length;
        return true;
      }

      if (EMAIL_RE.test(tail)) {
        emailMatch = tail.match(EMAIL_RE);

        url = emailMatch[0].slice(1, -1);
        fullUrl = state.md.normalizeLink('mailto:' + url);
        if (!state.md.validateLink(fullUrl)) { return false; }

        if (!silent) {
          token         = state.push('link_open', 'a', 1);
          token.attrs   = [ [ 'href', fullUrl ] ];
          token.markup  = 'autolink';
          token.info    = 'auto';

          token         = state.push('text', '', 0);
          token.content = state.md.normalizeLinkText(url);

          token         = state.push('link_close', 'a', -1);
          token.markup  = 'autolink';
          token.info    = 'auto';
        }

        state.pos += emailMatch[0].length;
        return true;
      }

      return false;
    };

    var HTML_TAG_RE$1 = html_re.HTML_TAG_RE;


    function isLetter(ch) {
      /*eslint no-bitwise:0*/
      var lc = ch | 0x20; // to lower case
      return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);
    }


    var html_inline = function html_inline(state, silent) {
      var ch, match, max, token,
          pos = state.pos;

      if (!state.md.options.html) { return false; }

      // Check start
      max = state.posMax;
      if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||
          pos + 2 >= max) {
        return false;
      }

      // Quick fail on second char
      ch = state.src.charCodeAt(pos + 1);
      if (ch !== 0x21/* ! */ &&
          ch !== 0x3F/* ? */ &&
          ch !== 0x2F/* / */ &&
          !isLetter(ch)) {
        return false;
      }

      match = state.src.slice(pos).match(HTML_TAG_RE$1);
      if (!match) { return false; }

      if (!silent) {
        token         = state.push('html_inline', '', 0);
        token.content = state.src.slice(pos, pos + match[0].length);
      }
      state.pos += match[0].length;
      return true;
    };

    var has               = utils.has;
    var isValidEntityCode = utils.isValidEntityCode;
    var fromCodePoint     = utils.fromCodePoint;


    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;


    var entity = function entity(state, silent) {
      var ch, code, match, pos = state.pos, max = state.posMax;

      if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }

      if (pos + 1 < max) {
        ch = state.src.charCodeAt(pos + 1);

        if (ch === 0x23 /* # */) {
          match = state.src.slice(pos).match(DIGITAL_RE);
          if (match) {
            if (!silent) {
              code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
              state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
            }
            state.pos += match[0].length;
            return true;
          }
        } else {
          match = state.src.slice(pos).match(NAMED_RE);
          if (match) {
            if (has(entities$2, match[1])) {
              if (!silent) { state.pending += entities$2[match[1]]; }
              state.pos += match[0].length;
              return true;
            }
          }
        }
      }

      if (!silent) { state.pending += '&'; }
      state.pos++;
      return true;
    };

    // For each opening emphasis-like marker find a matching closing one


    function processDelimiters(state, delimiters) {
      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx,
          isOddMatch, lastJump,
          openersBottom = {},
          max = delimiters.length;

      for (closerIdx = 0; closerIdx < max; closerIdx++) {
        closer = delimiters[closerIdx];

        // Length is only used for emphasis-specific "rule of 3",
        // if it's not defined (in strikethrough or 3rd party plugins),
        // we can default it to 0 to disable those checks.
        //
        closer.length = closer.length || 0;

        if (!closer.close) continue;

        // Previously calculated lower bounds (previous fails)
        // for each marker and each delimiter length modulo 3.
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [ -1, -1, -1 ];
        }

        minOpenerIdx = openersBottom[closer.marker][closer.length % 3];
        newMinOpenerIdx = -1;

        openerIdx = closerIdx - closer.jump - 1;

        for (; openerIdx > minOpenerIdx; openerIdx -= opener.jump + 1) {
          opener = delimiters[openerIdx];

          if (opener.marker !== closer.marker) continue;

          if (newMinOpenerIdx === -1) newMinOpenerIdx = openerIdx;

          if (opener.open && opener.end < 0) {

            isOddMatch = false;

            // from spec:
            //
            // If one of the delimiters can both open and close emphasis, then the
            // sum of the lengths of the delimiter runs containing the opening and
            // closing delimiters must not be a multiple of 3 unless both lengths
            // are multiples of 3.
            //
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }

            if (!isOddMatch) {
              // If previous delimiter cannot be an opener, we can safely skip
              // the entire sequence in future checks. This is required to make
              // sure algorithm has linear complexity (see *_*_*_*_*_... case).
              //
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ?
                delimiters[openerIdx - 1].jump + 1 :
                0;

              closer.jump  = closerIdx - openerIdx + lastJump;
              closer.open  = false;
              opener.end   = closerIdx;
              opener.jump  = lastJump;
              opener.close = false;
              newMinOpenerIdx = -1;
              break;
            }
          }
        }

        if (newMinOpenerIdx !== -1) {
          // If match for this delimiter run failed, we want to set lower bound for
          // future lookups. This is required to make sure algorithm has linear
          // complexity.
          //
          // See details here:
          // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442
          //
          openersBottom[closer.marker][(closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }


    var balance_pairs = function link_pairs(state) {
      var curr,
          tokens_meta = state.tokens_meta,
          max = state.tokens_meta.length;

      processDelimiters(state, state.delimiters);

      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(state, tokens_meta[curr].delimiters);
        }
      }
    };

    // Clean up tokens after emphasis and strikethrough postprocessing:


    var text_collapse = function text_collapse(state) {
      var curr, last,
          level = 0,
          tokens = state.tokens,
          max = state.tokens.length;

      for (curr = last = 0; curr < max; curr++) {
        // re-calculate levels after emphasis/strikethrough turns some text nodes
        // into opening/closing tags
        if (tokens[curr].nesting < 0) level--; // closing tag
        tokens[curr].level = level;
        if (tokens[curr].nesting > 0) level++; // opening tag

        if (tokens[curr].type === 'text' &&
            curr + 1 < max &&
            tokens[curr + 1].type === 'text') {

          // collapse two adjacent text nodes
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last) { tokens[last] = tokens[curr]; }

          last++;
        }
      }

      if (curr !== last) {
        tokens.length = last;
      }
    };

    var isWhiteSpace$1   = utils.isWhiteSpace;
    var isPunctChar$1    = utils.isPunctChar;
    var isMdAsciiPunct$1 = utils.isMdAsciiPunct;


    function StateInline(src, md, env, outTokens) {
      this.src = src;
      this.env = env;
      this.md = md;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);

      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = '';
      this.pendingLevel = 0;

      // Stores { start: end } pairs. Useful for backtrack
      // optimization of pairs parse (emphasis, strikes).
      this.cache = {};

      // List of emphasis-like delimiters for current tag
      this.delimiters = [];

      // Stack of delimiter lists for upper level tags
      this._prev_delimiters = [];
    }


    // Flush pending text
    //
    StateInline.prototype.pushPending = function () {
      var token$1 = new token('text', '', 0);
      token$1.content = this.pending;
      token$1.level = this.pendingLevel;
      this.tokens.push(token$1);
      this.pending = '';
      return token$1;
    };


    // Push new token to "stream".
    // If pending text exists - flush it as text token
    //
    StateInline.prototype.push = function (type, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }

      var token$1 = new token(type, tag, nesting);
      var token_meta = null;

      if (nesting < 0) {
        // closing tag
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }

      token$1.level = this.level;

      if (nesting > 0) {
        // opening tag
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = { delimiters: this.delimiters };
      }

      this.pendingLevel = this.level;
      this.tokens.push(token$1);
      this.tokens_meta.push(token_meta);
      return token$1;
    };


    // Scan a sequence of emphasis-like markers, and determine whether
    // it can start an emphasis sequence or end an emphasis sequence.
    //
    //  - start - position to scan from (it should point at a valid marker);
    //  - canSplitWord - determine if these markers can be found inside a word
    //
    StateInline.prototype.scanDelims = function (start, canSplitWord) {
      var pos = start, lastChar, nextChar, count, can_open, can_close,
          isLastWhiteSpace, isLastPunctChar,
          isNextWhiteSpace, isNextPunctChar,
          left_flanking = true,
          right_flanking = true,
          max = this.posMax,
          marker = this.src.charCodeAt(start);

      // treat beginning of the line as a whitespace
      lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

      while (pos < max && this.src.charCodeAt(pos) === marker) { pos++; }

      count = pos - start;

      // treat end of the line as a whitespace
      nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

      isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct$1(nextChar) || isPunctChar$1(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace$1(lastChar);
      isNextWhiteSpace = isWhiteSpace$1(nextChar);

      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }

      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }

      if (!canSplitWord) {
        can_open  = left_flanking  && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking  || isNextPunctChar);
      } else {
        can_open  = left_flanking;
        can_close = right_flanking;
      }

      return {
        can_open:  can_open,
        can_close: can_close,
        length:    count
      };
    };


    // re-export Token class to use in block rules
    StateInline.prototype.Token = token;


    var state_inline = StateInline;

    ////////////////////////////////////////////////////////////////////////////////
    // Parser rules

    var _rules$2 = [
      [ 'text',            text ],
      [ 'newline',         newline ],
      [ 'escape',          _escape ],
      [ 'backticks',       backticks ],
      [ 'strikethrough',   strikethrough.tokenize ],
      [ 'emphasis',        emphasis.tokenize ],
      [ 'link',            link ],
      [ 'image',           image$1 ],
      [ 'autolink',        autolink ],
      [ 'html_inline',     html_inline ],
      [ 'entity',          entity ]
    ];

    var _rules2 = [
      [ 'balance_pairs',   balance_pairs ],
      [ 'strikethrough',   strikethrough.postProcess ],
      [ 'emphasis',        emphasis.postProcess ],
      [ 'text_collapse',   text_collapse ]
    ];


    /**
     * new ParserInline()
     **/
    function ParserInline() {
      var i;

      /**
       * ParserInline#ruler -> Ruler
       *
       * [[Ruler]] instance. Keep configuration of inline rules.
       **/
      this.ruler = new ruler();

      for (i = 0; i < _rules$2.length; i++) {
        this.ruler.push(_rules$2[i][0], _rules$2[i][1]);
      }

      /**
       * ParserInline#ruler2 -> Ruler
       *
       * [[Ruler]] instance. Second ruler used for post-processing
       * (e.g. in emphasis-like rules).
       **/
      this.ruler2 = new ruler();

      for (i = 0; i < _rules2.length; i++) {
        this.ruler2.push(_rules2[i][0], _rules2[i][1]);
      }
    }


    // Skip single token by running all rules in validation mode;
    // returns `true` if any rule reported success
    //
    ParserInline.prototype.skipToken = function (state) {
      var ok, i, pos = state.pos,
          rules = this.ruler.getRules(''),
          len = rules.length,
          maxNesting = state.md.options.maxNesting,
          cache = state.cache;


      if (typeof cache[pos] !== 'undefined') {
        state.pos = cache[pos];
        return;
      }

      if (state.level < maxNesting) {
        for (i = 0; i < len; i++) {
          // Increment state.level and decrement it later to limit recursion.
          // It's harmless to do here, because no tokens are created. But ideally,
          // we'd need a separate private state variable for this purpose.
          //
          state.level++;
          ok = rules[i](state, true);
          state.level--;

          if (ok) { break; }
        }
      } else {
        // Too much nesting, just skip until the end of the paragraph.
        //
        // NOTE: this will cause links to behave incorrectly in the following case,
        //       when an amount of `[` is exactly equal to `maxNesting + 1`:
        //
        //       [[[[[[[[[[[[[[[[[[[[[foo]()
        //
        // TODO: remove this workaround when CM standard will allow nested links
        //       (we can replace it by preventing links from being parsed in
        //       validation mode)
        //
        state.pos = state.posMax;
      }

      if (!ok) { state.pos++; }
      cache[pos] = state.pos;
    };


    // Generate tokens for input range
    //
    ParserInline.prototype.tokenize = function (state) {
      var ok, i,
          rules = this.ruler.getRules(''),
          len = rules.length,
          end = state.posMax,
          maxNesting = state.md.options.maxNesting;

      while (state.pos < end) {
        // Try all possible rules.
        // On success, rule should:
        //
        // - update `state.pos`
        // - update `state.tokens`
        // - return true

        if (state.level < maxNesting) {
          for (i = 0; i < len; i++) {
            ok = rules[i](state, false);
            if (ok) { break; }
          }
        }

        if (ok) {
          if (state.pos >= end) { break; }
          continue;
        }

        state.pending += state.src[state.pos++];
      }

      if (state.pending) {
        state.pushPending();
      }
    };


    /**
     * ParserInline.parse(str, md, env, outTokens)
     *
     * Process input string and push inline tokens into `outTokens`
     **/
    ParserInline.prototype.parse = function (str, md, env, outTokens) {
      var i, rules, len;
      var state = new this.State(str, md, env, outTokens);

      this.tokenize(state);

      rules = this.ruler2.getRules('');
      len = rules.length;

      for (i = 0; i < len; i++) {
        rules[i](state);
      }
    };


    ParserInline.prototype.State = state_inline;


    var parser_inline = ParserInline;

    var re = function (opts) {
      var re = {};

      // Use direct extract instead of `regenerate` to reduse browserified size
      re.src_Any = regex$1.source;
      re.src_Cc  = regex$2.source;
      re.src_Z   = regex$4.source;
      re.src_P   = regex.source;

      // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
      re.src_ZPCc = [ re.src_Z, re.src_P, re.src_Cc ].join('|');

      // \p{\Z\Cc} (white spaces + control)
      re.src_ZCc = [ re.src_Z, re.src_Cc ].join('|');

      // Experimental. List of chars, completely prohibited in links
      // because can separate it from other part of text
      var text_separators = '[><\uff5c]';

      // All possible word characters (everything without punctuation, spaces & controls)
      // Defined via punctuation & spaces to save space
      // Should be something like \p{\L\N\S\M} (\w but without `_`)
      re.src_pseudo_letter       = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
      // The same as abothe but without [0-9]
      // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

      ////////////////////////////////////////////////////////////////////////////////

      re.src_ip4 =

        '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

      // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
      re.src_auth    = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

      re.src_port =

        '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

      re.src_host_terminator =

        '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

      re.src_path =

        '(?:' +
          '[/?#]' +
            '(?:' +
              '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-]).|' +
              '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' +
              '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' +
              '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' +
              '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' +
              "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" +
              "\\'(?=" + re.src_pseudo_letter + '|[-]).|' +  // allow `I'm_king` if no pair found
              '\\.{2,}[a-zA-Z0-9%/&]|' + // google has many dots in "google search" links (#66, #81).
                                         // github has ... in commit range links,
                                         // Restrict to
                                         // - english
                                         // - percent-encoded
                                         // - parts of file path
                                         // - params separator
                                         // until more examples found.
              '\\.(?!' + re.src_ZCc + '|[.]).|' +
              (opts && opts['---'] ?
                '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
                :
                '\\-+|'
              ) +
              '\\,(?!' + re.src_ZCc + ').|' +       // allow `,,,` in paths
              '\\!+(?!' + re.src_ZCc + '|[!]).|' +  // allow `!!!` in paths, but not at the end
              '\\?(?!' + re.src_ZCc + '|[?]).' +
            ')+' +
          '|\\/' +
        ')?';

      // Allow anything in markdown spec, forbid quote (") at the first position
      // because emails enclosed in quotes are far more common
      re.src_email_name =

        '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';

      re.src_xn =

        'xn--[a-z0-9\\-]{1,59}';

      // More to read about domain names
      // http://serverfault.com/questions/638260/

      re.src_domain_root =

        // Allow letters & digits (http://test1)
        '(?:' +
          re.src_xn +
          '|' +
          re.src_pseudo_letter + '{1,63}' +
        ')';

      re.src_domain =

        '(?:' +
          re.src_xn +
          '|' +
          '(?:' + re.src_pseudo_letter + ')' +
          '|' +
          '(?:' + re.src_pseudo_letter + '(?:-|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' +
        ')';

      re.src_host =

        '(?:' +
        // Don't need IP check, because digits are already allowed in normal domain names
        //   src_ip4 +
        // '|' +
          '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain/*_root*/ + ')' +
        ')';

      re.tpl_host_fuzzy =

        '(?:' +
          re.src_ip4 +
        '|' +
          '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' +
        ')';

      re.tpl_host_no_ip_fuzzy =

        '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

      re.src_host_strict =

        re.src_host + re.src_host_terminator;

      re.tpl_host_fuzzy_strict =

        re.tpl_host_fuzzy + re.src_host_terminator;

      re.src_host_port_strict =

        re.src_host + re.src_port + re.src_host_terminator;

      re.tpl_host_port_fuzzy_strict =

        re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

      re.tpl_host_port_no_ip_fuzzy_strict =

        re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;


      ////////////////////////////////////////////////////////////////////////////////
      // Main rules

      // Rude test fuzzy links by host, for quick deny
      re.tpl_host_fuzzy_test =

        'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

      re.tpl_email_fuzzy =

          '(^|' + text_separators + '|"|\\(|' + re.src_ZCc + ')' +
          '(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

      re.tpl_link_fuzzy =
          // Fuzzy link can't be prepended with .:/\- and non punctuation.
          // but can start with > (markdown blockquote)
          '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|' + re.src_ZPCc + '))' +
          '((?![$+<=>^`|\uff5c])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

      re.tpl_link_no_ip_fuzzy =
          // Fuzzy link can't be prepended with .:/\- and non punctuation.
          // but can start with > (markdown blockquote)
          '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|' + re.src_ZPCc + '))' +
          '((?![$+<=>^`|\uff5c])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

      return re;
    };

    ////////////////////////////////////////////////////////////////////////////////
    // Helpers

    // Merge objects
    //
    function assign$2(obj /*from1, from2, from3, ...*/) {
      var sources = Array.prototype.slice.call(arguments, 1);

      sources.forEach(function (source) {
        if (!source) { return; }

        Object.keys(source).forEach(function (key) {
          obj[key] = source[key];
        });
      });

      return obj;
    }

    function _class(obj) { return Object.prototype.toString.call(obj); }
    function isString(obj) { return _class(obj) === '[object String]'; }
    function isObject(obj) { return _class(obj) === '[object Object]'; }
    function isRegExp(obj) { return _class(obj) === '[object RegExp]'; }
    function isFunction(obj) { return _class(obj) === '[object Function]'; }


    function escapeRE(str) { return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&'); }

    ////////////////////////////////////////////////////////////////////////////////


    var defaultOptions = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };


    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function (acc, k) {
        return acc || defaultOptions.hasOwnProperty(k);
      }, false);
    }


    var defaultSchemas = {
      'http:': {
        validate: function (text, pos, self) {
          var tail = text.slice(pos);

          if (!self.re.http) {
            // compile lazily, because "host"-containing variables can change on tlds update.
            self.re.http =  new RegExp(
              '^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'
            );
          }
          if (self.re.http.test(tail)) {
            return tail.match(self.re.http)[0].length;
          }
          return 0;
        }
      },
      'https:':  'http:',
      'ftp:':    'http:',
      '//':      {
        validate: function (text, pos, self) {
          var tail = text.slice(pos);

          if (!self.re.no_http) {
          // compile lazily, because "host"-containing variables can change on tlds update.
            self.re.no_http =  new RegExp(
              '^' +
              self.re.src_auth +
              // Don't allow single-level domains, because of false positives like '//test'
              // with code comments
              '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' +
              self.re.src_port +
              self.re.src_host_terminator +
              self.re.src_path,

              'i'
            );
          }

          if (self.re.no_http.test(tail)) {
            // should not be `://` & `///`, that protects from errors in protocol name
            if (pos >= 3 && text[pos - 3] === ':') { return 0; }
            if (pos >= 3 && text[pos - 3] === '/') { return 0; }
            return tail.match(self.re.no_http)[0].length;
          }
          return 0;
        }
      },
      'mailto:': {
        validate: function (text, pos, self) {
          var tail = text.slice(pos);

          if (!self.re.mailto) {
            self.re.mailto =  new RegExp(
              '^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i'
            );
          }
          if (self.re.mailto.test(tail)) {
            return tail.match(self.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };

    /*eslint-disable max-len*/

    // RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
    var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

    // DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
    var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

    /*eslint-enable max-len*/

    ////////////////////////////////////////////////////////////////////////////////

    function resetScanCache(self) {
      self.__index__ = -1;
      self.__text_cache__   = '';
    }

    function createValidator(re) {
      return function (text, pos) {
        var tail = text.slice(pos);

        if (re.test(tail)) {
          return tail.match(re)[0].length;
        }
        return 0;
      };
    }

    function createNormalizer() {
      return function (match, self) {
        self.normalize(match);
      };
    }

    // Schemas compiler. Build regexps.
    //
    function compile(self) {

      // Load & clone RE patterns.
      var re$1 = self.re = re(self.__opts__);

      // Define dynamic patterns
      var tlds = self.__tlds__.slice();

      self.onCompile();

      if (!self.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re$1.src_xn);

      re$1.src_tlds = tlds.join('|');

      function untpl(tpl) { return tpl.replace('%TLDS%', re$1.src_tlds); }

      re$1.email_fuzzy      = RegExp(untpl(re$1.tpl_email_fuzzy), 'i');
      re$1.link_fuzzy       = RegExp(untpl(re$1.tpl_link_fuzzy), 'i');
      re$1.link_no_ip_fuzzy = RegExp(untpl(re$1.tpl_link_no_ip_fuzzy), 'i');
      re$1.host_fuzzy_test  = RegExp(untpl(re$1.tpl_host_fuzzy_test), 'i');

      //
      // Compile each schema
      //

      var aliases = [];

      self.__compiled__ = {}; // Reset compiled data

      function schemaError(name, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
      }

      Object.keys(self.__schemas__).forEach(function (name) {
        var val = self.__schemas__[name];

        // skip disabled methods
        if (val === null) { return; }

        var compiled = { validate: null, link: null };

        self.__compiled__[name] = compiled;

        if (isObject(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name, val);
          }

          if (isFunction(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name, val);
          }

          return;
        }

        if (isString(val)) {
          aliases.push(name);
          return;
        }

        schemaError(name, val);
      });

      //
      // Compile postponed aliases
      //

      aliases.forEach(function (alias) {
        if (!self.__compiled__[self.__schemas__[alias]]) {
          // Silently fail on missed schemas to avoid errons on disable.
          // schemaError(alias, self.__schemas__[alias]);
          return;
        }

        self.__compiled__[alias].validate =
          self.__compiled__[self.__schemas__[alias]].validate;
        self.__compiled__[alias].normalize =
          self.__compiled__[self.__schemas__[alias]].normalize;
      });

      //
      // Fake record for guessed links
      //
      self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

      //
      // Build schema condition
      //
      var slist = Object.keys(self.__compiled__)
                          .filter(function (name) {
                            // Filter disabled & fake schemas
                            return name.length > 0 && self.__compiled__[name];
                          })
                          .map(escapeRE)
                          .join('|');
      // (?!_) cause 1.5x slowdown
      self.re.schema_test   = RegExp('(^|(?!_)(?:[><\uff5c]|' + re$1.src_ZPCc + '))(' + slist + ')', 'i');
      self.re.schema_search = RegExp('(^|(?!_)(?:[><\uff5c]|' + re$1.src_ZPCc + '))(' + slist + ')', 'ig');

      self.re.pretest = RegExp(
        '(' + self.re.schema_test.source + ')|(' + self.re.host_fuzzy_test.source + ')|@',
        'i'
      );

      //
      // Cleanup
      //

      resetScanCache(self);
    }

    /**
     * class Match
     *
     * Match result. Single element of array, returned by [[LinkifyIt#match]]
     **/
    function Match(self, shift) {
      var start = self.__index__,
          end   = self.__last_index__,
          text  = self.__text_cache__.slice(start, end);

      /**
       * Match#schema -> String
       *
       * Prefix (protocol) for matched string.
       **/
      this.schema    = self.__schema__.toLowerCase();
      /**
       * Match#index -> Number
       *
       * First position of matched string.
       **/
      this.index     = start + shift;
      /**
       * Match#lastIndex -> Number
       *
       * Next position after matched string.
       **/
      this.lastIndex = end + shift;
      /**
       * Match#raw -> String
       *
       * Matched string.
       **/
      this.raw       = text;
      /**
       * Match#text -> String
       *
       * Notmalized text of matched string.
       **/
      this.text      = text;
      /**
       * Match#url -> String
       *
       * Normalized url of matched string.
       **/
      this.url       = text;
    }

    function createMatch(self, shift) {
      var match = new Match(self, shift);

      self.__compiled__[match.schema].normalize(match, self);

      return match;
    }


    /**
     * class LinkifyIt
     **/

    /**
     * new LinkifyIt(schemas, options)
     * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
     * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
     *
     * Creates new linkifier instance with optional additional schemas.
     * Can be called without `new` keyword for convenience.
     *
     * By default understands:
     *
     * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
     * - "fuzzy" links and emails (example.com, foo@bar.com).
     *
     * `schemas` is an object, where each key/value describes protocol/rule:
     *
     * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
     *   for example). `linkify-it` makes shure that prefix is not preceeded with
     *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
     * - __value__ - rule to check tail after link prefix
     *   - _String_ - just alias to existing rule
     *   - _Object_
     *     - _validate_ - validator function (should return matched length on success),
     *       or `RegExp`.
     *     - _normalize_ - optional function to normalize text & url of matched result
     *       (for example, for @twitter mentions).
     *
     * `options`:
     *
     * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
     * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
     *   like version numbers. Default `false`.
     * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
     *
     **/
    function LinkifyIt(schemas, options) {
      if (!(this instanceof LinkifyIt)) {
        return new LinkifyIt(schemas, options);
      }

      if (!options) {
        if (isOptionsObj(schemas)) {
          options = schemas;
          schemas = {};
        }
      }

      this.__opts__           = assign$2({}, defaultOptions, options);

      // Cache last tested result. Used to skip repeating steps on next `match` call.
      this.__index__          = -1;
      this.__last_index__     = -1; // Next scan position
      this.__schema__         = '';
      this.__text_cache__     = '';

      this.__schemas__        = assign$2({}, defaultSchemas, schemas);
      this.__compiled__       = {};

      this.__tlds__           = tlds_default;
      this.__tlds_replaced__  = false;

      this.re = {};

      compile(this);
    }


    /** chainable
     * LinkifyIt#add(schema, definition)
     * - schema (String): rule name (fixed pattern prefix)
     * - definition (String|RegExp|Object): schema definition
     *
     * Add new rule definition. See constructor description for details.
     **/
    LinkifyIt.prototype.add = function add(schema, definition) {
      this.__schemas__[schema] = definition;
      compile(this);
      return this;
    };


    /** chainable
     * LinkifyIt#set(options)
     * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
     *
     * Set recognition options for links without schema.
     **/
    LinkifyIt.prototype.set = function set(options) {
      this.__opts__ = assign$2(this.__opts__, options);
      return this;
    };


    /**
     * LinkifyIt#test(text) -> Boolean
     *
     * Searches linkifiable pattern and returns `true` on success or `false` on fail.
     **/
    LinkifyIt.prototype.test = function test(text) {
      // Reset scan cache
      this.__text_cache__ = text;
      this.__index__      = -1;

      if (!text.length) { return false; }

      var m, ml, me, len, shift, next, re, tld_pos, at_pos;

      // try to scan for link with schema - that's the most simple rule
      if (this.re.schema_test.test(text)) {
        re = this.re.schema_search;
        re.lastIndex = 0;
        while ((m = re.exec(text)) !== null) {
          len = this.testSchemaAt(text, m[2], re.lastIndex);
          if (len) {
            this.__schema__     = m[2];
            this.__index__      = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }

      if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
        // guess schemaless links
        tld_pos = text.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          // if tld is located after found link - no need to check fuzzy pattern
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

              shift = ml.index + ml[1].length;

              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__     = '';
                this.__index__      = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }

      if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
        // guess schemaless emails
        at_pos = text.indexOf('@');
        if (at_pos >= 0) {
          // We can't skip this check, because this cases are possible:
          // 192.168.1.1@gmail.com, my.in@example.com
          if ((me = text.match(this.re.email_fuzzy)) !== null) {

            shift = me.index + me[1].length;
            next  = me.index + me[0].length;

            if (this.__index__ < 0 || shift < this.__index__ ||
                (shift === this.__index__ && next > this.__last_index__)) {
              this.__schema__     = 'mailto:';
              this.__index__      = shift;
              this.__last_index__ = next;
            }
          }
        }
      }

      return this.__index__ >= 0;
    };


    /**
     * LinkifyIt#pretest(text) -> Boolean
     *
     * Very quick check, that can give false positives. Returns true if link MAY BE
     * can exists. Can be used for speed optimization, when you need to check that
     * link NOT exists.
     **/
    LinkifyIt.prototype.pretest = function pretest(text) {
      return this.re.pretest.test(text);
    };


    /**
     * LinkifyIt#testSchemaAt(text, name, position) -> Number
     * - text (String): text to scan
     * - name (String): rule (schema) name
     * - position (Number): text offset to check from
     *
     * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
     * at given position. Returns length of found pattern (0 on fail).
     **/
    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
      // If not supported schema check requested - terminate
      if (!this.__compiled__[schema.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
    };


    /**
     * LinkifyIt#match(text) -> Array|null
     *
     * Returns array of found link descriptions or `null` on fail. We strongly
     * recommend to use [[LinkifyIt#test]] first, for best speed.
     *
     * ##### Result match description
     *
     * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
     *   protocol-neutral  links.
     * - __index__ - offset of matched text
     * - __lastIndex__ - index of next char after mathch end
     * - __raw__ - matched text
     * - __text__ - normalized text
     * - __url__ - link, generated from matched text
     **/
    LinkifyIt.prototype.match = function match(text) {
      var shift = 0, result = [];

      // Try to take previous element from cache, if .test() called before
      if (this.__index__ >= 0 && this.__text_cache__ === text) {
        result.push(createMatch(this, shift));
        shift = this.__last_index__;
      }

      // Cut head if cache was used
      var tail = shift ? text.slice(shift) : text;

      // Scan string until end reached
      while (this.test(tail)) {
        result.push(createMatch(this, shift));

        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }

      if (result.length) {
        return result;
      }

      return null;
    };


    /** chainable
     * LinkifyIt#tlds(list [, keepOld]) -> this
     * - list (Array): list of tlds
     * - keepOld (Boolean): merge with current list if `true` (`false` by default)
     *
     * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
     * to avoid false positives. By default this algorythm used:
     *
     * - hostname with any 2-letter root zones are ok.
     * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
     *   are ok.
     * - encoded (`xn--...`) root zones are ok.
     *
     * If list is replaced, then exact match for 2-chars root zones will be checked.
     **/
    LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
      list = Array.isArray(list) ? list : [ list ];

      if (!keepOld) {
        this.__tlds__ = list.slice();
        this.__tlds_replaced__ = true;
        compile(this);
        return this;
      }

      this.__tlds__ = this.__tlds__.concat(list)
                                      .sort()
                                      .filter(function (el, idx, arr) {
                                        return el !== arr[idx - 1];
                                      })
                                      .reverse();

      compile(this);
      return this;
    };

    /**
     * LinkifyIt#normalize(match)
     *
     * Default normalizer (if schema does not define it's own).
     **/
    LinkifyIt.prototype.normalize = function normalize(match) {

      // Do minimal possible changes by default. Need to collect feedback prior
      // to move forward https://github.com/markdown-it/linkify-it/issues/1

      if (!match.schema) { match.url = 'http://' + match.url; }

      if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
        match.url = 'mailto:' + match.url;
      }
    };


    /**
     * LinkifyIt#onCompile()
     *
     * Override to modify basic RegExp-s.
     **/
    LinkifyIt.prototype.onCompile = function onCompile() {
    };


    var linkifyIt = LinkifyIt;

    /*! https://mths.be/punycode v1.4.1 by @mathias */


    /** Highest positive signed 32-bit float value */
    var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

    /** Bootstring parameters */
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128; // 0x80
    var delimiter = '-'; // '\x2D'

    /** Regular expressions */
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\x20-\x7E]/; // unprintable ASCII chars + non-ASCII chars
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

    /** Error messages */
    var errors = {
      'overflow': 'Overflow: input needs wider integers to process',
      'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
      'invalid-input': 'Invalid input'
    };

    /** Convenience shortcuts */
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;

    /*--------------------------------------------------------------------------*/

    /**
     * A generic error utility function.
     * @private
     * @param {String} type The error type.
     * @returns {Error} Throws a `RangeError` with the applicable error message.
     */
    function error(type) {
      throw new RangeError(errors[type]);
    }

    /**
     * A generic `Array#map` utility function.
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} callback The function that gets called for every array
     * item.
     * @returns {Array} A new array of values returned by the callback function.
     */
    function map$1(array, fn) {
      var length = array.length;
      var result = [];
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }

    /**
     * A simple `Array#map`-like wrapper to work with domain name strings or email
     * addresses.
     * @private
     * @param {String} domain The domain name or email address.
     * @param {Function} callback The function that gets called for every
     * character.
     * @returns {Array} A new string of characters returned by the callback
     * function.
     */
    function mapDomain(string, fn) {
      var parts = string.split('@');
      var result = '';
      if (parts.length > 1) {
        // In email addresses, only the domain name should be punycoded. Leave
        // the local part (i.e. everything up to `@`) intact.
        result = parts[0] + '@';
        string = parts[1];
      }
      // Avoid `split(regex)` for IE8 compatibility. See #17.
      string = string.replace(regexSeparators, '\x2E');
      var labels = string.split('.');
      var encoded = map$1(labels, fn).join('.');
      return result + encoded;
    }

    /**
     * Creates an array containing the numeric code points of each Unicode
     * character in the string. While JavaScript uses UCS-2 internally,
     * this function will convert a pair of surrogate halves (each of which
     * UCS-2 exposes as separate characters) into a single code point,
     * matching UTF-16.
     * @see `punycode.ucs2.encode`
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode.ucs2
     * @name decode
     * @param {String} string The Unicode input string (UCS-2).
     * @returns {Array} The new array of code points.
     */
    function ucs2decode(string) {
      var output = [],
        counter = 0,
        length = string.length,
        value,
        extra;
      while (counter < length) {
        value = string.charCodeAt(counter++);
        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
          // high surrogate, and there is a next character
          extra = string.charCodeAt(counter++);
          if ((extra & 0xFC00) == 0xDC00) { // low surrogate
            output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
          } else {
            // unmatched surrogate; only append this code unit, in case the next
            // code unit is the high surrogate of a surrogate pair
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }

    /**
     * Creates a string based on an array of numeric code points.
     * @see `punycode.ucs2.decode`
     * @memberOf punycode.ucs2
     * @name encode
     * @param {Array} codePoints The array of numeric code points.
     * @returns {String} The new Unicode string (UCS-2).
     */
    function ucs2encode(array) {
      return map$1(array, function(value) {
        var output = '';
        if (value > 0xFFFF) {
          value -= 0x10000;
          output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
          value = 0xDC00 | value & 0x3FF;
        }
        output += stringFromCharCode(value);
        return output;
      }).join('');
    }

    /**
     * Converts a basic code point into a digit/integer.
     * @see `digitToBasic()`
     * @private
     * @param {Number} codePoint The basic numeric code point value.
     * @returns {Number} The numeric value of a basic code point (for use in
     * representing integers) in the range `0` to `base - 1`, or `base` if
     * the code point does not represent a value.
     */
    function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    }

    /**
     * Converts a digit/integer into a basic code point.
     * @see `basicToDigit()`
     * @private
     * @param {Number} digit The numeric value of a basic code point.
     * @returns {Number} The basic code point whose value (when used for
     * representing integers) is `digit`, which needs to be in the range
     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
     * used; else, the lowercase form is used. The behavior is undefined
     * if `flag` is non-zero and `digit` has no uppercase form.
     */
    function digitToBasic(digit, flag) {
      //  0..25 map to ASCII a..z or A..Z
      // 26..35 map to ASCII 0..9
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }

    /**
     * Bias adaptation function as per section 3.4 of RFC 3492.
     * https://tools.ietf.org/html/rfc3492#section-3.4
     * @private
     */
    function adapt(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for ( /* no initialization */ ; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }

    /**
     * Converts a Punycode string of ASCII-only symbols to a string of Unicode
     * symbols.
     * @memberOf punycode
     * @param {String} input The Punycode string of ASCII-only symbols.
     * @returns {String} The resulting string of Unicode symbols.
     */
    function decode$2(input) {
      // Don't use UCS-2
      var output = [],
        inputLength = input.length,
        out,
        i = 0,
        n = initialN,
        bias = initialBias,
        basic,
        j,
        index,
        oldi,
        w,
        k,
        digit,
        t,
        /** Cached calculation results */
        baseMinusT;

      // Handle the basic code points: let `basic` be the number of input code
      // points before the last delimiter, or `0` if there is none, then copy
      // the first basic code points to the output.

      basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }

      for (j = 0; j < basic; ++j) {
        // if it's not a basic code point
        if (input.charCodeAt(j) >= 0x80) {
          error('not-basic');
        }
        output.push(input.charCodeAt(j));
      }

      // Main decoding loop: start just after the last delimiter if any basic code
      // points were copied; start at the beginning otherwise.

      for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */ ) {

        // `index` is the index of the next character to be consumed.
        // Decode a generalized variable-length integer into `delta`,
        // which gets added to `i`. The overflow checking is easier
        // if we increase `i` as we go, then subtract off its starting
        // value at the end to obtain `delta`.
        for (oldi = i, w = 1, k = base; /* no condition */ ; k += base) {

          if (index >= inputLength) {
            error('invalid-input');
          }

          digit = basicToDigit(input.charCodeAt(index++));

          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error('overflow');
          }

          i += digit * w;
          t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

          if (digit < t) {
            break;
          }

          baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error('overflow');
          }

          w *= baseMinusT;

        }

        out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);

        // `i` was supposed to wrap around from `out` to `0`,
        // incrementing `n` each time, so we'll fix that now:
        if (floor(i / out) > maxInt - n) {
          error('overflow');
        }

        n += floor(i / out);
        i %= out;

        // Insert `n` at position `i` of the output
        output.splice(i++, 0, n);

      }

      return ucs2encode(output);
    }

    /**
     * Converts a string of Unicode symbols (e.g. a domain name label) to a
     * Punycode string of ASCII-only symbols.
     * @memberOf punycode
     * @param {String} input The string of Unicode symbols.
     * @returns {String} The resulting Punycode string of ASCII-only symbols.
     */
    function encode$2(input) {
      var n,
        delta,
        handledCPCount,
        basicLength,
        bias,
        j,
        m,
        q,
        k,
        t,
        currentValue,
        output = [],
        /** `inputLength` will hold the number of code points in `input`. */
        inputLength,
        /** Cached calculation results */
        handledCPCountPlusOne,
        baseMinusT,
        qMinusT;

      // Convert the input in UCS-2 to Unicode
      input = ucs2decode(input);

      // Cache the length
      inputLength = input.length;

      // Initialize the state
      n = initialN;
      delta = 0;
      bias = initialBias;

      // Handle the basic code points
      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue < 0x80) {
          output.push(stringFromCharCode(currentValue));
        }
      }

      handledCPCount = basicLength = output.length;

      // `handledCPCount` is the number of code points that have been handled;
      // `basicLength` is the number of basic code points.

      // Finish the basic string - if it is not empty - with a delimiter
      if (basicLength) {
        output.push(delimiter);
      }

      // Main encoding loop:
      while (handledCPCount < inputLength) {

        // All non-basic code points < n have been handled already. Find the next
        // larger one:
        for (m = maxInt, j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }

        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
        // but guard against overflow
        handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error('overflow');
        }

        delta += (m - n) * handledCPCountPlusOne;
        n = m;

        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];

          if (currentValue < n && ++delta > maxInt) {
            error('overflow');
          }

          if (currentValue == n) {
            // Represent delta as a generalized variable-length integer
            for (q = delta, k = base; /* no condition */ ; k += base) {
              t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
              if (q < t) {
                break;
              }
              qMinusT = q - t;
              baseMinusT = base - t;
              output.push(
                stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
              );
              q = floor(qMinusT / baseMinusT);
            }

            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }

        ++delta;
        ++n;

      }
      return output.join('');
    }

    /**
     * Converts a Punycode string representing a domain name or an email address
     * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
     * it doesn't matter if you call it on a string that has already been
     * converted to Unicode.
     * @memberOf punycode
     * @param {String} input The Punycoded domain name or email address to
     * convert to Unicode.
     * @returns {String} The Unicode representation of the given Punycode
     * string.
     */
    function toUnicode(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ?
          decode$2(string.slice(4).toLowerCase()) :
          string;
      });
    }

    /**
     * Converts a Unicode string representing a domain name or an email address to
     * Punycode. Only the non-ASCII parts of the domain name will be converted,
     * i.e. it doesn't matter if you call it with a domain that's already in
     * ASCII.
     * @memberOf punycode
     * @param {String} input The domain name or email address to convert, as a
     * Unicode string.
     * @returns {String} The Punycode representation of the given domain name or
     * email address.
     */
    function toASCII(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ?
          'xn--' + encode$2(string) :
          string;
      });
    }
    var version = '1.4.1';
    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */

    var ucs2 = {
      decode: ucs2decode,
      encode: ucs2encode
    };
    var punycode = {
      version: version,
      ucs2: ucs2,
      toASCII: toASCII,
      toUnicode: toUnicode,
      encode: encode$2,
      decode: decode$2
    };

    var punycode$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        decode: decode$2,
        encode: encode$2,
        toUnicode: toUnicode,
        toASCII: toASCII,
        version: version,
        ucs2: ucs2,
        'default': punycode
    });

    // markdown-it default options


    var _default = {
      options: {
        html:         false,        // Enable HTML tags in source
        xhtmlOut:     false,        // Use '/' to close single tags (<br />)
        breaks:       false,        // Convert '\n' in paragraphs into <br>
        langPrefix:   'language-',  // CSS language prefix for fenced blocks
        linkify:      false,        // autoconvert URL-like texts to links

        // Enable some language-neutral replacements + quotes beautification
        typographer:  false,

        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,

        maxNesting:   100            // Internal protection, recursion limit
      },

      components: {

        core: {},
        block: {},
        inline: {}
      }
    };

    // "Zero" preset, with nothing enabled. Useful for manual configuring of simple


    var zero$2 = {
      options: {
        html:         false,        // Enable HTML tags in source
        xhtmlOut:     false,        // Use '/' to close single tags (<br />)
        breaks:       false,        // Convert '\n' in paragraphs into <br>
        langPrefix:   'language-',  // CSS language prefix for fenced blocks
        linkify:      false,        // autoconvert URL-like texts to links

        // Enable some language-neutral replacements + quotes beautification
        typographer:  false,

        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,

        maxNesting:   20            // Internal protection, recursion limit
      },

      components: {

        core: {
          rules: [
            'normalize',
            'block',
            'inline'
          ]
        },

        block: {
          rules: [
            'paragraph'
          ]
        },

        inline: {
          rules: [
            'text'
          ],
          rules2: [
            'balance_pairs',
            'text_collapse'
          ]
        }
      }
    };

    // Commonmark default options


    var commonmark = {
      options: {
        html:         true,         // Enable HTML tags in source
        xhtmlOut:     true,         // Use '/' to close single tags (<br />)
        breaks:       false,        // Convert '\n' in paragraphs into <br>
        langPrefix:   'language-',  // CSS language prefix for fenced blocks
        linkify:      false,        // autoconvert URL-like texts to links

        // Enable some language-neutral replacements + quotes beautification
        typographer:  false,

        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,

        maxNesting:   20            // Internal protection, recursion limit
      },

      components: {

        core: {
          rules: [
            'normalize',
            'block',
            'inline'
          ]
        },

        block: {
          rules: [
            'blockquote',
            'code',
            'fence',
            'heading',
            'hr',
            'html_block',
            'lheading',
            'list',
            'reference',
            'paragraph'
          ]
        },

        inline: {
          rules: [
            'autolink',
            'backticks',
            'emphasis',
            'entity',
            'escape',
            'html_inline',
            'image',
            'link',
            'newline',
            'text'
          ],
          rules2: [
            'balance_pairs',
            'emphasis',
            'text_collapse'
          ]
        }
      }
    };

    var punycode$2 = getCjsExportFromNamespace(punycode$1);

    var config = {
      default: _default,
      zero: zero$2,
      commonmark: commonmark
    };

    ////////////////////////////////////////////////////////////////////////////////
    //
    // This validator can prohibit more than really needed to prevent XSS. It's a
    // tradeoff to keep code simple and to be secure by default.
    //
    // If you need different setup - override validator method as you wish. Or
    // replace it with dummy function and use external sanitizer.
    //

    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

    function validateLink(url) {
      // url should be normalized at this point, and existing entities are decoded
      var str = url.trim().toLowerCase();

      return BAD_PROTO_RE.test(str) ? (GOOD_DATA_RE.test(str) ? true : false) : true;
    }

    ////////////////////////////////////////////////////////////////////////////////


    var RECODE_HOSTNAME_FOR = [ 'http:', 'https:', 'mailto:' ];

    function normalizeLink(url) {
      var parsed = mdurl.parse(url, true);

      if (parsed.hostname) {
        // Encode hostnames in urls like:
        // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
        //
        // We don't encode unknown schemas, because it's likely that we encode
        // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
        //
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode$2.toASCII(parsed.hostname);
          } catch (er) { /**/ }
        }
      }

      return mdurl.encode(mdurl.format(parsed));
    }

    function normalizeLinkText(url) {
      var parsed = mdurl.parse(url, true);

      if (parsed.hostname) {
        // Encode hostnames in urls like:
        // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
        //
        // We don't encode unknown schemas, because it's likely that we encode
        // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
        //
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode$2.toUnicode(parsed.hostname);
          } catch (er) { /**/ }
        }
      }

      // add '%' to exclude list because of https://github.com/markdown-it/markdown-it/issues/720
      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + '%');
    }


    /**
     * class MarkdownIt
     *
     * Main parser/renderer class.
     *
     * ##### Usage
     *
     * ```javascript
     * // node.js, "classic" way:
     * var MarkdownIt = require('markdown-it'),
     *     md = new MarkdownIt();
     * var result = md.render('# markdown-it rulezz!');
     *
     * // node.js, the same, but with sugar:
     * var md = require('markdown-it')();
     * var result = md.render('# markdown-it rulezz!');
     *
     * // browser without AMD, added to "window" on script load
     * // Note, there are no dash.
     * var md = window.markdownit();
     * var result = md.render('# markdown-it rulezz!');
     * ```
     *
     * Single line rendering, without paragraph wrap:
     *
     * ```javascript
     * var md = require('markdown-it')();
     * var result = md.renderInline('__markdown-it__ rulezz!');
     * ```
     **/

    /**
     * new MarkdownIt([presetName, options])
     * - presetName (String): optional, `commonmark` / `zero`
     * - options (Object)
     *
     * Creates parser instanse with given config. Can be called without `new`.
     *
     * ##### presetName
     *
     * MarkdownIt provides named presets as a convenience to quickly
     * enable/disable active syntax rules and options for common use cases.
     *
     * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
     *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
     * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
     *   similar to GFM, used when no preset name given. Enables all available rules,
     *   but still without html, typographer & autolinker.
     * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
     *   all rules disabled. Useful to quickly setup your config via `.enable()`.
     *   For example, when you need only `bold` and `italic` markup and nothing else.
     *
     * ##### options:
     *
     * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
     *   That's not safe! You may need external sanitizer to protect output from XSS.
     *   It's better to extend features via plugins, instead of enabling HTML.
     * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
     *   (`<br />`). This is needed only for full CommonMark compatibility. In real
     *   world you will need HTML output.
     * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
     * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
     *   Can be useful for external highlighters.
     * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
     * - __typographer__  - `false`. Set `true` to enable [some language-neutral
     *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
     *   quotes beautification (smartquotes).
     * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
     *   pairs, when typographer enabled and smartquotes on. For example, you can
     *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
     *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
     * - __highlight__ - `null`. Highlighter function for fenced code blocks.
     *   Highlighter `function (str, lang)` should return escaped HTML. It can also
     *   return empty string if the source was not changed and should be escaped
     *   externaly. If result starts with <pre... internal wrapper is skipped.
     *
     * ##### Example
     *
     * ```javascript
     * // commonmark mode
     * var md = require('markdown-it')('commonmark');
     *
     * // default mode
     * var md = require('markdown-it')();
     *
     * // enable everything
     * var md = require('markdown-it')({
     *   html: true,
     *   linkify: true,
     *   typographer: true
     * });
     * ```
     *
     * ##### Syntax highlighting
     *
     * ```js
     * var hljs = require('highlight.js') // https://highlightjs.org/
     *
     * var md = require('markdown-it')({
     *   highlight: function (str, lang) {
     *     if (lang && hljs.getLanguage(lang)) {
     *       try {
     *         return hljs.highlight(lang, str, true).value;
     *       } catch (__) {}
     *     }
     *
     *     return ''; // use external default escaping
     *   }
     * });
     * ```
     *
     * Or with full wrapper override (if you need assign class to `<pre>`):
     *
     * ```javascript
     * var hljs = require('highlight.js') // https://highlightjs.org/
     *
     * // Actual default values
     * var md = require('markdown-it')({
     *   highlight: function (str, lang) {
     *     if (lang && hljs.getLanguage(lang)) {
     *       try {
     *         return '<pre class="hljs"><code>' +
     *                hljs.highlight(lang, str, true).value +
     *                '</code></pre>';
     *       } catch (__) {}
     *     }
     *
     *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
     *   }
     * });
     * ```
     *
     **/
    function MarkdownIt(presetName, options) {
      if (!(this instanceof MarkdownIt)) {
        return new MarkdownIt(presetName, options);
      }

      if (!options) {
        if (!utils.isString(presetName)) {
          options = presetName || {};
          presetName = 'default';
        }
      }

      /**
       * MarkdownIt#inline -> ParserInline
       *
       * Instance of [[ParserInline]]. You may need it to add new rules when
       * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
       * [[MarkdownIt.enable]].
       **/
      this.inline = new parser_inline();

      /**
       * MarkdownIt#block -> ParserBlock
       *
       * Instance of [[ParserBlock]]. You may need it to add new rules when
       * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
       * [[MarkdownIt.enable]].
       **/
      this.block = new parser_block();

      /**
       * MarkdownIt#core -> Core
       *
       * Instance of [[Core]] chain executor. You may need it to add new rules when
       * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
       * [[MarkdownIt.enable]].
       **/
      this.core = new parser_core();

      /**
       * MarkdownIt#renderer -> Renderer
       *
       * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
       * rules for new token types, generated by plugins.
       *
       * ##### Example
       *
       * ```javascript
       * var md = require('markdown-it')();
       *
       * function myToken(tokens, idx, options, env, self) {
       *   //...
       *   return result;
       * };
       *
       * md.renderer.rules['my_token'] = myToken
       * ```
       *
       * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
       **/
      this.renderer = new renderer();

      /**
       * MarkdownIt#linkify -> LinkifyIt
       *
       * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
       * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
       * rule.
       **/
      this.linkify = new linkifyIt();

      /**
       * MarkdownIt#validateLink(url) -> Boolean
       *
       * Link validation function. CommonMark allows too much in links. By default
       * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
       * except some embedded image types.
       *
       * You can change this behaviour:
       *
       * ```javascript
       * var md = require('markdown-it')();
       * // enable everything
       * md.validateLink = function () { return true; }
       * ```
       **/
      this.validateLink = validateLink;

      /**
       * MarkdownIt#normalizeLink(url) -> String
       *
       * Function used to encode link url to a machine-readable format,
       * which includes url-encoding, punycode, etc.
       **/
      this.normalizeLink = normalizeLink;

      /**
       * MarkdownIt#normalizeLinkText(url) -> String
       *
       * Function used to decode link url to a human-readable format`
       **/
      this.normalizeLinkText = normalizeLinkText;


      // Expose utils & helpers for easy acces from plugins

      /**
       * MarkdownIt#utils -> utils
       *
       * Assorted utility functions, useful to write plugins. See details
       * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
       **/
      this.utils = utils;

      /**
       * MarkdownIt#helpers -> helpers
       *
       * Link components parser functions, useful to write plugins. See details
       * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
       **/
      this.helpers = utils.assign({}, helpers);


      this.options = {};
      this.configure(presetName);

      if (options) { this.set(options); }
    }


    /** chainable
     * MarkdownIt.set(options)
     *
     * Set parser options (in the same format as in constructor). Probably, you
     * will never need it, but you can change options after constructor call.
     *
     * ##### Example
     *
     * ```javascript
     * var md = require('markdown-it')()
     *             .set({ html: true, breaks: true })
     *             .set({ typographer, true });
     * ```
     *
     * __Note:__ To achieve the best possible performance, don't modify a
     * `markdown-it` instance options on the fly. If you need multiple configurations
     * it's best to create multiple instances and initialize each with separate
     * config.
     **/
    MarkdownIt.prototype.set = function (options) {
      utils.assign(this.options, options);
      return this;
    };


    /** chainable, internal
     * MarkdownIt.configure(presets)
     *
     * Batch load of all options and compenent settings. This is internal method,
     * and you probably will not need it. But if you will - see available presets
     * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
     *
     * We strongly recommend to use presets instead of direct config loads. That
     * will give better compatibility with next versions.
     **/
    MarkdownIt.prototype.configure = function (presets) {
      var self = this, presetName;

      if (utils.isString(presets)) {
        presetName = presets;
        presets = config[presetName];
        if (!presets) { throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name'); }
      }

      if (!presets) { throw new Error('Wrong `markdown-it` preset, can\'t be empty'); }

      if (presets.options) { self.set(presets.options); }

      if (presets.components) {
        Object.keys(presets.components).forEach(function (name) {
          if (presets.components[name].rules) {
            self[name].ruler.enableOnly(presets.components[name].rules);
          }
          if (presets.components[name].rules2) {
            self[name].ruler2.enableOnly(presets.components[name].rules2);
          }
        });
      }
      return this;
    };


    /** chainable
     * MarkdownIt.enable(list, ignoreInvalid)
     * - list (String|Array): rule name or list of rule names to enable
     * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
     *
     * Enable list or rules. It will automatically find appropriate components,
     * containing rules with given names. If rule not found, and `ignoreInvalid`
     * not set - throws exception.
     *
     * ##### Example
     *
     * ```javascript
     * var md = require('markdown-it')()
     *             .enable(['sub', 'sup'])
     *             .disable('smartquotes');
     * ```
     **/
    MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
      var result = [];

      if (!Array.isArray(list)) { list = [ list ]; }

      [ 'core', 'block', 'inline' ].forEach(function (chain) {
        result = result.concat(this[chain].ruler.enable(list, true));
      }, this);

      result = result.concat(this.inline.ruler2.enable(list, true));

      var missed = list.filter(function (name) { return result.indexOf(name) < 0; });

      if (missed.length && !ignoreInvalid) {
        throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
      }

      return this;
    };


    /** chainable
     * MarkdownIt.disable(list, ignoreInvalid)
     * - list (String|Array): rule name or list of rule names to disable.
     * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
     *
     * The same as [[MarkdownIt.enable]], but turn specified rules off.
     **/
    MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
      var result = [];

      if (!Array.isArray(list)) { list = [ list ]; }

      [ 'core', 'block', 'inline' ].forEach(function (chain) {
        result = result.concat(this[chain].ruler.disable(list, true));
      }, this);

      result = result.concat(this.inline.ruler2.disable(list, true));

      var missed = list.filter(function (name) { return result.indexOf(name) < 0; });

      if (missed.length && !ignoreInvalid) {
        throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
      }
      return this;
    };


    /** chainable
     * MarkdownIt.use(plugin, params)
     *
     * Load specified plugin with given params into current parser instance.
     * It's just a sugar to call `plugin(md, params)` with curring.
     *
     * ##### Example
     *
     * ```javascript
     * var iterator = require('markdown-it-for-inline');
     * var md = require('markdown-it')()
     *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
     *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
     *             });
     * ```
     **/
    MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
      var args = [ this ].concat(Array.prototype.slice.call(arguments, 1));
      plugin.apply(plugin, args);
      return this;
    };


    /** internal
     * MarkdownIt.parse(src, env) -> Array
     * - src (String): source string
     * - env (Object): environment sandbox
     *
     * Parse input string and return list of block tokens (special token type
     * "inline" will contain list of inline tokens). You should not call this
     * method directly, until you write custom renderer (for example, to produce
     * AST).
     *
     * `env` is used to pass data between "distributed" rules and return additional
     * metadata like reference info, needed for the renderer. It also can be used to
     * inject data in specific cases. Usually, you will be ok to pass `{}`,
     * and then pass updated object to renderer.
     **/
    MarkdownIt.prototype.parse = function (src, env) {
      if (typeof src !== 'string') {
        throw new Error('Input data should be a String');
      }

      var state = new this.core.State(src, this, env);

      this.core.process(state);

      return state.tokens;
    };


    /**
     * MarkdownIt.render(src [, env]) -> String
     * - src (String): source string
     * - env (Object): environment sandbox
     *
     * Render markdown string into html. It does all magic for you :).
     *
     * `env` can be used to inject additional metadata (`{}` by default).
     * But you will not need it with high probability. See also comment
     * in [[MarkdownIt.parse]].
     **/
    MarkdownIt.prototype.render = function (src, env) {
      env = env || {};

      return this.renderer.render(this.parse(src, env), this.options, env);
    };


    /** internal
     * MarkdownIt.parseInline(src, env) -> Array
     * - src (String): source string
     * - env (Object): environment sandbox
     *
     * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
     * block tokens list with the single `inline` element, containing parsed inline
     * tokens in `children` property. Also updates `env` object.
     **/
    MarkdownIt.prototype.parseInline = function (src, env) {
      var state = new this.core.State(src, this, env);

      state.inlineMode = true;
      this.core.process(state);

      return state.tokens;
    };


    /**
     * MarkdownIt.renderInline(src [, env]) -> String
     * - src (String): source string
     * - env (Object): environment sandbox
     *
     * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
     * will NOT be wrapped into `<p>` tags.
     **/
    MarkdownIt.prototype.renderInline = function (src, env) {
      env = env || {};

      return this.renderer.render(this.parseInline(src, env), this.options, env);
    };


    var lib = MarkdownIt;

    var markdownIt = lib;

    var htmlTagRegex = /<html(.|\s)*>(.|\s)*<\/html>/im;

    var md = new markdownIt({
        html: true,
        linkify: true
    });

    md.use(markdownItSanitizer, {
        imageClass: '',
        removeUnbalanced: false,
        removeUnknown: false
    });

    var KnockoutMarkdownBinding = {
        register: function (Knockout) {
            Knockout.bindingHandlers.markdown = {
                'init': function () {
                    // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)
                    return { 'controlsDescendantBindings': true };
                },
                'update': function (element, valueAccessor) {
                    // Remove existing children of this element.
                    while (element.firstChild) {
                        Knockout.removeNode(element.firstChild);
                    }

                    var rawText = Knockout.unwrap(valueAccessor());

                    // If the text contains an <html> tag, don't try to interpret it as Markdown because
                    // we'll probably break it in the process.
                    var html;
                    if (htmlTagRegex.test(rawText)) {
                        html = rawText;
                    } else {
                        html = md.render(rawText);
                    }

                    var nodes = Knockout.utils.parseHtmlFragment(html, element);
                    element.className = element.className + ' markdown';

                    for (var i = 0; i < nodes.length; ++i) {
                        var node = nodes[i];
                        setAnchorTargets(node);
                        element.appendChild(node);
                    }
                }
            };
        }
    };

    function setAnchorTargets(element) {
        if (element instanceof HTMLAnchorElement) {
            element.target = '_blank';
        }

        if (element.childNodes && element.childNodes.length > 0) {
            for (var i = 0; i < element.childNodes.length; ++i) {
                setAnchorTargets(element.childNodes[i]);
            }
        }
    }

    var hammer = createCommonjsModule(function (module) {
    /*! Hammer.JS - v2.0.7 - 2016-04-22
     * http://hammerjs.github.io/
     *
     * Copyright (c) 2016 Jorik Tangelder;
     * Licensed under the MIT license */
    (function(window, document, exportName, undefined$1) {

    var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
    var TEST_ELEMENT = document.createElement('div');

    var TYPE_FUNCTION = 'function';

    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;

    /**
     * set a timeout with a given scope
     * @param {Function} fn
     * @param {Number} timeout
     * @param {Object} context
     * @returns {number}
     */
    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }

    /**
     * if the argument is an array, we want to execute the fn on each entry
     * if it aint an array we don't want to do a thing.
     * this is used by all the methods that accept a single and array argument.
     * @param {*|Array} arg
     * @param {String} fn
     * @param {Object} [context]
     * @returns {Boolean}
     */
    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }

    /**
     * walk objects and arrays
     * @param {Object} obj
     * @param {Function} iterator
     * @param {Object} context
     */
    function each(obj, iterator, context) {
        var i;

        if (!obj) {
            return;
        }

        if (obj.forEach) {
            obj.forEach(iterator, context);
        } else if (obj.length !== undefined$1) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else {
            for (i in obj) {
                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
        }
    }

    /**
     * wrap a method with a deprecation warning and stack trace
     * @param {Function} method
     * @param {String} name
     * @param {String} message
     * @returns {Function} A new function wrapping the supplied method.
     */
    function deprecate(method, name, message) {
        var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
        return function() {
            var e = new Error('get-stack-trace');
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
                .replace(/^\s+at\s+/gm, '')
                .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

            var log = window.console && (window.console.warn || window.console.log);
            if (log) {
                log.call(window.console, deprecationMessage, stack);
            }
            return method.apply(this, arguments);
        };
    }

    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} target
     * @param {...Object} objects_to_assign
     * @returns {Object} target
     */
    var assign;
    if (typeof Object.assign !== 'function') {
        assign = function assign(target) {
            if (target === undefined$1 || target === null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }

            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (source !== undefined$1 && source !== null) {
                    for (var nextKey in source) {
                        if (source.hasOwnProperty(nextKey)) {
                            output[nextKey] = source[nextKey];
                        }
                    }
                }
            }
            return output;
        };
    } else {
        assign = Object.assign;
    }

    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} dest
     * @param {Object} src
     * @param {Boolean} [merge=false]
     * @returns {Object} dest
     */
    var extend = deprecate(function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || (merge && dest[keys[i]] === undefined$1)) {
                dest[keys[i]] = src[keys[i]];
            }
            i++;
        }
        return dest;
    }, 'extend', 'Use `assign`.');

    /**
     * merge the values from src in the dest.
     * means that properties that exist in dest will not be overwritten by src
     * @param {Object} dest
     * @param {Object} src
     * @returns {Object} dest
     */
    var merge = deprecate(function merge(dest, src) {
        return extend(dest, src, true);
    }, 'merge', 'Use `assign`.');

    /**
     * simple class inheritance
     * @param {Function} child
     * @param {Function} base
     * @param {Object} [properties]
     */
    function inherit(child, base, properties) {
        var baseP = base.prototype,
            childP;

        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;

        if (properties) {
            assign(childP, properties);
        }
    }

    /**
     * simple function bind
     * @param {Function} fn
     * @param {Object} context
     * @returns {Function}
     */
    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }

    /**
     * let a boolean value also be a function that must return a boolean
     * this first item in args will be used as the context
     * @param {Boolean|Function} val
     * @param {Array} [args]
     * @returns {Boolean}
     */
    function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined$1 : undefined$1, args);
        }
        return val;
    }

    /**
     * use the val2 when val1 is undefined
     * @param {*} val1
     * @param {*} val2
     * @returns {*}
     */
    function ifUndefined(val1, val2) {
        return (val1 === undefined$1) ? val2 : val1;
    }

    /**
     * addEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.addEventListener(type, handler, false);
        });
    }

    /**
     * removeEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.removeEventListener(type, handler, false);
        });
    }

    /**
     * find if a node is in the given parent
     * @method hasParent
     * @param {HTMLElement} node
     * @param {HTMLElement} parent
     * @return {Boolean} found
     */
    function hasParent(node, parent) {
        while (node) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }

    /**
     * small indexOf wrapper
     * @param {String} str
     * @param {String} find
     * @returns {Boolean} found
     */
    function inStr(str, find) {
        return str.indexOf(find) > -1;
    }

    /**
     * split string on whitespace
     * @param {String} str
     * @returns {Array} words
     */
    function splitStr(str) {
        return str.trim().split(/\s+/g);
    }

    /**
     * find if a array contains the object using indexOf or a simple polyFill
     * @param {Array} src
     * @param {String} find
     * @param {String} [findByKey]
     * @return {Boolean|Number} false when not found, or the index
     */
    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
            return src.indexOf(find);
        } else {
            var i = 0;
            while (i < src.length) {
                if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                    return i;
                }
                i++;
            }
            return -1;
        }
    }

    /**
     * convert array-like objects to real arrays
     * @param {Object} obj
     * @returns {Array}
     */
    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }

    /**
     * unique array with objects based on a key (like 'id') or just by the array's value
     * @param {Array} src [{id:1},{id:2},{id:1}]
     * @param {String} [key]
     * @param {Boolean} [sort=False]
     * @returns {Array} [{id:1},{id:2}]
     */
    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;

        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
                results.push(src[i]);
            }
            values[i] = val;
            i++;
        }

        if (sort) {
            if (!key) {
                results = results.sort();
            } else {
                results = results.sort(function sortUniqueArray(a, b) {
                    return a[key] > b[key];
                });
            }
        }

        return results;
    }

    /**
     * get the prefixed property
     * @param {Object} obj
     * @param {String} property
     * @returns {String|Undefined} prefixed
     */
    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);

        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = (prefix) ? prefix + camelProp : property;

            if (prop in obj) {
                return prop;
            }
            i++;
        }
        return undefined$1;
    }

    /**
     * get a unique id
     * @returns {number} uniqueId
     */
    var _uniqueId = 1;
    function uniqueId() {
        return _uniqueId++;
    }

    /**
     * get the window object of an element
     * @param {HTMLElement} element
     * @returns {DocumentView|Window}
     */
    function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return (doc.defaultView || doc.parentWindow || window);
    }

    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

    var SUPPORT_TOUCH = ('ontouchstart' in window);
    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined$1;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

    var INPUT_TYPE_TOUCH = 'touch';
    var INPUT_TYPE_PEN = 'pen';
    var INPUT_TYPE_MOUSE = 'mouse';
    var INPUT_TYPE_KINECT = 'kinect';

    var COMPUTE_INTERVAL = 25;

    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;

    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;

    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

    var PROPS_XY = ['x', 'y'];
    var PROPS_CLIENT_XY = ['clientX', 'clientY'];

    /**
     * create new input type manager
     * @param {Manager} manager
     * @param {Function} callback
     * @returns {Input}
     * @constructor
     */
    function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;

        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
                self.handler(ev);
            }
        };

        this.init();

    }

    Input.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() { },

        /**
         * bind the events
         */
        init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },

        /**
         * unbind the events
         */
        destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
    };

    /**
     * create new input type manager
     * called by the Manager constructor
     * @param {Hammer} manager
     * @returns {Input}
     */
    function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;

        if (inputClass) {
            Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
        } else {
            Type = TouchMouseInput;
        }
        return new (Type)(manager, inputHandler);
    }

    /**
     * handle input events
     * @param {Manager} manager
     * @param {String} eventType
     * @param {Object} input
     */
    function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
        var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;

        if (isFirst) {
            manager.session = {};
        }

        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;

        // compute scale, rotation etc
        computeInputData(manager, input);

        // emit secret event
        manager.emit('hammer.input', input);

        manager.recognize(input);
        manager.session.prevInput = input;
    }

    /**
     * extend the data with some usable properties like scale, rotate, velocity etc
     * @param {Object} manager
     * @param {Object} input
     */
    function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;

        // store the first input to calculate the distance and direction
        if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
        }

        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
            session.firstMultiple = false;
        }

        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;

        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);

        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);

        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

        input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
            session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

        computeIntervalInputData(session, input);

        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }

    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};

        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };

            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }

        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }

    /**
     * velocity is calculated every x ms
     * @param {Object} session
     * @param {Object} input
     */
    function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input,
            deltaTime = input.timeStamp - last.timeStamp,
            velocity, velocityX, velocityY, direction;

        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined$1)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;

            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);

            session.lastInterval = input;
        } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }

        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }

    /**
     * create a simple clone from the input used for storage of firstInput and firstMultiple
     * @param {Object} input
     * @returns {Object} clonedInputData
     */
    function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }

        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }

    /**
     * get the center of all the pointers
     * @param {Array} pointers
     * @return {Object} center contains `x` and `y` properties
     */
    function getCenter(pointers) {
        var pointersLength = pointers.length;

        // no need to loop when only one touch
        if (pointersLength === 1) {
            return {
                x: round(pointers[0].clientX),
                y: round(pointers[0].clientY)
            };
        }

        var x = 0, y = 0, i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }

        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }

    /**
     * calculate the velocity between two points. unit is in px per ms.
     * @param {Number} deltaTime
     * @param {Number} x
     * @param {Number} y
     * @return {Object} velocity `x` and `y`
     */
    function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }

    /**
     * get the direction between two points
     * @param {Number} x
     * @param {Number} y
     * @return {Number} direction
     */
    function getDirection(x, y) {
        if (x === y) {
            return DIRECTION_NONE;
        }

        if (abs(x) >= abs(y)) {
            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }

    /**
     * calculate the absolute distance between two points
     * @param {Object} p1 {x, y}
     * @param {Object} p2 {x, y}
     * @param {Array} [props] containing x and y keys
     * @return {Number} distance
     */
    function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];

        return Math.sqrt((x * x) + (y * y));
    }

    /**
     * calculate the angle between two coordinates
     * @param {Object} p1
     * @param {Object} p2
     * @param {Array} [props] containing x and y keys
     * @return {Number} angle
     */
    function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }

    /**
     * calculate the rotation degrees between two pointersets
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} rotation
     */
    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }

    /**
     * calculate the scale factor between two pointersets
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} scale
     */
    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }

    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };

    var MOUSE_ELEMENT_EVENTS = 'mousedown';
    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

    /**
     * Mouse events input
     * @constructor
     * @extends Input
     */
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;

        this.pressed = false; // mousedown state

        Input.apply(this, arguments);
    }

    inherit(MouseInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP[ev.type];

            // on start we want to have the left mouse button down
            if (eventType & INPUT_START && ev.button === 0) {
                this.pressed = true;
            }

            if (eventType & INPUT_MOVE && ev.which !== 1) {
                eventType = INPUT_END;
            }

            // mouse must be down
            if (!this.pressed) {
                return;
            }

            if (eventType & INPUT_END) {
                this.pressed = false;
            }

            this.callback(this.manager, eventType, {
                pointers: [ev],
                changedPointers: [ev],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            });
        }
    });

    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };

    // in IE10 the pointer types is defined as an enum
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
    };

    var POINTER_ELEMENT_EVENTS = 'pointerdown';
    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

    // IE10 has prefixed support, and case-sensitive
    if (window.MSPointerEvent && !window.PointerEvent) {
        POINTER_ELEMENT_EVENTS = 'MSPointerDown';
        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
    }

    /**
     * Pointer events input
     * @constructor
     * @extends Input
     */
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;

        Input.apply(this, arguments);

        this.store = (this.manager.session.pointerEvents = []);
    }

    inherit(PointerEventInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;

            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

            var isTouch = (pointerType == INPUT_TYPE_TOUCH);

            // get index of the event in the store
            var storeIndex = inArray(store, ev.pointerId, 'pointerId');

            // start and mouse must be down
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                if (storeIndex < 0) {
                    store.push(ev);
                    storeIndex = store.length - 1;
                }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                removePointer = true;
            }

            // it not found, so the pointer hasn't been down (so it's probably a hover)
            if (storeIndex < 0) {
                return;
            }

            // update the event in the store
            store[storeIndex] = ev;

            this.callback(this.manager, eventType, {
                pointers: store,
                changedPointers: [ev],
                pointerType: pointerType,
                srcEvent: ev
            });

            if (removePointer) {
                // remove from the store
                store.splice(storeIndex, 1);
            }
        }
    });

    var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };

    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

    /**
     * Touch events input
     * @constructor
     * @extends Input
     */
    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;

        Input.apply(this, arguments);
    }

    inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

            // should we handle the touch events?
            if (type === INPUT_START) {
                this.started = true;
            }

            if (!this.started) {
                return;
            }

            var touches = normalizeSingleTouches.call(this, ev, type);

            // when done, reset the started state
            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                this.started = false;
            }

            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);

        if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), 'identifier', true);
        }

        return [all, changed];
    }

    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };

    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

    /**
     * Multi-user touch events input
     * @constructor
     * @extends Input
     */
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};

        Input.apply(this, arguments);
    }

    inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
                return;
            }

            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;

        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
        }

        var i,
            targetTouches,
            changedTouches = toArray(ev.changedTouches),
            changedTargetTouches = [],
            target = this.target;

        // get target touches from touches
        targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
        });

        // collect touches
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }

        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
                changedTargetTouches.push(changedTouches[i]);
            }

            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) {
                delete targetIds[changedTouches[i].identifier];
            }
            i++;
        }

        if (!changedTargetTouches.length) {
            return;
        }

        return [
            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
            uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
            changedTargetTouches
        ];
    }

    /**
     * Combined touch and mouse input
     *
     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
     * This because touch devices also emit mouse events while doing a touch.
     *
     * @constructor
     * @extends Input
     */

    var DEDUP_TIMEOUT = 2500;
    var DEDUP_DISTANCE = 25;

    function TouchMouseInput() {
        Input.apply(this, arguments);

        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);

        this.primaryTouch = null;
        this.lastTouches = [];
    }

    inherit(TouchMouseInput, Input, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
                isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
                return;
            }

            // when we're in a touch event, record touches to  de-dupe synthetic mouse event
            if (isTouch) {
                recordTouches.call(this, inputEvent, inputData);
            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
                return;
            }

            this.callback(manager, inputEvent, inputData);
        },

        /**
         * remove the event listeners
         */
        destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
        }
    });

    function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            setLastTouch.call(this, eventData);
        }
    }

    function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];

        if (touch.identifier === this.primaryTouch) {
            var lastTouch = {x: touch.clientX, y: touch.clientY};
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function() {
                var i = lts.indexOf(lastTouch);
                if (i > -1) {
                    lts.splice(i, 1);
                }
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
    }

    function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
        for (var i = 0; i < this.lastTouches.length; i++) {
            var t = this.lastTouches[i];
            var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
                return true;
            }
        }
        return false;
    }

    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined$1;

    // magical touchAction value
    var TOUCH_ACTION_COMPUTE = 'compute';
    var TOUCH_ACTION_AUTO = 'auto';
    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
    var TOUCH_ACTION_NONE = 'none';
    var TOUCH_ACTION_PAN_X = 'pan-x';
    var TOUCH_ACTION_PAN_Y = 'pan-y';
    var TOUCH_ACTION_MAP = getTouchActionProps();

    /**
     * Touch Action
     * sets the touchAction property or uses the js alternative
     * @param {Manager} manager
     * @param {String} value
     * @constructor
     */
    function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }

    TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(value) {
            // find out the touch-action by the event handlers
            if (value == TOUCH_ACTION_COMPUTE) {
                value = this.compute();
            }

            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }
            this.actions = value.toLowerCase().trim();
        },

        /**
         * just re-set the touchAction value
         */
        update: function() {
            this.set(this.manager.options.touchAction);
        },

        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
                if (boolOrFn(recognizer.options.enable, [recognizer])) {
                    actions = actions.concat(recognizer.getTouchAction());
                }
            });
            return cleanTouchActions(actions.join(' '));
        },

        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;

            // if the touch action did prevented once this session
            if (this.manager.session.prevented) {
                srcEvent.preventDefault();
                return;
            }

            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

            if (hasNone) {
                //do not prevent defaults if this is a tap gesture

                var isTapPointer = input.pointers.length === 1;
                var isTapMovement = input.distance < 2;
                var isTapTouchTime = input.deltaTime < 250;

                if (isTapPointer && isTapMovement && isTapTouchTime) {
                    return;
                }
            }

            if (hasPanX && hasPanY) {
                // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
                return;
            }

            if (hasNone ||
                (hasPanY && direction & DIRECTION_HORIZONTAL) ||
                (hasPanX && direction & DIRECTION_VERTICAL)) {
                return this.preventSrc(srcEvent);
            }
        },

        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
        }
    };

    /**
     * when the touchActions are collected they are not a valid value, so we need to clean things up. *
     * @param {String} actions
     * @returns {*}
     */
    function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
        }

        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

        // if both pan-x and pan-y are set (different recognizers
        // for different directions, e.g. horizontal pan but vertical swipe?)
        // we need none (as otherwise with pan-x pan-y combined none of these
        // recognizers will work, since the browser would handle all panning
        if (hasPanX && hasPanY) {
            return TOUCH_ACTION_NONE;
        }

        // pan-x OR pan-y
        if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }

        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
        }

        return TOUCH_ACTION_AUTO;
    }

    function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
            return false;
        }
        var touchMap = {};
        var cssSupports = window.CSS && window.CSS.supports;
        ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

            // If css.supports is not supported but there is native touch-action assume it supports
            // all values. This is the case for IE 10 and 11.
            touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
        });
        return touchMap;
    }

    /**
     * Recognizer flow explained; *
     * All recognizers have the initial state of POSSIBLE when a input session starts.
     * The definition of a input session is from the first input until the last input, with all it's movement in it. *
     * Example session for mouse-input: mousedown -> mousemove -> mouseup
     *
     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
     * which determines with state it should be.
     *
     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
     * POSSIBLE to give it another change on the next cycle.
     *
     *               Possible
     *                  |
     *            +-----+---------------+
     *            |                     |
     *      +-----+-----+               |
     *      |           |               |
     *   Failed      Cancelled          |
     *                          +-------+------+
     *                          |              |
     *                      Recognized       Began
     *                                         |
     *                                      Changed
     *                                         |
     *                                  Ended/Recognized
     */
    var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;

    /**
     * Recognizer
     * Every recognizer needs to extend from this class.
     * @constructor
     * @param {Object} options
     */
    function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});

        this.id = uniqueId();

        this.manager = null;

        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);

        this.state = STATE_POSSIBLE;

        this.simultaneous = {};
        this.requireFail = [];
    }

    Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},

        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(options) {
            assign(this.options, options);

            // also update the touchAction, in case something changed about the directions/enabled state
            this.manager && this.manager.touchAction.update();
            return this;
        },

        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                return this;
            }

            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
                simultaneous[otherRecognizer.id] = otherRecognizer;
                otherRecognizer.recognizeWith(this);
            }
            return this;
        },

        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                return this;
            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
        },

        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                return this;
            }

            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
                requireFail.push(otherRecognizer);
                otherRecognizer.requireFailure(this);
            }
            return this;
        },

        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                return this;
            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) {
                this.requireFail.splice(index, 1);
            }
            return this;
        },

        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
            return this.requireFail.length > 0;
        },

        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
        },

        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(input) {
            var self = this;
            var state = this.state;

            function emit(event) {
                self.manager.emit(event, input);
            }

            // 'panstart' and 'panmove'
            if (state < STATE_ENDED) {
                emit(self.options.event + stateStr(state));
            }

            emit(self.options.event); // simple 'eventName' events

            if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
                emit(input.additionalEvent);
            }

            // panend and pancancel
            if (state >= STATE_ENDED) {
                emit(self.options.event + stateStr(state));
            }
        },

        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(input) {
            if (this.canEmit()) {
                return this.emit(input);
            }
            // it's failing anyway
            this.state = STATE_FAILED;
        },

        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
            var i = 0;
            while (i < this.requireFail.length) {
                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                    return false;
                }
                i++;
            }
            return true;
        },

        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(inputData) {
            // make a new copy of the inputData
            // so we can change the inputData without messing up the other recognizers
            var inputDataClone = assign({}, inputData);

            // is is enabled and allow recognizing?
            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                this.reset();
                this.state = STATE_FAILED;
                return;
            }

            // reset when we've reached the end
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                this.state = STATE_POSSIBLE;
            }

            this.state = this.process(inputDataClone);

            // the recognizer has recognized a gesture
            // so trigger an event
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                this.tryEmit(inputDataClone);
            }
        },

        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(inputData) { }, // jshint ignore:line

        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() { },

        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() { }
    };

    /**
     * get a usable string, used as event postfix
     * @param {Const} state
     * @returns {String} state
     */
    function stateStr(state) {
        if (state & STATE_CANCELLED) {
            return 'cancel';
        } else if (state & STATE_ENDED) {
            return 'end';
        } else if (state & STATE_CHANGED) {
            return 'move';
        } else if (state & STATE_BEGAN) {
            return 'start';
        }
        return '';
    }

    /**
     * direction cons to string
     * @param {Const} direction
     * @returns {String}
     */
    function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
            return 'down';
        } else if (direction == DIRECTION_UP) {
            return 'up';
        } else if (direction == DIRECTION_LEFT) {
            return 'left';
        } else if (direction == DIRECTION_RIGHT) {
            return 'right';
        }
        return '';
    }

    /**
     * get a recognizer by name if it is bound to a manager
     * @param {Recognizer|String} otherRecognizer
     * @param {Recognizer} recognizer
     * @returns {Recognizer}
     */
    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
            return manager.get(otherRecognizer);
        }
        return otherRecognizer;
    }

    /**
     * This recognizer is just used as a base for the simple attribute recognizers.
     * @constructor
     * @extends Recognizer
     */
    function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }

    inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
            /**
             * @type {Number}
             * @default 1
             */
            pointers: 1
        },

        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
        },

        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(input) {
            var state = this.state;
            var eventType = input.eventType;

            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);

            // on cancel input and we've recognized before, return STATE_CANCELLED
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
                if (eventType & INPUT_END) {
                    return state | STATE_ENDED;
                } else if (!(state & STATE_BEGAN)) {
                    return STATE_BEGAN;
                }
                return state | STATE_CHANGED;
            }
            return STATE_FAILED;
        }
    });

    /**
     * Pan
     * Recognized when the pointer is down and moved in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);

        this.pX = null;
        this.pY = null;
    }

    inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
            event: 'pan',
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },

        getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
                actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
                actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
        },

        directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;

            // lock to axis?
            if (!(direction & options.direction)) {
                if (options.direction & DIRECTION_HORIZONTAL) {
                    direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs(input.deltaX);
                } else {
                    direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs(input.deltaY);
                }
            }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
        },

        attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) &&
                (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
        },

        emit: function(input) {

            this.pX = input.deltaX;
            this.pY = input.deltaY;

            var direction = directionStr(input.direction);

            if (direction) {
                input.additionalEvent = this.options.event + direction;
            }
            this._super.emit.call(this, input);
        }
    });

    /**
     * Pinch
     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
     * @constructor
     * @extends AttrRecognizer
     */
    function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'pinch',
            threshold: 0,
            pointers: 2
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
        },

        attrTest: function(input) {
            return this._super.attrTest.call(this, input) &&
                (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },

        emit: function(input) {
            if (input.scale !== 1) {
                var inOut = input.scale < 1 ? 'in' : 'out';
                input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
        }
    });

    /**
     * Press
     * Recognized when the pointer is down for x ms without any movement.
     * @constructor
     * @extends Recognizer
     */
    function PressRecognizer() {
        Recognizer.apply(this, arguments);

        this._timer = null;
        this._input = null;
    }

    inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
            event: 'press',
            pointers: 1,
            time: 251, // minimal time of the pointer to be pressed
            threshold: 9 // a minimal movement is ok, but keep it low
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_AUTO];
        },

        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;

            this._input = input;

            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
                this.reset();
            } else if (input.eventType & INPUT_START) {
                this.reset();
                this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                }, options.time, this);
            } else if (input.eventType & INPUT_END) {
                return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
        },

        reset: function() {
            clearTimeout(this._timer);
        },

        emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) {
                return;
            }

            if (input && (input.eventType & INPUT_END)) {
                this.manager.emit(this.options.event + 'up', input);
            } else {
                this._input.timeStamp = now();
                this.manager.emit(this.options.event, this._input);
            }
        }
    });

    /**
     * Rotate
     * Recognized when two or more pointer are moving in a circular motion.
     * @constructor
     * @extends AttrRecognizer
     */
    function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
            event: 'rotate',
            threshold: 0,
            pointers: 2
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
        },

        attrTest: function(input) {
            return this._super.attrTest.call(this, input) &&
                (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
    });

    /**
     * Swipe
     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
            event: 'swipe',
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },

        getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
        },

        attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;

            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                velocity = input.overallVelocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
                velocity = input.overallVelocityX;
            } else if (direction & DIRECTION_VERTICAL) {
                velocity = input.overallVelocityY;
            }

            return this._super.attrTest.call(this, input) &&
                direction & input.offsetDirection &&
                input.distance > this.options.threshold &&
                input.maxPointers == this.options.pointers &&
                abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },

        emit: function(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) {
                this.manager.emit(this.options.event + direction, input);
            }

            this.manager.emit(this.options.event, input);
        }
    });

    /**
     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
     * between the given interval and position. The delay option can be used to recognize multi-taps without firing
     * a single tap.
     *
     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
     * multi-taps being recognized.
     * @constructor
     * @extends Recognizer
     */
    function TapRecognizer() {
        Recognizer.apply(this, arguments);

        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;

        this._timer = null;
        this._input = null;
        this.count = 0;
    }

    inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'tap',
            pointers: 1,
            taps: 1,
            interval: 300, // max time between the multi-tap taps
            time: 250, // max time of the pointer to be down (like finger on the screen)
            threshold: 9, // a minimal movement is ok, but keep it low
            posThreshold: 10 // a multi-tap can be a bit off the initial position
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_MANIPULATION];
        },

        process: function(input) {
            var options = this.options;

            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;

            this.reset();

            if ((input.eventType & INPUT_START) && (this.count === 0)) {
                return this.failTimeout();
            }

            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (validMovement && validTouchTime && validPointers) {
                if (input.eventType != INPUT_END) {
                    return this.failTimeout();
                }

                var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

                this.pTime = input.timeStamp;
                this.pCenter = input.center;

                if (!validMultiTap || !validInterval) {
                    this.count = 1;
                } else {
                    this.count += 1;
                }

                this._input = input;

                // if tap count matches we have recognized it,
                // else it has began recognizing...
                var tapCount = this.count % options.taps;
                if (tapCount === 0) {
                    // no failing requirements, immediately trigger the tap event
                    // or wait as long as the multitap interval to trigger
                    if (!this.hasRequireFailures()) {
                        return STATE_RECOGNIZED;
                    } else {
                        this._timer = setTimeoutContext(function() {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.interval, this);
                        return STATE_BEGAN;
                    }
                }
            }
            return STATE_FAILED;
        },

        failTimeout: function() {
            this._timer = setTimeoutContext(function() {
                this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
        },

        reset: function() {
            clearTimeout(this._timer);
        },

        emit: function() {
            if (this.state == STATE_RECOGNIZED) {
                this._input.tapCount = this.count;
                this.manager.emit(this.options.event, this._input);
            }
        }
    });

    /**
     * Simple way to create a manager with a default set of recognizers.
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }

    /**
     * @const {string}
     */
    Hammer.VERSION = '2.0.7';

    /**
     * default settings
     * @namespace
     */
    Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,

        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,

        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,

        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,

        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,

        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
            // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
            [RotateRecognizer, {enable: false}],
            [PinchRecognizer, {enable: false}, ['rotate']],
            [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
            [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
            [TapRecognizer],
            [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
            [PressRecognizer]
        ],

        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
            /**
             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userSelect: 'none',

            /**
             * Disable the Windows Phone grippers when pressing an element.
             * @type {String}
             * @default 'none'
             */
            touchSelect: 'none',

            /**
             * Disables the default callout shown when you touch and hold a touch target.
             * On iOS, when you touch and hold a touch target such as a link, Safari displays
             * a callout containing information about the link. This property allows you to disable that callout.
             * @type {String}
             * @default 'none'
             */
            touchCallout: 'none',

            /**
             * Specifies whether zooming is enabled. Used by IE10>
             * @type {String}
             * @default 'none'
             */
            contentZooming: 'none',

            /**
             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userDrag: 'none',

            /**
             * Overrides the highlight color shown when the user taps a link or a JavaScript
             * clickable element in iOS. This property obeys the alpha value, if specified.
             * @type {String}
             * @default 'rgba(0,0,0,0)'
             */
            tapHighlightColor: 'rgba(0,0,0,0)'
        }
    };

    var STOP = 1;
    var FORCED_STOP = 2;

    /**
     * Manager
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Manager(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});

        this.options.inputTarget = this.options.inputTarget || element;

        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};

        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);

        toggleCssProps(this, true);

        each(this.options.recognizers, function(item) {
            var recognizer = this.add(new (item[0])(item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }

    Manager.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(options) {
            assign(this.options, options);

            // Options that need a little more setup
            if (options.touchAction) {
                this.touchAction.update();
            }
            if (options.inputTarget) {
                // Clean up existing event listeners and reinitialize
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init();
            }
            return this;
        },

        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
        },

        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) {
                return;
            }

            // run the touch-action polyfill
            this.touchAction.preventDefaults(inputData);

            var recognizer;
            var recognizers = this.recognizers;

            // this holds the recognizer that is being recognized.
            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
            // if no recognizer is detecting a thing, it is set to `null`
            var curRecognizer = session.curRecognizer;

            // reset when the last recognizer is recognized
            // or when we're in a new session
            if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
                curRecognizer = session.curRecognizer = null;
            }

            var i = 0;
            while (i < recognizers.length) {
                recognizer = recognizers[i];

                // find out if we are allowed try to recognize the input for this one.
                // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                //      that is being recognized.
                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                //      this can be setup with the `recognizeWith()` method on the recognizer.
                if (session.stopped !== FORCED_STOP && ( // 1
                        !curRecognizer || recognizer == curRecognizer || // 2
                        recognizer.canRecognizeWith(curRecognizer))) { // 3
                    recognizer.recognize(inputData);
                } else {
                    recognizer.reset();
                }

                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                // current active recognizer. but only if we don't already have an active recognizer
                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                    curRecognizer = session.curRecognizer = recognizer;
                }
                i++;
            }
        },

        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(recognizer) {
            if (recognizer instanceof Recognizer) {
                return recognizer;
            }

            var recognizers = this.recognizers;
            for (var i = 0; i < recognizers.length; i++) {
                if (recognizers[i].options.event == recognizer) {
                    return recognizers[i];
                }
            }
            return null;
        },

        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(recognizer) {
            if (invokeArrayArg(recognizer, 'add', this)) {
                return this;
            }

            // remove existing
            var existing = this.get(recognizer.options.event);
            if (existing) {
                this.remove(existing);
            }

            this.recognizers.push(recognizer);
            recognizer.manager = this;

            this.touchAction.update();
            return recognizer;
        },

        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(recognizer) {
            if (invokeArrayArg(recognizer, 'remove', this)) {
                return this;
            }

            recognizer = this.get(recognizer);

            // let's make sure this recognizer exists
            if (recognizer) {
                var recognizers = this.recognizers;
                var index = inArray(recognizers, recognizer);

                if (index !== -1) {
                    recognizers.splice(index, 1);
                    this.touchAction.update();
                }
            }

            return this;
        },

        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(events, handler) {
            if (events === undefined$1) {
                return;
            }
            if (handler === undefined$1) {
                return;
            }

            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                handlers[event] = handlers[event] || [];
                handlers[event].push(handler);
            });
            return this;
        },

        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(events, handler) {
            if (events === undefined$1) {
                return;
            }

            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                if (!handler) {
                    delete handlers[event];
                } else {
                    handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
                }
            });
            return this;
        },

        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(event, data) {
            // we also want to trigger dom events
            if (this.options.domEvents) {
                triggerDomEvent(event, data);
            }

            // no handlers, so skip it all
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
                return;
            }

            data.type = event;
            data.preventDefault = function() {
                data.srcEvent.preventDefault();
            };

            var i = 0;
            while (i < handlers.length) {
                handlers[i](data);
                i++;
            }
        },

        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
            this.element && toggleCssProps(this, false);

            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
        }
    };

    /**
     * add/remove the css properties as defined in manager.options.cssProps
     * @param {Manager} manager
     * @param {Boolean} add
     */
    function toggleCssProps(manager, add) {
        var element = manager.element;
        if (!element.style) {
            return;
        }
        var prop;
        each(manager.options.cssProps, function(value, name) {
            prop = prefixed(element.style, name);
            if (add) {
                manager.oldCssProps[prop] = element.style[prop];
                element.style[prop] = value;
            } else {
                element.style[prop] = manager.oldCssProps[prop] || '';
            }
        });
        if (!add) {
            manager.oldCssProps = {};
        }
    }

    /**
     * trigger dom event
     * @param {String} event
     * @param {Object} data
     */
    function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }

    assign(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,

        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,

        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,

        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,

        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,

        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,

        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        assign: assign,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    });

    // this prevents errors when Hammer is loaded in the presence of an AMD
    //  style loader but by script tag, not by the loader.
    var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
    freeGlobal.Hammer = Hammer;

    if (typeof undefined$1 === 'function' && undefined$1.amd) {
        undefined$1(function() {
            return Hammer;
        });
    } else if ( module.exports) {
        module.exports = Hammer;
    } else {
        window[exportName] = Hammer;
    }

    })(window, document, 'Hammer');
    });

    var KnockoutHammerBinding = {
        register: function (Knockout) {
            Cesium.knockout.bindingHandlers.swipeLeft = {
                init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
                    var f = knockout.unwrap(valueAccessor());
                    new hammer(element).on('swipeleft', function (e) {
                        var viewModel = bindingContext.$data;
                        f.apply(viewModel, arguments);
                    });
                }
            };

            Cesium.knockout.bindingHandlers.swipeRight = {
                init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
                    var f = knockout.unwrap(valueAccessor());
                    new hammer(element).on('swiperight', function (e) {
                        var viewModel = bindingContext.$data;
                        f.apply(viewModel, arguments);
                    });
                }
            };
        }
    };

    var registerKnockoutBindings = function () {
        Cesium.SvgPathBindingHandler.register(Cesium.knockout);
        KnockoutMarkdownBinding.register(Cesium.knockout);
        KnockoutHammerBinding.register(Cesium.knockout);

        Cesium.knockout.bindingHandlers.embeddedComponent = {
            init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
                var component = Cesium.knockout.unwrap(valueAccessor());
                component.show(element);
                return { controlsDescendantBindings: true };
            },
            update: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
            }
        };
    };

    var createFragmentFromTemplate = function (htmlString) {
        var holder = document.createElement('div');
        holder.innerHTML = htmlString;

        var fragment = document.createDocumentFragment();
        while (holder.firstChild) {
            fragment.appendChild(holder.firstChild);
        }

        return fragment;
    };

    var loadView = function (htmlString, container, viewModel) {
        container = Cesium.getElement(container);

        var fragment = createFragmentFromTemplate(htmlString);

        // Sadly, fragment.childNodes doesn't have a slice function.
        // This code could be replaced with Array.prototype.slice.call(fragment.childNodes)
        // but that seems slightly error prone.
        var nodes = [];

        var i;
        for (i = 0; i < fragment.childNodes.length; ++i) {
            nodes.push(fragment.childNodes[i]);
        }

        container.appendChild(fragment);

        for (i = 0; i < nodes.length; ++i) {
            var node = nodes[i];
            if (node.nodeType === 1 || node.nodeType === 8) {
                Cesium.knockout.applyBindings(viewModel, node);
            }
        }

        return nodes;
    };

    var geodesic;

    var DistanceLegendViewModel = function (options) {
        geodesic = new Cesium.EllipsoidGeodesic();
        if (!Cesium.defined(options) || !Cesium.defined(options.terria)) {
            throw new Cesium.DeveloperError('options.terria is required.');
        }

        this.terria = options.terria;
        this._removeSubscription = undefined;
        this._lastLegendUpdate = undefined;
        this.eventHelper = new Cesium.EventHelper();

        this.distanceLabel = undefined;
        this.barWidth = undefined;

        this.enableDistanceLegend =  (Cesium.defined(options.enableDistanceLegend))?options.enableDistanceLegend:true;

        Cesium.knockout.track(this, ['distanceLabel', 'barWidth']);

        this.eventHelper.add(this.terria.afterWidgetChanged, function () {
            if (Cesium.defined(this._removeSubscription)) {
                this._removeSubscription();
                this._removeSubscription = undefined;
            }
        }, this);
    //        this.terria.beforeWidgetChanged.addEventListener(function () {
    //            if (Cesium.defined(this._removeSubscription)) {
    //                this._removeSubscription();
    //                this._removeSubscription = undefined;
    //            }
    //        }, this);

        var that = this;

        function addUpdateSubscription() {
            if (Cesium.defined(that.terria)) {
                var scene = that.terria.scene;
                that._removeSubscription = scene.postRender.addEventListener(function () {
                    updateDistanceLegendCesium(this, scene);
                }, that);
            }
        }

        addUpdateSubscription();
        this.eventHelper.add(this.terria.afterWidgetChanged, function () {
            addUpdateSubscription();
        }, this);
        //this.terria.afterWidgetChanged.addEventListener(function() {
        //    addUpdateSubscription();
        // }, this);
    };


    DistanceLegendViewModel.prototype.destroy = function () {

        this.eventHelper.removeAll();
    };

    DistanceLegendViewModel.prototype.show = function (container) {
        var testing ;
        if ( this.enableDistanceLegend)
        {
                testing = '<div class="distance-legend" data-bind="visible: distanceLabel && barWidth">' +
                '<div class="distance-legend-label" data-bind="text: distanceLabel"></div>' +
                '<div class="distance-legend-scale-bar" data-bind="style: { width: barWidth + \'px\', left: (5 + (125 - barWidth) / 2) + \'px\' }"></div>' +
                '</div>';
        }
        else
        {
                testing = '<div class="distance-legend"  style="display: none;" data-bind="visible: distanceLabel && barWidth">' +
                '<div class="distance-legend-label"  data-bind="text: distanceLabel"></div>' +
                '<div class="distance-legend-scale-bar"  data-bind="style: { width: barWidth + \'px\', left: (5 + (125 - barWidth) / 2) + \'px\' }"></div>' +
                '</div>';
        }
        loadView(testing, container, this);
        // loadView(distanceLegendTemplate, container, this);
        //loadView(require('fs').readFileSync(__dirname + '/../Views/DistanceLegend.html', 'utf8'), container, this);
    };

    DistanceLegendViewModel.create = function (options) {
        var result = new DistanceLegendViewModel(options);
        result.show(options.container);
        return result;
    };

    var distances = [
        1, 2, 3, 5,
        10, 20, 30, 50,
        100, 200, 300, 500,
        1000, 2000, 3000, 5000,
        10000, 20000, 30000, 50000,
        100000, 200000, 300000, 500000,
        1000000, 2000000, 3000000, 5000000,
        10000000, 20000000, 30000000, 50000000];

    function updateDistanceLegendCesium(viewModel, scene) {
        if (!viewModel.enableDistanceLegend)
        {
                viewModel.barWidth = undefined;
            viewModel.distanceLabel = undefined;
            return;
        }
        var now = Cesium.getTimestamp();
        if (now < viewModel._lastLegendUpdate + 250) {
            return;
        }

        viewModel._lastLegendUpdate = now;

        // Find the distance between two pixels at the bottom center of the screen.
        var width = scene.canvas.clientWidth;
        var height = scene.canvas.clientHeight;

        var left = scene.camera.getPickRay(new Cesium.Cartesian2((width / 2) | 0, height - 1));
        var right = scene.camera.getPickRay(new Cesium.Cartesian2(1 + (width / 2) | 0, height - 1));

        var globe = scene.globe;
        var leftPosition = globe.pick(left, scene);
        var rightPosition = globe.pick(right, scene);

        if (!Cesium.defined(leftPosition) || !Cesium.defined(rightPosition)) {
            viewModel.barWidth = undefined;
            viewModel.distanceLabel = undefined;
            return;
        }

        var leftCartographic = globe.ellipsoid.cartesianToCartographic(leftPosition);
        var rightCartographic = globe.ellipsoid.cartesianToCartographic(rightPosition);

        geodesic.setEndPoints(leftCartographic, rightCartographic);
        var pixelDistance = geodesic.surfaceDistance;

        // Find the first distance that makes the scale bar less than 100 pixels.
        var maxBarWidth = 100;
        var distance;
        for (var i = distances.length - 1; !Cesium.defined(distance) && i >= 0; --i) {
            if (distances[i] / pixelDistance < maxBarWidth) {
                distance = distances[i];
            }
        }

        if (Cesium.defined(distance)) {
            var label;
            if (distance >= 1000) {
                label = (distance / 1000).toString() + ' km';
            } else {
                label = distance.toString() + ' m';
            }

            viewModel.barWidth = (distance / pixelDistance) | 0;
            viewModel.distanceLabel = label;
        } else {
            viewModel.barWidth = undefined;
            viewModel.distanceLabel = undefined;
        }
    }

    /**
     * The view-model for a control in the user interface
     *
     * @alias UserInterfaceControl
     * @constructor
     * @abstract
     *
     * @param {Terria} terria The Terria instance.
     */
    var UserInterfaceControl = function (terria) {

        if (!Cesium.defined(terria)) {
            throw new Cesium.DeveloperError('terria is required');
        }

        this._terria = terria;

        /**
         * Gets or sets the name of the control which is set as the controls title.
         * This property is observable.
         * @type {String}
         */
        this.name = 'Unnamed Control';

        /**
         * Gets or sets the text to be displayed in the UI control.
         * This property is observable.
         * @type {String}
         */
        this.text = undefined;

        /**
         * Gets or sets the svg icon of the control.  This property is observable.
         * @type {Object}
         */
        this.svgIcon = undefined;

        /**
         * Gets or sets the height of the svg icon.  This property is observable.
         * @type {Integer}
         */
        this.svgHeight = undefined;

        /**
         * Gets or sets the width of the svg icon.  This property is observable.
         * @type {Integer}
         */
        this.svgWidth = undefined;

        /**
         * Gets or sets the CSS class of the control. This property is observable.
         * @type {String}
         */
        this.cssClass = undefined;

        /**
         * Gets or sets the property describing whether or not the control is in the active state.
         * This property is observable.
         * @type {Boolean}
         */
        this.isActive = false;

        Cesium.knockout.track(this, ['name', 'svgIcon', 'svgHeight', 'svgWidth', 'cssClass', 'isActive']);
    };

    Object.defineProperties(UserInterfaceControl.prototype, {
        /**
         * Gets the Terria instance.
         * @memberOf UserInterfaceControl.prototype
         * @type {Terria}
         */
        terria: {
            get: function () {
                return this._terria;
            }
        },
        /**
         * Gets a value indicating whether this button has text associated with it.
         * @type {Object}
         */
        hasText: {
            get: function () {
                return Cesium.defined(this.text) && typeof this.text === 'string';
            }
        }

    });

    /**
     * When implemented in a derived class, performs an action when the user clicks
     * on this control.
     * @abstract
     * @protected
     */
    UserInterfaceControl.prototype.activate = function () {
        throw new Cesium.DeveloperError('activate must be implemented in the derived class.');
    };

    /**
     * The view-model for a control in the navigation control tool bar
     *
     * @alias NavigationControl
     * @constructor
     * @abstract
     *
     * @param {Terria} terria The Terria instance.
     */
    var NavigationControl = function (terria) {
        UserInterfaceControl.apply(this, arguments);
    };

    NavigationControl.prototype = Object.create(UserInterfaceControl.prototype);

    var Utils = {};

    var unprojectedScratch;
    var rayScratch;

    /**
     * gets the focus point of the camera
     * @param {Viewer|Widget} terria The terria
     * @param {boolean} inWorldCoordinates true to get the focus in world coordinates, otherwise get it in projection-specific map coordinates, in meters.
     * @param {Cesium.Cartesian3} [result] The object in which the result will be stored.
     * @return {Cesium.Cartesian3} The modified result parameter, a new instance if none was provided or undefined if there is no focus point.
     */
    Utils.getCameraFocus = function (terria, inWorldCoordinates, result) {
        var scene = terria.scene;
        var camera = scene.camera;
        unprojectedScratch = new Cesium.Cartographic();
        rayScratch = new Cesium.Ray();
        
        if(scene.mode == Cesium.SceneMode.MORPHING) {
            return undefined;
        }

        if(!Cesium.defined(result)) {
            result = new Cesium.Cartesian3();
        }

        // TODO bug when tracking: if entity moves the current position should be used and not only the one when starting orbiting/rotating
        // TODO bug when tracking: reset should reset to default view of tracked entity

        if(Cesium.defined(terria.trackedEntity)) {
            result = terria.trackedEntity.position.getValue(terria.clock.currentTime, result);
        } else {
            rayScratch.origin = camera.positionWC;
            rayScratch.direction = camera.directionWC;
            result = scene.globe.pick(rayScratch, scene, result);
        }

        if (!Cesium.defined(result)) {
            return undefined;
        }

        if(scene.mode == Cesium.SceneMode.SCENE2D || scene.mode == Cesium.SceneMode.COLUMBUS_VIEW) {
            result = camera.worldToCameraCoordinatesPoint(result, result);

            if(inWorldCoordinates) {
                result = scene.globe.ellipsoid.cartographicToCartesian(scene.mapProjection.unproject(result, unprojectedScratch), result);
            }
        } else {
            if(!inWorldCoordinates) {
                result = camera.worldToCameraCoordinatesPoint(result, result);
            }
        }

        return result;
    };

    /**
     * The model for a zoom in control in the navigation control tool bar
     *
     * @alias ZoomOutNavigationControl
     * @constructor
     * @abstract
     *
     * @param {Terria} terria The Terria instance.
     * @param {boolean} zoomIn is used for zooming in (true) or out (false)
     */
    var ZoomNavigationControl = function (terria, zoomIn) {
        NavigationControl.apply(this, arguments);

        /**
         * Gets or sets the name of the control which is set as the control's title.
         * This property is observable.
         * @type {String}
         */
        this.name = '';
        //this.name = 'Zoom ' + (zoomIn ? 'In' : 'Out');

        /**
         * Gets or sets the text to be displayed in the nav control. Controls that
         * have text do not display the svgIcon.
         * This property is observable.
         * @type {String}
         */
        this.text = zoomIn ? '+' : '-';

        /**
         * Gets or sets the CSS class of the control. This property is observable.
         * @type {String}
         */
        this.cssClass = 'navigation-control-icon-zoom-' + (zoomIn ? 'in' : 'out');

        this.relativeAmount = 2;

        if (zoomIn) {
            // this ensures that zooming in is the inverse of zooming out and vice versa
            // e.g. the camera position remains when zooming in and out
            this.relativeAmount = 1 / this.relativeAmount;
        }
    };

    ZoomNavigationControl.prototype.relativeAmount = 1;

    ZoomNavigationControl.prototype = Object.create(NavigationControl.prototype);

    /**
     * When implemented in a derived class, performs an action when the user clicks
     * on this control
     * @abstract
     * @protected
     */
    ZoomNavigationControl.prototype.activate = function () {
        this.zoom(this.relativeAmount);
    };


    ZoomNavigationControl.prototype.zoom = function (relativeAmount) {
        // this.terria.analytics.logEvent('navigation', 'click', 'zoomIn');

        this.isActive = true;

        if (Cesium.defined(this.terria)) {
            var scene = this.terria.scene;

            var sscc = scene.screenSpaceCameraController;
            // do not zoom if it is disabled
            if (!sscc.enableInputs || !sscc.enableZoom) {
                return;
            }
            // TODO
    //            if(scene.mode == Cesium.SceneMode.COLUMBUS_VIEW && !sscc.enableTranslate) {
    //                return;
    //            }

            var camera = scene.camera;
            var orientation;

            switch (scene.mode) {
                case Cesium.SceneMode.MORPHING:
                    break;
                case Cesium.SceneMode.SCENE2D:
                    camera.zoomIn(camera.positionCartographic.height * (1 - this.relativeAmount));
                    break;
                default:
                    var focus;

                    if(Cesium.defined(this.terria.trackedEntity)) {
                        focus = new Cesium.Cartesian3();
                    } else {
                        focus = Utils.getCameraFocus(this.terria, false);
                    }

                    if (!Cesium.defined(focus)) {
                        // Camera direction is not pointing at the globe, so use the ellipsoid horizon point as
                        // the focal point.
                        var ray = new Cesium.Ray(camera.worldToCameraCoordinatesPoint(scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic)), camera.directionWC);
                        focus = Cesium.IntersectionTests.grazingAltitudeLocation(ray, scene.globe.ellipsoid);

                        orientation = {
                            heading: camera.heading,
                            pitch: camera.pitch,
                            roll: camera.roll
                        };
                    } else {
                        orientation = {
                            direction: camera.direction,
                            up: camera.up
                        };
                    }
                    
                    if(!Cesium.defined(focus)){
                        return;
                    }
                    var cartesian3Scratch = new Cesium.Cartesian3();
                    var direction = Cesium.Cartesian3.subtract(camera.position, focus, cartesian3Scratch);
                    var movementVector = Cesium.Cartesian3.multiplyByScalar(direction, relativeAmount, direction);
                    var endPosition = Cesium.Cartesian3.add(focus, movementVector, focus);

                    if (Cesium.defined(this.terria.trackedEntity) || scene.mode == Cesium.SceneMode.COLUMBUS_VIEW) {
                        // sometimes flyTo does not work (jumps to wrong position) so just set the position without any animation
                        // do not use flyTo when tracking an entity because during animatiuon the position of the entity may change
                        camera.position = endPosition;
                    } else {
                        camera.flyTo({
                            destination: endPosition,
                            orientation: orientation,
                            duration: 0.5,
                            convert: false
                        });
                    }
            }
        }

        // this.terria.notifyRepaintRequired();
        this.isActive = false;
    };

    var svgReset = 'M 7.5,0 C 3.375,0 0,3.375 0,7.5 0,11.625 3.375,15 7.5,15 c 3.46875,0 6.375,-2.4375 7.21875,-5.625 l -1.96875,0 C 12,11.53125 9.9375,13.125 7.5,13.125 4.40625,13.125 1.875,10.59375 1.875,7.5 1.875,4.40625 4.40625,1.875 7.5,1.875 c 1.59375,0 2.90625,0.65625 3.9375,1.6875 l -3,3 6.5625,0 L 15,0 12.75,2.25 C 11.4375,0.84375 9.5625,0 7.5,0 z';

    /**
     * The model for a zoom in control in the navigation control tool bar
     *
     * @alias ResetViewNavigationControl
     * @constructor
     * @abstract
     *
     * @param {Terria} terria The Terria instance.
     */
    var ResetViewNavigationControl = function (terria)
    {
        NavigationControl.apply(this, arguments);

        /**
         * Gets or sets the name of the control which is set as the control's title.
         * This property is observable.
         * @type {String}
         */
        this.name = '';
        //this.name = 'Reset View';
        this.navigationLocked = false;

        /**
         * Gets or sets the svg icon of the control.  This property is observable.
         * @type {Object}
         */
        this.svgIcon = svgReset;

        /**
         * Gets or sets the height of the svg icon.  This property is observable.
         * @type {Integer}
         */
        this.svgHeight = 15;

        /**
         * Gets or sets the width of the svg icon.  This property is observable.
         * @type {Integer}
         */
        this.svgWidth = 15;

        /**
         * Gets or sets the CSS class of the control. This property is observable.
         * @type {String}
         */
        this.cssClass = "navigation-control-icon-reset";

    };

    ResetViewNavigationControl.prototype = Object.create(NavigationControl.prototype);

        ResetViewNavigationControl.prototype.setNavigationLocked = function (locked)
    {
        this.navigationLocked = locked;
    };

    ResetViewNavigationControl.prototype.resetView = function ()
    {
        //this.terria.analytics.logEvent('navigation', 'click', 'reset');
        if (this.navigationLocked)
        {
            return;
        }
        var scene = this.terria.scene;

        var sscc = scene.screenSpaceCameraController;
        if (!sscc.enableInputs)
        {
            return;
        }

        this.isActive = true;

        var camera = scene.camera;

        if (Cesium.defined(this.terria.trackedEntity))
        {
            // when tracking do not reset to default view but to default view of tracked entity
            var trackedEntity = this.terria.trackedEntity;
            this.terria.trackedEntity = undefined;
            this.terria.trackedEntity = trackedEntity;
        }
        else
        {
            // reset to a default position or view Cesium.defined in the options
            if (this.terria.options.defaultResetView)
            {
                if (this.terria.options.defaultResetView && this.terria.options.defaultResetView instanceof Cesium.Cartographic)
                {
                    camera.flyTo({
                        destination: scene.globe.ellipsoid.cartographicToCartesian(this.terria.options.defaultResetView)
                    });
                }
                else if (this.terria.options.defaultResetView && this.terria.options.defaultResetView instanceof Cesium.Rectangle)
                {
                    try
                    {
                        Cesium.Rectangle.validate(this.terria.options.defaultResetView);
                        camera.flyTo({
                            destination: this.terria.options.defaultResetView
                        });
                    }
                    catch (e)
                    {
                        console.log("Cesium-navigation/ResetViewNavigationControl:   options.defaultResetView Cesium rectangle is  invalid!");
                    }
                }
            }
            else if (typeof camera.flyHome === "function")
            {
                camera.flyHome(1);
            }
            else
            {
                camera.flyTo({'destination': Cesium.Camera.DEFAULT_VIEW_RECTANGLE, 'duration': 1});
            }
        }
        this.isActive = false;
    };

    /**
     * When implemented in a derived class, performs an action when the user clicks
     * on this control
     * @abstract
     * @protected
     */
    ResetViewNavigationControl.prototype.activate = function ()
    {
        this.resetView();
    };

    var svgCompassOuterRing = 'm 66.5625,0 0,15.15625 3.71875,0 0,-10.40625 5.5,10.40625 4.375,0 0,-15.15625 -3.71875,0 0,10.40625 L 70.9375,0 66.5625,0 z M 72.5,20.21875 c -28.867432,0 -52.28125,23.407738 -52.28125,52.28125 0,28.87351 23.413818,52.3125 52.28125,52.3125 28.86743,0 52.28125,-23.43899 52.28125,-52.3125 0,-28.873512 -23.41382,-52.28125 -52.28125,-52.28125 z m 0,1.75 c 13.842515,0 26.368948,5.558092 35.5,14.5625 l -11.03125,11 0.625,0.625 11.03125,-11 c 8.9199,9.108762 14.4375,21.579143 14.4375,35.34375 0,13.764606 -5.5176,26.22729 -14.4375,35.34375 l -11.03125,-11 -0.625,0.625 11.03125,11 c -9.130866,9.01087 -21.658601,14.59375 -35.5,14.59375 -13.801622,0 -26.321058,-5.53481 -35.4375,-14.5 l 11.125,-11.09375 c 6.277989,6.12179 14.857796,9.90625 24.3125,9.90625 19.241896,0 34.875,-15.629154 34.875,-34.875 0,-19.245847 -15.633104,-34.84375 -34.875,-34.84375 -9.454704,0 -18.034511,3.760884 -24.3125,9.875 L 37.0625,36.4375 C 46.179178,27.478444 58.696991,21.96875 72.5,21.96875 z m -0.875,0.84375 0,13.9375 1.75,0 0,-13.9375 -1.75,0 z M 36.46875,37.0625 47.5625,48.15625 C 41.429794,54.436565 37.65625,63.027539 37.65625,72.5 c 0,9.472461 3.773544,18.055746 9.90625,24.34375 L 36.46875,107.9375 c -8.96721,-9.1247 -14.5,-21.624886 -14.5,-35.4375 0,-13.812615 5.53279,-26.320526 14.5,-35.4375 z M 72.5,39.40625 c 18.297686,0 33.125,14.791695 33.125,33.09375 0,18.302054 -14.827314,33.125 -33.125,33.125 -18.297687,0 -33.09375,-14.822946 -33.09375,-33.125 0,-18.302056 14.796063,-33.09375 33.09375,-33.09375 z M 22.84375,71.625 l 0,1.75 13.96875,0 0,-1.75 -13.96875,0 z m 85.5625,0 0,1.75 14,0 0,-1.75 -14,0 z M 71.75,108.25 l 0,13.9375 1.71875,0 0,-13.9375 -1.71875,0 z';

    var svgCompassGyro = 'm 72.71875,54.375 c -0.476702,0 -0.908208,0.245402 -1.21875,0.5625 -0.310542,0.317098 -0.551189,0.701933 -0.78125,1.1875 -0.172018,0.363062 -0.319101,0.791709 -0.46875,1.25 -6.91615,1.075544 -12.313231,6.656514 -13,13.625 -0.327516,0.117495 -0.661877,0.244642 -0.9375,0.375 -0.485434,0.22959 -0.901634,0.471239 -1.21875,0.78125 -0.317116,0.310011 -0.5625,0.742111 -0.5625,1.21875 l 0.03125,0 c 0,0.476639 0.245384,0.877489 0.5625,1.1875 0.317116,0.310011 0.702066,0.58291 1.1875,0.8125 0.35554,0.168155 0.771616,0.32165 1.21875,0.46875 1.370803,6.10004 6.420817,10.834127 12.71875,11.8125 0.146999,0.447079 0.30025,0.863113 0.46875,1.21875 0.230061,0.485567 0.470708,0.870402 0.78125,1.1875 0.310542,0.317098 0.742048,0.5625 1.21875,0.5625 0.476702,0 0.876958,-0.245402 1.1875,-0.5625 0.310542,-0.317098 0.582439,-0.701933 0.8125,-1.1875 0.172018,-0.363062 0.319101,-0.791709 0.46875,-1.25 6.249045,-1.017063 11.256351,-5.7184 12.625,-11.78125 0.447134,-0.1471 0.86321,-0.300595 1.21875,-0.46875 0.485434,-0.22959 0.901633,-0.502489 1.21875,-0.8125 0.317117,-0.310011 0.5625,-0.710861 0.5625,-1.1875 l -0.03125,0 c 0,-0.476639 -0.245383,-0.908739 -0.5625,-1.21875 C 89.901633,71.846239 89.516684,71.60459 89.03125,71.375 88.755626,71.244642 88.456123,71.117495 88.125,71 87.439949,64.078341 82.072807,58.503735 75.21875,57.375 c -0.15044,-0.461669 -0.326927,-0.884711 -0.5,-1.25 -0.230061,-0.485567 -0.501958,-0.870402 -0.8125,-1.1875 -0.310542,-0.317098 -0.710798,-0.5625 -1.1875,-0.5625 z m -0.0625,1.40625 c 0.03595,-0.01283 0.05968,0 0.0625,0 0.0056,0 0.04321,-0.02233 0.1875,0.125 0.144288,0.147334 0.34336,0.447188 0.53125,0.84375 0.06385,0.134761 0.123901,0.309578 0.1875,0.46875 -0.320353,-0.01957 -0.643524,-0.0625 -0.96875,-0.0625 -0.289073,0 -0.558569,0.04702 -0.84375,0.0625 C 71.8761,57.059578 71.936151,56.884761 72,56.75 c 0.18789,-0.396562 0.355712,-0.696416 0.5,-0.84375 0.07214,-0.07367 0.120304,-0.112167 0.15625,-0.125 z m 0,2.40625 c 0.448007,0 0.906196,0.05436 1.34375,0.09375 0.177011,0.592256 0.347655,1.271044 0.5,2.03125 0.475097,2.370753 0.807525,5.463852 0.9375,8.9375 -0.906869,-0.02852 -1.834463,-0.0625 -2.78125,-0.0625 -0.92298,0 -1.802327,0.03537 -2.6875,0.0625 0.138529,-3.473648 0.493653,-6.566747 0.96875,-8.9375 0.154684,-0.771878 0.320019,-1.463985 0.5,-2.0625 0.405568,-0.03377 0.804291,-0.0625 1.21875,-0.0625 z m -2.71875,0.28125 c -0.129732,0.498888 -0.259782,0.987558 -0.375,1.5625 -0.498513,2.487595 -0.838088,5.693299 -0.96875,9.25 -3.21363,0.15162 -6.119596,0.480068 -8.40625,0.9375 -0.682394,0.136509 -1.275579,0.279657 -1.84375,0.4375 0.799068,-6.135482 5.504716,-11.036454 11.59375,-12.1875 z M 75.5,58.5 c 6.043169,1.18408 10.705093,6.052712 11.5,12.15625 -0.569435,-0.155806 -1.200273,-0.302525 -1.875,-0.4375 -2.262525,-0.452605 -5.108535,-0.783809 -8.28125,-0.9375 -0.130662,-3.556701 -0.470237,-6.762405 -0.96875,-9.25 C 75.761959,59.467174 75.626981,58.990925 75.5,58.5 z m -2.84375,12.09375 c 0.959338,0 1.895843,0.03282 2.8125,0.0625 C 75.48165,71.267751 75.5,71.871028 75.5,72.5 c 0,1.228616 -0.01449,2.438313 -0.0625,3.59375 -0.897358,0.0284 -1.811972,0.0625 -2.75,0.0625 -0.927373,0 -1.831062,-0.03473 -2.71875,-0.0625 -0.05109,-1.155437 -0.0625,-2.365134 -0.0625,-3.59375 0,-0.628972 0.01741,-1.232249 0.03125,-1.84375 0.895269,-0.02827 1.783025,-0.0625 2.71875,-0.0625 z M 68.5625,70.6875 c -0.01243,0.60601 -0.03125,1.189946 -0.03125,1.8125 0,1.22431 0.01541,2.407837 0.0625,3.5625 -3.125243,-0.150329 -5.92077,-0.471558 -8.09375,-0.90625 -0.784983,-0.157031 -1.511491,-0.316471 -2.125,-0.5 -0.107878,-0.704096 -0.1875,-1.422089 -0.1875,-2.15625 0,-0.115714 0.02849,-0.228688 0.03125,-0.34375 0.643106,-0.20284 1.389577,-0.390377 2.25,-0.5625 2.166953,-0.433487 4.97905,-0.75541 8.09375,-0.90625 z m 8.3125,0.03125 c 3.075121,0.15271 5.824455,0.446046 7.96875,0.875 0.857478,0.171534 1.630962,0.360416 2.28125,0.5625 0.0027,0.114659 0,0.228443 0,0.34375 0,0.735827 -0.07914,1.450633 -0.1875,2.15625 -0.598568,0.180148 -1.29077,0.34562 -2.0625,0.5 -2.158064,0.431708 -4.932088,0.754666 -8.03125,0.90625 0.04709,-1.154663 0.0625,-2.33819 0.0625,-3.5625 0,-0.611824 -0.01924,-1.185379 -0.03125,-1.78125 z M 57.15625,72.5625 c 0.0023,0.572772 0.06082,1.131112 0.125,1.6875 -0.125327,-0.05123 -0.266577,-0.10497 -0.375,-0.15625 -0.396499,-0.187528 -0.665288,-0.387337 -0.8125,-0.53125 -0.147212,-0.143913 -0.15625,-0.182756 -0.15625,-0.1875 0,-0.0047 -0.02221,-0.07484 0.125,-0.21875 0.147212,-0.143913 0.447251,-0.312472 0.84375,-0.5 0.07123,-0.03369 0.171867,-0.06006 0.25,-0.09375 z m 31.03125,0 c 0.08201,0.03503 0.175941,0.05872 0.25,0.09375 0.396499,0.187528 0.665288,0.356087 0.8125,0.5 0.14725,0.14391 0.15625,0.21405 0.15625,0.21875 0,0.0047 -0.009,0.04359 -0.15625,0.1875 -0.147212,0.143913 -0.416001,0.343722 -0.8125,0.53125 -0.09755,0.04613 -0.233314,0.07889 -0.34375,0.125 0.06214,-0.546289 0.09144,-1.094215 0.09375,-1.65625 z m -29.5,3.625 c 0.479308,0.123125 0.983064,0.234089 1.53125,0.34375 2.301781,0.460458 5.229421,0.787224 8.46875,0.9375 0.167006,2.84339 0.46081,5.433176 0.875,7.5 0.115218,0.574942 0.245268,1.063612 0.375,1.5625 -5.463677,-1.028179 -9.833074,-5.091831 -11.25,-10.34375 z m 27.96875,0 C 85.247546,81.408945 80.919274,85.442932 75.5,86.5 c 0.126981,-0.490925 0.261959,-0.967174 0.375,-1.53125 0.41419,-2.066824 0.707994,-4.65661 0.875,-7.5 3.204493,-0.15162 6.088346,-0.480068 8.375,-0.9375 0.548186,-0.109661 1.051942,-0.220625 1.53125,-0.34375 z M 70.0625,77.53125 c 0.865391,0.02589 1.723666,0.03125 2.625,0.03125 0.912062,0 1.782843,-0.0048 2.65625,-0.03125 -0.165173,2.736408 -0.453252,5.207651 -0.84375,7.15625 -0.152345,0.760206 -0.322989,1.438994 -0.5,2.03125 -0.437447,0.03919 -0.895856,0.0625 -1.34375,0.0625 -0.414943,0 -0.812719,-0.02881 -1.21875,-0.0625 -0.177011,-0.592256 -0.347655,-1.271044 -0.5,-2.03125 -0.390498,-1.948599 -0.700644,-4.419842 -0.875,-7.15625 z m 1.75,10.28125 c 0.284911,0.01545 0.554954,0.03125 0.84375,0.03125 0.325029,0 0.648588,-0.01171 0.96875,-0.03125 -0.05999,0.148763 -0.127309,0.31046 -0.1875,0.4375 -0.18789,0.396562 -0.386962,0.696416 -0.53125,0.84375 -0.144288,0.147334 -0.181857,0.125 -0.1875,0.125 -0.0056,0 -0.07446,0.02233 -0.21875,-0.125 C 72.355712,88.946416 72.18789,88.646562 72,88.25 71.939809,88.12296 71.872486,87.961263 71.8125,87.8125 z';

    var svgCompassRotationMarker = 'M 72.46875,22.03125 C 59.505873,22.050338 46.521615,27.004287 36.6875,36.875 L 47.84375,47.96875 C 61.521556,34.240041 83.442603,34.227389 97.125,47.90625 l 11.125,-11.125 C 98.401629,26.935424 85.431627,22.012162 72.46875,22.03125 z';

    var vectorScratch;
    var oldTransformScratch;
    var newTransformScratch;
    var centerScratch;

    var NavigationViewModel = function (options)
    {
        vectorScratch = new Cesium.Cartesian2();

        oldTransformScratch = new Cesium.Matrix4();
        newTransformScratch = new Cesium.Matrix4();
        centerScratch = new Cesium.Cartesian3();
        
        this.terria = options.terria;
        this.eventHelper = new Cesium.EventHelper();
        this.enableZoomControls = (Cesium.defined(options.enableZoomControls)) ? options.enableZoomControls : true;
        this.enableCompass = (Cesium.defined(options.enableCompass)) ? options.enableCompass : true;
        this.navigationLocked = false;

        // if (this.showZoomControls)
        //   {
        this.controls = options.controls;
        if (!Cesium.defined(this.controls))
        {
            this.controls = [
                new ZoomNavigationControl(this.terria, true),
                new ResetViewNavigationControl(this.terria),
                new ZoomNavigationControl(this.terria, false)
            ];
        }
        //}

        this.svgCompassOuterRing = svgCompassOuterRing;
        this.svgCompassGyro = svgCompassGyro;
        this.svgCompassRotationMarker = svgCompassRotationMarker;

        this.showCompass = Cesium.defined(this.terria) && this.enableCompass;
        this.heading = this.showCompass ? this.terria.scene.camera.heading : 0.0;

        this.isOrbiting = false;
        this.orbitCursorAngle = 0;
        this.orbitCursorOpacity = 0.0;
        this.orbitLastTimestamp = 0;
        this.orbitFrame = undefined;
        this.orbitIsLook = false;
        this.orbitMouseMoveFunction = undefined;
        this.orbitMouseUpFunction = undefined;

        this.isRotating = false;
        this.rotateInitialCursorAngle = undefined;
        this.rotateFrame = undefined;
        this.rotateIsLook = false;
        this.rotateMouseMoveFunction = undefined;
        this.rotateMouseUpFunction = undefined;

        this._unsubcribeFromPostRender = undefined;

        Cesium.knockout.track(this, ['controls', 'showCompass', 'heading', 'isOrbiting', 'orbitCursorAngle', 'isRotating']);

        var that = this;


        NavigationViewModel.prototype.setNavigationLocked = function (locked)
        {
            this.navigationLocked = locked;
            if (this.controls && this.controls.length > 1)
            {
                this.controls[1].setNavigationLocked(this.navigationLocked);
            }
        };

        function widgetChange()
        {
            if (Cesium.defined(that.terria))
            {
                if (that._unsubcribeFromPostRender)
                {
                    that._unsubcribeFromPostRender();
                    that._unsubcribeFromPostRender = undefined;
                }

                that.showCompass =  that.enableCompass;

                that._unsubcribeFromPostRender = that.terria.scene.postRender.addEventListener(function ()
                {
                    that.heading = that.terria.scene.camera.heading;
                });
            }
            else
            {
                if (that._unsubcribeFromPostRender)
                {
                    that._unsubcribeFromPostRender();
                    that._unsubcribeFromPostRender = undefined;
                }
                that.showCompass = false;
            }
        }

        this.eventHelper.add(this.terria.afterWidgetChanged, widgetChange, this);
        //this.terria.afterWidgetChanged.addEventListener(widgetChange);

        widgetChange();
    };


    NavigationViewModel.prototype.destroy = function ()
    {

        this.eventHelper.removeAll();

        //loadView(require('fs').readFileSync(baseURLEmpCesium + 'js-lib/terrajs/lib/Views/Navigation.html', 'utf8'), container, this);

    };

    NavigationViewModel.prototype.show = function (container)
    {
        var testing;
        if (this.enableZoomControls && this.enableCompass)
        {
            testing = '<div class="compass"  data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }">' +
                    '<div class="compass-outer-ring-background"></div>' +
                    ' <div class="compass-rotation-marker" data-bind="visible: isOrbiting, style: { transform: \'rotate(-\' + orbitCursorAngle + \'rad)\', \'-webkit-transform\': \'rotate(-\' + orbitCursorAngle + \'rad)\', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }"></div>' +
                    ' <div class="compass-outer-ring" title="Click and drag to rotate the camera" data-bind="style: { transform: \'rotate(-\' + heading + \'rad)\', \'-webkit-transform\': \'rotate(-\' + heading + \'rad)\' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }"></div>' +
                    ' <div class="compass-gyro-background"></div>' +
                    ' <div class="compass-gyro" data-bind="cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \'compass-gyro-active\': isOrbiting }"></div>' +
                    '</div>' +
                    '<div class="navigation-controls">' +
                    '<!-- ko foreach: controls -->' +
                    '<div data-bind="click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? \'navigation-control-last\' : \'navigation-control\' ">' +
                    '   <!-- ko if: $data.hasText -->' +
                    '   <div data-bind="text: $data.text, css: $data.isActive ?  \'navigation-control-icon-active \' + $data.cssClass : $data.cssClass"></div>' +
                    '   <!-- /ko -->' +
                    '  <!-- ko ifnot: $data.hasText -->' +
                    '  <div data-bind="cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  \'navigation-control-icon-active \' + $data.cssClass : $data.cssClass"></div>' +
                    '  <!-- /ko -->' +
                    ' </div>' +
                    ' <!-- /ko -->' +
                    '</div>';
        }
        else if (!this.enableZoomControls && this.enableCompass)
        {
            testing = '<div class="compass"  data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }">' +
                    '<div class="compass-outer-ring-background"></div>' +
                    ' <div class="compass-rotation-marker" data-bind="visible: isOrbiting, style: { transform: \'rotate(-\' + orbitCursorAngle + \'rad)\', \'-webkit-transform\': \'rotate(-\' + orbitCursorAngle + \'rad)\', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }"></div>' +
                    ' <div class="compass-outer-ring" title="Click and drag to rotate the camera" data-bind="style: { transform: \'rotate(-\' + heading + \'rad)\', \'-webkit-transform\': \'rotate(-\' + heading + \'rad)\' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }"></div>' +
                    ' <div class="compass-gyro-background"></div>' +
                    ' <div class="compass-gyro" data-bind="cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \'compass-gyro-active\': isOrbiting }"></div>' +
                    '</div>' +
                    '<div class="navigation-controls"  style="display: none;" >' +
                    '<!-- ko foreach: controls -->' +
                    '<div data-bind="click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? \'navigation-control-last\' : \'navigation-control\' ">' +
                    '   <!-- ko if: $data.hasText -->' +
                    '   <div data-bind="text: $data.text, css: $data.isActive ?  \'navigation-control-icon-active \' + $data.cssClass : $data.cssClass"></div>' +
                    '   <!-- /ko -->' +
                    '  <!-- ko ifnot: $data.hasText -->' +
                    '  <div data-bind="cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  \'navigation-control-icon-active \' + $data.cssClass : $data.cssClass"></div>' +
                    '  <!-- /ko -->' +
                    ' </div>' +
                    ' <!-- /ko -->' +
                    '</div>';
        }
        else if (this.enableZoomControls && !this.enableCompass)
        {
            testing = '<div class="compass"  style="display: none;" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }">' +
                    '<div class="compass-outer-ring-background"></div>' +
                    ' <div class="compass-rotation-marker" data-bind="visible: isOrbiting, style: { transform: \'rotate(-\' + orbitCursorAngle + \'rad)\', \'-webkit-transform\': \'rotate(-\' + orbitCursorAngle + \'rad)\', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }"></div>' +
                    ' <div class="compass-outer-ring" title="Click and drag to rotate the camera" data-bind="style: { transform: \'rotate(-\' + heading + \'rad)\', \'-webkit-transform\': \'rotate(-\' + heading + \'rad)\' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }"></div>' +
                    ' <div class="compass-gyro-background"></div>' +
                    ' <div class="compass-gyro" data-bind="cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \'compass-gyro-active\': isOrbiting }"></div>' +
                    '</div>' +
                    '<div class="navigation-controls"    >' +
                    '<!-- ko foreach: controls -->' +
                    '<div data-bind="click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? \'navigation-control-last\' : \'navigation-control\' ">' +
                    '   <!-- ko if: $data.hasText -->' +
                    '   <div data-bind="text: $data.text, css: $data.isActive ?  \'navigation-control-icon-active \' + $data.cssClass : $data.cssClass"></div>' +
                    '   <!-- /ko -->' +
                    '  <!-- ko ifnot: $data.hasText -->' +
                    '  <div data-bind="cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  \'navigation-control-icon-active \' + $data.cssClass : $data.cssClass"></div>' +
                    '  <!-- /ko -->' +
                    ' </div>' +
                    ' <!-- /ko -->' +
                    '</div>';
        }
        else if (!this.enableZoomControls && !this.enableCompass)
        {
            testing = '<div class="compass"  style="display: none;" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }">' +
                    '<div class="compass-outer-ring-background"></div>' +
                    ' <div class="compass-rotation-marker" data-bind="visible: isOrbiting, style: { transform: \'rotate(-\' + orbitCursorAngle + \'rad)\', \'-webkit-transform\': \'rotate(-\' + orbitCursorAngle + \'rad)\', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }"></div>' +
                    ' <div class="compass-outer-ring" title="Click and drag to rotate the camera" data-bind="style: { transform: \'rotate(-\' + heading + \'rad)\', \'-webkit-transform\': \'rotate(-\' + heading + \'rad)\' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }"></div>' +
                    ' <div class="compass-gyro-background"></div>' +
                    ' <div class="compass-gyro" data-bind="cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \'compass-gyro-active\': isOrbiting }"></div>' +
                    '</div>' +
                    '<div class="navigation-controls"   style="display: none;" >' +
                    '<!-- ko foreach: controls -->' +
                    '<div data-bind="click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? \'navigation-control-last\' : \'navigation-control\' ">' +
                    '   <!-- ko if: $data.hasText -->' +
                    '   <div data-bind="text: $data.text, css: $data.isActive ?  \'navigation-control-icon-active \' + $data.cssClass : $data.cssClass"></div>' +
                    '   <!-- /ko -->' +
                    '  <!-- ko ifnot: $data.hasText -->' +
                    '  <div data-bind="cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  \'navigation-control-icon-active \' + $data.cssClass : $data.cssClass"></div>' +
                    '  <!-- /ko -->' +
                    ' </div>' +
                    ' <!-- /ko -->' +
                    '</div>';
        }
        loadView(testing, container, this);
        // loadView(navigatorTemplate, container, this);
        //loadView(require('fs').readFileSync(baseURLEmpCesium + 'js-lib/terrajs/lib/Views/Navigation.html', 'utf8'), container, this);

    };

    /**
     * Adds a control to this toolbar.
     * @param {NavControl} control The control to add.
     */
    NavigationViewModel.prototype.add = function (control)
    {
        this.controls.push(control);
    };

    /**
     * Removes a control from this toolbar.
     * @param {NavControl} control The control to remove.
     */
    NavigationViewModel.prototype.remove = function (control)
    {
        this.controls.remove(control);
    };

    /**
     * Checks if the control given is the last control in the control array.
     * @param {NavControl} control The control to remove.
     */
    NavigationViewModel.prototype.isLastControl = function (control)
    {
        return (control === this.controls[this.controls.length - 1]);
    };

    NavigationViewModel.prototype.handleMouseDown = function (viewModel, e)
    {
        var scene = this.terria.scene;
        if (scene.mode === Cesium.SceneMode.MORPHING)
        {
            return true;
        }
        if (viewModel.navigationLocked)
        {
            return true;
        }

        var compassElement = e.currentTarget;
        var compassRectangle = e.currentTarget.getBoundingClientRect();
        var maxDistance = compassRectangle.width / 2.0;
        var center = new Cesium.Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
        var clickLocation = new Cesium.Cartesian2(e.clientX - compassRectangle.left, e.clientY - compassRectangle.top);
        var vector = Cesium.Cartesian2.subtract(clickLocation, center, vectorScratch);
        var distanceFromCenter = Cesium.Cartesian2.magnitude(vector);

        var distanceFraction = distanceFromCenter / maxDistance;

        var nominalTotalRadius = 145;
        var norminalGyroRadius = 50;

        if (distanceFraction < norminalGyroRadius / nominalTotalRadius)
        {
            orbit(this, compassElement, vector);
    //            return false;
        }
        else if (distanceFraction < 1.0)
        {
            rotate(this, compassElement, vector);
    //            return false;
        }
        else
        {
            return true;
        }
    };

    NavigationViewModel.prototype.handleDoubleClick = function (viewModel, e)
    {
        var scene = viewModel.terria.scene;
        var camera = scene.camera;

        var sscc = scene.screenSpaceCameraController;

        if (scene.mode == Cesium.SceneMode.MORPHING || !sscc.enableInputs)
        {
            return true;
        }
        if (viewModel.navigationLocked)
        {
            return true;
        }
        if (scene.mode == Cesium.SceneMode.COLUMBUS_VIEW && !sscc.enableTranslate)
        {
            return;
        }
        if (scene.mode == Cesium.SceneMode.SCENE3D || scene.mode == Cesium.SceneMode.COLUMBUS_VIEW)
        {
            if (!sscc.enableLook)
            {
                return;
            }

            if (scene.mode == Cesium.SceneMode.SCENE3D)
            {
                if (!sscc.enableRotate)
                {
                    return
                }
            }
        }

        var center = Utils.getCameraFocus(viewModel.terria, true, centerScratch);

        if (!Cesium.defined(center))
        {
            // Globe is barely visible, so reset to home view.

            this.controls[1].resetView();
            return;
        }

        var cameraPosition = scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic, new Cesium.Cartesian3());

        var surfaceNormal = scene.globe.ellipsoid.geodeticSurfaceNormal(center);

        var focusBoundingSphere = new Cesium.BoundingSphere(center, 0);

        camera.flyToBoundingSphere(focusBoundingSphere, {
            offset: new Cesium.HeadingPitchRange(0,
                    // do not use camera.pitch since the pitch at the center/target is required
                    Cesium.Math.PI_OVER_TWO - Cesium.Cartesian3.angleBetween(
                            surfaceNormal,
                            camera.directionWC
                            ),
                    // distanceToBoundingSphere returns wrong values when in 2D or Columbus view so do not use
                    // camera.distanceToBoundingSphere(focusBoundingSphere)
                    // instead calculate distance manually
                    Cesium.Cartesian3.distance(cameraPosition, center)
                    ),
            duration: 1.5
        });
    };

    NavigationViewModel.create = function (options)
    {
        //options.enableZoomControls = this.enableZoomControls;
        //options.enableCompass = this.enableCompass;
        var result = new NavigationViewModel(options);
        result.show(options.container);
        return result;
    };

    function orbit(viewModel, compassElement, cursorVector)
    {
        var scene = viewModel.terria.scene;


        var sscc = scene.screenSpaceCameraController;

        // do not orbit if it is disabled
        if (scene.mode == Cesium.SceneMode.MORPHING || !sscc.enableInputs)
        {
            return;
        }
        if (viewModel.navigationLocked)
        {
            return true;
        }

        switch (scene.mode)
        {
            case Cesium.SceneMode.COLUMBUS_VIEW:
                if (sscc.enableLook)
                {
                    break;
                }

                if (!sscc.enableTranslate || !sscc.enableTilt)
                {
                    return;
                }
                break;
            case Cesium.SceneMode.SCENE3D:
                if (sscc.enableLook)
                {
                    break;
                }

                if (!sscc.enableTilt || !sscc.enableRotate)
                {
                    return;
                }
                break;
            case Cesium.SceneMode.SCENE2D:
                if (!sscc.enableTranslate)
                {
                    return;
                }
                break;
        }

        // Remove existing event handlers, if any.
        document.removeEventListener('mousemove', viewModel.orbitMouseMoveFunction, false);
        document.removeEventListener('mouseup', viewModel.orbitMouseUpFunction, false);

        if (Cesium.defined(viewModel.orbitTickFunction))
        {
            viewModel.terria.clock.onTick.removeEventListener(viewModel.orbitTickFunction);
        }

        viewModel.orbitMouseMoveFunction = undefined;
        viewModel.orbitMouseUpFunction = undefined;
        viewModel.orbitTickFunction = undefined;

        viewModel.isOrbiting = true;
        viewModel.orbitLastTimestamp = Cesium.getTimestamp();

        var camera = scene.camera;

        if (Cesium.defined(viewModel.terria.trackedEntity))
        {
            // when tracking an entity simply use that reference frame
            viewModel.orbitFrame = undefined;
            viewModel.orbitIsLook = false;
        }
        else
        {
            var center = Utils.getCameraFocus(viewModel.terria, true, centerScratch);

            if (!Cesium.defined(center))
            {
                viewModel.orbitFrame = Cesium.Transforms.eastNorthUpToFixedFrame(camera.positionWC, scene.globe.ellipsoid, newTransformScratch);
                viewModel.orbitIsLook = true;
            }
            else
            {
                viewModel.orbitFrame = Cesium.Transforms.eastNorthUpToFixedFrame(center, scene.globe.ellipsoid, newTransformScratch);
                viewModel.orbitIsLook = false;
            }
        }

        viewModel.orbitTickFunction = function (e)
        {
            var timestamp = Cesium.getTimestamp();
            var deltaT = timestamp - viewModel.orbitLastTimestamp;
            var rate = (viewModel.orbitCursorOpacity - 0.5) * 2.5 / 1000;
            var distance = deltaT * rate;

            var angle = viewModel.orbitCursorAngle + Cesium.Math.PI_OVER_TWO;
            var x = Math.cos(angle) * distance;
            var y = Math.sin(angle) * distance;

            var oldTransform;

            if (viewModel.navigationLocked)
            {
                return true;
            }

            if (Cesium.defined(viewModel.orbitFrame))
            {
                oldTransform = Cesium.Matrix4.clone(camera.transform, oldTransformScratch);

                camera.lookAtTransform(viewModel.orbitFrame);
            }

            // do not look up/down or rotate in 2D mode
            if (scene.mode == Cesium.SceneMode.SCENE2D)
            {
                camera.move(new Cesium.Cartesian3(x, y, 0), Math.max(scene.canvas.clientWidth, scene.canvas.clientHeight) / 100 * camera.positionCartographic.height * distance);
            }
            else
            {
                if (viewModel.orbitIsLook)
                {
                    camera.look(Cesium.Cartesian3.UNIT_Z, -x);
                    camera.look(camera.right, -y);
                }
                else
                {
                    camera.rotateLeft(x);
                    camera.rotateUp(y);
                }
            }

            if (Cesium.defined(viewModel.orbitFrame))
            {
                camera.lookAtTransform(oldTransform);
            }

            // viewModel.terria.cesium.notifyRepaintRequired();

            viewModel.orbitLastTimestamp = timestamp;
        };

        function updateAngleAndOpacity(vector, compassWidth)
        {
            var angle = Math.atan2(-vector.y, vector.x);
            viewModel.orbitCursorAngle = Cesium.Math.zeroToTwoPi(angle - Cesium.Math.PI_OVER_TWO);

            var distance = Cesium.Cartesian2.magnitude(vector);
            var maxDistance = compassWidth / 2.0;
            var distanceFraction = Math.min(distance / maxDistance, 1.0);
            var easedOpacity = 0.5 * distanceFraction * distanceFraction + 0.5;
            viewModel.orbitCursorOpacity = easedOpacity;

            //viewModel.terria.cesium.notifyRepaintRequired();
        }

        viewModel.orbitMouseMoveFunction = function (e)
        {
            var compassRectangle = compassElement.getBoundingClientRect();
            var center = new Cesium.Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
            var clickLocation = new Cesium.Cartesian2(e.clientX - compassRectangle.left, e.clientY - compassRectangle.top);
            var vector = Cesium.Cartesian2.subtract(clickLocation, center, vectorScratch);
            updateAngleAndOpacity(vector, compassRectangle.width);
        };

        viewModel.orbitMouseUpFunction = function (e)
        {
            // TODO: if mouse didn't move, reset view to looking down, north is up?

            viewModel.isOrbiting = false;
            document.removeEventListener('mousemove', viewModel.orbitMouseMoveFunction, false);
            document.removeEventListener('mouseup', viewModel.orbitMouseUpFunction, false);

            if (Cesium.defined(viewModel.orbitTickFunction))
            {
                viewModel.terria.clock.onTick.removeEventListener(viewModel.orbitTickFunction);
            }

            viewModel.orbitMouseMoveFunction = undefined;
            viewModel.orbitMouseUpFunction = undefined;
            viewModel.orbitTickFunction = undefined;
        };

        document.addEventListener('mousemove', viewModel.orbitMouseMoveFunction, false);
        document.addEventListener('mouseup', viewModel.orbitMouseUpFunction, false);
        viewModel.terria.clock.onTick.addEventListener(viewModel.orbitTickFunction);

        updateAngleAndOpacity(cursorVector, compassElement.getBoundingClientRect().width);
    }

    function rotate(viewModel, compassElement, cursorVector)
    {
        var scene = viewModel.terria.scene;
        var camera = scene.camera;

        var sscc = scene.screenSpaceCameraController;
        // do not rotate in 2D mode or if rotating is disabled
        if (scene.mode == Cesium.SceneMode.MORPHING || scene.mode == Cesium.SceneMode.SCENE2D || !sscc.enableInputs)
        {
            return;
        }
        if (viewModel.navigationLocked)
        {
            return true;
        }

        if (!sscc.enableLook && (scene.mode == Cesium.SceneMode.COLUMBUS_VIEW || (scene.mode == Cesium.SceneMode.SCENE3D && !sscc.enableRotate)))
        {
            return;
        }

        // Remove existing event handlers, if any.
        document.removeEventListener('mousemove', viewModel.rotateMouseMoveFunction, false);
        document.removeEventListener('mouseup', viewModel.rotateMouseUpFunction, false);

        viewModel.rotateMouseMoveFunction = undefined;
        viewModel.rotateMouseUpFunction = undefined;

        viewModel.isRotating = true;
        viewModel.rotateInitialCursorAngle = Math.atan2(-cursorVector.y, cursorVector.x);

        if (Cesium.defined(viewModel.terria.trackedEntity))
        {
            // when tracking an entity simply use that reference frame
            viewModel.rotateFrame = undefined;
            viewModel.rotateIsLook = false;
        }
        else
        {
            var viewCenter = Utils.getCameraFocus(viewModel.terria, true, centerScratch);

            if (!Cesium.defined(viewCenter) || (scene.mode == Cesium.SceneMode.COLUMBUS_VIEW && !sscc.enableLook && !sscc.enableTranslate))
            {
                viewModel.rotateFrame = Cesium.Transforms.eastNorthUpToFixedFrame(camera.positionWC, scene.globe.ellipsoid, newTransformScratch);
                viewModel.rotateIsLook = true;
            }
            else
            {
                viewModel.rotateFrame = Cesium.Transforms.eastNorthUpToFixedFrame(viewCenter, scene.globe.ellipsoid, newTransformScratch);
                viewModel.rotateIsLook = false;
            }
        }

        var oldTransform;
        if (Cesium.defined(viewModel.rotateFrame))
        {
            oldTransform = Cesium.Matrix4.clone(camera.transform, oldTransformScratch);
            camera.lookAtTransform(viewModel.rotateFrame);
        }

        viewModel.rotateInitialCameraAngle = -camera.heading;

        if (Cesium.defined(viewModel.rotateFrame))
        {
            camera.lookAtTransform(oldTransform);
        }

        viewModel.rotateMouseMoveFunction = function (e)
        {
            var compassRectangle = compassElement.getBoundingClientRect();
            var center = new Cesium.Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
            var clickLocation = new Cesium.Cartesian2(e.clientX - compassRectangle.left, e.clientY - compassRectangle.top);
            var vector = Cesium.Cartesian2.subtract(clickLocation, center, vectorScratch);
            var angle = Math.atan2(-vector.y, vector.x);

            var angleDifference = angle - viewModel.rotateInitialCursorAngle;
            var newCameraAngle = Cesium.Math.zeroToTwoPi(viewModel.rotateInitialCameraAngle - angleDifference);

            var camera = viewModel.terria.scene.camera;

            var oldTransform;
            if (Cesium.defined(viewModel.rotateFrame))
            {
                oldTransform = Cesium.Matrix4.clone(camera.transform, oldTransformScratch);
                camera.lookAtTransform(viewModel.rotateFrame);
            }

            var currentCameraAngle = -camera.heading;
            camera.rotateRight(newCameraAngle - currentCameraAngle);

            if (Cesium.defined(viewModel.rotateFrame))
            {
                camera.lookAtTransform(oldTransform);
            }

            // viewModel.terria.cesium.notifyRepaintRequired();
        };

        viewModel.rotateMouseUpFunction = function (e)
        {
            viewModel.isRotating = false;
            document.removeEventListener('mousemove', viewModel.rotateMouseMoveFunction, false);
            document.removeEventListener('mouseup', viewModel.rotateMouseUpFunction, false);

            viewModel.rotateMouseMoveFunction = undefined;
            viewModel.rotateMouseUpFunction = undefined;
        };

        document.addEventListener('mousemove', viewModel.rotateMouseMoveFunction, false);
        document.addEventListener('mouseup', viewModel.rotateMouseUpFunction, false);
    }

    /**
     * @alias CesiumNavigation
     * @constructor
     *
     * @param {Viewer|CesiumWidget} viewerCesiumWidget The Viewer or CesiumWidget instance
     */
    var CesiumNavigation = function (viewerCesiumWidget) {
        initialize.apply(this, arguments);

        this._onDestroyListeners = [];
    };

    CesiumNavigation.prototype.distanceLegendViewModel = undefined;
    CesiumNavigation.prototype.navigationViewModel = undefined;
    CesiumNavigation.prototype.navigationDiv = undefined;
    CesiumNavigation.prototype.distanceLegendDiv = undefined;
    CesiumNavigation.prototype.terria = undefined;
    CesiumNavigation.prototype.container = undefined;
    CesiumNavigation.prototype._onDestroyListeners = undefined;
    CesiumNavigation.prototype._navigationLocked = false;

        CesiumNavigation.prototype.setNavigationLocked = function ( locked)
    {
        this._navigationLocked = locked;
        this.navigationViewModel.setNavigationLocked( this._navigationLocked );
        
    };

        CesiumNavigation.prototype.getNavigationLocked = function ()
    {
        return this._navigationLocked  ;
    };

    CesiumNavigation.prototype.destroy = function ()
    {
        if (Cesium.defined(this.navigationViewModel))
        {
            this.navigationViewModel.destroy();
        }
        if (Cesium.defined(this.distanceLegendViewModel))
        {
            this.distanceLegendViewModel.destroy();
        }

        if (Cesium.defined(this.navigationDiv))
        {
            this.navigationDiv.parentNode.removeChild(this.navigationDiv);
        }
        delete this.navigationDiv;

        if (Cesium.defined(this.distanceLegendDiv))
        {
            this.distanceLegendDiv.parentNode.removeChild(this.distanceLegendDiv);
        }
        delete this.distanceLegendDiv;

        if (Cesium.defined(this.container))
        {
            this.container.parentNode.removeChild(this.container);
        }
        delete this.container;

        for (var i = 0; i < this._onDestroyListeners.length; i++)
        {
            this._onDestroyListeners[i]();
        }
    };

    CesiumNavigation.prototype.addOnDestroyListener = function (callback)
    {
        if (typeof callback === "function")
        {
            this._onDestroyListeners.push(callback);
        }
    };

    /**
     * @param {Viewer|CesiumWidget} viewerCesiumWidget The Viewer or CesiumWidget instance
     * @param options
     */
    function initialize(viewerCesiumWidget, options) {
        if (!Cesium.defined(viewerCesiumWidget)) {
            throw new DeveloperError('CesiumWidget or Viewer is required.');
        }

    //        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        var cesiumWidget = Cesium.defined(viewerCesiumWidget.cesiumWidget) ? viewerCesiumWidget.cesiumWidget : viewerCesiumWidget;

        var container = document.createElement('div');
        container.className = 'cesium-widget-cesiumNavigationContainer';
        cesiumWidget.container.appendChild(container);

        this.terria = viewerCesiumWidget;
        this.terria.options = (Cesium.defined(options))?options :{};
        this.terria.afterWidgetChanged = new Cesium.Event();
        this.terria.beforeWidgetChanged = new Cesium.Event();
        this.container = container;
        
        //this.navigationDiv.setAttribute("id", "navigationDiv");
        
            
            // Register custom Knockout.js bindings.  If you're not using the TerriaJS user interface, you can remove this.
        registerKnockoutBindings();

        if (!Cesium.defined(this.terria.options.enableDistanceLegend) || this.terria.options.enableDistanceLegend)
        {
            this.distanceLegendDiv = document.createElement('div');
                container.appendChild(this.distanceLegendDiv);
            this.distanceLegendDiv.setAttribute("id", "distanceLegendDiv");
            this.distanceLegendViewModel = DistanceLegendViewModel.create({
                container: this.distanceLegendDiv,
                terria: this.terria,
                mapElement: container,
                enableDistanceLegend: true
            });
            
        }
        

        if ((!Cesium.defined(this.terria.options.enableZoomControls) || this.terria.options.enableZoomControls) && (!Cesium.defined(this.terria.options.enableCompass) || this.terria.options.enableCompass))
        {
            this.navigationDiv = document.createElement('div');
            this.navigationDiv.setAttribute("id", "navigationDiv");
            container.appendChild(this.navigationDiv);
            // Create the navigation controls.
            this.navigationViewModel = NavigationViewModel.create({
                container: this.navigationDiv,
                terria: this.terria,
                enableZoomControls: true,
                enableCompass: true
            });
        }
        else  if ((Cesium.defined(this.terria.options.enableZoomControls) && !this.terria.options.enableZoomControls) && (!Cesium.defined(this.terria.options.enableCompass) || this.terria.options.enableCompass))
        {
            this.navigationDiv = document.createElement('div');
            this.navigationDiv.setAttribute("id", "navigationDiv");
            container.appendChild(this.navigationDiv);
            // Create the navigation controls.
            this.navigationViewModel = NavigationViewModel.create({
                container: this.navigationDiv,
                terria: this.terria,
                enableZoomControls: false,
                enableCompass: true
            });
        }
        else  if ((!Cesium.defined(this.terria.options.enableZoomControls) || this.terria.options.enableZoomControls) && (Cesium.defined(this.terria.options.enableCompass) && !this.terria.options.enableCompass))
        {
            this.navigationDiv = document.createElement('div');
            this.navigationDiv.setAttribute("id", "navigationDiv");
            container.appendChild(this.navigationDiv);
            // Create the navigation controls.
            this.navigationViewModel = NavigationViewModel.create({
                container: this.navigationDiv,
                terria: this.terria,
                enableZoomControls: true,
                enableCompass: false
            });
        }
        else  if ((Cesium.defined(this.terria.options.enableZoomControls) &&  !this.terria.options.enableZoomControls) && (Cesium.defined(this.terria.options.enableCompass) &&  !this.terria.options.enableCompass))
        ;

    }

    var css_248z$1 = "/*html {\r\n    height: 100%;\r\n    -webkit-font-smoothing: antialiased;\r\n}\r\n\r\nbody {\r\n    height: 100%;\r\n    width: 100%;\r\n    margin: 0;\r\n    overflow: hidden;\r\n    padding: 0;\r\n    background: #000;\r\n    font-size: 15px;\r\n    font-family: @default-font;\r\n}*/\r\n.full-window {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  margin: 0;\r\n  overflow: hidden;\r\n  padding: 0;\r\n  -webkit-transition: left 0.25s ease-out;\r\n  -moz-transition: left 0.25s ease-out;\r\n  -ms-transition: left 0.25s ease-out;\r\n  -o-transition: left 0.25s ease-out;\r\n  transition: left 0.25s ease-out;\r\n}\r\n.transparent-to-input {\r\n  pointer-events: none;\r\n}\r\n.opaque-to-input {\r\n  pointer-events: auto;\r\n}\r\n.clickable {\r\n  cursor: pointer;\r\n}\r\n/*a {\r\n    text-decoration: none;\r\n    color: @highlight-color;\r\n}*/\r\na:hover {\r\n  text-decoration: underline;\r\n}\r\n/*\r\n@modal-background-color: @panel-background-color;\r\n@modal-text-color: @panel-emphasized-text-color;\r\n@modal-header-background-color: rgba(0,0,0,0.2);\r\n@modal-header-text-color: @panel-emphasized-text-color;*/\r\n/*.modal-background {\r\n    .opaque-to-input;\r\n    position: fixed;\r\n    left: 0;\r\n    right: 0;\r\n    top: 0;\r\n    bottom: 0;\r\n    background-color: rgba(0,0,0,0.5);\r\n    z-index: 1000;  required for IE9 \r\n}*/\r\n/*\r\n.modal {\r\n    position: absolute;\r\n    margin: auto;\r\n    background-color: @modal-background-color;\r\n    top: 0;\r\n    left: 0;\r\n    bottom: 0;\r\n    right: 0;\r\n    max-height: 100%;\r\n    max-width: 100%;\r\n    font-family: @default-font;\r\n    color: @modal-text-color;\r\n}\r\n\r\n.modal-header {\r\n  background-color: @modal-header-background-color;\r\n  border-bottom: @panel-element-border;\r\n  font-size: 15px;\r\n  line-height: 40px;\r\n  margin: 0;\r\n}\r\n\r\n.modal-header h1 {\r\n  font-size: 15px;\r\n  color: @modal-header-text-color;\r\n  margin-left: 15px;\r\n}*/\r\n/* Commented out due to conflicts with client apps. \r\n.modal-content {\r\n  margin-left: 15px;\r\n  margin-right: 15px;\r\n  margin-bottom: 15px;\r\n  padding-top: 15px;\r\n  overflow: auto;\r\n}*/\r\n/*.modal-close-button {\r\n    position: absolute;\r\n    right: 15px;\r\n    cursor: pointer;\r\n    font-size: 18px;\r\n    color: @modal-header-text-color;\r\n}*/\r\n#ui {\r\n  z-index: 2100;\r\n}\r\n@media print {\r\n  .full-window {\r\n    position: initial;\r\n  }\r\n}\r\n/* input[type=text] {\r\n  height: 38px;\r\n  background-color: #eeeeee;\r\n  color: @input-text-color;\r\n  font-size: 14px;\r\n}\r\n\r\n::-webkit-input-placeholder {\r\n  color: fade(@input-text-color, 75%);\r\n  font-style: italic;\r\n}\r\n\r\n:-moz-placeholder { /* Firefox 18- \r\n  color: fade(@input-text-color, 75%);\r\n  font-style: italic;\r\n}\r\n\r\n::-moz-placeholder {  /* Firefox 19+  \r\n  color: fade(@input-text-color, 75%);\r\n  font-style: italic;\r\n}\r\n\r\n:-ms-input-placeholder {\r\n  color: fade(@input-text-color, 75%);\r\n  font-style: italic;\r\n}\r\n\r\ninput:focus {\r\n    outline-color: #FFFFFF;\r\n}\r\n*/\r\n/*select {\r\n  display: block;\r\n  background-color: @panel-form-input-background-color;\r\n  color: @panel-form-input-text-color;\r\n  height: 40px;\r\n  border: 0;\r\n  margin-top: 10px;\r\n  font-size: 14px;\r\n  padding-left: 5px;\r\n}*/\r\n.markdown img {\r\n  max-width: 100%;\r\n}\r\n.markdown svg {\r\n  max-height: 100%;\r\n}\r\n.markdown input,\r\n.markdown select,\r\n.markdown textarea,\r\n.markdown fieldset {\r\n  font-family: inherit;\r\n  font-size: 1rem;\r\n  box-sizing: border-box;\r\n  margin-top: 0;\r\n  margin-bottom: 0;\r\n}\r\n.markdown label {\r\n  vertical-align: middle;\r\n}\r\n.markdown h1,\r\n.markdown h2,\r\n.markdown h3,\r\n.markdown h4,\r\n.markdown h5,\r\n.markdown h6 {\r\n  font-family: inherit;\r\n  font-weight: bold;\r\n  line-height: 1.25;\r\n  margin-top: 1em;\r\n  margin-bottom: 0.5em;\r\n}\r\n.markdown h1 {\r\n  font-size: 2rem;\r\n}\r\n.markdown h2 {\r\n  font-size: 1.5rem;\r\n}\r\n.markdown h3 {\r\n  font-size: 1.25rem;\r\n}\r\n.markdown h4 {\r\n  font-size: 1rem;\r\n}\r\n.markdown h5 {\r\n  font-size: 0.875rem;\r\n}\r\n.markdown h6 {\r\n  font-size: 0.75rem;\r\n}\r\n.markdown p {\r\n  margin-top: 0;\r\n  margin-bottom: 1rem;\r\n}\r\n.markdown strong {\r\n  font-weight: bold;\r\n}\r\n.markdown em {\r\n  font-style: italic;\r\n}\r\n.markdown small {\r\n  font-size: 80%;\r\n}\r\n.markdown mark {\r\n  color: #000;\r\n  background: #ff0;\r\n}\r\n.markdown u {\r\n  text-decoration: underline;\r\n}\r\n.markdown s {\r\n  text-decoration: line-through;\r\n}\r\n.markdown dl,\r\n.markdown ol,\r\n.markdown ul {\r\n  margin-top: 0;\r\n  margin-bottom: 1rem;\r\n}\r\n.markdown ol {\r\n  list-style: decimal inside;\r\n}\r\n.markdown ul {\r\n  list-style: disc inside;\r\n}\r\n.markdown pre,\r\n.markdown code,\r\n.markdown samp {\r\n  font-family: monospace;\r\n  font-size: inherit;\r\n}\r\n.markdown pre {\r\n  margin-top: 0;\r\n  margin-bottom: 1rem;\r\n  overflow-x: scroll;\r\n}\r\n.markdown a {\r\n  color: #68ADFE;\r\n  text-decoration: none;\r\n}\r\n.markdown a:hover {\r\n  text-decoration: underline;\r\n}\r\n.markdown pre,\r\n.markdown code {\r\n  background-color: transparent;\r\n  border-radius: 3px;\r\n}\r\n.markdown hr {\r\n  border: 0;\r\n  border-bottom-style: solid;\r\n  border-bottom-width: 1px;\r\n  border-bottom-color: rgba(0, 0, 0, 0.125);\r\n}\r\n.markdown .left-align {\r\n  text-align: left;\r\n}\r\n.markdown .center {\r\n  text-align: center;\r\n}\r\n.markdown .right-align {\r\n  text-align: right;\r\n}\r\n.markdown .justify {\r\n  text-align: justify;\r\n}\r\n.markdown .truncate {\r\n  max-width: 100%;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  white-space: nowrap;\r\n}\r\n.markdown ol.upper-roman {\r\n  list-style-type: upper-roman;\r\n}\r\n.markdown ol.lower-alpha {\r\n  list-style-type: lower-alpha;\r\n}\r\n.markdown ul.circle {\r\n  list-style-type: circle;\r\n}\r\n.markdown ul.square {\r\n  list-style-type: square;\r\n}\r\n.markdown .list-reset {\r\n  list-style: none;\r\n  padding-left: 0;\r\n}\r\n.floating {\r\n  pointer-events: auto;\r\n  position: absolute;\r\n  border-radius: 15px;\r\n  background-color: rgba(47, 53, 60, 0.8);\r\n}\r\n.floating-horizontal {\r\n  pointer-events: auto;\r\n  position: absolute;\r\n  border-radius: 15px;\r\n  background-color: rgba(47, 53, 60, 0.8);\r\n  padding-left: 5px;\r\n  padding-right: 5px;\r\n}\r\n.floating-vertical {\r\n  pointer-events: auto;\r\n  position: absolute;\r\n  border-radius: 15px;\r\n  background-color: rgba(47, 53, 60, 0.8);\r\n  padding-top: 5px;\r\n  padding-bottom: 5px;\r\n}\r\n@media print {\r\n  .floating {\r\n    display: none;\r\n  }\r\n}\r\n.distance-legend {\r\n  pointer-events: auto;\r\n  position: absolute;\r\n  border-radius: 15px;\r\n  background-color: rgba(47, 53, 60, 0.8);\r\n  padding-left: 5px;\r\n  padding-right: 5px;\r\n  right: 25px;\r\n  bottom: 30px;\r\n  height: 30px;\r\n  width: 125px;\r\n  border: 1px solid rgba(255, 255, 255, 0.1);\r\n  box-sizing: content-box;\r\n}\r\n.distance-legend-label {\r\n  display: inline-block;\r\n  font-family: 'Roboto', sans-serif;\r\n  font-size: 14px;\r\n  font-weight: lighter;\r\n  line-height: 30px;\r\n  color: #FFFFFF;\r\n  width: 125px;\r\n  text-align: center;\r\n}\r\n.distance-legend-scale-bar {\r\n  border-left: 1px solid #FFFFFF;\r\n  border-right: 1px solid #FFFFFF;\r\n  border-bottom: 1px solid #FFFFFF;\r\n  position: absolute;\r\n  height: 10px;\r\n  top: 15px;\r\n}\r\n@media print {\r\n  .distance-legend {\r\n    display: none;\r\n  }\r\n}\r\n@media screen and (max-width: 700px), screen and (max-height: 420px) {\r\n  .distance-legend {\r\n    display: none;\r\n  }\r\n}\r\n.navigation-controls {\r\n  position: absolute;\r\n  right: 30px;\r\n  top: 210px;\r\n  width: 30px;\r\n  border: 1px solid rgba(255, 255, 255, 0.1);\r\n  font-weight: 300;\r\n  -webkit-touch-callout: none;\r\n  -webkit-user-select: none;\r\n  -khtml-user-select: none;\r\n  -moz-user-select: none;\r\n  -ms-user-select: none;\r\n  user-select: none;\r\n}\r\n.navigation-control {\r\n  cursor: pointer;\r\n  border-bottom: 1px solid #555555;\r\n}\r\n.naviagation-control:active {\r\n  color: #FFF;\r\n}\r\n.navigation-control-last {\r\n  cursor: pointer;\r\n  border-bottom: 1px solid #555555;\r\n  border-bottom: 0;\r\n}\r\n.navigation-control-icon-zoom-in {\r\n  position: relative;\r\n  text-align: center;\r\n  font-size: 20px;\r\n  color: #FFFFFF;\r\n  padding-bottom: 4px;\r\n}\r\n.navigation-control-icon-zoom-out {\r\n  position: relative;\r\n  text-align: center;\r\n  font-size: 20px;\r\n  color: #FFFFFF;\r\n}\r\n.navigation-control-icon-reset {\r\n  position: relative;\r\n  left: 10px;\r\n  width: 10px;\r\n  height: 10px;\r\n  fill: rgba(255, 255, 255, 0.8);\r\n  padding-top: 6px;\r\n  padding-bottom: 6px;\r\n  box-sizing: content-box;\r\n}\r\n.compass {\r\n  pointer-events: auto;\r\n  position: absolute;\r\n  right: 0px;\r\n  top: 100px;\r\n  width: 95px;\r\n  height: 95px;\r\n  overflow: hidden;\r\n}\r\n.compass-outer-ring {\r\n  position: absolute;\r\n  top: 0;\r\n  width: 95px;\r\n  height: 95px;\r\n  fill: rgba(255, 255, 255, 0.5);\r\n}\r\n.compass-outer-ring-background {\r\n  position: absolute;\r\n  top: 14px;\r\n  left: 14px;\r\n  width: 44px;\r\n  height: 44px;\r\n  border-radius: 44px;\r\n  border: 12px solid rgba(47, 53, 60, 0.8);\r\n  box-sizing: content-box;\r\n}\r\n.compass-gyro {\r\n  pointer-events: none;\r\n  position: absolute;\r\n  top: 0;\r\n  width: 95px;\r\n  height: 95px;\r\n  fill: #CCC;\r\n}\r\n.compass-gyro-active {\r\n  fill: #68ADFE;\r\n}\r\n.compass-gyro-background {\r\n  position: absolute;\r\n  top: 30px;\r\n  left: 30px;\r\n  width: 33px;\r\n  height: 33px;\r\n  border-radius: 33px;\r\n  background-color: rgba(47, 53, 60, 0.8);\r\n  border: 1px solid rgba(255, 255, 255, 0.2);\r\n  box-sizing: content-box;\r\n}\r\n.compass-gyro-background:hover + .compass-gyro {\r\n  fill: #68ADFE;\r\n}\r\n.compass-rotation-marker {\r\n  position: absolute;\r\n  top: 0;\r\n  width: 95px;\r\n  height: 95px;\r\n  fill: #68ADFE;\r\n}\r\n@media screen and (max-width: 700px), screen and (max-height: 420px) {\r\n  .navigation-controls {\r\n    display: none;\r\n  }\r\n  .compass {\r\n    display: none;\r\n  }\r\n}\r\n@media print {\r\n  .navigation-controls {\r\n    display: none;\r\n  }\r\n  .compass {\r\n    display: none;\r\n  }\r\n}\r\n";
    styleInject(css_248z$1);

    /**
     * A mixin which adds the Compass/Navigation widget to the Viewer widget.
     * Rather than being called directly, this function is normally passed as
     * a parameter to {@link Viewer#extend}, as shown in the example below.
     * @exports viewerCesiumNavigationMixin
     *
     * @param {Viewer} viewer The viewer instance.
     * @param {{}} options The options.
     *
     * @exception {Cesium.DeveloperError} viewer is required.
     *
     * @demo {@link http://localhost:8080/index.html|run local server with examples}
     *
     * @example
     * var viewer = new Cesium.Viewer('cesiumContainer');
     * viewer.extend(viewerCesiumNavigationMixin);
     */
    function viewerCesiumNavigationMixin(viewer, options) {
        if (!Cesium.defined(viewer)) {
            throw new Cesium.DeveloperError('viewer is required.');
        }

        var cesiumNavigation = init(viewer, options);

        cesiumNavigation.addOnDestroyListener((function (viewer) {
            return function () {
                delete viewer.cesiumNavigation;
            };
        })(viewer));

        Object.defineProperties(viewer, {
            cesiumNavigation: {
                configurable: true,
                get: function () {
                    return viewer.cesiumWidget.cesiumNavigation;
                }
            }
        });
    }

    /**
     *
     * @param {CesiumWidget} cesiumWidget The cesium widget instance.
     * @param {{}} options The options.
     */
    viewerCesiumNavigationMixin.mixinWidget = function (cesiumWidget, options) {
        return init.apply(undefined, arguments);
    };

    /**
     * @param {Viewer|CesiumWidget} viewerCesiumWidget The Viewer or CesiumWidget instance
     * @param {{}} options the options
     */
    var init = function (viewerCesiumWidget, options) {
        var cesiumNavigation = new CesiumNavigation(viewerCesiumWidget, options);

        var cesiumWidget = Cesium.defined(viewerCesiumWidget.cesiumWidget) ? viewerCesiumWidget.cesiumWidget : viewerCesiumWidget;

        Object.defineProperties(cesiumWidget, {
            cesiumNavigation: {
                configurable: true,
                get: function () {
                    return cesiumNavigation;
                }
            }
        });

        cesiumNavigation.addOnDestroyListener((function (cesiumWidget) {
            return function () {
                delete cesiumWidget.cesiumNavigation;
            };
        })(cesiumWidget));

        return cesiumNavigation;
    };

    //import echarts from 'echarts'

    function WeatherLengthWayInEcharts(we,options) {
        this._scene = we.viewer.scene;

        this._left = Cesium.defaultValue(options.left,we.viewer.container.offsetLeft);
        this._bottom = Cesium.defaultValue(options.bottom,20);


        //var dom = Cesium.getElement(options.container);
        var dom = document.createElement('WeatherLengthWayInEcharts');
        we.viewer.container.parentElement.appendChild(dom);

        this._gridWidth = we.viewer.container.offsetWidth;
        this._gridHeight = we.viewer.container.offsetHeight;

        dom.style = 'position: absolute;display: block;width:100%;height:100%;right: 0px;bottom:0px;pointer-events: none;';
        this._echarts = echarts.init(dom);
        this.createOptions();
        var that = this;
        var slightMode = Cesium.defaultValue(options.slightMode,true);
        if(slightMode){
            this.updateEcharts();
        }
        else {
            var left = this._left + 1;
            var bottom = this._bottom;
            we.viewer.container.style.opacity = 0.0;
            this._postUpdateRemoveListener = we.viewer.scene.postRender.addEventListener(
                function (scene, time) {
                    that._option.graphic =
                    [
                      {
                        type: 'image',
                        left: left,
                        bottom: bottom,
                        style: {
                          image: we.viewer.scene.canvas.toDataURL(),
                          width: we.viewer.container.offsetWidth,
                          height: we.viewer.container.offsetHeight
                        }
                      }
                    ];

                    that.updateEcharts();
                }
            );
        }
    }
    WeatherLengthWayInEcharts.prototype.updateOptions = function (volumeSlice) {
        var that = this;
        volumeSlice.onUpdate = function(){
            if(volumeSlice instanceof WeatherLengthWay){
                var height = volumeSlice._volume.offsetZ + volumeSlice._volume.meter.depth;
                var length =  Math.floor(volumeSlice.length * 0.001);
                that._option.xAxis.data = ['0',length + 'km'];
                that._option.yAxis.data = ['0',Math.floor(0.3 * height * 0.001) + 'km',Math.floor(0.7 * height * 0.001) + 'km',Math.floor(height * 0.001) + 'km'];
            }
            else {
                var rectangle = volumeSlice._rectangle;
                var s = Cesium.Math.toDegrees(rectangle.south).toFixed(1);
                var n = Cesium.Math.toDegrees(rectangle.north).toFixed(1);
                var w = Cesium.Math.toDegrees(rectangle.west).toFixed(1);
                var e = Cesium.Math.toDegrees(rectangle.east).toFixed(1);
                that._option.xAxis.data = [w, '经度'+ e];
                that._option.yAxis.data = ['纬度'+ s, n];
            
            }
            that.updateEcharts();
            that._scene.requestRender();
        };
        volumeSlice.onUpdate();
    };

    WeatherLengthWayInEcharts.prototype.createOptions = function () {
        this._option = {
            grid: [
                {left: this._left, width: this._gridWidth,height: this._gridHeight, bottom: this._bottom}
            ],
            xAxis: {
                type: 'category',
                data: ['0','19km'],
                boundaryGap: false,
                axisLine: {
                    lineStyle: {
                        color: '#fff'
                    }
                },
                axisLabel: {
                    textStyle: {
                        color: '#fff'
                    }
                },
            },
            yAxis: {
                left: 0,
                type: 'category',
                data: ['0', '1km', '2km', '3km'],
                boundaryGap: false,
                axisLine: {
                    lineStyle: {
                        color: '#fff'
                    }
                },
                axisLabel: {
                    textStyle: {
                        color: '#fff'
                    }
                },
            }
        };
    };

    WeatherLengthWayInEcharts.prototype.updateEcharts = function () {
        this._echarts.setOption(this._option,true,false);
    };

    Object.defineProperties(WeatherLengthWayInEcharts.prototype, {
        show: {
            get: function () {
                return this._echarts.getDom().style.display === 'block';
            },
            set: function (value) {
                this._echarts.getDom().style.display = value ? 'block' : 'none';
            },
        }
    });

    WeatherLengthWayInEcharts.prototype.isDestroyed = function () {
        return false;
    };

    WeatherLengthWayInEcharts.prototype.destroy = function () {
        if(Cesium.defined()){
            this._postUpdateRemoveListener();
        }
        this._echarts.dispose();
        return Cesium.destroyObject(this);
    };

    WeatherSystem.Level = {
        Slight: 0,
        Normal: 1,
        Heavy: 2,
    };

    function WeatherSystem(we){
        this._we = we;
        this._snow = false;
        this._rain = false;
        this._fog = false;
        this._fogPostProcessStage = undefined;
        this._snowPostProcessStage = undefined;
        this._rainPostProcessStage = undefined;
        this._customPostProcessStage = undefined;
        this._rainAttribute = new Cesium.Matrix4(
            0.8/**/, 0.6/*cx*/, 0.0, 0.0,
            0.8/**/, 0.7/*cy*/, 0.0, 0.0,
            1.0/**/, 0.8/*cz*/, 0.0, 0.0,
            0.5/*mix*/, 0.0, 0.0, 0.0);
        this._snowAttribute = new Cesium.Matrix4(
            1.0/**/, 0.0/*cFactor*/, 0.0, 0.0,
            1.0/**/, 0.0/**/, 0.0, 0.0,
            1.0/**/, 0.0/**/, 0.0, 0.0,
            0.5/*mix*/, 0.0, 0.0, 0.0);

        this._snowLevel = WeatherSystem.Level.Normal;
        this._rainLevel = WeatherSystem.Level.Normal;
    }

    Object.defineProperties(WeatherSystem.prototype, {
        snowLevel: {
            get: function () {
                return this._snowLevel;
            },
            set: function (value) {
                this._snowLevel = value;
                if(this._snowLevel === WeatherSystem.Level.Slight) {
                    this._snowAttribute[3] = 0.2;
                    this._snowAttribute[4] = 0.0;
                }
                else if(this._snowLevel === WeatherSystem.Level.Heavy) {
                    this._snowAttribute[3] = 0.5;
                    this._snowAttribute[4] = 1.0;
                }
                else {
                    this._snowAttribute[3] = 0.5;
                    this._snowAttribute[4] = 0.0;
                }
            }
        },
        rainLevel: {
            get: function () {
                return this._rainLevel;
            },
            set: function (value) {
                this._rainLevel = value;
                if(this._rainLevel === WeatherSystem.Level.Slight) {
                    this._rainAttribute[0] = 0.5;
                    this._rainAttribute[1] = 1.5;
                    this._rainAttribute[3] = 0.2;
                }
                else if(this._rainLevel === WeatherSystem.Level.Heavy) {
                    this._rainAttribute[0] = 2.0;
                    this._rainAttribute[1] = 2.0;
                    this._rainAttribute[3] = 0.5;
                }
                else {
                    this._rainAttribute[0] = 0.8;
                    this._rainAttribute[1] = 0.8;
                    this._rainAttribute[3] = 0.4;
                }
            }
        },
        snow: {
            get: function () {
                return this._snow;
            },
            set: function(value) {
                if(value !== this._snow) {
                    this._snow = value;
                    if(value){
                        if(!Cesium.defined(this._snowPostProcessStage)){
                            this._snowPostProcessStage = this.createSnowPostProcessStage();
                        }
                        this._we.viewer.scene.postProcessStages.add(this._snowPostProcessStage);
                    }
                    else {
                        if(Cesium.defined(this._snowPostProcessStage)){
                            this._we.viewer.scene.postProcessStages.remove(this._snowPostProcessStage);
                            this._snowPostProcessStage = undefined;
                        }
                    }

                }
            }
        },
        rain: {
            get: function () {
                return this._rain;
            },
            set: function(value) {
                if(value !== this._rain) {
                    this._rain = value;
                    if(value){
                        if(!Cesium.defined(this._rainPostProcessStage)){
                            this._rainPostProcessStage = this.createRainPostProcessStage();
                        }
                        this._we.viewer.scene.postProcessStages.add(this._rainPostProcessStage);
                    }
                    else {
                        if(Cesium.defined(this._rainPostProcessStage)){
                            this._we.viewer.scene.postProcessStages.remove(this._rainPostProcessStage);
                            this._rainPostProcessStage = undefined;
                        }
                    }

                }
            }
        },
        fog: {
            get: function () {
                return this._fog;
            },
            set: function(value) {
                if(value !== this._fog) {
                    this._fog = value;
                    if(value){
                        if(!Cesium.defined(this._fogPostProcessStage)){
                            this._fogPostProcessStage = this.createFogPostProcessStage();
                        }
                        this._we.viewer.scene.postProcessStages.add(this._fogPostProcessStage);
                    }
                    else {
                        if(Cesium.defined(this._fogPostProcessStage)){
                            this._we.viewer.scene.postProcessStages.remove(this._fogPostProcessStage);
                            this._fogPostProcessStage = undefined;
                        }
                    }

                }
            }
        },
    });

    WeatherSystem.prototype.snowParticle = function () {
        var scene = this._we.viewer.scene;
        // snow
        var snowParticleSize = 12.0;
        var snowRadius = 100000.0;
        var minimumSnowImageSize = new Cesium.Cartesian2(
            snowParticleSize,
            snowParticleSize
        );
        var maximumSnowImageSize = new Cesium.Cartesian2(
            snowParticleSize * 2.0,
            snowParticleSize * 2.0
        );
        var snowSystem;

        var snowGravityScratch = new Cesium.Cartesian3();
        var snowUpdate = function (particle, dt) {
            snowGravityScratch = Cesium.Cartesian3.normalize(
                particle.position,
                snowGravityScratch
            );
            Cesium.Cartesian3.multiplyByScalar(
                snowGravityScratch,
                Cesium.Math.randomBetween(-30.0, -300.0),
                snowGravityScratch
            );
            particle.velocity = Cesium.Cartesian3.add(
                particle.velocity,
                snowGravityScratch,
                particle.velocity
            );

            var distance = Cesium.Cartesian3.distance(
                scene.camera.position,
                particle.position
            );
            if (distance > snowRadius) {
                particle.endColor.alpha = 0.0;
            } else {
                particle.endColor.alpha =
                snowSystem.endColor.alpha / (distance / snowRadius + 0.1);
            }
        };

            snowSystem = new Cesium.ParticleSystem({
            modelMatrix: new Cesium.Matrix4.fromTranslation(
                scene.camera.position
            ),
            minimumSpeed: -1.0,
            maximumSpeed: 0.0,
            lifetime: 15.0,
            emitter: new Cesium.SphereEmitter(snowRadius),
            startScale: 0.5,
            endScale: 1.0,
            image: Directory.CesiumDir + "Assets/Textures/snowflake_particle.png",
            emissionRate: 700.0,
            startColor: Cesium.Color.WHITE.withAlpha(0.0),
            endColor: Cesium.Color.WHITE.withAlpha(1.0),
            minimumImageSize: minimumSnowImageSize,
            maximumImageSize: maximumSnowImageSize,
            updateCallback: snowUpdate,
        });
        //this._we.viewer.scene.primitives.add(snowSystem);

        //scene.skyAtmosphere.hueShift = -0.8;
        //scene.skyAtmosphere.saturationShift = -0.7;
        //scene.skyAtmosphere.brightnessShift = -0.33;

        //scene.fog.density = 0.001;
        //scene.fog.minimumBrightness = 0.8;

        this._snowSystem = snowSystem;
    };


    WeatherSystem.prototype.createSnowPostProcessStage = function () {
        var fragmentShaderSource =
        "uniform sampler2D colorTexture;\n\
    uniform mat4 snowAttribute;\n\
    varying vec2 v_textureCoordinates;\n\
    float snow(vec2 uv,float scale)\n\
    {\n\
        float timeFactor = snowAttribute[0][0];\n\
        float time = czm_frameNumber / 60.0 * timeFactor;\n\
        float w=smoothstep(1.,0.,-uv.y*(scale/10.0));if(w<.1)return 0.;\n\
        uv+=time/scale;uv.y+=time*2./scale;uv.x+=sin(uv.y+time*.5)/scale;\n\
        uv*=scale;vec2 s=floor(uv),f=fract(uv),p;float k=3.0,d;\n\
        p=0.5+0.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p);k=min(d,k);\n\
        k=smoothstep(0.0,k,sin(f.x+f.y)*0.01);\n\
        return k*w;\n\
    }\n\
    void main(){\n\
        float cFactor = snowAttribute[1][0];\n\
        float mFactor = snowAttribute[0][3];\n\
        vec2 resolution = czm_viewport.zw;\n\
        vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n\
        vec3 finalColor=vec3(0);\n\
        float c=smoothstep(1.,0.3,clamp(uv.y*.3+.8,0.,.75));\n\
        c *= cFactor;\n\
        c+=snow(uv,30.0)*cFactor;\n\
        c+=snow(uv,20.0)*cFactor;\n\
        c+=snow(uv,15.0)*cFactor;\n\
        c+=snow(uv,10.0);\n\
        c+=snow(uv,8.0);\n\
        c+=snow(uv,6.0);\n\
        c+=snow(uv,5.0);\n\
        finalColor=(vec3(c));\n\
        gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(finalColor,1), mFactor);\n\
    }";

        var postStage = new Cesium.PostProcessStage({
            fragmentShader: fragmentShaderSource,
            uniforms: {
                snowAttribute: this._snowAttribute
            }
        });

        return postStage;
    };

    WeatherSystem.prototype.createRainPostProcessStage = function () {
        var fragmentShaderSource =
            "uniform sampler2D colorTexture;\n\
        uniform mat4 rainAttribute;\n\
        varying vec2 v_textureCoordinates;\n\
        float hash(float x){\n\
            return fract(sin(x*133.3)*13.13);\n\
        }\n\
        void main(void){\n\
            float timeFactor = rainAttribute[0][0];\n\
            float xFactor = rainAttribute[0][1];\n\
            float yFactor = rainAttribute[0][2];\n\
            float mFactor = rainAttribute[0][3];\n\
            float cx = rainAttribute[1][0];\n\
            float cy = rainAttribute[1][1];\n\
            float cz = rainAttribute[1][2];\n\
            float time = czm_frameNumber / 60.0 * timeFactor;\n\
            vec2 resolution = czm_viewport.zw;\n\
            vec2 uv= (gl_FragCoord.xy*2.0 - resolution.xy)/min(resolution.x,resolution.y);\n\
            vec3 c = vec3(cx,cy,cz);\n\
            float a = -0.4;\n\
            float si = sin(a),co=cos(a);\n\
            uv*= mat2(co,-si,si,co);\n\
            uv*= length(uv + vec2(0.0,4.9)) * 0.3 + 1.0;\n\
            float v = 1.0 - sin(hash(floor(uv.x*100.))*2.0);\n\
            float b = clamp(abs(sin(20.0*time*v + uv.y*(5.0/(2.0+v))))-.95,0.,1.)*20.;\n\
            v*=xFactor;\n\
            b*=yFactor;\n\
            c*=v*b;\n\
            gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(c,1), mFactor);\n\
        }";

        var postStage = new Cesium.PostProcessStage({
            fragmentShader: fragmentShaderSource,
            uniforms: {
                rainAttribute: this._rainAttribute
            }
        });

        return postStage;
    };

    WeatherSystem.prototype.createFogPostProcessStage = function () {
        var fragmentShaderSource =
        "float getDistance(sampler2D depthTexture, vec2 texCoords) \n" +
        "{ \n" +
        "    float depth = czm_unpackDepth(texture2D(depthTexture, texCoords)); \n" +
        "    if (depth == 0.0) { \n" +
        "        return czm_infinity; \n" +
        "    } \n" +
        "    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, depth); \n" +
        "    return -eyeCoordinate.z / eyeCoordinate.w; \n" +
        "} \n" +
        "float interpolateByDistance(vec4 nearFarScalar, float distance) \n" +
        "{ \n" +
        "    float startDistance = nearFarScalar.x; \n" +
        "    float startValue = nearFarScalar.y; \n" +
        "    float endDistance = nearFarScalar.z; \n" +
        "    float endValue = nearFarScalar.w; \n" +
        "    float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0); \n" +
        "    return mix(startValue, endValue, t); \n" +
        "} \n" +
        "vec4 alphaBlend(vec4 sourceColor, vec4 destinationColor) \n" +
        "{ \n" +
        "    return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a); \n" +
        "} \n" +
        "uniform sampler2D colorTexture; \n" +
        "uniform sampler2D depthTexture; \n" +
        "uniform vec4 fogByDistance; \n" +
        "uniform vec4 fogColor; \n" +
        "varying vec2 v_textureCoordinates; \n" +
        "void main(void) \n" +
        "{ \n" +
        "    float distance = getDistance(depthTexture, v_textureCoordinates); \n" +
        "    vec4 sceneColor = texture2D(colorTexture, v_textureCoordinates); \n" +
        "    float blendAmount = interpolateByDistance(fogByDistance, distance); \n" +
        "    vec4 finalFogColor = vec4(fogColor.rgb, fogColor.a * blendAmount); \n" +
        "    gl_FragColor = alphaBlend(finalFogColor, sceneColor); \n" +
        "} \n";

        var postStage = new Cesium.PostProcessStage({
            fragmentShader: fragmentShaderSource,
            uniforms: {
                fogByDistance: new Cesium.Cartesian4(10000, 0.0, 20000, 1.0),
                fogColor: Cesium.Color.WHITE,
            }
        });

        return postStage;
    };

    WeatherSystem.prototype.removeCustomPostProcessStage = function () {
        if(Cesium.defined(this._customPostProcessStage)){
            this._we.viewer.scene.postProcessStages.remove(this._customPostProcessStage);
            this._customPostProcessStage = undefined;
        }
        if(Cesium.defined(this._videoElement)){
            this._videoElement.remove();
            this._videoElement = undefined;
        }
        
        this._synchronizer = this._synchronizer && this._synchronizer.destroy();
        this._particleTexture = this._particleTexture && this._particleTexture.destroy();
    };

    WeatherSystem.prototype.addCustomPostProcessStage = function (videoUrl) {
        this.removeCustomPostProcessStage();

        var fragmentShaderSource =
        "uniform sampler2D colorTexture; \n" +
        "uniform sampler2D particleTexture; \n" +
        "varying vec2 v_textureCoordinates; \n" +
        "void main(void) \n" +
        "{ \n" +
        "    vec2 resolution = czm_viewport.zw; \n" +
        "    vec2 uv = (gl_FragCoord.xy*2.0-resolution.xy)/min(resolution.x,resolution.y); \n" +
        "    float time = mod(czm_frameNumber,18.0) / 6.0; \n" +
        "    vec4 sceneColor = texture2D(colorTexture, v_textureCoordinates); \n" +
        "    //uv = v_textureCoordinates + vec2(1.0,0.0) * time; \n" +
        "    uv = v_textureCoordinates; \n" +
        "    vec2 uv2 = uv; \n" +
        "    //uv2.x+=floor(time)/3.0; \n" +
        "    vec4 particleColor = texture2D(particleTexture,uv2); \n" +
        "    gl_FragColor = sceneColor; \n" +
        "    //if(particleColor.w > 0.0 && particleColor.r > 0.0 && particleColor.g > 0.0 && particleColor.b > 0.0) \n" +
        "    //if(particleColor.w > 0.0) \n" +
        "       gl_FragColor = mix(sceneColor, particleColor, clamp(particleColor.g+particleColor.r+particleColor.b,0.0,1.0)); \n" +
        "} \n";

        var video = document.createElement("VIDEO");
        video.setAttribute("width", "320");
        video.setAttribute("height", "240");
        video.setAttribute("muted", "");
        video.setAttribute("autoplay", "");
        video.setAttribute("loop", "");
        video.setAttribute("crossorigin", "");
        video.setAttribute("controls", "");
        video.setAttribute("src", videoUrl);
        video.setAttribute("style", "display:none");
        document.body.appendChild(video);
        //this._we.viewer.container.appendChild(video);
        var that = this;
        this._videoElement = video;
       
        //this._videoElement = document.getElementById("trailer2");
        var sampler = new Cesium.Sampler({
            minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
            magnificationFilter: Cesium.TextureMagnificationFilter.LINEAR,
          });

        video.onplay = function(){
            if(!Cesium.defined(that._videoElement) || Cesium.defined(that._particleTexture)){
                return;
            }
            that._particleTexture = new Cesium.Texture({
                context: that._we.viewer.scene.context,
                source: that._videoElement,
                sampler: sampler,
            });
            that._customPostProcessStage = new Cesium.PostProcessStage({
                fragmentShader: fragmentShaderSource,
                uniforms: {
                    particleTexture: that._particleTexture
                }
            });
        
            that._synchronizer = new Cesium.VideoSynchronizer({
                clock: that._we.viewer.clock,
                element: that._videoElement,
              });
            that._we.viewer.scene.postProcessStages.add(that._customPostProcessStage);
        };

    };

    WeatherSystem.prototype.clear = function () {
        this.removeCustomPostProcessStage();
        this.fog = false;
        this.rain = false;
        this.snow = false;
    };

    WeatherSystem.prototype.createRegionWeather = function (options) {
        var fsSnow = "float snow(vec2 uv, float scale) { \n" +
        "    float time = czm_frameNumber / 60.0; \n" +
        "    float w = smoothstep(1., 0., -uv.y * (scale / 10.)); \n" +
        "    if (w < .1) \n" +
        "        return 0.; \n" +
        "    uv += time / scale; \n" +
        "    uv.y += time * 2. / scale; \n" +
        "    uv.x += sin(uv.y + time * .5) / scale; \n" +
        "    uv *= scale; \n" +
        "    vec2 s = floor(uv), f = fract(uv), p; \n" +
        "    float k = 3., d; \n" +
        "    p = .5 + .35 * sin(11. * fract(sin((s + p + scale) * mat2(7, 3, 6, 5)) * 5.)) - f; \n" +
        "    d = length(p); \n" +
        "    k = min(d, k); \n" +
        "    k = smoothstep(0., k, sin(f.x + f.y) * 0.01); \n" +
        "    return k * w; \n" +
        "    }" +
          "czm_material czm_getMaterial(czm_materialInput materialInput) { \n" +
          "    float time = czm_frameNumber / 60.0; \n" +
            "    czm_material material = czm_getDefaultMaterial(materialInput); \n" +
            "    vec2 st = materialInput.st; \n" +
            "    vec4 color = vec4(0.); \n" +
            "    vec2 uv=st; \n" +
            "    vec3 finalColor = vec3(0);\n" +
            "    // float c=smoothstep(1.,0.3,clamp(uv.y*.3+.8,0.,.75));\n" +
            "    float c = 0.0;\n" +
            "    c += snow(uv, 30.) * .0;\n" +
            "    c += snow(uv, 20.) * .0;\n" +
            "    c += snow(uv, 15.) * .0;\n" +
            "    c += snow(uv, 10.);\n" +
            "    c += snow(uv, 8.);\n" +
            "    c += snow(uv, 6.);\n" +
            "    c += snow(uv, 5.);\n" +
            "    finalColor = (vec3(c));\n" +
            "    material.diffuse = finalColor; \n" +
            "    material.alpha = min(finalColor.r,min(finalColor.b,finalColor.g)); \n" +
            "    material.shininess = 1.0; \n" + // Sharpen highlight
            "    return material; \n" +
            "} \n";

        this._regionPrimitive = new Cesium.Primitive(options);
        this._regionPrimitive.appearance.material = new Cesium.Material({
            fabric: {
                source: fsSnow
            },
        });
    };


    WeatherSystem.prototype.createRegionRain = function (options) {
        var fsRain = "float hash(float x){ \n" +
        "return fract(sin(x*133.3)*13.13);\n" +
        "}\n" +
        "czm_material czm_getMaterial(czm_materialInput materialInput) { \n" +
        "    float time = czm_frameNumber / 60.0; \n" +
          "    czm_material material = czm_getDefaultMaterial(materialInput); \n" +
          "    vec2 st = materialInput.st; \n" +
          "    vec4 color = vec4(0.); \n" +
          "    vec2 uv=st; \n" +
          "    uv.x=1.0-uv.x; \n" +
          "    vec3 c=vec3(.6,.7,.8); \n" +
          "    float a=-.4; \n" +
          "    float si=sin(a),co=cos(a); \n" +
          "    uv*=mat2(co,-si,si,co); \n" +
          "    uv*=length(uv+vec2(0,4.9))*.3+1.; \n" +
          "    float v=1.-sin(hash(floor(uv.x*100.))*2.); \n" +
          "    float b=clamp(abs(sin(20.*time*v+uv.y*(5./(2.+v))))-.95,0.,1.)*20.; \n" +
          "    c*=v*b; \n" +
          "    color = vec4(c,1.0); \n" +
          "    material.diffuse = vec3(1.0); \n" +
          "    material.alpha = min(color.r,min(color.b,color.g)); \n" +
          "    material.shininess = 1.0; \n" + // Sharpen highlight
          "    return material; \n" +
          "} \n";

        this._regionRainPrimitive = new Cesium.Primitive(options);
        this._regionRainPrimitive.appearance.material = new Cesium.Material({
            fabric: {
                source: fsRain
            },
        });
    };

    WeatherSystem.prototype.update = function (frameState) {
        if(Cesium.defined(this._snowSystem)){
            this._snowSystem.modelMatrix = new Cesium.Matrix4.fromTranslation(
                this._we.viewer.scene.camera.position
            ),
            this._snowSystem.update(frameState);
        }

        if(Cesium.defined(this._particleTexture) && Cesium.defined(this._videoElement)){
            if (this._videoElement.readyState >= 2) {
                this._particleTexture.copyFrom(this._videoElement);
            }
        }
        
        if(Cesium.defined(this._regionRainPrimitive)){
            this._regionRainPrimitive.update(frameState);
        }
        if(Cesium.defined(this._regionPrimitive)){
            this._regionPrimitive.update(frameState);
        }
    };

    WeatherSystem.prototype.isDestroyed = function () {
        return false;
    };

    WeatherSystem.prototype.destroy = function () {
        this.removeCustomPostProcessStage();
        return Cesium.destroyObject(this);
    };

    function CommonLayers() {
    }
    CommonLayers._Base_World = function () {
        return new Cesium.SingleTileImageryProvider({
            url: Directory.CesiumDir + 'Assets/Textures/world.jpg',
            rectangle: Cesium.Rectangle.fromDegrees(-180,-90,180,90)
        });
    };

    CommonLayers._NaturalEarthII = function () {
        return new Cesium.TileMapServiceImageryProvider({
            url: Directory.CesiumDir + '/Assets/Textures/NaturalEarthII',
            minimumLevel: 2,
            maximumLevel: 2,
        });
    };

    CommonLayers.TDT_Url = 'https://t{s}.tianditu.gov.cn/'; 
    CommonLayers.TDT_Token = '835402675b4eef1d10ff69553d33801f'; 
    CommonLayers.TDT_Subdomains = ['0','1','2','3','4','5','6','7'];

    CommonLayers._TDT_Img = function () {
        return new Cesium.WebMapTileServiceImageryProvider({
            url: CommonLayers.TDT_Url + 'img_w/wmts?service=wmts&request=GetTile&version=1.0.0&LAYER=img&tileMatrixSet=w&TileMatrix={TileMatrix}&TileRow={TileRow}&TileCol={TileCol}&style=default&format=tiles&tk=' + CommonLayers.TDT_Token,
            layer: 'img',
            style: 'default',
            format: 'image/jpeg',
            tileMatrixSetID: 'w',
            subdomains: CommonLayers.TDT_Subdomains,
            show: true,
            minimumLevel: 1,
            maximumLevel: 18
        });
    };

    CommonLayers._TDT_Vec = function () {
        return new Cesium.WebMapTileServiceImageryProvider({
            url: CommonLayers.TDT_Url + 'vec_w/wmts?service=wmts&request=GetTile&version=1.0.0&LAYER=vec&tileMatrixSet=w&TileMatrix={TileMatrix}&TileRow={TileRow}&TileCol={TileCol}&style=default&format=tiles&tk=' + CommonLayers.TDT_Token,
            layer: 'img',
            style: 'default',
            format: 'image/png',
            tileMatrixSetID: 'w',
            subdomains: CommonLayers.TDT_Subdomains,
            show: true,
            minimumLevel: 1,
            maximumLevel: 18
        });
    };

    CommonLayers._TDT_Ter = function () {
        return new Cesium.WebMapTileServiceImageryProvider({
            url: CommonLayers.TDT_Url + 'ter_w/wmts?service=wmts&request=GetTile&version=1.0.0&LAYER=ter&tileMatrixSet=w&TileMatrix={TileMatrix}&TileRow={TileRow}&TileCol={TileCol}&style=default&format=tiles&tk=' + CommonLayers.TDT_Token,
            layer: 'img',
            style: 'default',
            format: 'image/jpeg',
            tileMatrixSetID: 'w',
            subdomains: CommonLayers.TDT_Subdomains,
            show: true,
            minimumLevel: 1,
            maximumLevel: 14
        });
    };

    CommonLayers._TDT_Cia = function () {
        return new Cesium.WebMapTileServiceImageryProvider({
            url: CommonLayers.TDT_Url + 'cia_w/wmts?service=wmts&request=GetTile&version=1.0.0&LAYER=cia&tileMatrixSet=w&TileMatrix={TileMatrix}&TileRow={TileRow}&TileCol={TileCol}&style=default.png&tk=' + CommonLayers.TDT_Token,
            layer: 'img',
            style: 'default',
            format: 'image/png',
            tileMatrixSetID: 'w',
            subdomains: CommonLayers.TDT_Subdomains,
            show: true,
            minimumLevel: 1,
            maximumLevel: 18
        });
    };

    CommonLayers._TDT_Cta = function () {
        return new Cesium.WebMapTileServiceImageryProvider({
            url: CommonLayers.TDT_Url + 'cta_w/wmts?service=wmts&request=GetTile&version=1.0.0&LAYER=cta&tileMatrixSet=w&TileMatrix={TileMatrix}&TileRow={TileRow}&TileCol={TileCol}&style=default.png&tk=' + CommonLayers.TDT_Token,
            layer: 'img',
            style: 'default',
            format: 'image/png',
            tileMatrixSetID: 'w',
            subdomains: CommonLayers.TDT_Subdomains,
            show: true,
            minimumLevel: 1,
            maximumLevel: 14
        });
    };

    CommonLayers._TDT_Cva = function () {
        return new Cesium.WebMapTileServiceImageryProvider({
            url: CommonLayers.TDT_Url + 'cva_w/wmts?service=wmts&request=GetTile&version=1.0.0&LAYER=cva&tileMatrixSet=w&TileMatrix={TileMatrix}&TileRow={TileRow}&TileCol={TileCol}&style=default.png&tk=' + CommonLayers.TDT_Token,
            layer: 'img',
            style: 'default',
            format: 'image/png',
            tileMatrixSetID: 'w',
            subdomains: CommonLayers.TDT_Subdomains,
            show: true,
            minimumLevel: 1,
            maximumLevel: 18
        });
    };

    CommonLayers._TDT_Dem = function () {
        var terrainUrls = new Array();
        for (var i = 0; i < CommonLayers.TDT_Subdomains.length; i++){
            var url = CommonLayers.TDT_Url.replace('{s}', CommonLayers.TDT_Subdomains[i]) + 'DataServer?T=elv_c&tk=' + CommonLayers.TDT_Token;
            terrainUrls.push(url);
        }
        return new GeoTerrainProvider({
            urls: terrainUrls
        });
    };


    CommonLayers.Google_Host = 'http://mt{s}.google.cn/'; 
    CommonLayers.Google_Url = 'vt?lyrs={TileMatrixSet}@167000000&hl=zh-CN&gl=cn&x={TileCol}&y={TileRow}&z={TileMatrix}&s=Galil'; 
    CommonLayers.Google_Subdomains = ['0','1','2','3'];

    CommonLayers._Google_s = function () {
        return new Cesium.WebMapTileServiceImageryProvider({
            url: CommonLayers.Google_Host + CommonLayers.Google_Url,
            layer: 'img',
            style: 'default',
            format: 'image/jpg',
            tileMatrixSetID: 's',
            subdomains: CommonLayers.Google_Subdomains,
            show: true
        });
    };

    CommonLayers._Google_m = function () {
        return new Cesium.WebMapTileServiceImageryProvider({
            url: CommonLayers.Google_Host + CommonLayers.Google_Url,
            layer: 'img',
            style: 'default',
            format: 'image/png',
            tileMatrixSetID: 'm',
            subdomains: CommonLayers.Google_Subdomains,
            show: true
        });
    };

    CommonLayers._Google_h = function () {
        return new Cesium.WebMapTileServiceImageryProvider({
            url: CommonLayers.Google_Host + CommonLayers.Google_Url,
            layer: 'img',
            style: 'default',
            format: 'image/png',
            tileMatrixSetID: 'h',
            subdomains: CommonLayers.Google_Subdomains,
            show: true
        });
    };

    CommonLayers._Google_y = function () {
        return new Cesium.WebMapTileServiceImageryProvider({
            url: CommonLayers.Google_Host + CommonLayers.Google_Url,
            layer: 'img',
            style: 'default',
            format: 'image/png',
            tileMatrixSetID: 'y',
            subdomains: CommonLayers.Google_Subdomains,
            show: true
        });
    };

    CommonLayers._Google_t = function () {
        return new Cesium.WebMapTileServiceImageryProvider({
            url: CommonLayers.Google_Host + CommonLayers.Google_Url,
            layer: 'img',
            style: 'default',
            format: 'image/jpg',
            tileMatrixSetID: 't',
            subdomains: CommonLayers.Google_Subdomains,
            show: true
        });
    };

    CommonLayers._Google_p = function () {
        return new Cesium.WebMapTileServiceImageryProvider({
            url: CommonLayers.Google_Host + CommonLayers.Google_Url,
            layer: 'img',
            style: 'default',
            format: 'image/jpg',
            tileMatrixSetID: 'p',
            subdomains: CommonLayers.Google_Subdomains,
            show: true
        });
    };

    CommonLayers.GaoDe_Url = 'https://wprd0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&style={TileMatrixSet}&x={TileCol}&y={TileRow}&z={TileMatrix}&scl=1'; 
    CommonLayers.GaoDe_Subdomains = ['1','2','3','4'];
    CommonLayers._GaoDe_st = function () {
        return new Cesium.WebMapTileServiceImageryProvider({
            url: CommonLayers.GaoDe_Url,
            layer: 'img',
            style: 'default',
            format: 'image/png',
            tileMatrixSetID: '6',
            subdomains: CommonLayers.GaoDe_Subdomains,
            show: true
        });
    };

    CommonLayers._GaoDe_rd = function () {
        return new Cesium.WebMapTileServiceImageryProvider({
            url: CommonLayers.GaoDe_Url,
            layer: 'img',
            style: 'default',
            format: 'image/png',
            tileMatrixSetID: '7',
            subdomains: CommonLayers.GaoDe_Subdomains,
            show: true
        });
    };

    CommonLayers._GaoDe_an = function () {
        return new Cesium.WebMapTileServiceImageryProvider({
            url: CommonLayers.GaoDe_Url,
            layer: 'img',
            style: 'default',
            format: 'image/png',
            tileMatrixSetID: '8',
            subdomains: CommonLayers.GaoDe_Subdomains,
            show: true
        });
    };

    CommonLayers._ArcgisImg = function () {
        return new Cesium.UrlTemplateImageryProvider({
            url: 'https://server.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
            layer: 'img',
            style: 'default',
            format: 'image/jfif',
            tileMatrixSetID: '8',
            show: true,
            minimumLevel: 1,
            maximumLevel: 18
        });
    };

    CommonLayers._ArcgisImg1 = function () {
        return new Cesium.ArcGisMapServerImageryProvider({
            url: 'http://cache1.arcgisonline.cn/arcgis/rest/services/ChinaOnlineCommunity/MapServer'
        });
    };

    CommonLayers._ArcgisStreetPurplishBlue = function () {
        return new Cesium.ArcGisMapServerImageryProvider({
            url: 'http://cache1.arcgisonline.cn/arcgis/rest/services/ChinaOnlineStreetPurplishBlue/MapServer'
        });
    };


    Object.defineProperties(CommonLayers, {
        Base_World: {
            get: function () {
                return this._Base_World();
            }
        },
        Base_WorldVM: {
            get: function () {
                return new Cesium.ProviderViewModel({
                    name: '默认底图',
                    tooltip: '默认',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/ImageryProviders/mapboxSatellite.png'),
                    creationFunction: this._Base_World
                });
            }
        },
        NaturalEarthII: {
            get: function () {
                return this._NaturalEarthII();
            }
        },
        TDT_Img: {
            get: function () {
                return this._TDT_Img();
            }
        },
        TDT_ImgVM: {
            get: function () {
                return new Cesium.ProviderViewModel({
                    name: '天地图影像',
                    tooltip: '天地图',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/ImageryProviders/blueMarble.png'),
                    creationFunction: this._TDT_Img
                });
            }
        },
        TDT_VecVM: {
            get: function () {
                return new Cesium.ProviderViewModel({
                    name: '天地图矢量',
                    tooltip: '天地图',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/ImageryProviders/mapboxStreets.png'),
                    creationFunction: this._TDT_Vec
                });
            }
        },
        TDT_TerVM: {
            get: function () {
                return new Cesium.ProviderViewModel({
                    name: '天地图地形',
                    tooltip: '天地图',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/ImageryProviders/blueMarble.png'),
                    creationFunction: this._TDT_Ter
                });
            }
        },
        TDT_ImgCiaVM: {
            get: function () {
                var that = this;
                return new Cesium.ProviderViewModel({
                    name: '天地图影像+地名',
                    tooltip: '天地图',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/ImageryProviders/mapboxTerrain.png'),
                    creationFunction: function(){
                        return [that.TDT_Img,that.TDT_Cia]
                    }
                });
            }
        },
        TDT_VecCiaVM: {
            get: function () {
                var that = this;
                return new Cesium.ProviderViewModel({
                    name: '天地图矢量+地名',
                    tooltip: '天地图',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/ImageryProviders/bingAerialLabels.png'),
                    creationFunction: function(){
                        return [that.TDT_Vec,that.TDT_Cva]
                    }
                });
            }
        },
        TDT_TerCtaVM: {
            get: function () {
                var that = this;
                return new Cesium.ProviderViewModel({
                    name: '天地图矢量+地名',
                    tooltip: '天地图',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/ImageryProviders/esriWorldStreetMap.png'),
                    creationFunction: function(){
                        return [that.TDT_Ter,that.TDT_Cta]
                    }
                });
            }
        },
        Arcgis_VM: {
            get: function () {
                var that = this;
                return new Cesium.ProviderViewModel({
                    name: 'Arcgis影像',
                    tooltip: 'Arcgis影像',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/ImageryProviders/bingAerialLabels.png'),
                    creationFunction: function(){
                        return [that.ArcgisImg]
                    }
                });
            }
        },
        ArcgisStreetPurplishBlue_VM: {
            get: function () {
                var that = this;
                return new Cesium.ProviderViewModel({
                    name: 'Arcgis蓝黑色',
                    tooltip: 'Arcgis蓝黑色',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/ImageryProviders/bingAerialLabels.png'),
                    creationFunction: function(){
                        return [that.ArcgisStreetPurplishBlue]
                    }
                });
            }
        },
        Google_VM_S: {
            get: function () {
                var that = this;
                return new Cesium.ProviderViewModel({
                    name: 'Google影像',
                    tooltip: 'Google',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/ImageryProviders/sentinel-2.png'),
                    creationFunction: function(){
                        return [that.Google_s]
                    }
                });
            }
        },
        Google_VM_Y: {
            get: function () {
                var that = this;
                return new Cesium.ProviderViewModel({
                    name: 'Google影像',
                    tooltip: 'Google',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/ImageryProviders/bingAerialLabels.png'),
                    creationFunction: function(){
                        return [that.Google_y]
                    }
                });
            }
        },
        Google_VM_H: {
            get: function () {
                var that = this;
                return new Cesium.ProviderViewModel({
                    name: 'Google标注',
                    tooltip: 'Google',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/ImageryProviders/bingAerialLabels.png'),
                    creationFunction: function(){
                        return [that.Google_h]
                    }
                });
            }
        },
        Google_VM_T: {
            get: function () {
                var that = this;
                return new Cesium.ProviderViewModel({
                    name: 'Google高程',
                    tooltip: 'Google',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/ImageryProviders/bingAerialLabels.png'),
                    creationFunction: function(){
                        return [that.Google_t]
                    }
                });
            }
        },
        Google_VM_M: {
            get: function () {
                var that = this;
                return new Cesium.ProviderViewModel({
                    name: 'Google地图',
                    tooltip: 'Google',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/ImageryProviders/openStreetMap.png'),
                    creationFunction: function(){
                        return [that.Google_m]
                    }
                });
            }
        },
        TDT_Vec: {
            get: function () {
                return this._TDT_Vec();
            }
        },
        TDT_Ter: {
            get: function () {
                return this._TDT_Ter();
            }
        },
        TDT_Cia: {
            get: function () {
                return this._TDT_Cia();
            }
        },
        TDT_CiaVM: {
            get: function () {
                return new Cesium.ProviderViewModel({
                    name: '天地图地名',
                    tooltip: '天地图地名',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/ImageryProviders/bingAerialLabels.png'),
                    creationFunction: this._TDT_Cia
                });
            }
        },
        TDT_Cta: {
            get: function () {
                return this._TDT_Cta();
            }
        },
        TDT_Cva: {
            get: function () {
                return this._TDT_Cva();
            }
        },
        TDT_Dem: {
            get: function () {
                return this._TDT_Dem();
            }
        },
        TDT_DemVM: {
            get: function () {
                return new Cesium.ProviderViewModel({
                    name: '天地图高程',
                    tooltip: '天地图',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/TerrainProviders/CesiumWorldTerrain.png'),
                    creationFunction: this._TDT_Dem
                });
            }
        },
        Empty_DemVM: {
            get: function () {
                return new Cesium.ProviderViewModel({
                    name: '天高程',
                    tooltip: '默认',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/TerrainProviders/Ellipsoid.png'),
                    creationFunction: function () {
                        return new Cesium.EllipsoidTerrainProvider({
                          ellipsoid: Cesium.Ellipsoid.WGS84
                        })
                    }
                });
            }
        },
        Google_m: {/*路线*/
            get: function () {
                return this._Google_m();
            }
        },
        Google_s: {/*卫星*/
            get: function () {
                return this._Google_s();
            }
        },
        Google_y: {/*卫星带标签*/
            get: function () {
                return this._Google_y();
            }
        },
        Google_h: {/*标签*/
            get: function () {
                return this._Google_h();
            }
        },
        Google_t: {/*地形*/
            get: function () {
                return this._Google_t();
            }
        },
        Google_p: {/*地形带标签*/
            get: function () {
                return this._Google_p();
            }
        },
        GaoDe_st: {/*卫星*/
            get: function () {
                return this._GaoDe_st();
            }
        },
        GaoDe_rd: {/*路线*/
            get: function () {
                return this._GaoDe_rd();
            }
        },
        GaoDe_an: {/*标签*/
            get: function () {
                return this._GaoDe_an();
            }
        },
        ArcgisImg: {
            get: function () {
                return this._ArcgisImg();
            }
        },
        ArcgisStreetPurplishBlue: {
            get: function () {
                return this._ArcgisStreetPurplishBlue();
            }
        },
    });

    function DrawLineHandler(options) {
      this._viewer = options.viewer;
      this._material = Cesium.defaultValue(
        options.material,
        new Cesium.PolylineGlowMaterialProperty({
          glowPower: 0.25,
          color: Cesium.Color.fromCssColorString('#00f').withAlpha(0.9)
        }));
      this._handler = undefined;
      this._tooltip = undefined;
      this._pointPositions = [];
      this._linePositions = [];
      this._entities = [];
    }

    DrawLineHandler.prototype.onFinish = function () {
      this._tooltip = this._tooltip && this._tooltip.destroy();
      this._handler = this._handler && this._handler.destroy();
    };

    DrawLineHandler.prototype.startDraw = function (points) {
      var that = this;
      this.onFinish();
      this._tooltip = new Tooltip();
      this._tooltip.createGraph(this._viewer.container);
      if (!Cesium.defined(that._handler)) {
        that._handler = new Cesium.ScreenSpaceEventHandler(that._viewer.scene.canvas);
      }
      that.clearEntities();
      var promise = Cesium.when.defer();
      that._handler.setInputAction(function (movement) {
        var position = that._viewer.camera.pickEllipsoid(movement.position, that._viewer.scene.globe.ellipsoid);
        // 第一个点加两遍
        if (that._linePositions.length === 0) {
          that._linePositions.push(position);
          var dynamicPositions = new Cesium.CallbackProperty(function () {
            return that._linePositions
          }, false);
          var options = {
            polyline: {
              positions: dynamicPositions,
              // clampToGround: true,
              width: 8,
              material: that._material
            }
          };
          that._entities.push(that._viewer.entities.add(options));
        }
        that._linePositions.push(position);
        that._pointPositions.push(position);
        that._entities.push(that.createPoint(position));
        if (Cesium.defined(points) && that._pointPositions.length === points) {
          that.onFinish();
          promise.resolve(that._pointPositions);
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

      that._handler.setInputAction(function (movement) {
        var message = that._pointPositions.length === 0 ? '左键单击取点' : '再次单击完成(或右键取消)';
        that._tooltip.showAt(movement.endPosition, message);
        if (that._pointPositions.length === 0) {
          return
        }
        var position = that._viewer.camera.pickEllipsoid(movement.endPosition, that._viewer.scene.globe.ellipsoid);
        if (Cesium.defined(position)) {
          // 清除上一个点
          that._linePositions.pop();
          that._linePositions.push(position);
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

      that._handler.setInputAction(function () {
        if (Cesium.defined(points) && that._pointPositions.length === points) {
          that.onFinish();
          promise.resolve(that._pointPositions);
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

      that._handler.setInputAction(function () {
        that.destroy();
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

      return promise;
    };

    DrawLineHandler.prototype.createPoint = function (position) {
      return this._viewer.entities.add({
        position: position,
        point: {
          color: Cesium.Color.RED,
          pixelSize: 5
          // heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
        }
      })
    };

    DrawLineHandler.prototype.clearEntities = function () {
      for (var i = 0; i < this._entities.length; i++) {
        this._viewer.entities.remove(this._entities[i]);
      }
      this._entities = [];
      this._pointPositions = [];
      this._linePositions = [];
    };

    DrawLineHandler.prototype.destroy = function () {
      this._handler = this._handler && this._handler.destroy();
      this._tooltip = this._tooltip && this._tooltip.destroy();
      this.clearEntities();
    };

    function DrawRectHandler(scene, options) {
        this._scene = scene;
        this._handler1 = undefined;
        this._handler2 = undefined;
        this._handler3 = undefined;
        this._handler4 = undefined;
        this._gotFirst = false;
        this._finished = false;
        this._stDownCartesian = undefined;
        this._stCartographic = undefined;
        this._edCartographic = undefined;

        var isGroundPrimitive = false;
        var isContinunous = true;
        if (Cesium.defined(options)) {
            isGroundPrimitive = Cesium.defaultValue(options.GroundPrimitive, false);
            isContinunous = Cesium.defaultValue(options.continunous, true);
        }

        this.GroundPrimitive = isGroundPrimitive;
        this.continunous = isContinunous;
        this._rectangle = undefined;
    }
    DrawRectHandler.prototype.destroy = function () {
        this._handler1 = this._handler1 && this._handler1.destroy();
        this._handler2 = this._handler2 && this._handler2.destroy();
        this._handler3 = this._handler3 && this._handler3.destroy();
        this._handler4 = this._handler4 && this._handler4.destroy();
        if (Cesium.defined(this._surface)) { this._surface.destroy(); this._surface = undefined; }
    };

    DrawRectHandler.prototype.updateRect = function () {
        if (Cesium.defined(this._surface)) { this._surface.destroy(); this._surface = undefined; }

        var west = this._stCartographic.longitude < this._edCartographic.longitude ? this._stCartographic.longitude : this._edCartographic.longitude;
        var east = this._stCartographic.longitude > this._edCartographic.longitude ? this._stCartographic.longitude : this._edCartographic.longitude;
        var south = this._stCartographic.latitude < this._edCartographic.latitude ? this._stCartographic.latitude : this._edCartographic.latitude;
        var north = this._stCartographic.latitude > this._edCartographic.latitude ? this._stCartographic.latitude : this._edCartographic.latitude;
        this._rectangle = new Cesium.Rectangle(west, south, east, north);

        var rectangleInstance = new Cesium.GeometryInstance({
            geometry: new Cesium.RectangleGeometry({ rectangle: this._rectangle, })
        });

        if (this.GroundPrimitive)
            this._surface = new Cesium.GroundPrimitive({ geometryInstances: rectangleInstance, asynchronous: false });
        else
            this._surface = new Cesium.Primitive({ geometryInstances: rectangleInstance, asynchronous: false });


        this._surface.appearance = new Cesium.EllipsoidSurfaceAppearance({
            aboveGround: false,
            renderState: {
                depthTest: { enabled: false },
                depthMask: false,
                blending: Cesium.BlendingState.ALPHA_BLEND,
                cull: {
                    enabled: false,
                    face: Cesium.CullFace.FRONT
                }
            },
        });
    };

    DrawRectHandler.prototype.startDraw = function () {
        var scene = this._scene;
        var that = this;
        var promise = Cesium.when.defer();

        if (Cesium.defined(this._handler1)) { this._handler1.destroy(); this._handler1 = undefined; }
        this._handler1 = new Cesium.ScreenSpaceEventHandler(scene.canvas);
        this._handler1.setInputAction(function (movement) {
            if (that._gotFirst) {
                that._gotFirst = false;
                that._finished = true;
                if (!that.continunous)
                    that.destroy();
                else {
                    if (Cesium.defined(that._handler3)) { that._handler3.destroy(); that._handler3 = undefined; }
                }
                promise.resolve(that._rectangle);
            }
            else {
                that._stDownCartesian = movement;
                that._finished = false;
            }
        }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

        this._handler2 = this._handler2 && this._handler2.destroy();
        this._handler2 = new Cesium.ScreenSpaceEventHandler(scene.canvas);
        this._handler2.setInputAction(function (movement) {
            if (that._gotFirst || that._finished) {
                return;
            }

            if (that._stDownCartesian.position.x != movement.position.x
                && that._stDownCartesian.position.y != movement.position.y) {
                return;
            }

            var cartesian = scene.camera.pickEllipsoid(
                movement.position,
                scene.globe.ellipsoid
            );

            if (Cesium.defined(cartesian)) {
                that._stCartographic = Cesium.Cartographic.fromCartesian(cartesian);
                that._gotFirst = true;

                that._handler3 = that._handler3 && that._handler3.destroy();
                that._handler3 = new Cesium.ScreenSpaceEventHandler(scene.canvas);
                that._handler3.setInputAction(function (movement) {
                    var cartesian = scene.camera.pickEllipsoid(
                        movement.endPosition,
                        scene.globe.ellipsoid
                    );
                    if (Cesium.defined(cartesian)) {
                        that._edCartographic = Cesium.Cartographic.fromCartesian(cartesian);
                        that.updateRect();
                    }
                }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
            }
        }, Cesium.ScreenSpaceEventType.LEFT_UP);

        this._handler4 = this._handler4 && this._handler4.destroy();
        this._handler4 = new Cesium.ScreenSpaceEventHandler(scene.canvas);
        this._handler4.setInputAction(function () {
            that.destroy();
        }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

        return promise;
    };

    DrawRectHandler.prototype.update = function (frameState) {
        if(Cesium.defined(this._surface)){
            this._surface.update(frameState);
        }
    };

    function DrawPolygonalLineHandler(options){
        var {scene} = options;
        this.scene = scene;

        this._handler1 = undefined;
        this._handler2 = undefined;
        this._handler3 = undefined;
        this._finished = false;
        this._stDownMovement = undefined;
        this._edCartesian = undefined;
        this._edPoint = undefined;
        this._linePositions = [];
        this._pointCollection = new Cesium.PointPrimitiveCollection();
    }

    DrawPolygonalLineHandler.prototype.startDraw = function () {
        var promise = Cesium.when.defer();
        var {scene} = this;
        var that = this;

        if (Cesium.defined(this._handler1)) { this._handler1.destroy(); this._handler1 = undefined; }
        this._handler1 = new Cesium.ScreenSpaceEventHandler(scene.canvas);
        this._handler1.setInputAction(function (movement) {
            that._stDownMovement = movement;
        }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

        this._handler2 = this._handler2 && this._handler2.destroy();
        this._handler2 = new Cesium.ScreenSpaceEventHandler(scene.canvas);
        this._handler2.setInputAction(function (movement) {
            if (that._finished) {
                return;
            }

            if (that._stDownMovement.position.x != movement.position.x
                && that._stDownMovement.position.y != movement.position.y) {
                return;
            }

            var cartesian = scene.camera.pickEllipsoid(
                movement.position,
                scene.globe.ellipsoid
            );

            if (Cesium.defined(cartesian)) {
                that._pointCollection.add({
                    position : cartesian,
                    color : Config.pointColor,
                    pixelSize : Config.pixelSize
                });
                that._linePositions.push(cartesian);

                that._handler3 = that._handler3 && that._handler3.destroy();
                that._handler3 = new Cesium.ScreenSpaceEventHandler(scene.canvas);
                that._handler3.setInputAction(function (movement) {
                    var cartesian = scene.camera.pickEllipsoid(
                        movement.endPosition,
                        scene.globe.ellipsoid
                    );
                    if (Cesium.defined(cartesian)) {
                        that._edCartesian = cartesian;
                        that.updatePrimitive();
                    }
                }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
            }
        }, Cesium.ScreenSpaceEventType.LEFT_UP);

        this._handler4 = this._handler4 && this._handler4.destroy();
        this._handler4 = new Cesium.ScreenSpaceEventHandler(scene.canvas);
        this._handler4.setInputAction(function () {
            that.destroy();
            if(that._linePositions.length > 0 && Cesium.defined(that._edCartesian)){
                that._linePositions.push(that._edCartesian);
                promise.resolve(that._linePositions);
            }
        }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

        return promise;
    };

    DrawPolygonalLineHandler.prototype.updatePrimitive = function () {
        var {_linePositions} = this;

        if(_linePositions.length === 0 || !Cesium.defined(this._edCartesian)){
            return;
        }

        if(!Cesium.defined(this._edPoint)){
            this._edPoint = this._pointCollection.add({
                position : this._edCartesian,
                color : Config.pointColor,
                pixelSize : Config.pixelSize
            });
        }else {
            this._edPoint.position = this._edCartesian;
        }

        var positions = [];
        Object.assign(positions,_linePositions);
        positions.push(this._edCartesian);

        var instance = new Cesium.GeometryInstance({
            geometry : new Cesium.GroundPolylineGeometry({
                positions : positions,
                width : Config.lineWidth
            })
        });

        if(!Cesium.defined(this._appearance)){
            this._appearance = new Cesium.PolylineMaterialAppearance({
                material : Cesium.Material.fromType(Cesium.Material.PolylineGlowType)
            });
        }

        this._polylinePrimitive = this._polylinePrimitive && this._polylinePrimitive.destroy();
        this._polylinePrimitive = new Cesium.GroundPolylinePrimitive({ geometryInstances: instance, asynchronous: false });
        this._polylinePrimitive.appearance = this._appearance;
    };

    DrawPolygonalLineHandler.prototype.update = function (frameState) {
        if(Cesium.defined(this._polylinePrimitive)){
            this._polylinePrimitive.update(frameState);
            this._pointCollection.update(frameState);
        }
    };

    DrawPolygonalLineHandler.prototype.destroy = function () {
        this._handler1 = this._handler1 && this._handler1.destroy();
        this._handler2 = this._handler2 && this._handler2.destroy();
        this._handler3 = this._handler3 && this._handler3.destroy();
        this._handler4 = this._handler3 && this._handler4.destroy();
        this._polylinePrimitive = this._polylinePrimitive && this._polylinePrimitive.destroy();
        this._pointCollection = this._pointCollection && this._pointCollection.destroy();
    };

    var Overlay = function (viewer) {
        this._visible = false;
        this._viewer = viewer;
    };

    Object.defineProperties(Overlay.prototype, {
        target: {
            get: function () {
                return this._target;
            },
        },
        content: {
            set: function (value) {
                if (Cesium.defined(this.target)) {
                    this.target.textContent = value;
                }
            }
        },
    });

    Overlay.prototype.createGraph = function (container, earthPin) {
        this._target = Overlay.createWrapNode();
        if (Cesium.defined(container)) {
            container.appendChild(this._target);
        }
        if (Cesium.defined(earthPin)) {
            this.content = earthPin.content;
        }
        return this._target;
    };

    Overlay.createWrapNode = function () {
        var div = document.createElement('div');
        div.className = 'backdrop';
        div.style.display = 'none';
        div.style.position = 'absolute';
        div.style.bottom = '0';
        div.style.left = '0';
        div.style['pointer-events'] = 'none';
        div.style.padding = '4px';
        div.style.backgroundColor = 'white';
        div.style.color = 'black';
        return div;
    };

    Overlay.prototype.setVisible = function (visible) {
        if (!Cesium.defined(this._target)) {
            this.createGraph();
        }
        if (this._visible !== visible) {
            this._visible = visible;
            this._target.style.display = visible ? 'block' : 'none';
        }
    };

    Overlay.prototype.showAt = function (position, message) {
        if (position && message) {
            this.setVisible(true);
            this._target.innerHTML = message;
            this._target.style.left = position.x + 10 + "px";
            this._target.style.bottom = this._viewer.canvas.clientHeight - position.y + 'px';
        }
    };

    Overlay.prototype.destroy = function () {
        if (Cesium.defined(this._target)) {
            this._target.remove();
        }
    };

    var highlighted;

    function CommonPickHandler(viewer, options) {
        highlighted = {
            feature: undefined,
            originalMaterial: undefined,
            originalColor: new Cesium.Color(),
            originalScale: 1.0,
            highlightColor: function (destColor) {
                if (Cesium.Color.equals(this.originalColor, destColor)) {
                    var newColor = new Cesium.Color();
                    Cesium.Color.add(this.originalColor, Cesium.Color.WHITE, newColor);
                    Cesium.Color.divideByScalar(newColor, 0.4, newColor);
                    return newColor;
                } else {
                    return destColor;
                }
            }
        };

        this._scene = viewer.scene;
        this._handlerMove = undefined;
        this._handlerDown = undefined;
        this._highlightColor = Cesium.defaultValue(options.color, Cesium.Color.YELLOW);
        this._featurePickEvent = new Cesium.Event();
        this._removeEventSubscription = this._featurePickEvent.addEventListener(
            CommonPickHandler.prototype._onPickFeature,
            this
        );

        if (Cesium.defaultValue(options.infomation, true)) {
            this.onMovePickFeature = this.onPickFeature;
        }
        else {
            this.onPickFeature = undefined;
            this.onMovePickFeature = undefined;
        }

        this._keepHighlight = true;
        this._tooltip = new Overlay(viewer);
        this._tooltip.createGraph(viewer.container);
    }
    Object.defineProperties(CommonPickHandler.prototype, {
        featurePickEvent: {
            get: function () {
                return this._featurePickEvent;
            },
        },
    });

    CommonPickHandler.prototype.onPickFeature = function (
        entity,
        propertyName,
        screenPosition,
        oldValue) {
        if (Cesium.defined(entity)) {
            var pick_info = '';
            if (entity instanceof Cesium.Cesium3DTileFeature) {
                var propertyNames = entity.getPropertyNames();
                var length = propertyNames.length;
                for (var i = 0; i < length; ++i) {
                    var propertyName = propertyNames[i];
                    var message = propertyName + ': ' + entity.getProperty(propertyName);
                    pick_info += message + '<br/>';
                }
            }
            else if (entity.id instanceof Cesium.Entity) {
                if (Cesium.defined(entity.id.kml) && Cesium.defined(entity.id.kml.extendedData)) {
                    for (var data in entity.id.kml.extendedData) {
                        var message = data + ': ' + entity.id.kml.extendedData[data].value;
                        pick_info += message + '<br/>';
                    }
                }
                else if (Cesium.defined(entity.id.properties)) {
                    var length = entity.id.properties.propertyNames.length;
                    for (var i = 0; i < length; ++i) {
                        var propertyName = entity.id.properties.propertyNames[i];
                        var message = propertyName + ': ' + entity.id.properties[propertyName];
                        pick_info += message + '<br/>';
                    }
                }
            }
            this._tooltip.showAt(screenPosition, pick_info);
        } else {
            this._tooltip.setVisible(false);
        }
    };

    CommonPickHandler.prototype._onPickFeature = function (
        entity,
        propertyName,
        newValue,
        oldValue) {
        if (propertyName === 'onPickFeature') {
            this.onPickFeature(entity, propertyName, newValue, oldValue);
        }
        else if (propertyName === 'onMovePickFeature') {
            this.onPickFeature(entity, propertyName, newValue, oldValue);
        }
    };

    CommonPickHandler.prototype.destroy = function () {
        this._handlerMove = this._handlerMove && this._handlerMove.destroy();
        this._handlerDown = this._handlerDown && this._handlerDown.destroy();
        this._tooltip = this._tooltip && this._tooltip.destroy();
    };

    CommonPickHandler.isAllowPicking = function (pickFeature) {
        if (Cesium.defined(pickFeature) &&
            Cesium.defined(pickFeature.id) && Cesium.defined(pickFeature.id.entityCollection)
            && Cesium.defined(pickFeature.id.entityCollection.owner)) {
            var allowPicking = Cesium.defaultValue(pickFeature.id.entityCollection.owner.allowPicking, true);
            // if(!allowPicking && Cesium.defined(pickFeature.primitive)){
            //     pickFeature.primitive.allowPicking = false;
            // }
            return allowPicking;
        }
        return true;
    };

    CommonPickHandler.prototype.clearHighlight = function () {
        if (Cesium.defined(highlighted.feature)) {
            if (Cesium.defined(highlighted.feature.id)) {
                if (Cesium.defined(highlighted.feature.id.model)) {
                    highlighted.feature.id.point.color = highlighted.originalColor;
                }
                if (Cesium.defined(highlighted.feature.id.point)) {
                    highlighted.feature.id.point.color = highlighted.originalColor;
                }
                if (Cesium.defined(highlighted.feature.id.billboard)) {
                    highlighted.feature.id.billboard.scale = highlighted.originalScale;
                }
                if (Cesium.defined(highlighted.feature.id.label)) {
                    highlighted.feature.id.label.scale = highlighted.originalScale;
                }
                if (Cesium.defined(highlighted.feature.id.polygon)) {
                    if (Cesium.defined(highlighted.feature.id.polygon.material && Cesium.defined(highlighted.originalMaterial))) {
                        highlighted.feature.id.polygon.material = highlighted.originalMaterial;
                    }
                }
                if (Cesium.defined(highlighted.feature.id.polyline)) {
                    if (Cesium.defined(highlighted.feature.id.polyline.material && Cesium.defined(highlighted.originalMaterial))) {
                        highlighted.feature.id.polyline.material = highlighted.originalMaterial;
                    }
                }
            }
            if (Cesium.defined(highlighted.feature.color)) {
                highlighted.feature.color = highlighted.originalColor;
            }
            highlighted.feature = undefined;
        }
    };

    CommonPickHandler.prototype.start = function () {
        var that = this;

        //on mouse move
        this._handlerMove = new Cesium.ScreenSpaceEventHandler(this._scene.canvas);
        this._handlerMove.setInputAction(function (movement) {
            //清除高亮
            if (Cesium.defined(that.onMovePickFeature) && !that._keepHighlight) ;
            var pickedFeature = that._scene.pick(movement.endPosition);
            var pickChanged = Cesium.defined(highlighted.feature) && !Cesium.defined(pickedFeature);
            that.clearHighlight();
            if (pickedFeature !== highlighted.feature) {
                pickChanged = true;
                highlighted.feature = pickedFeature;
                var allowPicking = CommonPickHandler.isAllowPicking(pickedFeature);
                if (!allowPicking) {
                    highlighted.feature = undefined;
                    return;
                }
                if (Cesium.defined(pickedFeature) && Cesium.defined(pickedFeature.id)) {
                    if (Cesium.defined(pickedFeature.id.model)) {
                        Cesium.Color.clone(pickedFeature.id.model.color._value, highlighted.originalColor);
                        pickedFeature.id.model.color = highlighted.highlightColor(that._highlightColor);
                    }
                    else if (Cesium.defined(pickedFeature.id.point)) {
                        Cesium.Color.clone(pickedFeature.id.point.color._value, highlighted.originalColor);
                    }
                    else if (Cesium.defined(pickedFeature.id.polygon)) {
                        if (Cesium.defined(pickedFeature.id.polygon.material)) {
                            highlighted.originalMaterial = pickedFeature.id.polygon.material;
                            Cesium.Color.clone(highlighted.originalMaterial.color.value, highlighted.originalColor);
                            var color = highlighted.highlightColor(that._highlightColor);
                            pickedFeature.id.polygon.material = new Cesium.ColorMaterialProperty(color);
                        }
                    }
                    else if (Cesium.defined(pickedFeature.id.polyline)) {
                        if (allowPicking && Cesium.defined(pickedFeature.id.polyline.material)) {
                            highlighted.originalMaterial = pickedFeature.id.polyline.material;
                            Cesium.Color.clone(highlighted.originalMaterial.color.value, highlighted.originalColor);
                            var color = highlighted.highlightColor(that._highlightColor);
                            pickedFeature.id.polyline.material = new Cesium.ColorMaterialProperty(color);
                        }
                    }
                    else if (Cesium.defined(pickedFeature.id.billboard)) {
                        highlighted.originalScale = Cesium.defined(pickedFeature.id.billboard.scale) ? pickedFeature.id.billboard.scale : 1.0;
                        pickedFeature.id.billboard.scale = highlighted.originalScale * 2.0;

                        if (Cesium.defined(pickedFeature.id.label)) {
                            pickedFeature.id.label.scale = highlighted.originalScale * 2.0;
                        }
                    }
                    // else if(pickedFeature.primitive instanceof Cesium.PointPrimitive){
                    //     Cesium.Color.clone(pickedFeature.primitive.color, highlighted.originalColor);
                    //     pickedFeature.primitive.color = highlighted.highlightColor(that._highlightColor);
                    // }
                } else {
                    Cesium.Color.clone(pickedFeature.color, highlighted.originalColor);
                    pickedFeature.color = highlighted.highlightColor(that._highlightColor);
                }
            }

            if (Cesium.defined(that.onMovePickFeature) && pickChanged) {
                that.featurePickEvent.raiseEvent(pickedFeature, "onMovePickFeature", movement.endPosition, '');
            }

        }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);


        //on mouse down
        this._handlerDown = new Cesium.ScreenSpaceEventHandler(this._scene.canvas);
        this._handlerDown.setInputAction(function (movement) {
            //that.clearHighlight();
            if (Cesium.defined(that.onPickFeature)) {
                var pickedFeature = that._scene.pick(movement.position);
                that.featurePickEvent.raiseEvent(pickedFeature, "onPickFeature", movement.position, '');
            }
        }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
    };

    function InternalHandler(viewer, options) {
      this._scene = viewer.scene;
      this._handlerMove = undefined;
      this._handlerDown = undefined;
      this._handlerUp = undefined;

      this._moveEvent = undefined;
      this._downEvent = undefined;
      this._upEvent = undefined;

      this._pickEvent = undefined;
      this._lastPos = undefined;
    }

    InternalHandler.Type = {
      pickEllipsoid: 0,
    };

    Object.defineProperties(InternalHandler.prototype, {
      moveEvent: {
        get: function () {
          if (!Cesium.defined(this._moveEvent)) {
            this._moveEvent = new Cesium.Event();
            this.startMove();
          }
          return this._moveEvent;
        },
      },
      downEvent: {
        get: function () {
          if (!Cesium.defined(this._downEvent)) {
            this._downEvent = new Cesium.Event();
            this.startDown();
          }
          return this._downEvent;
        },
      },
      upEvent: {
        get: function () {
          if (!Cesium.defined(this._upEvent)) {
            this._upEvent = new Cesium.Event();
            this.startUp();
          }
          return this._upEvent;
        },
      },
      pickEvent: {
        get: function () {
          if (!Cesium.defined(this._pickEvent)) {
            this._pickEvent = new Cesium.Event();
            this.startPick();
          }
          return this._pickEvent;
        },
      },
    });

    InternalHandler.prototype.destroy = function () {
      this._handlerMove = this._handlerMove && this._handlerMove.destroy();
      this._handlerDown = this._handlerDown && this._handlerDown.destroy();
    };

    InternalHandler.prototype.startMove = function () {
      var that = this;
      var scene = this._scene;

      //on mouse move
      this._handlerMove = new Cesium.ScreenSpaceEventHandler(scene.canvas);
      this._handlerMove.setInputAction(function (movement) {
        var cartesian = scene.camera.pickEllipsoid(
          movement.endPosition,
          scene.globe.ellipsoid
        );
        if (Cesium.defined(cartesian)) {
          that._moveEvent.raiseEvent(
            cartesian,
            InternalHandler.Type.pickEllipsoid,
            movement.endPosition,
            ""
          );
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    };

    InternalHandler.prototype.startDown = function () {
      var that = this;
      var scene = this._scene;

      //on mouse down
      this._handlerDown = new Cesium.ScreenSpaceEventHandler(scene.canvas);
      this._handlerDown.setInputAction(function (movement) {
        if (Cesium.defined(that._downEvent)) {
          var cartesian = scene.camera.pickEllipsoid(
            movement.position,
            scene.globe.ellipsoid
          );
          if (Cesium.defined(cartesian)) {
            that._downEvent.raiseEvent(
              cartesian,
              InternalHandler.Type.pickEllipsoid,
              movement.position,
              ""
            );
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
    };

    InternalHandler.prototype.startUp = function () {
      var that = this;
      var scene = this._scene;

      //on mouse up
      this._handlerUp = new Cesium.ScreenSpaceEventHandler(scene.canvas);
      this._handlerUp.setInputAction(function (movement) {
        if (Cesium.defined(that._upEvent)) {
          var cartesian = scene.camera.pickEllipsoid(
            movement.position,
            scene.globe.ellipsoid
          );
          if (Cesium.defined(cartesian)) {
            that._upEvent.raiseEvent(
              cartesian,
              InternalHandler.Type.pickEllipsoid,
              movement.position,
              ""
            );
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_UP);
    };

    InternalHandler.prototype.startPick = function () {
      var that = this;
      var scene = this._scene;

      //on mouse up
      this._handlerUp = new Cesium.ScreenSpaceEventHandler(scene.canvas);
      this._handlerUp.setInputAction(function (movement) {
        if (Cesium.defined(that._pickEvent)) {
          var cartesian = scene.camera.pickEllipsoid(
            movement.position,
            scene.globe.ellipsoid
          );
          if (Cesium.defined(cartesian)) {
            that._pickEvent.raiseEvent(
              cartesian,
              InternalHandler.Type.pickEllipsoid,
              movement.position,
              ""
            );
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    };

    function EditableHandler(we) {
        this._we = we;
        this._handler1 = undefined;
        this._handler2 = undefined;
        this._handler3 = undefined;
        this._scene = we.viewer.scene;
        this._isEditing = false;
        this._highlightedFeature = undefined;
        this._tooltip = undefined;
    }

    Object.defineProperties(EditableHandler.prototype, {
        isEditing: {
            get: function () {
                return !this._we.viewer.scene.screenSpaceCameraController.enableInputs;
            },
            set: function (value) {
                this._we.viewer.scene.screenSpaceCameraController.enableInputs = !value;
            }
        }
    });

    EditableHandler.prototype.destroy = function () {
        this._handler1 = this._handler1 && this._handler1.destroy();
        this._handler2 = this._handler2 && this._handler2.destroy();
        this._handler3 = this._handler3 && this._handler3.destroy();
        this._handler4 = this._handler4 && this._handler4.destroy();
    };

    EditableHandler.prototype.clearHighlight = function () {
        if (Cesium.defined(this._highlightedFeature)) {
            this._highlightedFeature.id.offHighlight();
            this._highlightedFeature = undefined;
        }
    };

    EditableHandler.prototype.onHighlight = function (feature) {
        this.clearHighlight();
        this._highlightedFeature = feature;
        this._highlightedFeature.id.onHighlight(feature.primitive._index);
    };

    EditableHandler.prototype.isHeightPoint = function (feature) {
        if (Cesium.defined(feature) && Cesium.defined(feature.id)) {
            return feature.id.isHeightPoint(feature.primitive);
        }

        return false;
    };

    EditableHandler.prototype.updateCartesian = function (cartesian) {
        if (Cesium.defined(this._highlightedFeature)) {
            this._highlightedFeature.id.updateCartesian(cartesian);
        }
    };

    EditableHandler.prototype.start = function () {
        var scene = this._we.viewer.scene;
        var that = this;
        var pickPosition;

        this._handler3 = new Cesium.ScreenSpaceEventHandler(scene.canvas);
        this._handler3.setInputAction(function (movement) {
            if (that.isEditing) {
                if (that.isHeightPoint(that._highlightedFeature)) {
                    var offset = {
                        x: movement.endPosition.x - pickPosition.x,
                        y: movement.endPosition.y - pickPosition.y
                    };

                    var screenHeight = scene.canvas.height;
                    var topHeight = pickPosition.y;
                    var bottomHeight = screenHeight - pickPosition.y;
                    var ratioY = offset.y > 0 ? offset.y / bottomHeight : offset.y / topHeight;

                    var ratio = ratioY * 2.0;
                    pickPosition.y = movement.endPosition.y;
                    ratio = that._highlightedFeature.id.scaleHeight - ratio;
                    if (ratio > 1.0) ratio = 1.0;
                    if (ratio < 0.0) ratio = 0.0;
                    that._highlightedFeature.id.scaleHeight = ratio;

                    if (Cesium.defined(that._highlightedFeature.id) && Cesium.defined(that._highlightedFeature.id.tip)) {
                        that._tooltip = that._highlightedFeature.id.getTip(that._we.viewer.container);
                        var cartesian = Cesium.Cartesian3.clone(that._highlightedFeature.id.heightPointPosition, new Cesium.Cartesian3());
                        that._tooltip.showAt(cartesian, that._highlightedFeature.id.tip);
                    }
                }
                else {
                    var cartesian = scene.camera.pickEllipsoid(
                        movement.endPosition,
                        scene.globe.ellipsoid
                    );
                }
                if (Cesium.defined(cartesian)) {
                    var cartographic = Cesium.Cartographic.fromCartesian(cartesian);
                    var message = Cesium.Math.toDegrees(cartographic.longitude).toFixed(2)
                        + ',' + Cesium.Math.toDegrees(cartographic.latitude).toFixed(2);

                    that._tooltip = that._highlightedFeature.id.getTip(that._we.viewer.container);
                    that._tooltip.showAt(cartesian, message);

                    that.updateCartesian(cartesian);
                }
            } else {
                that.clearHighlight();
                var pickedFeature = scene.pick(movement.endPosition);
                if (Cesium.defined(pickedFeature) && pickedFeature.id instanceof EditablePoint) {
                    that.onHighlight(pickedFeature);
                }
            }

        }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

        this._handler1 = new Cesium.ScreenSpaceEventHandler(scene.canvas);
        this._handler1.setInputAction(function (movement) {
            if (Cesium.defined(that._tooltip)) {
                that._tooltip.visible = false;
            }
            var pickedFeature = scene.pick(movement.position);
            if (Cesium.defined(pickedFeature) && pickedFeature.id instanceof EditablePoint) {
                pickPosition = movement.position;
                that.onHighlight(pickedFeature);
                that.isEditing = true;
            }
        }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

        this._handler2 = new Cesium.ScreenSpaceEventHandler(scene.canvas);
        this._handler2.setInputAction(function (movement) {
            that.isEditing = false;
            that.clearHighlight();
        }, Cesium.ScreenSpaceEventType.LEFT_UP);


        this._handler4 = new Cesium.ScreenSpaceEventHandler(scene.canvas);
        this._handler4.setInputAction(function (movement) {
            var pickedFeature = scene.pick(movement.position);
            if (Cesium.defined(pickedFeature) && pickedFeature.id instanceof EditablePoint) {
                pickedFeature.id.destroy();
            }
            if (Cesium.defined(that._tooltip)) {
                that._tooltip.visible = false;
            }
        }, Cesium.ScreenSpaceEventType.RIGHT_DOWN);
    };

    EditableHandler.prototype.update = function (frameState) {
        if (Cesium.defined(this._tooltip) && !this._tooltip.isDestroyed() && this._tooltip.visible) ;
    };

    function FlyHandler(we){
        this._we = we;
        this._handler = undefined;

        this._handler = new Cesium.ScreenSpaceEventHandler(this._we.viewer.scene.canvas);
        this._handler.setInputAction(function (movement) {
            we.viewer.camera.cancelFlight();
        }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

    }

    FlyHandler.prototype.destroy = function () {
        this._handler = this._handler && this._handler.destroy();
    };

    function HandlerManager(WE){
        this._we = WE;
        this._internalHandler = undefined;
        this._currentHandler = undefined;
        this._editHander = undefined;
        this._flyHander = undefined;
        this._enableTip = true;

        this._internalHandler = new InternalHandler(WE.viewer,Cesium.defaultValue.EMPTY_OBJECT);
    }

    Object.defineProperties(HandlerManager.prototype, {
        currentHander: {
            get: function () {
                return this._currentHandler;
            },
        },
        currentHandler: {
            get: function () {
                return this._currentHandler;
            },
        },
        internalHandler: {
            get: function () {
                return this._internalHandler;
            },
        },
        enableFlyHandler: {
            get: function () {
                return Cesium.defined(this._flyHander);
            },
            set: function (value) {
                if(value){
                    if(!Cesium.defined(this._flyHander)){
                        this._flyHander = new FlyHandler(this._we);
                    }
                }
                else {
                    this._flyHander = this._flyHander && this._flyHander.destroy();
                }
            }
        },    
        enableTip: {
            get: function () {
                return this._enableTip;
            },
            set: function (value) {
                this._enableTip = value;
            }
        },
    });

    HandlerManager.prototype.createEditablePoint = function(){
        return new EditablePoint(this._we);
    };
        
    HandlerManager.prototype.startDraw = function(options){
        this.stop();

        var type = Cesium.defaultValue(options.handleType,"line");

        var promise;
        if(type === 'line' || type === '线'){
            this._currentHandler = new DrawLineHandler({viewer: this._we.viewer});
            promise = this._currentHandler.startDraw(2);
        }
        else if(type === 'rectangle'|| type === '矩形'){
            this._currentHandler = new DrawRectHandler(this._we.viewer.scene, options);
            promise = this._currentHandler.startDraw();
        }
        else if(type === '折线'){
            this._currentHandler = new DrawPolygonalLineHandler({scene: this._we.scene});
            promise = this._currentHandler.startDraw();
        }
        
        return promise;
    };

    HandlerManager.prototype.startPick = function(options){
        this.stop();
        var type = Cesium.defaultValue(options.handleType,"CommonPick");
        if(type === 'CommonPick'){
            this._currentHandler = new CommonPickHandler(this._we.viewer, options);
            this._currentHandler.start();
        }
    };

    HandlerManager.prototype.startEdit = function(options){
        this.stopEdit();
        this._editHander = new EditableHandler(this._we);
        this._editHander.start();
    };

    HandlerManager.prototype.stopEdit = function(){
        this._editHander = this._editHander && this._editHander.destroy();
    };

    HandlerManager.prototype.stop = function(){
        this._currentHandler = this._currentHandler && this._currentHandler.destroy();
    };

    HandlerManager.prototype.destroy = function () {
        this.stop();
        this._internalHandler = this._internalHandler && this._internalHandler.destroy();
    };

    HandlerManager.prototype.update = function (frameState) {
        if(Cesium.defined(this._currentHandler) && Cesium.defined(this._currentHandler.update)){
            this._currentHandler.update(frameState);
        }
        if(this._enableTip && Cesium.defined(this._editHander) && Cesium.defined(this._editHander.update)){
            this._editHander.update(frameState);
        }
    };

    function PointLayer(options) {
        //All public configuration is defined as ES5 properties
        //These are just the "private" variables and their defaults.
        this._name = options.name;
        this._changed = new Cesium.Event();
        this._error = new Cesium.Event();
        this._isLoading = false;
        this._loading = new Cesium.Event();
        this._entityCollection = new Cesium.EntityCollection();
        this._seriesNames = [];
        this._seriesToDisplay = undefined;
        this._offsetHeight = Cesium.defaultValue(options.offsetHeight,0);
        this._heightScale = Cesium.defaultValue(options.heightScale,10000);
        this._entityCluster = new Cesium.EntityCluster();
        this._show = true;
        this._random = Cesium.defaultValue(options.random,false);
        this._color = Cesium.defaultValue(options.color,Cesium.Color.RED);
        this._outlineColor = Cesium.defaultValue(options.outlineColor,Cesium.Color.YELLOW);
        
        this._pointOptions = options.pointOptions;
        this._labelOptions = options.labelOptions;
      }
      
      Object.defineProperties(PointLayer.prototype, {
        //The below properties must be implemented by all DataSource instances
      
        /**
         * Gets a human-readable name for this instance.
         * @memberof PointLayer.prototype
         * @type {String}
         */
        name: {
          get: function () {
            return this._name;
          },
        },
        /**
         * Since WebGL Globe JSON is not time-dynamic, this property is always undefined.
         * @memberof PointLayer.prototype
         * @type {DataSourceClock}
         */
        clock: {
          value: undefined,
          writable: false,
        },
        /**
         * Gets the collection of Entity instances.
         * @memberof PointLayer.prototype
         * @type {EntityCollection}
         */
        entities: {
          get: function () {
            return this._entityCollection;
          },
        },
        /**
         * Gets a value indicating if the data source is currently loading data.
         * @memberof PointLayer.prototype
         * @type {Boolean}
         */
        isLoading: {
          get: function () {
            return this._isLoading;
          },
        },
        /**
         * Gets an event that will be raised when the underlying data changes.
         * @memberof PointLayer.prototype
         * @type {Event}
         */
        changedEvent: {
          get: function () {
            return this._changed;
          },
        },
        /**
         * Gets an event that will be raised if an error is encountered during
         * processing.
         * @memberof PointLayer.prototype
         * @type {Event}
         */
        errorEvent: {
          get: function () {
            return this._error;
          },
        },
        /**
         * Gets an event that will be raised when the data source either starts or
         * stops loading.
         * @memberof PointLayer.prototype
         * @type {Event}
         */
        loadingEvent: {
          get: function () {
            return this._loading;
          },
        },
      
        //These properties are specific to this DataSource.
      
        /**
         * Gets the array of series names.
         * @memberof PointLayer.prototype
         * @type {String[]}
         */
        seriesNames: {
          get: function () {
            return this._seriesNames;
          },
        },
        /**
         * Gets or sets the name of the series to display.  WebGL JSON is designed
         * so that only one series is viewed at a time.  Valid values are defined
         * in the seriesNames property.
         * @memberof PointLayer.prototype
         * @type {String}
         */
        seriesToDisplay: {
          get: function () {
            return this._seriesToDisplay;
          },
          set: function (value) {
            this._seriesToDisplay = value;
      
            //Iterate over all entities and set their show property
            //to true only if they are part of the current series.
            var collection = this._entityCollection;
            var entities = collection.values;
            collection.suspendEvents();
            for (var i = 0; i < entities.length; i++) {
              var entity = entities[i];
              entity.show = value === entity.seriesName;
            }
            collection.resumeEvents();
          },
        },
        /**
         * Gets or sets the scale factor applied to the height of each line.
         * @memberof PointLayer.prototype
         * @type {Number}
         */
        heightScale: {
          get: function () {
            return this._heightScale;
          },
          set: function (value) {
            if (value <= 0) {
              throw new Cesium.DeveloperError("value must be greater than 0");
            }
            this._heightScale = value;
          },
        },
        /**
         * Gets whether or not this data source should be displayed.
         * @memberof PointLayer.prototype
         * @type {Boolean}
         */
        show: {
          get: function () {
            return this._show;
          },
          set: function (value) {
            this._show = value;
            var collection = this._entityCollection;
            var entities = collection.values;
            collection.suspendEvents();
            for (var i = 0; i < entities.length; i++) {
              var entity = entities[i];
              entity.show = value;
            }
            collection.resumeEvents();
          },
        },
        /**
         * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
         * @memberof PointLayer.prototype
         * @type {EntityCluster}
         */
        clustering: {
          get: function () {
            return this._entityCluster;
          },
          set: function (value) {
            if (!Cesium.defined(value)) {
              throw new Cesium.DeveloperError("value must be defined.");
            }
            this._entityCluster = value;
          },
        },
      });
      
      /**
       * Asynchronously loads the GeoJSON at the provided url, replacing any existing data.
       * @param {Object} url The url to be processed.
       * @returns {Promise} a promise that will resolve when the GeoJSON is loaded.
       */
      PointLayer.prototype.loadUrl = function (url) {
        if (!Cesium.defined(url)) {
          throw new Cesium.DeveloperError("url is required.");
        }
      
        var that = this;
        return Cesium.Resource.fetchJson(url)
          .then(function (json) {
            return that.load(json, url);
          })
          .otherwise(function (error) {
            //Otherwise will catch any errors or exceptions that occur
            //during the promise processing. When this happens,
            //we raise the error event and reject the promise.
            this._setLoading(false);
            that._error.raiseEvent(that, error);
            return Cesium.when.reject(error);
          });
      };
      
      /**
       * Loads the provided data, replacing any existing data.
       * @param {Array} data The object to be processed.
       */
      PointLayer.prototype.load = function (data) {
      
        //Clear out any data that might already exist.
        this._setLoading(true);
        this._seriesNames.length = 0;
        this._seriesToDisplay = undefined;
      
        var heightScale = this.heightScale;
        var entities = this._entityCollection;
      
        //It's a good idea to suspend events when making changes to a
        //large amount of entities.  This will cause events to be batched up
        //into the minimal amount of function calls and all take place at the
        //end of processing (when resumeEvents is called).
        entities.suspendEvents();
        entities.removeAll();
      
        
        var geometries = data.geometries;

        if(data.type === 'Topology') {
          Object.keys(data.objects).forEach(function(element){
            geometries = data.objects[element].geometries;
          });
        }    
        
        for (var x = 0; x < geometries.length; x++) {
          var coordinates = geometries[x].coordinates;
          var longitude = coordinates[0];
          var latitude = coordinates[1];
          var height = 0.0;

          var surfacePosition = Cesium.Cartesian3.fromDegrees(
            longitude,
            latitude,
            height
          );

          var text = geometries[x].properties[this._name];

          var entity = new Cesium.Entity({
            id: this._name + " index " + x.toString(),
            show: this._show,
            position: surfacePosition,
          });

          if(Cesium.defined(this._pointOptions)) {
            entity.point = Object.assign(this._pointOptions, {text: text});
          }

          if(Cesium.defined(this._labelOptions)) {
            entity.label = Object.assign(this._labelOptions, {text: text});
          }

          //Add the entity to the collection.
          entities.add(entity);
        }
      
        //Once all data is processed, call resumeEvents and raise the changed event.
        entities.resumeEvents();
        this._changed.raiseEvent(this);
        this._setLoading(false);
      };
      
      PointLayer.prototype._setLoading = function (isLoading) {
        if (this._isLoading !== isLoading) {
          this._isLoading = isLoading;
          this._loading.raiseEvent(this, isLoading);
        }
      };

    function WeatherVolumeTransfunctions() {
    }
    WeatherVolumeTransfunctions.ValueAndColorRamp_DBZ_Swan = {
      ValueRamp: [0.0, 10.0, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0, 45.0, 50.0, 55.0, 60.0, 65.0],
      ColorRamp: [[0.0, 0.0, 0.0, 0.0], 
          [122.0, 114.0, 239.0, 255.0], 
          [30.0, 38.0, 209.0, 255.0], 
          [167.0, 253.0, 169.0, 255.0], 
          [0.0, 235.0, 0.0, 255.0], 
          [16.0, 147.0, 26.0, 255.0], 
          [253.0, 245.0, 100.0, 255.0], 
          [201.0, 201.0, 2.0, 255.0], 
          [141.0, 141.0, 0.0, 255.0], 
          [255.0, 173.0, 173.0, 255.0], 
          [255.0, 100.0, 92.0, 255.0], 
          [239.0, 2.0, 48.0, 255.0], 
          [171.0, 36.0, 251.0, 255.0]],
    };

    WeatherVolumeTransfunctions.ValueAndColorRamp_DBZ = {
        ValueRamp: [0.0, 10.0, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0, 45.0, 50.0, 55.0, 60.0, 65.0, 70.0],
        ColorRamp: [[0.0, 0.0, 0.0, 0.0], 
            [1.0, 160.0, 240.0, 255.0], 
            [0.0, 236.0, 236.0, 255.0], 
            [0.0, 216.0, 0.0, 255.0], 
            [1.0, 144.0, 0.0, 255.0], 
            [255.0, 255.0, 0.0, 255.0], 
            [231.0, 192.0, 0.0, 255.0], 
            [255.0, 144.0, 0.0, 255.0], 
            [255.0, 0.0, 0.0, 255.0], 
            [214.0, 0.0, 0.0, 255.0], 
            [192.0, 0.0, 0.0, 255.0], 
            [255.0, 0.0, 240.0, 255.0], 
            [150.0, 0.0, 180.0, 255.0], 
            [173.0, 144.0, 240.0, 255.0]],
    };

    WeatherVolumeTransfunctions.Transfunction_DBZ = "vec4 v_transfer(float v,float z,bool usePhongLight)\n\
{\n\
  vec4 fragColor = vec4(0.0,0.0,0.0,0.0);\n\
  float ramp[14] = float[14](0.0,10.0,15.0,20.0,25.0,30.0,35.0,40.0,45.0,50.0,55.0,60.0,65.0,70.0);\n\
  const vec4 colorRamp[14] = vec4[14](\n\
  vec4(000.0,000.0,000.0,000.0),\n\
  vec4(001.0,160.0,240.0,255.0 ),\n\
  vec4(000.0,236.0,236.0,255.0 ),\n\
  vec4(000.0,216.0,000.0,255.0 ),\n\
  vec4(001.0,144.0,000.0,255.0 ),\n\
  vec4(255.0,255.0,000.0,255.0),\n\
  vec4(231.0,192.0,000.0,255.0),\n\
  vec4(255.0,144.0,000.0,255.0),\n\
  vec4(255.0,000.0,000.0,255.0),\n\
  vec4(214.0,000.0,000.0,255.0),\n\
  vec4(192.0,000.0,000.0,255.0),\n\
  vec4(255.0,000.0,240.0,255.0),\n\
  vec4(150.0,000.0,180.0,255.0),\n\
  vec4(173.0,144.0,240.0,255.0));\n\
  for(int i=0;i<14;i++){\n\
    if(v <= ramp[i]){\n\
      vec4 floatColor = colorRamp[i]/255.0;\n\
      if(i>0){\n\
        floatColor.a = v / 70.0;\n\
        floatColor.rgba = (floatColor.rgba) * (0.7  + 0.3 * (v - ramp[i-1])/ (ramp[i]- ramp[i-1]));\n\
      }\n\
      fragColor = floatColor;\n\
      break;\n\
    }\n\
  }\n\
  return fragColor;\n\
}\n\
";

    WeatherVolumeTransfunctions.ValueAndColorRamp_ZQ = {
      ValueRamp: [0, 6, 8, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20],
      ColorRamp: [[0, 0, 0, 0],
      [5, 131, 177, 255],
      [5, 64, 215, 255],
      [5, 175, 17, 255],
      [5, 132, 13, 255],
      [201, 181, 51, 255],
      [191, 163, 39, 255],
      [203, 17, 16, 255],
      [121, 15, 20, 255],
      [76, 14, 20, 255],
      [202, 177, 214, 255],
      [122, 124, 174, 255],
      [207, 216, 226, 255]],
    };

    WeatherVolumeTransfunctions.Transfunction_ZQ = "vec4 v_transfer(float v,float z,bool usePhongLight)\n\
{\n\
  vec4 fragColor = vec4(0.0,0.0,0.0,0.0);\n\
  float ramp[13] = float[13](0.0,6.0,8.0,10.0,11.0,12.0,14.0,15.0,16.0,17.0,18.0,19.0,20.0);\n\
  const vec4 colorRamp[13] = vec4[13](\n\
  vec4(000.0,000.0,000.0,000.0),\n\
  vec4(005.0,131.0,177.0,255.0 ),\n\
  vec4(005.0,064.0,215.0,255.0 ),\n\
  vec4(005.0,175.0,017.0,255.0 ),\n\
  vec4(005.0,132.0,013.0,255.0 ),\n\
  vec4(201.0,181.0,051.0,255.0),\n\
  vec4(191.0,163.0,039.0,255.0),\n\
  vec4(203.0,017.0,016.0,255.0),\n\
  vec4(121.0,015.0,020.0,255.0),\n\
  vec4(076.0,014.0,020.0,255.0),\n\
  vec4(202.0,177.0,214.0,255.0),\n\
  vec4(122.0,124.0,174.0,255.0),\n\
  vec4(207.0,216.0,226.0,255.0));\n\
  for(int i=0;i<13;i++){\n\
    if(v <= ramp[i]){\n\
      vec4 floatColor = colorRamp[i]/255.0;\n\
      if(i>0){\n\
        floatColor.a = v / 20.0;\n\
        floatColor.rgba = (floatColor.rgba) * (0.7  + 0.3 * (v - ramp[i-1])/ (ramp[i]- ramp[i-1]));\n\
      }\n\
      fragColor = floatColor;\n\
      break;\n\
    }\n\
  }\n\
  return fragColor;\n\
}\n\
";

    WeatherVolumeTransfunctions.Transfunction_ZT = "vec4 v_transfer(float v,float z,bool usePhongLight)\n\
{\n\
  vec4 fragColor = vec4(0.0,0.0,0.0,0.0);\n\
  float ramp[17] = float[17](-20.0,-12.0,-8.0,-4.0,0.0,4.0,8.0,12.0,16.0,20.0,24.0,28.0,32.0,35.0,37.0,40.0,60.0);\n\
  const vec4 colorRamp[17] = vec4[17](\n\
  vec4(000.0,000.0,000.0,000.0),\n\
  vec4(000.0,048.0,132.0,255.0),\n\
  vec4(027.0,092.0,165.0,255.0 ),\n\
  vec4(062.0,159.0,236.0,255.0 ),\n\
  vec4(135.0,210.0,247.0,255.0 ),\n\
  vec4(213.0,247.0,255.0,255.0 ),\n\
  vec4(241.0,254.0,236.0,255.0),\n\
  vec4(207.0,255.0,208.0,255.0),\n\
  vec4(190.0,254.0,142.0,255.0),\n\
  vec4(254.0,254.0,158.0,255.0),\n\
  vec4(254.0,243.0,197.0,255.0),\n\
  vec4(255.0,207.0,171.0,255.0),\n\
  vec4(254.0,243.0,197.0,255.0),\n\
  vec4(254.0,243.0,197.0,255.0),\n\
  vec4(254.0,243.0,197.0,255.0),\n\
  vec4(254.0,000.0,000.0,255.0),\n\
  vec4(255.0,000.0,000.0,255.0));\n\
  float alpha = 0.0;\n\
  for(int i=0;i<17;i++){\n\
    if(v <= ramp[i]){\n\
      vec4 floatColor = colorRamp[i]/255.0;\n\
      if(i>0){\n\
        floatColor.a = alpha;\n\
        vec4 floatColor0 = colorRamp[i-1]/255.0;\n\
        float r = (v - ramp[i-1])/ (ramp[i]- ramp[i-1]);\n\
        floatColor.rgba = floatColor0.rgba * r + floatColor.rgba * (1.0 - r);\n\
      }\n\
      fragColor = floatColor;\n\
      break;\n\
    }\n\
    alpha += 1.0 /17.0;\n\
  }\n\
  return fragColor;\n\
}\n\
";


    WeatherVolumeTransfunctions.ValueAndColorRamp_ZT = {
      ValueRamp: [-20.0,-12.0,-8.0,-4.0,0.0,4.0,8.0,12.0,16.0,20.0,24.0,28.0,32.0,35.0,37.0,40.0,60.0],
      ColorRamp: [[0, 0, 0, 0],
      [0, 48, 132, 255],
      [27, 92, 165, 255],
      [62,159,236, 255],
      [0,128,236, 255],
      [0,255,208, 255],
      [190,254,142, 255],
      [254,254,158, 255],
      [254,128,47, 255],
      [255,47,47, 255],
      [254,0,0, 255],
      [254,0,0, 255],
      [254,0,0, 255],
      [254,0,0, 255],
      [254,0,0, 255],
      [254,0,0, 255],
      [255,0,0, 255]],
    };

    WeatherVolumeTransfunctions.ValueAndColorRamp_UV = {
      ValueRamp: [0.0,3.3,5.4,7.9,10.7,13.8,17.1,20.7,24.4,28.4,32.6,36.9,41.4,46.1,50.9,56.0,70.0],
      ColorRamp: [[0, 0, 0, 0],
      [1, 152, 255, 255],
      [3, 103, 253, 255],
      [44,155,0, 255],
      [38,255,0, 255],
      [212,254,7, 255],
      [255,252,1, 255],
      [243,213,41, 255],
      [254,153,3, 255],
      [225,195,197, 255],
      [197,151,151, 255],
      [144,76,65, 255],
      [254,52,52, 255],
      [211,57,57, 255],
      [180,53,64, 255],
      [177,50,179, 255],
      [219,55,227, 255]],
    };

    WeatherVolumeTransfunctions.ValueAndColorRamp_DBZ1 = {
      ValueRamp: [0.0, 10.0, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0, 45.0, 50.0, 55.0, 60.0, 65.0, 70.0],
      ColorRamp: [[0.0, 0.0, 0.0, 0.0], 
          [1.0, 160.0, 240.0, 0.0], 
          [0.0, 236.0, 236.0, 0.0], 
          [0.0, 216.0, 0.0, 0.0], 
          [1.0, 144.0, 0.0, 0.0], 
          [255.0, 255.0, 0.0, 0.0], 
          [231.0, 192.0, 0.0, 16.0], 
          [255.0, 144.0, 0.0, 128.0], 
          [255.0, 0.0, 0.0, 32.0], 
          [214.0, 0.0, 0.0, 0.0], 
          [192.0, 0.0, 0.0, 0.0], 
          [255.0, 0.0, 240.0, 255.0], 
          [150.0, 0.0, 180.0, 255.0], 
          [173.0, 144.0, 240.0, 255.0]],
    };

    WeatherVolumeTransfunctions.ValueAndColorRamp_DBZ2 = {
      ValueRamp: [0.0, 10.0, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0, 45.0, 50.0, 55.0, 60.0, 65.0, 70.0],
      ColorRamp: [[0.0, 0.0, 0.0, 0.0], 
          [1.0, 160.0, 240.0, 0.0], 
          [0.0, 236.0, 236.0, 0.0], 
          [0.0, 216.0, 0.0, 0.0], 
          [1.0, 144.0, 0.0, 64.0], 
          [255.0, 255.0, 0.0, 0.0], 
          [231.0, 192.0, 0.0, 0.0], 
          [255.0, 144.0, 0.0, 0.0], 
          [255.0, 0.0, 0.0, 128.0], 
          [214.0, 0.0, 0.0, 255.0], 
          [192.0, 0.0, 0.0, 255.0], 
          [255.0, 0.0, 240.0, 255.0], 
          [150.0, 0.0, 180.0, 255.0], 
          [173.0, 144.0, 240.0, 255.0]],
    };

    WeatherVolumeTransfunctions.Transfunction_CommonTFTTK = "vec4 v_transfer(float v,float z,bool usePhongLight,vec4 color)\n\
{\n\
  float offset = u_attribute[0][1];\n\
  float range = u_attribute[0][2] - u_attribute[0][1];\n\
  v -= offset;\n\
  vec4 fragColor = vec4(0.0,0.0,0.0,0.0); \n\
  if(v < 0.0) return fragColor;\n\
  vec4 floatColor = texture2D(tfTexture, vec2(v/range, 0.0)); \n\
  vec4 floatColor0 = texture2D(tfTexture, vec2(v/range, 1.0)); \n\
  floatColor.a = v/range * floatColor.a * (z > 0.0 ? (0.6 - z * 0.4) : 1.0); \n\
  fragColor = floatColor; \n\
  return fragColor; \n\
}\n\
";

    WeatherVolumeTransfunctions.Transfunction_CommonTF = "vec4 v_transfer(float v,float z,bool usePhongLight,vec4 color)\n\
{\n\
  float offset = u_attribute[0][1];\n\
  float range = u_attribute[0][2] - u_attribute[0][1];\n\
  v -= offset;\n\
  vec4 fragColor = vec4(0.0,0.0,0.0,0.0); \n\
  if(v < 0.0) return fragColor;\n\
  vec4 floatColor = texture2D(tfTexture, vec2(v/range, 0.0)); \n\
  vec4 floatColor0 = texture2D(tfTexture, vec2(v/range, 1.0)); \n\
  float clampA = floatColor0.x * 255.0; \n\
  float clampB = floatColor0.y * 255.0; \n\
  floatColor.a = v/range * floatColor.a * (z > 0.0 ? (0.6 - z * 0.4) : 1.0); \n\
  if(!usePhongLight)\n\
    floatColor.rgb = (floatColor.rgb) * (0.9  + 0.1 * (v - clampA) / (clampB - clampA));\n\
  fragColor = floatColor; \n\
  return fragColor; \n\
}\n\
";

    WeatherVolumeTransfunctions.Transfunction_ClampTF = "vec4 v_transfer(float v,float z,bool usePhongLight,vec4 color)\n\
{\n\
  float offset = u_attribute[0][1];\n\
  float range = u_attribute[0][2] - u_attribute[0][1];\n\
  v -= offset;\n\
  vec4 fragColor = vec4(0.0,0.0,0.0,0.0); \n\
  if(v < 0.0) return fragColor;\n\
  fragColor = vec4(0.0,1.0 - v/range,v/range,v/range); \n\
  return fragColor; \n\
}\n\
";

    WeatherVolumeTransfunctions.Transfunction_WindTF = "vec4 v_transfer(inout float v0,float z,bool usePhongLight,inout vec4 color)\n\
{\n\
  float offset = u_attribute[0][1];\n\
  float scaler = u_attribute[0][0];\n\
  float range = u_attribute[0][2] - u_attribute[0][1];\n\
  vec4 color2 = vec4(color.z,color.w,0.0,0.0);\n\
  float v2 = czm_unpackVolume(color2,scaler,offset);\n\
  vec4 fragColor = vec4(0.0,0.0,0.0,0.0); \n\
  vec2 nor = vec2(v2,v0);\n\
  //color.zw = normalize(nor) * 0.5 + vec2(0.5,0.5);\n\
  v0 = sqrt(v2 * v2);\n\
  float v = v0 - offset;\n\
  if(v < 0.0) return fragColor;\n\
  vec4 floatColor = texture2D(tfTexture, vec2(v/range, 0.0)); \n\
  vec4 floatColor0 = texture2D(tfTexture, vec2(v/range, 1.0)); \n\
  float clampA = floatColor0.x * 255.0; \n\
  float clampB = floatColor0.y * 255.0; \n\
  floatColor.a = v/range * floatColor.a * (z > 0.0 ? (0.6 - z * 0.4) : 1.0); \n\
  if(!usePhongLight)\n\
    floatColor.rgb = (floatColor.rgb) * (0.9  + 0.1 * (v - clampA) / (clampB - clampA));\n\
  fragColor = floatColor; \n\
  return fragColor; \n\
}\n\
";

    function CustomImageryProvider(options) {
      options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
      this.ext = options.ext;
      this.varname = options.varname;
      this._url = options.url;
      this.ffx = Cesium.defaultValue(options.ffx, 1);
      this._makeUrlCallback = options.makeUrlCallback;

      /**
       * The default alpha blending value of this provider, with 0.0 representing fully transparent and
       * 1.0 representing fully opaque.
       *
       * @type {Number|undefined}
       * @default undefined
       */
      this.defaultAlpha = undefined;

      /**
       * The default alpha blending value on the night side of the globe of this provider, with 0.0 representing fully transparent and
       * 1.0 representing fully opaque.
       *
       * @type {Number|undefined}
       * @default undefined
       */
      this.defaultNightAlpha = undefined;

      /**
       * The default alpha blending value on the day side of the globe of this provider, with 0.0 representing fully transparent and
       * 1.0 representing fully opaque.
       *
       * @type {Number|undefined}
       * @default undefined
       */
      this.defaultDayAlpha = undefined;

      /**
       * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0
       * makes the imagery darker while greater than 1.0 makes it brighter.
       *
       * @type {Number|undefined}
       * @default undefined
       */
      this.defaultBrightness = undefined;

      /**
       * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces
       * the contrast while greater than 1.0 increases it.
       *
       * @type {Number|undefined}
       * @default undefined
       */
      this.defaultContrast = undefined;

      /**
       * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.
       *
       * @type {Number|undefined}
       * @default undefined
       */
      this.defaultHue = undefined;

      /**
       * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the
       * saturation while greater than 1.0 increases it.
       *
       * @type {Number|undefined}
       * @default undefined
       */
      this.defaultSaturation = undefined;

      /**
       * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.
       *
       * @type {Number|undefined}
       * @default undefined
       */
      this.defaultGamma = undefined;

      /**
       * The default texture minification filter to apply to this provider.
       *
       * @type {TextureMinificationFilter}
       * @default undefined
       */
      this.defaultMinificationFilter = undefined;

      /**
       * The default texture magnification filter to apply to this provider.
       *
       * @type {TextureMagnificationFilter}
       * @default undefined
       */
      this.defaultMagnificationFilter = undefined;

      this._image = undefined;
      this._texture = undefined;
      this._tileWidth = 0;
      this._tileHeight = 0;
      this._errorEvent = new Cesium.Event();

      this._ready = false;
      this._readyPromise = Cesium.when.defer();

      var credit = options.credit;
      if (typeof credit === "string") {
        credit = new Cesium.Credit(credit);
      }
      this._credit = credit;

      var that = this;
      var error;

      function success(image) {
        that._image = image;
        that._tileWidth = Cesium.defaultValue(image.width, 256);
        that._tileHeight = Cesium.defaultValue(image.height, 256);
        that._readyPromise.resolve(image);
        Cesium.TileProviderError.handleSuccess(that._errorEvent);
      }

      function failure(e) {
        var message = "Failed to load image " + resource.url + ".";
        error = Cesium.TileProviderError.handleError(
          error,
          that,
          that._errorEvent,
          message,
          0,
          0,
          0,
          doRequest,
          e
        );
        that._readyPromise.reject(new Cesium.RuntimeError(message));
      }

      this.requestData(options.name, options.postData)
        .then(success)
        .otherwise(failure);
    }

    Object.defineProperties(CustomImageryProvider.prototype, {
      url: {
        get: function () {
          return this._url;
        },
        set: function (value) {
          this._url = value;
        },
      },
      /**
       * Gets the proxy used by this provider.
       * @memberof CustomImageryProvider.prototype
       * @type {Proxy}
       * @readonly
       */
      proxy: {
        get: function () {
          return undefined;
        },
      },

      /**
       * Gets the width of each tile, in pixels. This function should
       * not be called before {@link CustomImageryProvider#ready} returns true.
       * @memberof CustomImageryProvider.prototype
       * @type {Number}
       * @readonly
       */
      tileWidth: {
        get: function () {

          return this._tileWidth;
        },
      },

      /**
       * Gets the height of each tile, in pixels.  This function should
       * not be called before {@link CustomImageryProvider#ready} returns true.
       * @memberof CustomImageryProvider.prototype
       * @type {Number}
       * @readonly
       */
      tileHeight: {
        get: function () {

          return this._tileHeight;
        },
      },

      /**
       * Gets the maximum level-of-detail that can be requested.  This function should
       * not be called before {@link CustomImageryProvider#ready} returns true.
       * @memberof CustomImageryProvider.prototype
       * @type {Number|undefined}
       * @readonly
       */
      maximumLevel: {
        get: function () {

          return 0;
        },
      },

      /**
       * Gets the minimum level-of-detail that can be requested.  This function should
       * not be called before {@link CustomImageryProvider#ready} returns true.
       * @memberof CustomImageryProvider.prototype
       * @type {Number}
       * @readonly
       */
      minimumLevel: {
        get: function () {

          return 0;
        },
      },

      /**
       * Gets the tiling scheme used by this provider.  This function should
       * not be called before {@link CustomImageryProvider#ready} returns true.
       * @memberof CustomImageryProvider.prototype
       * @type {TilingScheme}
       * @readonly
       */
      tilingScheme: {
        get: function () {

          return this._tilingScheme;
        },
      },

      /**
       * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
       * not be called before {@link CustomImageryProvider#ready} returns true.
       * @memberof CustomImageryProvider.prototype
       * @type {Cesium.Rectangle}
       * @readonly
       */
      rectangle: {
        get: function () {
          return this._tilingScheme.rectangle;
        },
      },

      /**
       * Gets the tile discard policy.  If not undefined, the discard policy is responsible
       * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
       * returns undefined, no tiles are filtered.  This function should
       * not be called before {@link CustomImageryProvider#ready} returns true.
       * @memberof CustomImageryProvider.prototype
       * @type {TileDiscardPolicy}
       * @readonly
       */
      tileDiscardPolicy: {
        get: function () {

          return undefined;
        },
      },

      /**
       * Gets an event that is raised Cesium.when the imagery provider encounters an asynchronous error.  By subscribing
       * to the event, you will be notified of the error and can potentially recover from it.  Cesium.Event listeners
       * are passed an instance of {@link Cesium.TileProviderError}.
       * @memberof CustomImageryProvider.prototype
       * @type {Cesium.Event}
       * @readonly
       */
      errorEvent: {
        get: function () {
          return this._errorEvent;
        },
      },

      /**
       * Gets a value indicating whether or not the provider is ready for use.
       * @memberof CustomImageryProvider.prototype
       * @type {Boolean}
       * @readonly
       */
      ready: {
        get: function () {
          return this._ready;
        },
      },

      /**
       * Gets a promise that resolves to true Cesium.when the provider is ready for use.
       * @memberof CustomImageryProvider.prototype
       * @type {Promise.<Boolean>}
       * @readonly
       */
      readyPromise: {
        get: function () {
          return this._readyPromise.promise;
        },
      },

      /**
       * Gets the credit to display Cesium.when this imagery provider is active.  Typically this is used to credit
       * the source of the imagery.  This function should not be called before {@link CustomImageryProvider#ready} returns true.
       * @memberof CustomImageryProvider.prototype
       * @type {Cesium.Credit}
       * @readonly
       */
      credit: {
        get: function () {
          return this._credit;
        },
      },

      /**
       * Gets a value indicating whether or not the images provided by this imagery provider
       * include an alpha channel.  If this property is false, an alpha channel, if present, will
       * be ignored.  If this property is true, any images without an alpha channel will be treated
       * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
       * and texture upload time are reduced.
       * @memberof CustomImageryProvider.prototype
       * @type {Boolean}
       * @readonly
       */
      hasAlphaChannel: {
        get: function () {
          return true;
        },
      },
    });

    /**
     * Gets the credits to be displayed Cesium.when a given tile is displayed.
     *
     * @param {Number} x The tile X coordinate.
     * @param {Number} y The tile Y coordinate.
     * @param {Number} level The tile level;
     * @returns {Cesium.Credit[]} The credits to be displayed Cesium.when the tile is displayed.
     *
     * @exception {Cesium.DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.
     */
    CustomImageryProvider.prototype.getTileCredits = function (x, y, level) {
      return undefined;
    };

    /**
     * Requests the image for a given tile.  This function should
     * not be called before {@link CustomImageryProvider#ready} returns true.
     *
     * @param {Number} x The tile X coordinate.
     * @param {Number} y The tile Y coordinate.
     * @param {Number} level The tile level.
     * @param {Request} [request] The request object. Intended for internal use only.
     * @returns {Promise.<HTMLImageElement|HTMLCanvasElement>|undefined} A promise for the image that will resolve Cesium.when the image is available, or
     *          undefined if there are too many active requests to the server, and the request
     *          should be retried later.  The resolved image may be either an
     *          Image or a Canvas DOM object.
     *
     * @exception {Cesium.DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
     */
    CustomImageryProvider.prototype.requestImage = function (x, y, level, request) {

      return this._image;
    };

    /**
     * Picking features is not currently supported by this imagery provider, so this function simply returns
     * undefined.
     *
     * @param {Number} x The tile X coordinate.
     * @param {Number} y The tile Y coordinate.
     * @param {Number} level The tile level.
     * @param {Number} longitude The longitude at which to pick features.
     * @param {Number} latitude  The latitude at which to pick features.
     * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve Cesium.when the asynchronous
     *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
     *                   instances.  The array may be empty if no features are found at the given location.
     *                   It may also be undefined if picking is not supported.
     */
    CustomImageryProvider.prototype.pickFeatures = function (
      x,
      y,
      level,
      longitude,
      latitude
    ) {
      return undefined;
    };

    CustomImageryProvider.prototype.requestData = function (name, postData) {
      if (Cesium.defined(postData)) {
        return WeatherData.postWithParams(
          postData,
          name,
          this.varname,
          this.ext,
          this.url
        );
      } else if (Cesium.defined(this._makeUrlCallback)) {
        return WeatherData.request(this._makeUrlCallback());
      } else {
        return WeatherData.requestWithParams(
          name,
          this.varname,
          this.ext,
          this.url
        );
      }
    };

    CustomImageryProvider.prototype.createReprojectCommand = function (
      uniformMap,
      ReprojectWebMercatorFS,
      context,
      texture
    ) {
      var width = texture.width;
      var height = texture.height;

      if (Cesium.defined(this.ffx) && this.ffx > 1) {
        width *= this.ffx;
        height *= this.ffx;
      }

      this._computeCommand = new Cesium.ComputeCommand({
        uniformMap: uniformMap,
        fragmentShaderSource: ReprojectWebMercatorFS,
        preExecute: function (command) {
          var outputTexture = command.outputTexture;
          if (!Cesium.defined(outputTexture) || outputTexture.isDestroyed()) {
            command.outputTexture = new Cesium.Texture({
              context: context,
              width: width,
              height: height,
              pixelFormat: Cesium.PixelFormat.RGBA,
              pixelDatatype: texture.pixelDatatype,
              preMultiplyAlpha: texture.preMultiplyAlpha,
            });
          }
        },
        persists: true,
      });
    };

    function CloudImageryLayer(options) {
      var imageryProvider = new CustomImageryProvider(options);
      Cesium.ImageryLayer.call(this, imageryProvider);

      this._enableCaches = Cesium.defaultValue(options.enableCaches, false);
      this.remoteUrl = options.url;
      this._currentName = this.name = options.name;
      this.scene = options.scene;
      this._rectangle = options.rectangle;
      this.ValueAndColorRamp = options.ValueAndColorRamp;
      this.byteLength = 0;
      this.texture = undefined;
      this.textureTF = undefined;
      this._reCompute = false;

      var that = this;

      this._attributeMatrix = new Cesium.Matrix4(
        0.0 /*scaler*/,
        100.0 /*filtrationMax*/,
        0.0,
        0.0,
        0.0 /*clampMin*/,
        0.0,
        0.0,
        1.0 /*clearFactor*/,
        0.0 /*clampMax*/,
        0.0,
        0.0,
        0.0,
        0.0 /*filtrationMin*/,
        0.0,
        0.0,
        0.0
      );

      this.queueReprojectionCommandsCOPY = this.queueReprojectionCommands;

      this._isLoading = true;
      imageryProvider._readyPromise.then(function (array) {
        that.success(array, that.name);
        that.createComputeCommand();
        imageryProvider._ready = true;
      });

      this._dirty = false;
      this._timeSampleArray = undefined;
      var legendUrl = Cesium.defaultValue(options.legendUrl, "");
      if (legendUrl !== "") {
        Cesium.Resource.fetchImage(options.legendUrl).then(function (image) {
          that.textureTF = new Cesium.Texture({
            context: that.scene.context,
            source: image,
            flipY: false,
          });
          that.useLegendColor = true;
        });
      }
    }

    CloudImageryLayer.CreateClassPrototype = function () {
      var prototype = CloudImageryLayer.prototype;
      CloudImageryLayer.prototype = new Cesium.ImageryLayer({});
      Object.assign(CloudImageryLayer.prototype, prototype);
      Object.defineProperties(CloudImageryLayer.prototype, {
        filtrationMin: {
          get: function () {
            return this._attributeMatrix[3];
          },
          set: function (value) {
            if (this._attributeMatrix[3] !== value) {
              this._attributeMatrix[3] = value;
              this._reCompute = true;
            }
          },
        },
        clearFactor: {
          get: function () {
            return this._attributeMatrix[13];
          },
          set: function (value) {
            if (this._attributeMatrix[13] !== value) {
              this._attributeMatrix[13] = value;
            }
          },
        },
        useLegendColor: {
          get: function () {
            return this._attributeMatrix[14] === 1.0;
          },
          set: function (value) {
            if (this.useLegendColor !== value) {
              this._attributeMatrix[14] = value ? 1.0 : 0.0;
            }
          },
        },
        currentName: {
          get: function () {
            return this._currentName;
          },
          set: function (value) {
            if (this._currentName !== value) {
              this._currentName = value;
              this._dirty = true;
            }
          },
        },
        timeSampleArray: {
          get: function () {
            return this._timeSampleArray;
          },
          set: function (value) {
            this._timeSampleArray = value;
          },
        },
      });
    };

    CloudImageryLayer.prototype.loadData = function (name) {
      this._isLoading = true;

      if (this._enableCaches && this._caches.contains(name)) {
        var data = this._caches.get(name);
        this.success(data, name);
      } else {
        var promise = this._imageryProvider.requestData(name);
        var that = this;
        Cesium.when(promise)
          .then((data) => {
            if (that._enableCaches) {
              that._caches.set(name, data);
            }
            that.success(data, name);
          })
          .otherwise((error) => {
            console.log(error);
            that._isLoading = false;
          });
      }
    };

    CloudImageryLayer.prototype.updateData = function () {
      if (this._isLoading) {
        return;
      }

      this.loadData(this._currentName);
    };

    CloudImageryLayer.prototype.success = function (volumeData, name) {
      if (name !== this._currentName) {
        this._isLoading = false;
        return;
      }
      
      var imageryProvider = this.imageryProvider;
      this._attributeMatrix[0] = volumeData.u_s_o.scaler;
      this._attributeMatrix[1] = volumeData.u_s_o.clampMin;
      this._attributeMatrix[2] = volumeData.u_s_o.clampMax;
      var internalFormat = Cesium.defaultValue(
        volumeData.internalFormat,
        Cesium.PixelFormat.RGBA
      );

      if (
        this.byteLength === volumeData.source.arrayBufferView.length &&
        Cesium.defined(this.texture)
      ) {
        this.texture.copyFrom(volumeData.source);
        this._reCompute = true;
      } else {
        this.texture = this.texture && this.texture.destroy();
        this.byteLength = volumeData.source.arrayBufferView.length;

        if (!Cesium.defined(this.rectangle)) {
          this._rectangle = Cesium.Rectangle.fromDegrees(
            volumeData.extent.xmin,
            volumeData.extent.ymin,
            volumeData.extent.xmax,
            volumeData.extent.ymax
          );
        }

        imageryProvider._tilingScheme = new Cesium.GeographicTilingScheme({
          rectangle: this._rectangle,
          numberOfLevelZeroTilesX: 1,
          numberOfLevelZeroTilesY: 1,
          ellipsoid: this.scene.globe.ellipsoid,
        });

        var sampler = new Cesium.Sampler({
          wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
          wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
          minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
          magnificationFilter: Cesium.TextureMagnificationFilter.LINEAR,
        });

        this.texture = new Cesium.Texture({
          context: this.scene.context,
          pixelFormat: internalFormat,
          source: volumeData.source,
          flipY: false,
          sampler: sampler,
        });
      }

      this._isLoading = false;
    };

    CloudImageryLayer.prototype.createComputeCommand = function () {
      var ReprojectWebMercatorFS =
        "uniform sampler2D u_texture;\n\
    uniform sampler2D u_textureTF;\n\
    uniform mat4 u_attribute;\n\
    varying vec2 v_textureCoordinates;\n\
  void main()\n\
  {\n\
    float clearFactor = u_attribute[3][1];\n\
    float useLegendColor = u_attribute[3][2];\n\
    vec4 color = texture2D(u_texture, v_textureCoordinates);\n\
    float alpha = pow(color.r,clearFactor);\n\
    //color.xyz = color.xyz * 0.0 + vec3(1.0);\n\
    if(useLegendColor > 0.0){\n\
     color = texture2D(u_textureTF, vec2(color.r,0.0));\n\
    }\n\
    color.a = alpha;\n\
    gl_FragColor = color;\n\
  }\n\
  ";

      var context = this.scene.context;
      var that = this;
      var uniformMap = {
        u_texture: function () {
          return that.texture;
        },
        u_textureTF: function () {
          return that.useLegendColor ? that.textureTF : context.defaultTexture;
        },
        u_attribute: function () {
          return that._attributeMatrix;
        },
      };

      this._imageryProvider.createReprojectCommand(
        uniformMap,
        ReprojectWebMercatorFS,
        context,
        this.texture
      );
    };

    CloudImageryLayer.prototype.destroy = function () {
      this.textureTF = this.textureTF && this.textureTF.destroy();
      return Cesium.destroyObject(this);
    };

    CloudImageryLayer.prototype._createTextureWebGL = function (context, imagery) {
      return undefined;
    };

    CloudImageryLayer.prototype.updateTime = function (frameState) {
      if (Cesium.defined(this.timeSampleArray)) {
        var index = this.timeSampleArray.getIndex(frameState.time);
        var url = this.timeSampleArray.getUrl(index);
        if (Cesium.defined(url)) {
          if (this._currentIndex !== index) {
            this.currentName = url;
            this._currentIndex = index;
          }
        }
      }
    };

    CloudImageryLayer.prototype.update = function (frameState) {
      if (!frameState.passes.render) {
        return;
      }

      if (Cesium.defaultValue(frameState.shouldAnimate, false)) {
        this.updateTime(frameState);
      }

      if (this._dirty) {
        this._dirty = false;
        this.updateData();
      }

      if (this._reCompute) {
        this._reCompute = false;
        if (Cesium.defined(this.imageryProvider._computeCommand)) {
          this._reprojectComputeCommands.push(this.imageryProvider._computeCommand);
        }
      }
    };

    function DataProcess(remoteUrl,options){
        this.readyPromise = Cesium.when.defer();
        this.loadData(remoteUrl,options);
    }

    DataProcess.randomizeParticles = function(maxParticles, viewerParameters, data){
        viewerParameters.lonRange.x = data._attributeMatrix[6];
        viewerParameters.lonRange.y = data._attributeMatrix[7];
        viewerParameters.latRange.x = data._attributeMatrix[8];
        viewerParameters.latRange.y = data._attributeMatrix[9];
        var array = new Float32Array(4 * maxParticles);
        for (var i = 0; i < maxParticles; i++) {
            array[4 * i] = Cesium.Math.randomBetween(viewerParameters.lonRange.x, viewerParameters.lonRange.y);
            array[4 * i + 1] = Cesium.Math.randomBetween(viewerParameters.latRange.x, viewerParameters.latRange.y);
            array[4 * i + 2] = Cesium.Math.randomBetween(data.lev.min, data.lev.max);
            array[4 * i + 3] = 0.0;
        }
        return array;
    };

    function CustomPrimitive(options){
        this.commandType = options.commandType;

        this.geometry = options.geometry;
        this.attributeLocations = options.attributeLocations;
        this.primitiveType = options.primitiveType;

        this.uniformMap = options.uniformMap;

        this.vertexShaderSource = options.vertexShaderSource;
        this.fragmentShaderSource = options.fragmentShaderSource;

        this.rawRenderState = options.rawRenderState;
        this.framebuffer = options.framebuffer;

        this.outputTexture = options.outputTexture;

        this.autoClear = Cesium.defaultValue(options.autoClear, false);
        this.preExecute = options.preExecute;
        this.postExecute = options.postExecute;
        this.count = options.count;
        this.show = true;
        this.commandToExecute = undefined;
        this.clearCommand = undefined;
        if (this.autoClear) {
            this.clearCommand = new Cesium.ClearCommand({
                color: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
                depth: 1.0,
                framebuffer: this.framebuffer,
                pass: Cesium.Pass.OPAQUE
            });
        }
    }
       

    CustomPrimitive.prototype.createCommand = function(context) {
        switch (this.commandType) {
            case 'Draw': {
                var vertexArray = Cesium.VertexArray.fromGeometry({
                    context: context,
                    geometry: this.geometry,
                    attributeLocations: this.attributeLocations,
                    bufferUsage: Cesium.BufferUsage.STATIC_DRAW,
                });

                var shaderProgram = Cesium.ShaderProgram.fromCache({
                    context: context,
                    attributeLocations: this.attributeLocations,
                    vertexShaderSource: this.vertexShaderSource,
                    fragmentShaderSource: this.fragmentShaderSource
                });

                var renderState = Cesium.RenderState.fromCache(this.rawRenderState);
                return new Cesium.DrawCommand({
                    owner: this,
                    vertexArray: vertexArray,
                    primitiveType: this.primitiveType,
                    uniformMap: this.uniformMap,
                    modelMatrix: Cesium.Matrix4.IDENTITY,
                    shaderProgram: shaderProgram,
                    framebuffer: this.framebuffer,
                    renderState: renderState,
                    pass: Cesium.Pass.OPAQUE
                });
            }
            case 'Compute': {
                return new Cesium.ComputeCommand({
                    owner: this,
                    fragmentShaderSource: this.fragmentShaderSource,
                    uniformMap: this.uniformMap,
                    outputTexture: this.outputTexture,
                    persists: true
                });
            }
        }
    };

    CustomPrimitive.prototype.update = function(frameState) {
        if (!this.show) {
            return;
        }

        if (!Cesium.defined(this.commandToExecute)) {
            this.commandToExecute = this.createCommand(frameState.context);
        }

        if (Cesium.defined(this.preExecute)) {
            this.preExecute();
        }

        if (Cesium.defined(this.clearCommand)) {
            frameState.commandList.push(this.clearCommand);
        }
        frameState.commandList.push(this.commandToExecute);
    };

    CustomPrimitive.prototype.isDestroyed = function() {
        return false;
    };

    CustomPrimitive.prototype.destroy = function() {
        if (Cesium.defined(this.commandToExecute)) {
            this.commandToExecute.shaderProgram = this.commandToExecute.shaderProgram && this.commandToExecute.shaderProgram.destroy();
        }
        return Cesium.destroyObject(this);
    };

    //This file is automatically rebuilt by the WeatherEarth build process.
    var getWindFS = "#ifdef THREE_DIMANSION\n\
precision highp sampler3D;\n\
uniform sampler3D windTexture; // eastward northward wind\n\
#else\n\
uniform sampler2D windTexture; // eastward northward wind\n\
#endif\n\
// the size of UV textures: width = lon, height = lat*lev\n\
\n\
uniform sampler2D currentParticlesPosition; // (lon, lat, lev)\n\
\n\
uniform vec3 dimension; // (lon, lat, lev)\n\
uniform vec3 minimum; // minimum of each dimension\n\
uniform vec3 maximum; // maximum of each dimension\n\
uniform vec3 interval; // interval of each dimension\n\
uniform mat4 u_attribute; //\n\
\n\
varying vec2 v_textureCoordinates;\n\
\n\
vec3 mapPositionToNormalizedIndex2D(vec3 lonLatLev) {\n\
    // ensure the range of longitude and latitude\n\
    //lonLatLev.x = mod(lonLatLev.x, 360.0);\n\
    //lonLatLev.x = clamp(lonLatLev.x, -180.0, 180.0);\n\
    lonLatLev.x = clamp(lonLatLev.x, 0.0, 360.0);\n\
    lonLatLev.y = clamp(lonLatLev.y, -90.0, 90.0);\n\
\n\
    vec3 index3D = vec3(0.0);\n\
    index3D.x = (lonLatLev.x - minimum.x) / interval.x;\n\
    //index3D.x = (lonLatLev.x + 0.0) / interval.x;\n\
    index3D.y = (lonLatLev.y - minimum.y) / interval.y;\n\
    index3D.z = (lonLatLev.z - minimum.z) / interval.z;\n\
\n\
    // the st texture coordinate corresponding to (col, row) index\n\
    // example\n\
    // data array is [0, 1, 2, 3, 4, 5], width = 3, height = 2\n\
    // the content of texture will be\n\
    // t 1.0\n\
    //    |  3 4 5\n\
    //    |\n\
    //    |  0 1 2\n\
    //   0.0------1.0 s\n\
\n\
    vec2 index2D = vec2(index3D.x, index3D.z * dimension.y + index3D.y);\n\
    index2D = vec2(index3D.x, index3D.y);\n\
    vec2 normalizedIndex2D = vec2(index2D.x / dimension.x, index2D.y / (dimension.y * dimension.z));\n\
    normalizedIndex2D = vec2(index2D.x / dimension.x, index2D.y / dimension.y);\n\
    return vec3(normalizedIndex2D, index3D.z/ dimension.z);\n\
}\n\
\n\
vec2 getWind(vec3 lonLatLev) {\n\
    vec3 normalizedIndex2D = mapPositionToNormalizedIndex2D(lonLatLev);\n\
#ifdef THREE_DIMANSION\n\
    float sliceZ = u_attribute[3][0];\n\
    vec4 color = texture3D(windTexture, normalizedIndex2D);\n\
#else\n\
    vec4 color = texture2D(windTexture, normalizedIndex2D.xy);\n\
#endif\n\
    float scaler = u_attribute[0][0];\n\
    float clampMin = u_attribute[0][1];\n\
    float clampMax = u_attribute[0][2];\n\
    return czm_unpackUV(color,scaler,clampMin);\n\
}\n\
\n\
const mat4 kernelMatrix = mat4(\n\
    0.0, -1.0, 2.0, -1.0, // first column\n\
    2.0, 0.0, -5.0, 3.0, // second column\n\
    0.0, 1.0, 4.0, -3.0, // third column\n\
    0.0, 0.0, -1.0, 1.0 // fourth column\n\
);\n\
float oneDimensionInterpolation(float t, float p0, float p1, float p2, float p3) {\n\
    vec4 tVec4 = vec4(1.0, t, t * t, t * t * t);\n\
    tVec4 = tVec4 / 2.0;\n\
    vec4 pVec4 = vec4(p0, p1, p2, p3);\n\
    return dot((tVec4 * kernelMatrix), pVec4);\n\
}\n\
\n\
vec2 calculateB(float t, float lon, float lat, float lev) {\n\
    float lon0 = floor(lon) - 1.0 * interval.x;\n\
    float lon1 = floor(lon);\n\
    float lon2 = floor(lon) + 1.0 * interval.x;\n\
    float lon3 = floor(lon) + 2.0 * interval.x;\n\
\n\
    vec2 p0 = getWind(vec3(lon0, lat, lev));\n\
    vec2 p1 = getWind(vec3(lon1, lat, lev));\n\
    vec2 p2 = getWind(vec3(lon2, lat, lev));\n\
    vec2 p3 = getWind(vec3(lon3, lat, lev));\n\
\n\
    float u = oneDimensionInterpolation(t, p0.x, p1.x, p2.x, p3.x);\n\
    float v = oneDimensionInterpolation(t, p0.y, p1.y, p2.y, p3.y);\n\
    return vec2(u,v);\n\
}\n\
\n\
vec2 interpolateOneTexture(vec3 lonLatLev) {\n\
    float lon = lonLatLev.x;\n\
    float lat = lonLatLev.y;\n\
    float lev = lonLatLev.z;\n\
\n\
    float lat0 = floor(lat) - 1.0 * interval.y;\n\
    float lat1 = floor(lat);\n\
    float lat2 = floor(lat) + 1.0 * interval.y;\n\
    float lat3 = floor(lat) + 2.0 * interval.y;\n\
\n\
    vec2 coef = lonLatLev.xy - floor(lonLatLev.xy);\n\
    vec2 b0 = calculateB(coef.x, lon, lat0, lev);\n\
    vec2 b1 = calculateB(coef.x, lon, lat1, lev);\n\
    vec2 b2 = calculateB(coef.x, lon, lat2, lev);\n\
    vec2 b3 = calculateB(coef.x, lon, lat3, lev);\n\
\n\
    float u = oneDimensionInterpolation(coef.y, b0.x, b1.x, b2.x, b3.x);\n\
    float v = oneDimensionInterpolation(coef.y, b0.y, b1.y, b2.y, b3.y);\n\
\n\
    return vec2(u,v);\n\
}\n\
\n\
vec3 bicubic(vec3 lonLatLev) {\n\
    // https://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm\n\
    vec2 uv = interpolateOneTexture(lonLatLev);\n\
    float w = 0.0;\n\
    return vec3(uv.x, uv.y, w);\n\
}\n\
\n\
void main() {\n\
    // texture coordinate must be normalized\n\
    vec2 st = v_textureCoordinates;\n\
    vec3 lonLatLev = texture2D(currentParticlesPosition, st).rgb;\n\
    vec3 windVector = bicubic(lonLatLev);\n\
	gl_FragColor = vec4(windVector, 0.0);\n\
}";

    //This file is automatically rebuilt by the WeatherEarth build process.
    var updateSpeedFS = "uniform sampler2D currentParticlesSpeed; // (u, v, w, normalization)\n\
uniform sampler2D particlesWind;\n\
\n\
// use to calculate the relative speed\n\
uniform vec2 uSpeedRange; // (min, max);\n\
uniform vec2 vSpeedRange;\n\
uniform float pixelSize;\n\
uniform float speedFactor;\n\
\n\
varying vec2 v_textureCoordinates;\n\
\n\
vec4 calcRelativeSpeed(vec3 speed) {\n\
    vec3 percent = vec3(0.0);\n\
    percent.x = (speed.x - uSpeedRange.x) / (uSpeedRange.y - uSpeedRange.x);\n\
    percent.y = (speed.y - vSpeedRange.x) / (vSpeedRange.y - vSpeedRange.x);\n\
	float normalization = length(percent);\n\
\n\
    float minRelativeSpeed = -speedFactor * pixelSize;\n\
    float maxRelativeSpeed = speedFactor * pixelSize;\n\
\n\
	vec3 relativeSpeed = vec3(0.0);\n\
    relativeSpeed.x = mix(minRelativeSpeed, maxRelativeSpeed, percent.x);\n\
    relativeSpeed.y = mix(minRelativeSpeed, maxRelativeSpeed, percent.y);\n\
	\n\
	return vec4(relativeSpeed, normalization);\n\
}\n\
\n\
void main() {\n\
    vec2 st = v_textureCoordinates;\n\
    \n\
    // texture coordinate must be normalized\n\
    vec3 currentSpeed = texture2D(currentParticlesSpeed, st).rgb;\n\
	vec3 windVector = texture2D(particlesWind, st).rgb;\n\
	\n\
	vec4 nextSpeed = calcRelativeSpeed(windVector);\n\
	gl_FragColor = nextSpeed;\n\
}";

    //This file is automatically rebuilt by the WeatherEarth build process.
    var updatePositionFS = "uniform sampler2D currentParticlesPosition; // (lon, lat, lev)\n\
uniform sampler2D currentParticlesSpeed; // (u, v, w, normalization)\n\
\n\
varying vec2 v_textureCoordinates;\n\
\n\
vec2 lengthOfLonLat(vec3 lonLatLev) {\n\
    // unit conversion: meters -> longitude latitude degrees\n\
    // see https://en.wikipedia.org/wiki/Geographic_coordinate_system#Length_of_a_degree for detail\n\
\n\
    // Calculate the length of a degree of latitude and longitude in meters\n\
    float latitude = radians(lonLatLev.y);\n\
\n\
    float term1 = 111132.92;\n\
    float term2 = 559.82 * cos(2.0 * latitude);\n\
    float term3 = 1.175 * cos(4.0 * latitude);\n\
    float term4 = 0.0023 * cos(6.0 * latitude);\n\
    float latLength = term1 - term2 + term3 - term4;\n\
\n\
    float term5 = 111412.84 * cos(latitude);\n\
    float term6 = 93.5 * cos(3.0 * latitude);\n\
    float term7 = 0.118 * cos(5.0 * latitude);\n\
    float longLength = term5 - term6 + term7;\n\
\n\
    return vec2(longLength, latLength);\n\
}\n\
\n\
void updatePosition(vec3 lonLatLev, vec3 speed) {\n\
    vec2 lonlatLengthgth = lengthOfLonLat(lonLatLev);\n\
    float u = speed.x / lonlatLengthgth.x;\n\
    float v = speed.y / lonlatLengthgth.y;\n\
    float w = 0.0;\n\
    vec3 windVectorInLonLatLev = vec3(u, v, w);\n\
\n\
    vec3 nextParticle = lonLatLev + windVectorInLonLatLev;\n\
\n\
    gl_FragColor = vec4(nextParticle, 0.0);\n\
}\n\
\n\
void main() {\n\
    vec2 st = v_textureCoordinates;\n\
    // st.x += 0.5;\n\
    // if(st.x > 1.0) st.x -= 1.0;\n\
\n\
    // texture coordinate must be normalized\n\
    vec3 lonLatLev = texture2D(currentParticlesPosition, st).rgb;\n\
    vec3 speed = texture2D(currentParticlesSpeed, st).rgb;\n\
\n\
    updatePosition(lonLatLev, speed);\n\
}";

    //This file is automatically rebuilt by the WeatherEarth build process.
    var postProcessingPositionFS = "uniform sampler2D nextParticlesPosition;\n\
uniform sampler2D nextParticlesSpeed; // (u, v, w, normalization)\n\
\n\
// range (min, max)\n\
uniform vec2 lonRange;\n\
uniform vec2 latRange;\n\
\n\
uniform float randomCoef; // use to improve the pseudo-random generator\n\
uniform float dropRate; // drop rate is a chance a particle will restart at random position to avoid degeneration\n\
uniform float dropRateBump;\n\
uniform mat4 u_attribute; //\n\
\n\
varying vec2 v_textureCoordinates;\n\
\n\
// pseudo-random generator\n\
const vec3 randomConstants = vec3(12.9898, 78.233, 4375.85453);\n\
const vec2 normalRange = vec2(0.0, 1.0);\n\
float rand(vec2 seed, vec2 range) {\n\
    vec2 randomSeed = randomCoef * seed;\n\
    float temp = dot(randomConstants.xy, randomSeed);\n\
    temp = fract(sin(temp) * (randomConstants.z + temp));\n\
    return temp * (range.y - range.x) + range.x;\n\
}\n\
\n\
vec3 generateRandomParticle(vec2 seed, float lev) {\n\
    // ensure the longitude is in [0, 360]\n\
    float randomLon = mod(rand(seed, lonRange), 360.0);\n\
    //float randomLon = rand(seed, lonRange);\n\
    float randomLat = rand(-seed, latRange);\n\
\n\
    return vec3(randomLon, randomLat, lev);\n\
}\n\
\n\
bool particleOutbound(vec3 particle) {\n\
    float minLon = u_attribute[1][2];\n\
    float maxLon = u_attribute[1][3];\n\
    float minLat = u_attribute[2][0];\n\
    float maxLat = u_attribute[2][1];\n\
    return particle.y < minLat || particle.y > maxLat || particle.x < minLon || particle.x > maxLon;\n\
}\n\
\n\
void main() {\n\
  vec2 st = v_textureCoordinates;\n\
	vec3 nextParticle = texture2D(nextParticlesPosition, st).rgb;\n\
    vec4 nextSpeed = texture2D(nextParticlesSpeed, st);\n\
    float particleDropRate = dropRate + dropRateBump * nextSpeed.a;\n\
\n\
    vec2 seed1 = nextParticle.xy + st;\n\
    vec2 seed2 = nextSpeed.xy + st;\n\
    vec3 randomParticle = generateRandomParticle(seed1, nextParticle.z);\n\
    float randomNumber = rand(seed2, normalRange);\n\
	\n\
    if (randomNumber < particleDropRate || particleOutbound(nextParticle)) {\n\
		gl_FragColor = vec4(randomParticle, 1.0); // 1.0 means this is a random particle\n\
    } else {\n\
		gl_FragColor = vec4(nextParticle, 0.0);\n\
    }\n\
}";

    //This file is automatically rebuilt by the WeatherEarth build process.
    var postProcessingSpeedFS = "uniform sampler2D postProcessingPosition;\n\
uniform sampler2D nextParticlesSpeed;\n\
\n\
varying vec2 v_textureCoordinates;\n\
\n\
void main() {\n\
	//\n\
    vec2 st = v_textureCoordinates;\n\
    // st.x += 0.5;\n\
    // if(st.x > 1.0) st.x -= 1.0;\n\
\n\
\n\
	vec4 randomParticle = texture2D(postProcessingPosition, st);\n\
	vec4 particleSpeed = texture2D(nextParticlesSpeed, st);\n\
	\n\
    if (randomParticle.a > 0.0) {\n\
		gl_FragColor = vec4(0.0);\n\
    } else {\n\
		gl_FragColor = particleSpeed;\n\
    }\n\
}";

    function ParticlesComputing(context, data, userInput, viewerParameters){
        this.createWindTextures(context, data);
        this.createParticlesTextures(context, userInput, viewerParameters, data);
        this.createComputingPrimitives(data, userInput, viewerParameters);
    }

    ParticlesComputing.prototype.createWindTextures = function(context, data) {
        // var windTextureOptions = {
        //     context: context,
        //     width: data.dimensions.lon,
        //     height: data.dimensions.lat * data.dimensions.lev,
        //     pixelFormat: Cesium.PixelFormat.RGBA,
        //     pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE,
        //     flipY: false,
        //     sampler: new Cesium.Sampler({
        //         // the values of texture will not be interpolated
        //         minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
        //         magnificationFilter: Cesium.TextureMagnificationFilter.LINEAR
        //     })
        // };
        //this.windTexturesUV = Util.createTexture(windTextureOptions, data.UV.array);

        this.windTexturesUV = data.textureUV;
        this._attributeMatrix = data._attributeMatrix;
    };

    ParticlesComputing.prototype.createParticlesTextures = function(context, userInput, viewerParameters, data) {
        var particlesTextureOptions = {
            context: context,
            width: userInput.particlesTextureSize,
            height: userInput.particlesTextureSize,
            pixelFormat: Cesium.PixelFormat.RGBA,
            pixelDatatype: Cesium.PixelDatatype.FLOAT,
            flipY: false,
            sampler: new Cesium.Sampler({
                // the values of texture will not be interpolated
                minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
                magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
            })
        };

        var particlesArray = DataProcess.randomizeParticles(userInput.maxParticles, viewerParameters, data);
        var zeroArray = new Float32Array(4 * userInput.maxParticles).fill(0);

        this.particlesTextures = {
            particlesWind: Util.createTexture(particlesTextureOptions),

            currentParticlesPosition: Util.createTexture(particlesTextureOptions, particlesArray),
            nextParticlesPosition: Util.createTexture(particlesTextureOptions, particlesArray),

            currentParticlesSpeed: Util.createTexture(particlesTextureOptions, zeroArray),
            nextParticlesSpeed: Util.createTexture(particlesTextureOptions, zeroArray),

            postProcessingPosition: Util.createTexture(particlesTextureOptions, particlesArray),
            postProcessingSpeed: Util.createTexture(particlesTextureOptions, zeroArray)
        };

        // this.particlesTextures.currentParticlesSpeed.sampler = new Cesium.Sampler({
        //     minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
        //     magnificationFilter: Cesium.TextureMagnificationFilter.LINEAR
        // });
        // this.particlesTextures.nextParticlesSpeed.sampler = new Cesium.Sampler({
        //     minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
        //     magnificationFilter: Cesium.TextureMagnificationFilter.LINEAR
        // });
        // this.particlesTextures.postProcessingSpeed.sampler = new Cesium.Sampler({
        //     minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
        //     magnificationFilter: Cesium.TextureMagnificationFilter.LINEAR
        // });
    };

    ParticlesComputing.prototype.destroyParticlesTextures = function() {
        var that = this;
        Object.keys(this.particlesTextures).forEach( function(key){
            that.particlesTextures[key].destroy();
        });
    };

    ParticlesComputing.prototype.createComputingPrimitives = function(data, userInput, viewerParameters) {
        var dimension = new Cesium.Cartesian3(data.dimensions.lon, data.dimensions.lat, data.dimensions.lev);
        var minimum = new Cesium.Cartesian3(data.lon.min, data.lat.min, data.lev.min);
        var maximum = new Cesium.Cartesian3(data.lon.max, data.lat.max, data.lev.max);
        var interval = new Cesium.Cartesian3(
            (maximum.x - minimum.x) / (dimension.x - 1),
            (maximum.y - minimum.y) / (dimension.y - 1),
            dimension.z > 1 ? (maximum.z - minimum.z) / (dimension.z - 1) : 1.0
        );
        var uSpeedRange = new Cesium.Cartesian2(data.U.min, data.U.max);
        var vSpeedRange = new Cesium.Cartesian2(data.V.min, data.V.max);

        var that = this;
        var windFS = getWindFS;
        data.td = dimension.z > 1;
        if(data.td){
            windFS = '#define THREE_DIMANSION\n' + [getWindFS];
        }

        this.primitives = {
            getWind: new CustomPrimitive({
                commandType: 'Compute',
                uniformMap: {
                    windTexture: function () {
                        return that.windTexturesUV;
                    },
                    currentParticlesPosition: function () {
                        return that.particlesTextures.currentParticlesPosition;
                    },
                    dimension: function () {
                        return dimension;
                    },
                    minimum: function () {
                        return minimum;
                    },
                    maximum: function () {
                        return maximum;
                    },
                    interval: function () {
                        return interval;
                    },
                    u_attribute: function () {
                        return that._attributeMatrix;
                    },
                },
                fragmentShaderSource: new Cesium.ShaderSource({
                    sources: [windFS]
                }),
                outputTexture: this.particlesTextures.particlesWind,
                preExecute: function () {
                    // keep the outputTexture up to date
                    that.primitives.getWind.commandToExecute.outputTexture = that.particlesTextures.particlesWind;
                }
            }),

            updateSpeed: new CustomPrimitive({
                commandType: 'Compute',
                uniformMap: {
                    currentParticlesSpeed: function () {
                        return that.particlesTextures.currentParticlesSpeed;
                    },
                    particlesWind: function () {
                        return that.particlesTextures.particlesWind;
                    },
                    uSpeedRange: function () {
                        return uSpeedRange;
                    },
                    vSpeedRange: function () {
                        return vSpeedRange;
                    },
                    pixelSize: function () {
                        return viewerParameters.pixelSize;
                    },
                    speedFactor: function () {
                        return userInput.speedFactor;
                    }
                },
                fragmentShaderSource: new Cesium.ShaderSource({
                    sources: [updateSpeedFS]
                }),
                outputTexture: this.particlesTextures.nextParticlesSpeed,
                preExecute: function () {
                    // swap textures before binding
                    var temp;
                    temp = that.particlesTextures.currentParticlesSpeed;
                    that.particlesTextures.currentParticlesSpeed = that.particlesTextures.postProcessingSpeed;
                    that.particlesTextures.postProcessingSpeed = temp;

                    // keep the outputTexture up to date
                    that.primitives.updateSpeed.commandToExecute.outputTexture = that.particlesTextures.nextParticlesSpeed;
                }
            }),

            updatePosition: new CustomPrimitive({
                commandType: 'Compute',
                uniformMap: {
                    currentParticlesPosition: function () {
                        return that.particlesTextures.currentParticlesPosition;
                    },
                    currentParticlesSpeed: function () {
                        return that.particlesTextures.currentParticlesSpeed;
                    }
                },
                fragmentShaderSource: new Cesium.ShaderSource({
                    sources: [updatePositionFS]
                }),
                outputTexture: this.particlesTextures.nextParticlesPosition,
                preExecute: function () {
                    // swap textures before binding
                    var temp;
                    temp = that.particlesTextures.currentParticlesPosition;
                    that.particlesTextures.currentParticlesPosition = that.particlesTextures.postProcessingPosition;
                    that.particlesTextures.postProcessingPosition = temp;

                    // keep the outputTexture up to date
                    that.primitives.updatePosition.commandToExecute.outputTexture = that.particlesTextures.nextParticlesPosition;
                }
            }),

            postProcessingPosition: new CustomPrimitive({
                commandType: 'Compute',
                uniformMap: {
                    nextParticlesPosition: function () {
                        return that.particlesTextures.nextParticlesPosition;
                    },
                    nextParticlesSpeed: function () {
                        return that.particlesTextures.nextParticlesSpeed;
                    },
                    lonRange: function () {
                        return viewerParameters.lonRange;
                    },
                    latRange: function () {
                        return viewerParameters.latRange;
                    },
                    randomCoef: function () {
                        var randomCoef = Math.random();
                        return randomCoef;
                    },
                    dropRate: function () {
                        return userInput.dropRate;
                    },
                    dropRateBump: function () {
                        return userInput.dropRateBump;
                    },
                    u_attribute: function () {
                        return that._attributeMatrix;
                    },
                },
                fragmentShaderSource: new Cesium.ShaderSource({
                    sources: [postProcessingPositionFS]
                }),
                outputTexture: this.particlesTextures.postProcessingPosition,
                preExecute: function () {
                    // keep the outputTexture up to date
                    that.primitives.postProcessingPosition.commandToExecute.outputTexture = that.particlesTextures.postProcessingPosition;
                }
            }),

            postProcessingSpeed: new CustomPrimitive({
                commandType: 'Compute',
                uniformMap: {
                    postProcessingPosition: function () {
                        return that.particlesTextures.postProcessingPosition;
                    },
                    nextParticlesSpeed: function () {
                        return that.particlesTextures.nextParticlesSpeed;
                    }
                },
                fragmentShaderSource: new Cesium.ShaderSource({
                    sources: [postProcessingSpeedFS]
                }),
                outputTexture: this.particlesTextures.postProcessingSpeed,
                preExecute: function () {
                    // keep the outputTexture up to date
                    that.primitives.postProcessingSpeed.commandToExecute.outputTexture = that.particlesTextures.postProcessingSpeed;
                }
            })
        };
    };


    ParticlesComputing.prototype.update = function (frameState) {
        this.primitives.getWind.update(frameState);
        this.primitives.updateSpeed.update(frameState);
        this.primitives.updatePosition.update(frameState);
        this.primitives.postProcessingPosition.update(frameState);
        this.primitives.postProcessingSpeed.update(frameState);
    };

    //This file is automatically rebuilt by the WeatherEarth build process.
    var fullscreenVS = "attribute vec3 position;\n\
attribute vec2 st;\n\
varying vec2 textureCoordinate;\n\
\n\
void main() {\n\
    textureCoordinate = st;\n\
	gl_Position = vec4(position, 1.0);\n\
}";

    //This file is automatically rebuilt by the WeatherEarth build process.
    var screenDrawFS = "uniform sampler2D trailsColorTexture;\n\
uniform sampler2D trailsDepthTexture;\n\
uniform mat4 u_attribute; //\n\
\n\
varying vec2 textureCoordinate;\n\
\n\
void main() {\n\
\n\
    float trailsDepth = texture2D(trailsDepthTexture, textureCoordinate).r;\n\
    float globeDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, textureCoordinate));\n\
	float disableGlobe = u_attribute[2][2];\n\
	\n\
    if (trailsDepth < globeDepth || disableGlobe > 0.0) {\n\
        vec4 trailsColor = texture2D(trailsColorTexture, textureCoordinate);\n\
        gl_FragColor = trailsColor;\n\
        //gl_FragColor = vec4(textureCoordinate.x);\n\
    } else {\n\
        gl_FragColor = vec4(0.0);\n\
    }\n\
}";

    //This file is automatically rebuilt by the WeatherEarth build process.
    var segmentDrawVS = "attribute vec2 st;\n\
// it is not normal itself, but used to control normal\n\
attribute vec3 normal; // (point to use, offset sign, not used component)\n\
\n\
uniform sampler2D currentParticlesPosition;\n\
uniform sampler2D postProcessingPosition;\n\
uniform sampler2D postProcessingSpeed;\n\
\n\
uniform float particleHeight;\n\
uniform float aspect;\n\
uniform float pixelSize;\n\
uniform float lineWidth;\n\
\n\
uniform mat4 u_attribute; //\n\
\n\
varying float speedNormalization;\n\
varying vec3 textureCoordinate;\n\
\n\
vec3 convertCoordinate(vec3 lonLatLev) {\n\
    // WGS84 (lon, lat, lev) -> ECEF (x, y, z)\n\
    // see https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates for detail\n\
	\n\
    // WGS 84 geometric constants \n\
    float a = 6378137.0; // Semi-major axis \n\
    float b = 6356752.3142; // Semi-minor axis \n\
    float e2 = 6.69437999014e-3; // First eccentricity squared\n\
\n\
    float latitude = radians(lonLatLev.y);\n\
    float longitude = radians(lonLatLev.x);\n\
\n\
    float cosLat = cos(latitude);\n\
    float sinLat = sin(latitude);\n\
    float cosLon = cos(longitude);\n\
    float sinLon = sin(longitude);\n\
\n\
    float N_Phi = a / sqrt(1.0 - e2 * sinLat * sinLat);\n\
    float h = lonLatLev.z + particleHeight; // it should be high enough otherwise the particle may not pass the terrain depth test\n\
\n\
    float scale = u_attribute[2][3];\n\
    h *= scale;\n\
\n\
    vec3 cartesian = vec3(0.0);\n\
    cartesian.x = (N_Phi + h) * cosLat * cosLon;\n\
    cartesian.y = (N_Phi + h) * cosLat * sinLon;\n\
    cartesian.z = ((b * b) / (a * a) * N_Phi + h) * sinLat;\n\
    return cartesian;\n\
}\n\
\n\
vec4 calcProjectedCoord(vec3 lonLatLev) {\n\
    // the range of longitude in Cesium is [-180, 180] but the range of longitude in the NetCDF file is [0, 360]\n\
    // [0, 180] is corresponding to [0, 180] and [180, 360] is corresponding to [-180, 0]\n\
    //lonLatLev.x = mod(lonLatLev.x + 180.0, 360.0) - 180.0;\n\
    lonLatLev.x = mod(lonLatLev.x + 180.0, 360.0) - 180.0;\n\
    vec3 particlePosition = convertCoordinate(lonLatLev);\n\
    vec4 projectedCoord = czm_modelViewProjection * vec4(particlePosition, 1.0);\n\
    return projectedCoord;\n\
}\n\
\n\
vec4 calcOffset(vec4 currentProjectedCoord, vec4 nextProjectedCoord, float offsetSign) {\n\
    vec2 aspectVec2 = vec2(aspect, 1.0);\n\
    vec2 currentXY = (currentProjectedCoord.xy / currentProjectedCoord.w) * aspectVec2;\n\
    vec2 nextXY = (nextProjectedCoord.xy / nextProjectedCoord.w) * aspectVec2;\n\
\n\
    float offsetLength = lineWidth / 2.0;\n\
    vec2 direction = normalize(nextXY - currentXY);\n\
    vec2 normalVector = vec2(-direction.y, direction.x);\n\
	normalVector.x = normalVector.x / aspect;\n\
    normalVector = offsetLength * normalVector;\n\
\n\
    vec4 offset = vec4(offsetSign * normalVector, 0.0, 0.0);\n\
    return offset;\n\
}\n\
\n\
void main() {\n\
    vec2 particleIndex = st;\n\
    \n\
    float minLon = u_attribute[1][2];\n\
    float maxLon = u_attribute[1][3];\n\
    float minLat = u_attribute[2][0];\n\
    float maxLat = u_attribute[2][1];\n\
    float minZ = u_attribute[3][1];\n\
    float maxZ = u_attribute[3][2];\n\
	vec3 currentPosition = texture2D(currentParticlesPosition, particleIndex).rgb;\n\
	vec4 nextPosition = texture2D(postProcessingPosition, particleIndex);\n\
	\n\
	vec4 currentProjectedCoord = vec4(0.0);\n\
	vec4 nextProjectedCoord = vec4(0.0);\n\
	if (nextPosition.w > 0.0) {\n\
		currentProjectedCoord = calcProjectedCoord(currentPosition);\n\
		nextProjectedCoord = calcProjectedCoord(currentPosition);\n\
	} else {\n\
	    currentProjectedCoord = calcProjectedCoord(currentPosition);\n\
		nextProjectedCoord = calcProjectedCoord(nextPosition.xyz);\n\
	}\n\
\n\
    vec3 lonLatLev = currentPosition;\n\
    if(maxLon - minLon > 300.0)\n\
    {\n\
        lonLatLev.x = mod(lonLatLev.x + 180.0, 360.0);\n\
    }\n\
    float stz = (lonLatLev.z - minZ) / (maxZ - minZ);\n\
    textureCoordinate = vec3((lonLatLev.x - minLon) / (maxLon - minLon)\n\
        ,(lonLatLev.y - minLat) / (maxLat - minLat)\n\
        ,clamp(stz,0.0,1.0));\n\
\n\
    bool tans360to_180 = u_attribute[1][1] == 1.0;\n\
    if(tans360to_180){\n\
      textureCoordinate.x += 0.5;\n\
      if(textureCoordinate.x > 1.0) textureCoordinate.x -= 1.0;\n\
    }\n\
\n\
	float pointToUse = normal.x; // -1 is currentProjectedCoord and +1 is nextProjectedCoord\n\
	float offsetSign = normal.y;\n\
	\n\
    vec4 offset = pixelSize * calcOffset(currentProjectedCoord, nextProjectedCoord, offsetSign);\n\
    if (pointToUse < 0.0) {\n\
        gl_Position = currentProjectedCoord + offset;\n\
    } else {\n\
        gl_Position = nextProjectedCoord + offset;\n\
    }\n\
	\n\
    speedNormalization = texture2D(postProcessingSpeed, particleIndex).a;\n\
}";

    //This file is automatically rebuilt by the WeatherEarth build process.
    var segmentDrawFS = "#ifdef THREE_DIMANSION\n\
precision highp sampler3D;\n\
uniform sampler3D windTexture; // eastward northward wind\n\
#else\n\
uniform sampler2D windTexture; // eastward northward wind\n\
#endif\n\
\n\
uniform sampler2D textureTF;\n\
uniform mat4 u_attribute; //\n\
varying float speedNormalization;\n\
varying vec3 textureCoordinate;\n\
\n\
void main() {\n\
    //gl_FragColor = texture2D(colorTable, vec2(speedNormalization / 70.0, 0.0));\n\
    float filtrationMin = u_attribute[0][3];\n\
    float filtrationMax = u_attribute[1][0];\n\
    float scaler = u_attribute[0][0];\n\
    float clampMin = u_attribute[0][1];\n\
    float clampMax = u_attribute[0][2];\n\
    float clampValue = max(-clampMin,clampMax);\n\
    #ifdef THREE_DIMANSION\n\
    vec4 colorUV = texture3D(windTexture, textureCoordinate);\n\
    #else\n\
    vec4 colorUV = texture2D(windTexture, textureCoordinate.xy);\n\
    #endif\n\
    vec2 valueUV = czm_unpackUV(colorUV, scaler, clampMin);\n\
    float speed = sqrt(valueUV.x * valueUV.x + valueUV.y * valueUV.y);\n\
    gl_FragColor = texture2D(textureTF,vec2(speed / clampValue,0.0));\n\
    //gl_FragColor = texture2D(textureTF, textureCoordinate);\n\
    gl_FragColor.a = speedNormalization;\n\
    if(speed < filtrationMin || speed > filtrationMax) gl_FragColor.a = 0.0;\n\
    //gl_FragColor = vec4(textureCoordinate.x,0.0,0.0,textureCoordinate.x);\n\
}";

    //This file is automatically rebuilt by the WeatherEarth build process.
    var trailDrawFS = "uniform sampler2D segmentsColorTexture;\n\
uniform sampler2D segmentsDepthTexture;\n\
\n\
uniform sampler2D currentTrailsColor;\n\
uniform sampler2D trailsDepthTexture;\n\
\n\
uniform float fadeOpacity;\n\
uniform mat4 u_attribute; //\n\
\n\
varying vec2 textureCoordinate;\n\
\n\
void main() {\n\
    vec4 pointsColor = texture2D(segmentsColorTexture, textureCoordinate);\n\
    vec4 trailsColor = texture2D(currentTrailsColor, textureCoordinate);\n\
\n\
    trailsColor = floor(fadeOpacity * 255.0 * trailsColor) / 255.0; // make sure the trailsColor will be strictly decreased\n\
\n\
    float pointsDepth = texture2D(segmentsDepthTexture, textureCoordinate).r;\n\
    float trailsDepth = texture2D(trailsDepthTexture, textureCoordinate).r;\n\
	float globeDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, textureCoordinate));\n\
	float disableGlobe = u_attribute[2][2];\n\
	gl_FragColor = vec4(0.0);\n\
	if (pointsDepth < globeDepth || disableGlobe > 0.0) {\n\
		gl_FragColor = gl_FragColor + pointsColor;\n\
	}\n\
	if (trailsDepth < globeDepth || disableGlobe > 0.0) \n\
	{\n\
		gl_FragColor = gl_FragColor + trailsColor;\n\
	}\n\
\n\
	gl_FragDepthEXT = min(pointsDepth, trailsDepth);\n\
}";

    function ParticlesRendering(context, data, userInput, viewerParameters, particlesComputing){
        this.createRenderingTextures(context, data);
        this.createRenderingFramebuffers(context);
        this.createRenderingPrimitives(context, userInput, viewerParameters, particlesComputing, data);
    }

    ParticlesRendering.prototype.createRenderingTextures = function(context, data) {
        var colorTextureOptions = {
            context: context,
            width: context.drawingBufferWidth,
            height: context.drawingBufferHeight,
            pixelFormat: Cesium.PixelFormat.RGBA,
            pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE
        };
        var depthTextureOptions = {
            context: context,
            width: context.drawingBufferWidth,
            height: context.drawingBufferHeight,
            pixelFormat: Cesium.PixelFormat.DEPTH_COMPONENT,
            pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT
        };
       
        this.textures = {
            segmentsColor: Util.createTexture(colorTextureOptions),
            segmentsDepth: Util.createTexture(depthTextureOptions),

            currentTrailsColor: Util.createTexture(colorTextureOptions),
            currentTrailsDepth: Util.createTexture(depthTextureOptions),

            nextTrailsColor: Util.createTexture(colorTextureOptions),
            nextTrailsDepth: Util.createTexture(depthTextureOptions),
        };
    };

    ParticlesRendering.prototype.createRenderingFramebuffers = function(context) {
        this.framebuffers = {
            segments: Util.createFramebuffer(context, this.textures.segmentsColor, this.textures.segmentsDepth),
            currentTrails: Util.createFramebuffer(context, this.textures.currentTrailsColor, this.textures.currentTrailsDepth),
            nextTrails: Util.createFramebuffer(context, this.textures.nextTrailsColor, this.textures.nextTrailsDepth)
        };
    };

    ParticlesRendering.prototype.createSegmentsGeometry = function(userInput) {
        var repeatVertex = 4;

        var st = [];
        for (var s = 0; s < userInput.particlesTextureSize; s++) {
            for (var t = 0; t < userInput.particlesTextureSize; t++) {
                for (var i = 0; i < repeatVertex; i++) {
                    st.push(s / userInput.particlesTextureSize);
                    st.push(t / userInput.particlesTextureSize);
                }
            }
        }
        st = new Float32Array(st);

        var normal = [];
        var pointToUse = [-1, 1];
        var offsetSign = [-1, 1];
        for (var i = 0; i < userInput.maxParticles; i++) {
            for (var j = 0; j < repeatVertex / 2; j++) {
                for (var k = 0; k < repeatVertex / 2; k++) {
                    normal.push(pointToUse[j]);
                    normal.push(offsetSign[k]);
                    normal.push(0);
                }
            }
        }
        normal = new Float32Array(normal);

        var indexSize = 6 * userInput.maxParticles;
        var vertexIndexes = new Uint32Array(indexSize);
        for (var i = 0, j = 0, vertex = 0; i < userInput.maxParticles; i++) {
            vertexIndexes[j++] = vertex + 0;
            vertexIndexes[j++] = vertex + 1;
            vertexIndexes[j++] = vertex + 2;
            vertexIndexes[j++] = vertex + 2;
            vertexIndexes[j++] = vertex + 1;
            vertexIndexes[j++] = vertex + 3;
            vertex += 4;
        }

        var geometry = new Cesium.Geometry({
            attributes: new Cesium.GeometryAttributes({
                st: new Cesium.GeometryAttribute({
                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                    componentsPerAttribute: 2,
                    values: st
                }),
                normal: new Cesium.GeometryAttribute({
                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                    componentsPerAttribute: 3,
                    values: normal
                }),
            }),
            indices: vertexIndexes
        });

        return geometry;
    };

    ParticlesRendering.prototype.createRenderingPrimitives = function(context, userInput, viewerParameters, particlesComputing, data) {
        var that = this;

        var segmentDrawFrag = segmentDrawFS;
        data.td = data.dimensions.lev > 1;
        if(data.td){
            segmentDrawFrag = '#define THREE_DIMANSION\n' + [segmentDrawFS];
        }

        this.primitives = {
            segments: new CustomPrimitive({
                commandType: 'Draw',
                attributeLocations: {
                    st: 0,
                    normal: 1
                },
                geometry: this.createSegmentsGeometry(userInput),
                primitiveType: Cesium.PrimitiveType.TRIANGLES,
                uniformMap: {
                    currentParticlesPosition: function () {
                        return particlesComputing.particlesTextures.currentParticlesPosition;
                    },
                    postProcessingPosition: function () {
                        return particlesComputing.particlesTextures.postProcessingPosition;
                    },
                    postProcessingSpeed: function () {
                        return particlesComputing.particlesTextures.postProcessingSpeed;
                    },
                    windTexture: function () {
                        return data.textureUV;
                    },
                    textureTF: function () {
                        return data.textureTF;
                    },
                    aspect: function () {
                        return context.drawingBufferWidth / context.drawingBufferHeight;
                    },
                    pixelSize: function () {
                        return viewerParameters.pixelSize;
                    },
                    lineWidth: function () {
                        return userInput.lineWidth;
                    },
                    particleHeight: function () {
                        return userInput.particleHeight;
                    },
                    u_attribute: function () {
                        return data._attributeMatrix;
                    }
                },
                vertexShaderSource: new Cesium.ShaderSource({
                    sources: [segmentDrawVS]
                }),
                fragmentShaderSource: new Cesium.ShaderSource({
                    sources: [segmentDrawFrag]
                }),
                rawRenderState: Util.createRawRenderState({
                    // undefined value means let Cesium deal with it
                    viewport: undefined,
                    depthTest: {
                        enabled: true
                    },
                    depthMask: true
                }),
                framebuffer: this.framebuffers.segments,
                autoClear: true
            }),

            trails: new CustomPrimitive({
                commandType: 'Draw',
                attributeLocations: {
                    position: 0,
                    st: 1
                },
                geometry: Util.getFullscreenQuad(),
                primitiveType: Cesium.PrimitiveType.TRIANGLES,
                uniformMap: {
                    segmentsColorTexture: function () {
                        return that.textures.segmentsColor;
                    },
                    segmentsDepthTexture: function () {
                        return that.textures.segmentsDepth;
                    },
                    currentTrailsColor: function () {
                        return that.framebuffers.currentTrails.getColorTexture(0);
                    },
                    trailsDepthTexture: function () {
                        return that.framebuffers.currentTrails.depthTexture;
                    },
                    fadeOpacity: function () {
                        return userInput.fadeOpacity;
                    },
                    u_attribute: function () {
                        return data._attributeMatrix;
                    }
                },
                // prevent Cesium from writing depth because the depth here should be written manually
                vertexShaderSource: new Cesium.ShaderSource({
                    defines: ['DISABLE_GL_POSITION_LOG_DEPTH'],
                    sources: [fullscreenVS]
                }),
                fragmentShaderSource: new Cesium.ShaderSource({
                    defines: ['DISABLE_LOG_DEPTH_FRAGMENT_WRITE'],
                    sources: [trailDrawFS]
                }),
                rawRenderState: Util.createRawRenderState({
                    viewport: undefined,
                    depthTest: {
                        enabled: true,
                        func1: Cesium.DepthFunction.ALWAYS // always pass depth test for full control of depth information
                    },
                    depthMask: true
                }),
                framebuffer: this.framebuffers.nextTrails,
                autoClear: true,
                preExecute: function () {
                    // swap framebuffers before binding
                    var temp;
                    temp = that.framebuffers.currentTrails;
                    that.framebuffers.currentTrails = that.framebuffers.nextTrails;
                    that.framebuffers.nextTrails = temp;

                    // keep the framebuffers up to date
                    that.primitives.trails.commandToExecute.framebuffer = that.framebuffers.nextTrails;
                    that.primitives.trails.clearCommand.framebuffer = that.framebuffers.nextTrails;
                }
            }),

            screen: new CustomPrimitive({
                commandType: 'Draw',
                attributeLocations: {
                    position: 0,
                    st: 1
                },
                geometry: Util.getFullscreenQuad(),
                primitiveType: Cesium.PrimitiveType.TRIANGLES,
                uniformMap: {
                    trailsColorTexture: function () {
                        return that.framebuffers.nextTrails.getColorTexture(0);
                    },
                    trailsDepthTexture: function () {
                        return that.framebuffers.nextTrails.depthTexture;
                    },
                    u_attribute: function () {
                        return data._attributeMatrix;
                    }
                },
                // prevent Cesium from writing depth because the depth here should be written manually
                vertexShaderSource: new Cesium.ShaderSource({
                    defines: ['DISABLE_GL_POSITION_LOG_DEPTH'],
                    sources: [fullscreenVS]
                }),
                fragmentShaderSource: new Cesium.ShaderSource({
                    defines: ['DISABLE_LOG_DEPTH_FRAGMENT_WRITE'],
                    sources: [screenDrawFS]
                }),
                rawRenderState: Util.createRawRenderState({
                    viewport: undefined,
                    depthTest: {
                        enabled: false
                    },
                    depthMask: true,
                    blending: {
                        enabled: true
                    }
                }),
                framebuffer: undefined // undefined value means let Cesium deal with it
            })
        };
    };

    ParticlesRendering.prototype.update = function (frameState) {
        this.primitives.segments.update(frameState);
        this.primitives.trails.update(frameState);
        this.primitives.screen.update(frameState);
    };

    function ParticleSystem(context, data, userInput, viewerParameters){
        this.context = context;
        this.data = data;
        this.userInput = userInput;
        this.viewerParameters = viewerParameters;

        this.particlesComputing = new ParticlesComputing(
            this.context, this.data,
            this.userInput, this.viewerParameters
        );
        this.particlesRendering = new ParticlesRendering(
            this.context, this.data,
            this.userInput, this.viewerParameters,
            this.particlesComputing
        );
    }

    ParticleSystem.prototype.canvasResize = function(context) {
        var that = this;
        this.particlesComputing.destroyParticlesTextures();
        //this.particlesComputing.windTexturesUV.destroy();
        //this.particlesRendering.textures.colorTable.destroy();
        Object.keys(this.particlesRendering.framebuffers).forEach(function(key){
            that.particlesRendering.framebuffers[key].destroy();
        });

        this.context = context;
        this.particlesComputing = new ParticlesComputing(
            this.context, this.data,
            this.userInput, this.viewerParameters
        );
        this.particlesRendering = new ParticlesRendering(
            this.context, this.data,
            this.userInput, this.viewerParameters,
            this.particlesComputing
        );
    };

    ParticleSystem.prototype.clearFramebuffers = function() {
        var clearCommand = new Cesium.ClearCommand({
            color: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
            depth: 1.0,
            framebuffer: undefined,
            pass: Cesium.Pass.OPAQUE
        });
        var that = this;
        Object.keys(this.particlesRendering.framebuffers).forEach(function(key){
            clearCommand.framebuffer = that.particlesRendering.framebuffers[key];
            clearCommand.execute(that.context);
        });
    };

    ParticleSystem.prototype.isDestroyed = function () {
        return false;
    };

    ParticleSystem.prototype.destroy = function () {
        if(Cesium.defined(this.particlesComputing)){
            this.particlesComputing.destroyParticlesTextures();
        }
        return Cesium.destroyObject(this);
    };

    ParticleSystem.prototype.refreshParticles = function(maxParticlesChanged) {
        this.clearFramebuffers();

        this.particlesComputing.destroyParticlesTextures();
        this.particlesComputing.createParticlesTextures(this.context, this.userInput, this.viewerParameters,this.data);

        if (maxParticlesChanged) {
            var geometry = this.particlesRendering.createSegmentsGeometry(this.userInput);
            this.particlesRendering.primitives.segments.geometry = geometry;
            var vertexArray = Cesium.VertexArray.fromGeometry({
                context: this.context,
                geometry: geometry,
                attributeLocations: this.particlesRendering.primitives.segments.attributeLocations,
                bufferUsage: Cesium.BufferUsage.STATIC_DRAW,
            });
            this.particlesRendering.primitives.segments.commandToExecute.vertexArray = vertexArray;
        }
    };

    ParticleSystem.prototype.applyUserInput = function(userInput) {
        var maxParticlesChanged = false;
        if (this.userInput.maxParticles != userInput.maxParticles) {
            maxParticlesChanged = true;
        }

        var that = this;
        Object.keys(userInput).forEach(function(key)  {
            that.userInput[key] = userInput[key];
        });
        this.refreshParticles(maxParticlesChanged);
    };

    ParticleSystem.prototype.applyViewerParameters = function(viewerParameters) {
        var that = this;
        Object.keys(viewerParameters).forEach(function(key)  {
            that.viewerParameters[key] = viewerParameters[key];
        });
        this.refreshParticles(false);
    };

    ParticleSystem.prototype.update = function (frameState) {
        if(Cesium.defined(this.particlesComputing)){
            this.particlesComputing.update(frameState);
        }
        if(Cesium.defined(this.particlesRendering)){
            this.particlesRendering.update(frameState);
        }
    };

    function WindImageryLayer(options) {
      var imageryProvider = new CustomImageryProvider(options);
      Cesium.ImageryLayer.call(this, imageryProvider);

      this._showAnimation = false;
      this.panel = {
        maxParticles: 64 * 64,
        particleHeight: 100.0,
        fadeOpacity: 0.996,
        dropRate: 0.003,
        dropRateBump: 0.01,
        speedFactor: 4.0,
        lineWidth: 4.0,
      };

      this.ValueAndColorRamp = options.ValueAndColorRamp;
      var flipX = Cesium.defaultValue(options.flipX, false);
      this.flipY = Cesium.defaultValue(options.flipY, false);
      this.scene = options.scene;
      this.varname = options.varname;
      this._rectangle = options.rectangle;
      this._attributeMatrix = new Cesium.Matrix4(
        0.0 /*scaler*/,
        100.0 /*filtrationMax*/,
        -90.0 /*ymin*/,
        0.0 /*sliceZ*/,
        0.0 /*clampMin*/,
        flipX ? 1.0 : 0.0 /*flipX*/,
        90.0 /*ymax*/,
        0.0 /*zmin*/,
        0.0 /*clampMax*/,
        0.0 /*xmin*/,
        0.0 /*disableGlobeDepth*/,
        1.0 /*zmax*/,
        0.0 /*filtrationMin*/,
        360.0 /*xmax*/,
        1.0 /*scaleHeight*/,
        0.0
      );

      var that = this;
      imageryProvider._readyPromise.then(function (array) {
        that.success(array, options.name);
        that.createComputeCommand();
        imageryProvider._ready = true;
      });
    }

    WindImageryLayer.CreateClassPrototype = function () {
      var prototype = WindImageryLayer.prototype;
      WindImageryLayer.prototype = new Cesium.ImageryLayer({});
      Object.assign(WindImageryLayer.prototype, prototype);
      Object.defineProperties(WindImageryLayer.prototype, {
        filtrationMin: {
          get: function () {
            return this._attributeMatrix[3];
          },
          set: function (value) {
            if (this._attributeMatrix[3] !== value) {
              this._attributeMatrix[3] = value;
              if (Cesium.defined(this.imageryProvider._computeCommand)) {
                this._reprojectComputeCommands.push(
                  this.imageryProvider._computeCommand
                );
              }
            }
          },
        },
        filtrationMax: {
          get: function () {
            return this._attributeMatrix[4];
          },
          set: function (value) {
            if (this._attributeMatrix[4] !== value) {
              this._attributeMatrix[4] = value;
              if (Cesium.defined(this.imageryProvider._computeCommand)) {
                this._reprojectComputeCommands.push(
                  this.imageryProvider._computeCommand
                );
              }
            }
          },
        },
        showAnimation: {
          get: function () {
            return this._showAnimation;
          },
          set: function (value) {
            this._showAnimation = value;
          },
        },
        disableGlobelDepth: {
          get: function () {
            return this._attributeMatrix[10] === 1.0;
          },
          set: function (value) {
            this._attributeMatrix[10] = value ? 1.0 : 0.0;
          },
        },
        scaleHeight: {
          get: function () {
            return this._attributeMatrix[11];
          },
          set: function (value) {
            this._attributeMatrix[11] = value;
          },
        },
        sliceZ: {
          get: function () {
            return this._attributeMatrix[12];
          },
          set: function (value) {
            if (this._attributeMatrix[12] !== value) {
              this._attributeMatrix[12] = Cesium.Math.clamp(value, 0.0, 1.0);
              if (Cesium.defined(this.imageryProvider._computeCommand)) {
                this._reprojectComputeCommands.push(
                  this.imageryProvider._computeCommand
                );
              }
            }
          },
        },
      });
    };

    WindImageryLayer.prototype.createComputeCommand = function () {
      var context = this.scene.context;
      var is3dTex = this.texture._depth > 1;
      var ReprojectWebMercatorFS =
        "precision highp sampler3D;\n\
  uniform " +
        (is3dTex ? "sampler3D" : "sampler2D") +
        " u_texture;\n\
  uniform sampler2D u_textureTF;\n\
  uniform mat4 u_attribute;\n\
  varying vec2 v_textureCoordinates;\n\
  void main()\n\
  {\n\
    float sliceZ = u_attribute[3][0];\n\
    float filtrationMin = u_attribute[0][3];\n\
    float filtrationMax = u_attribute[1][0];\n\
    float scaler = u_attribute[0][0];\n\
    float clampMin = u_attribute[0][1];\n\
    float clampMax = u_attribute[0][2];\n\
    float clampValue = max(-clampMin,clampMax);\n\
    vec2 st = v_textureCoordinates;\n\
    bool tans360to_180 = u_attribute[1][1] == 1.0;\n\
    if(tans360to_180){\n\
      st.x += 0.5;\n\
      if(st.x > 1.0) st.x -= 1.0;\n\
    }\n" +
        "vec4 colorUV = " +
        (is3dTex
          ? "texture3D(u_texture, vec3(st,sliceZ));\n"
          : "texture2D(u_texture, st);\n") +
        "vec2 valueUV = czm_unpackUV(colorUV, scaler, clampMin);\n\
    float speed = sqrt(valueUV.x * valueUV.x + valueUV.y * valueUV.y);\n\
    gl_FragColor = texture2D(u_textureTF,vec2(speed / clampValue,0.0));\n\
    if(speed < filtrationMin || speed > filtrationMax) gl_FragColor.a = 0.0;\n\
  }\n\
  ";

      var that = this;
      var uniformMap = {
        u_texture: function () {
          return that.texture;
        },
        u_textureTF: function () {
          return that.textureTF;
        },
        u_attribute: function () {
          return that._attributeMatrix;
        },
      };

      this._imageryProvider.createReprojectCommand(
        uniformMap,
        ReprojectWebMercatorFS,
        context,
        this.texture
      );
    };

    WindImageryLayer.prototype._createTextureWebGL = function (context, imagery) {
      return undefined;
    };

    WindImageryLayer.prototype.success = function (volumeData, name) {
      var context = this.scene.context;
      this._attributeMatrix[0] = volumeData.u_s_o.scaler;
      this._attributeMatrix[1] = volumeData.u_s_o.clampMin;
      this._attributeMatrix[2] = volumeData.u_s_o.clampMax;
      this.volumeData = volumeData;
      this.textureTF = WeatherVolumeLibrary.createTransferTexture(
        context,
        this.ValueAndColorRamp,
        volumeData.u_s_o.clampMax,
        0,
        Cesium.TextureMinificationFilter.LINEAR,
        Cesium.TextureMagnificationFilter.LINEAR
      );

      if (!Cesium.defined(this.rectangle)) {
        this._rectangle = Cesium.Rectangle.fromDegrees(
          volumeData.extent.xmin,
          volumeData.extent.ymin,
          volumeData.extent.xmax,
          volumeData.extent.ymax
        );
      }

      this.imageryProvider._tilingScheme = new Cesium.GeographicTilingScheme({
        rectangle: this._rectangle,
        numberOfLevelZeroTilesX: 1,
        numberOfLevelZeroTilesY: 1,
        ellipsoid: this.scene.globe.ellipsoid,
      });

      this.texture = new Cesium.Texture({
        context: context,
        source: volumeData.source,
        pixelFormat: Cesium.PixelFormat.RGBA,
        flipY: this.flipY,
      });
    };

    WindImageryLayer.prototype.removeAnimation = function () {
      if (Cesium.defined(this.particleSystem)) {
        this.particleSystem = this.particleSystem && this.particleSystem.destroy();
      }
      if (Cesium.defined(this._moveStartSubscription)) {
        this._moveStartSubscription();
      }

      if (Cesium.defined(this._moveEndSubscription)) {
        this._moveEndSubscription();
      }
    };

    WindImageryLayer.prototype.createAnimation = function (context, camera) {
      if (Cesium.defined(this.particleSystem)) {
        return;
      }

      this.viewerParameters = {
        lonRange: new Cesium.Cartesian2(),
        latRange: new Cesium.Cartesian2(),
        pixelSize: 0.0,
      };
      // use a smaller earth radius to make sure distance to camera > 0
      this.globeBoundingSphere = new Cesium.BoundingSphere(
        Cesium.Cartesian3.ZERO,
        0.99 * 6378137.0
      );
      this.updateViewerParameters(context, camera);

      var data = {};

      data.u_s_o = this.volumeData.u_s_o;
      data.dimensions = {};
      data.dimensions.lon = this.volumeData.source.width;
      data.dimensions.lat = this.volumeData.source.height;
      data.dimensions.lev = this.volumeData.source.depth;

      data.lon = {};
      data.lon.min = this.volumeData.extent.xmin;
      data.lon.max = this.volumeData.extent.xmax;

      data.lat = {};
      data.lat.min = this.volumeData.extent.ymin;
      data.lat.max = this.volumeData.extent.ymax;

      this._attributeMatrix[6] = this.volumeData.extent.xmin;
      this._attributeMatrix[7] = this.volumeData.extent.xmax;
      this._attributeMatrix[8] = this.volumeData.extent.ymin;
      this._attributeMatrix[9] = this.volumeData.extent.ymax;

      this._attributeMatrix[14] = this.volumeData.meter.depth;

      data.lev = {};
      data.lev.min = 1;
      data.lev.max = data.dimensions.lev > 1 ? this._attributeMatrix[14] : 1;

      data.UV = {};
      data.U = {};
      data.V = {};
      data.U.min = data.u_s_o.clampMin;
      data.U.max = data.u_s_o.clampMax;

      data.V.min = data.u_s_o.clampMin;
      data.V.max = data.u_s_o.clampMax;

      data.textureUV = this.texture;
      data.textureTF = this.textureTF;
      data._attributeMatrix = this._attributeMatrix;
      this.particleSystem = new ParticleSystem(
        context,
        data,
        this.getUserInput(),
        this.viewerParameters
      );

      var that = this;
      this._moveStartSubscription = camera.moveStart.addEventListener(function () {
        that.dirty = true;
      });
      this._moveEndSubscription = camera.moveEnd.addEventListener(function () {
        that.dirty = true;
      });
    };

    WindImageryLayer.prototype.destroy = function () {
      if (Cesium.defined(this.particleSystem)) {
        this.removeAnimation();
      } else {
        this.texture = this.texture && this.texture.destroy();
      }
      this.textureTF = this.textureTF && this.textureTF.destroy();
      return Cesium.destroyObject(this);
    };

    WindImageryLayer.prototype.applyUserInput = function (userInput) {
      this.particleSystem.applyUserInput(userInput);
    };

    WindImageryLayer.prototype.updateViewerParameters = function (context, camera) {
      var viewRectangle = camera.computeViewRectangle(Cesium.Ellipsoid.WGS84);
      var lonLatRange = Util.viewRectangleToLonLatRange(viewRectangle);
      this.viewerParameters.lonRange.x = lonLatRange.lon.min;
      this.viewerParameters.lonRange.y = lonLatRange.lon.max;
      this.viewerParameters.latRange.x = lonLatRange.lat.min;
      this.viewerParameters.latRange.y = lonLatRange.lat.max;

      var pixelSize = camera.getPixelSize(
        this.globeBoundingSphere,
        context.drawingBufferWidth,
        context.drawingBufferHeight
      );
      if (pixelSize > 0) {
        this.viewerParameters.pixelSize = Cesium.Math.clamp(
          pixelSize,
          1000.0,
          pixelSize + 1.0
        );
      }
      pixelSize = 1000.0;
    };

    WindImageryLayer.prototype.getUserInput = function () {
      var particlesTextureSize = Math.ceil(Math.sqrt(this.panel.maxParticles));
      this.panel.maxParticles = particlesTextureSize * particlesTextureSize;

      return {
        particlesTextureSize: particlesTextureSize,
        maxParticles: this.panel.maxParticles,
        particleHeight: this.panel.particleHeight,
        fadeOpacity: this.panel.fadeOpacity,
        dropRate: this.panel.dropRate,
        dropRateBump: this.panel.dropRateBump,
        speedFactor: this.panel.speedFactor,
        lineWidth: this.panel.lineWidth,
      };
    };

    WindImageryLayer.prototype.update = function (frameState) {
      if (
        frameState.passes.render &&
        this.showAnimation &&
        Cesium.defined(this.imageryProvider) &&
        Cesium.defined(this.texture)
      ) {
        this.createAnimation(frameState.context, frameState.camera);

        if (!Cesium.defined(this.contextWidth)) {
          this.contextWidth = frameState.context.drawingBufferWidth;
          this.contextHeight = frameState.context.drawingBufferHeight;
        } else if (
          this.contextWidth !== frameState.context.drawingBufferWidth ||
          this.contextHeight !== frameState.context.drawingBufferHeight
        ) {
          this.particleSystem.canvasResize(frameState.context);
          this.contextWidth = frameState.context.drawingBufferWidth;
          this.contextHeight = frameState.context.drawingBufferHeight;
        }

        if (this.dirty) {
          this.updateViewerParameters(frameState.context, frameState.camera);
          this.particleSystem.applyViewerParameters(this.viewerParameters);
          this.particleSystem.refreshParticles(false);
          //this.particleSystem.particlesComputing.update(frameState);

          this.dirty = false;
          return;
        }
        this.particleSystem.update(frameState);
      } else {
        this.removeAnimation();
      }
    };

    function WeatherVolumeRectangle(){

    }

    WeatherVolumeRectangle.create = function(weatherVolume){
        var rectangle = weatherVolume.inner.rectangle;
        var height = 0;
        var extrudedHeight = weatherVolume.inner.meter.depth;
        var instances = [];
        var rectangleGeometry = new Cesium.RectangleGeometry({ 
            rectangle: rectangle, 
            granularity: Cesium.Math.RADIANS_PER_DEGREE * 0.1, 
            height: height, 
            extrudedHeight: extrudedHeight
        });
        
        var geometry = Cesium.RectangleGeometry.createGeometry(rectangleGeometry);
        
        var rectangleInstance = new Cesium.GeometryInstance({
            geometry: geometry,
        });  
        instances.push(rectangleInstance);
        var surface = new Cesium.Primitive({ 
            geometryInstances: instances, 
            asynchronous: false,
            debugShowBoundingVolume: false
        });

        surface.appearance = new Cesium.MaterialAppearance({
            renderState: {
              depthTest: { enabled: true },
              depthMask: true,
              blending: Cesium.BlendingState.ALPHA_BLEND,
              cull: {
                enabled: false,
                face: Cesium.CullFace.FRONT
              }
            },
            translucent: false,
            vertexShaderSource: "attribute vec3 position3DHigh;\n\
        attribute vec3 position3DLow;\n\
            attribute vec3 normal;\n\
            attribute vec2 st;\n\
            attribute float batchId;\n\
            varying vec3 v_positionEC;\n\
            varying vec3 v_normalEC;\n\
            varying vec2 v_st;\n\
            varying float v_batchId;\n\
            void main()\n\
        {\n\
            vec4 p = czm_computePosition();\n\
            v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n\
            v_normalEC = czm_normal * normal;\n\
            v_st = st;\n\
            v_batchId = batchId;\n\
            gl_Position = czm_modelViewProjectionRelativeToEye * p;\n\
            }\n\
        ",
        });

        var _uniforms = {
          baseTexture: weatherVolume.inner.texture,
          tfTexture: weatherVolume.inner._textureTF,
          clipMatrix: weatherVolume.inner._clipMatrix,
          u_attribute: weatherVolume.inner._attributeMatrix,
        };

        var fs = weatherVolume._TransFunction + 
        "    czm_material czm_getMaterial(czm_materialInput materialInput) {\n" +
        "    czm_material material = czm_getDefaultMaterial(materialInput); \n" +    
        "    vec2 st = materialInput.st; \n" +
        "    vec4 color = vec4(st.xy,1.0,1.0); \n" +
        "    color = texture3D(baseTexture, vec3(st.x,st.y,0.0)); \n" +
        "    float scaler = u_attribute[0][0];\n" + 
        "    float offset = u_attribute[0][1];\n" + 
        "    bool usePhongLight = u_attribute[0][3] > 0.0; \n" + 
        "    float value = czm_unpackVolume(color,scaler,offset);\n" + 
        "    color = v_transfer(value,0.0,!usePhongLight,color);\n" + 
        "    material.alpha = color.a; \n" +
        "    material.diffuse = color.rgb; \n" +
        "    material.specular = 0.0; \n" + // Specular mountain tops
        "    material.shininess = 0.0; \n" + // Sharpen highlight
        "    return material; \n" +
        "} \n"
        ;

        var i = 0;
        Object.keys(_uniforms).forEach(function(element){
            var re = new RegExp(element + "\\b", "g");
            fs = fs.replace(re, element + '_' + i++);
        });

        surface.appearance.material = new Cesium.Material({
            translucent: false,
            fabric: {      
              uniforms: _uniforms,
              source: fs,
            },
        });

        return surface;
    };

    function VolumeImageryLayer(options) {
      var imageryProvider = new CustomImageryProvider(options);
      Cesium.ImageryLayer.call(this, imageryProvider, options);
      this._we = options.we;
      this.scene = this._we.viewer.scene;
      this._currentName = this.name = options.name;
      this.varname = options.varname;
      this.TransFunction = options.TransFunction;
      this.ValueAndColorRamp = options.ValueAndColorRamp;
      this.ValueAndColorRampChild = options.ValueAndColorRampChild;
      this._postData = options.postData;

      this._readyPromise = Cesium.when.defer();
      var that = this;
      imageryProvider._readyPromise.then(function (array) {
        that.success(array, options.name);
        that.createComputeCommand();
        imageryProvider._ready = true;
        that._readyPromise.resolve(that._weatherVolume);
      });

      this.byteLength = 0;
      this._position = options.position;
      this._showChildVolume = true;
      this._buildChildVolume = false;
      this._dirty = false;
      this._showGrid = false;
      this._gridTexture = undefined;
      this._reCompute = false;
      this._showInner = Cesium.defaultValue(options.showInner, true);
      this._showVolumeRectangle = false;
      this._volumeRectangle = undefined;
      this._enableCaches = Cesium.defaultValue(options.enableCaches, false);
      this._caches = new Cesium.AssociativeArray();
      this._timeSampleArray = undefined;
      this._contentChangedEvent = new Cesium.Event();
      this._removeEventSubscription = this._contentChangedEvent.addEventListener(
        VolumeImageryLayer.prototype._onContentChanged,
        this
      );
    }

    VolumeImageryLayer.CreateClassPrototype = function () {
      var prototype = VolumeImageryLayer.prototype;
      VolumeImageryLayer.prototype = new Cesium.ImageryLayer({});
      Object.assign(VolumeImageryLayer.prototype, prototype);

      Object.defineProperties(VolumeImageryLayer.prototype, {
        readyPromise: {
          get: function () {
            return this._readyPromise.promise;
          },
        },
        rectangle: {
          get: function () {
            return this._imageryProvider.rectangle;
          },
        },
        timeSampleArray: {
          get: function () {
            return this._timeSampleArray;
          },
          set: function (value) {
            this._timeSampleArray = value;
          },
        },
        contentChangedEvent: {
          get: function () {
            return this._contentChangedEvent;
          },
        },
        weatherVolume: {
          get: function () {
            return this._weatherVolume;
          },
        },
        childWeatherVolume: {
          get: function () {
            return this._childWeatherVolume;
          },
        },
        currentName: {
          get: function () {
            return this._currentName;
          },
          set: function (value) {
            if (this._currentName !== value) {
              this._currentName = value;
              this._dirty = true;
            }
          },
        },
        showVolumeRectangle: {
          get: function () {
            return this._showVolumeRectangle;
          },
          set: function (value) {
            this._showVolumeRectangle = value;
          },
        },
        showInner: {
          get: function () {
            return this._showInner;
          },
          set: function (value) {
            this._showInner = value;
          },
        },
        showChildVolume: {
          get: function () {
            return this._showChildVolume;
          },
          set: function (value) {
            this._showChildVolume = value;
          },
        },
        buildChildVolume: {
          get: function () {
            return this._buildChildVolume;
          },
          set: function (value) {
            this._buildChildVolume = value;
            if (!value) {
              this.removeChildVolume();
            }
          },
        },
        showGrid: {
          get: function () {
            return this._showGrid;
          },
          set: function (value) {
            if (value && !Cesium.defined(this._gridTexture)) {
              this._gridTexture = Util.createRadarTexture(
                this.scene.context,
                460 * this.imageryProvider.ffx * 2,
                this.imageryProvider.ffx * 2
              );
            }
            this._reCompute = this._showGrid !== value;
            this._showGrid = value;
          },
        },
      });
    };

    VolumeImageryLayer.prototype._createTextureWebGL = function (context, imagery) {
      return undefined;
    };

    VolumeImageryLayer.prototype._onContentChanged = function (
      entity,
      propertyName,
      newValue,
      oldValue
    ) {
      if (propertyName == "onLoadNew") {
        this._onLoadNew(newValue, oldValue);
      }
    };

    VolumeImageryLayer.prototype._onLoadNew = function (newValue, oldValue) { };

    VolumeImageryLayer.prototype.loadData = function (name) {
      this._isLoading = true;

      if (this._enableCaches && this._caches.contains(name)) {
        var data = this._caches.get(name);
        this.success(data, name);
      } else {
        var that = this;
        var postData = Cesium.defined(this._postData) ? name: undefined;
        this._imageryProvider.requestData(name,postData).then((data) => {
          // if (that._enableCaches) {
          //   that._caches.set(name, data);
          // }
          that.success(data, name);
        }).otherwise((error) => {
          console.log(error);
          that._isLoading = false;
        });
      }
    };

    VolumeImageryLayer.prototype.success = function (volumeData, name) {
      if (name !== this._currentName) {
        this._isLoading = false;
        return;
      }

      if (
        this.byteLength === volumeData.source.arrayBufferView.length &&
        Cesium.defined(this._weatherVolume) &&
        Cesium.defined(this._weatherVolume.inner.texture)
      ) {
        this._weatherVolume.inner.texture.copyFrom(volumeData.source);
        this._reCompute = true;
      } else {
        this.byteLength = volumeData.source.arrayBufferView.length;
        var options = {};
        options.TransFunction = this.TransFunction;
        options.ValueAndColorRamp = this.ValueAndColorRamp;
        options.source = volumeData;
        options.name = name;
        options.varname = this.varname;
        options.sourceRelease = true;

        if(Cesium.defined(this._position)){
          volumeData.position = this._position;
        }

        this._weatherVolume = this._weatherVolume && this._weatherVolume.destroy();
        var weatherVolume = this._weatherVolume = new WeatherVolume(this.scene, options);
        this._we.globalVolumeState.setVolume(weatherVolume);

        var imageryProvider = this.imageryProvider;
        imageryProvider._tilingScheme = new Cesium.GeographicTilingScheme({
          rectangle: weatherVolume.inner.rectangle,
          numberOfLevelZeroTilesX: 1,
          numberOfLevelZeroTilesY: 1,
          ellipsoid: this.scene.globe.ellipsoid,
        });
      }

      this._contentChangedEvent.raiseEvent(
        this,
        "onLoadNew",
        name,
        this._currentName
      );

      this._isLoading = false;
    };

    VolumeImageryLayer.prototype.createComputeCommand = function () {
      var weatherVolume = this._weatherVolume;
      var that = this;
      var uniformMap = {
        baseTexture: function () {
          return weatherVolume.inner.texture;
        },
        tfTexture: function () {
          return weatherVolume.inner._textureTF;
        },
        gridTexture: function () {
          return that._showGrid
            ? that._gridTexture
            : that.scene.context.defaultTexture;
        },
        showGrid: function () {
          return that._showGrid ? 1.0 : 0.0;
        },
        u_attribute: function () {
          return weatherVolume.inner._attributeMatrix;
        },
        clipMatrix: function () {
          return weatherVolume.inner._clipMatrix;
        },
        statisticMatrix: function () {
          return weatherVolume.inner._statisticMatrix;
        },
      };

      var ReprojectWebMercatorFS =
        "precision highp sampler3D;\n" +
        "uniform sampler3D baseTexture;\n" +
        "uniform sampler2D tfTexture;\n" +
        "uniform sampler2D gridTexture;\n" +
        "uniform mat4 u_attribute;\n" +
        "uniform mat4 clipMatrix;\n" +
        "uniform mat4 statisticMatrix;\n" +
        "uniform float showGrid;\n" +
        "varying vec2 v_textureCoordinates;\n" +
        weatherVolume._TransFunction +
        "void main()\n" +
        "{\n" +
        "  float scaler = u_attribute[0][0];\n" +
        "  float offset = u_attribute[0][1];\n" +
        "  float filtrationmin = clipMatrix[3][2];\n" +
        "  float filtrationmax = clipMatrix[3][3];\n" +
        "  vec2 st = v_textureCoordinates;\n" +
        "  vec4 color = texture3D(baseTexture, vec3(st,0.0));\n" +
        "  float value = czm_unpackVolume(color,scaler,offset);\n" +
        "  bool usePhongLight = u_attribute[0][3] > 0.0; \n" +
        "  for(float i=0.1;i<=1.0;i+=0.001)\n" +
        "  {\n" +
        "      color = texture3D(baseTexture, vec3(st,i));\n" +
        "      value = max(value,czm_unpackVolume(color,scaler,offset));\n" +
        "  }\n" +
        "  color = v_transfer(value,0.0,!usePhongLight,color);\n" +
        "  if(value > filtrationmax || value < filtrationmin)\n" +
        "  {\n" +
        "    color.a = 0.0;\n" +
        "  }\n" +
        "  //vec2 toCenter = st - vec2(0.5,0.5);\n" +
        "  //if(length(toCenter) < 0.01){\n" +
        "  //  color.a = 0.0;\n" +
        "  //}\n" +
        "  if(showGrid > 0.0){ \n" +
        "   vec4 colorGrid = texture2D(gridTexture, st);\n" +
        "   if(color.a > 0.0)\n" +
        "     color.a = 1.0;\n" +
        "   gl_FragColor = mix(color,colorGrid,clamp(colorGrid.a,0.0,color.a == 1.0?0.5:1.0));\n" +
        "  } else {\n" +
        "   if(color.a == 0.0) discard;\n" +
        "   color.a = 1.0;\n" +
        "   gl_FragColor = color;\n" +
        "  }\n" +
        "}";

      this._imageryProvider.createReprojectCommand(
        uniformMap,
        ReprojectWebMercatorFS,
        this.scene.context,
        weatherVolume.inner.texture
      );
    };

    VolumeImageryLayer.prototype.destroy = function () {
      this.removeChildVolume();
      this._weatherVolume = this._weatherVolume && this._weatherVolume.destroy();
      this._removeEventSubscription();
      return Cesium.destroyObject(this);
    };

    VolumeImageryLayer.prototype.updateData = function () {
      if (this._isLoading) {
        return;
      }

      this.loadData(this._currentName);
    };

    VolumeImageryLayer.prototype.updateTime = function (frameState) {
      if (Cesium.defined(this.timeSampleArray)) {
        var index = this.timeSampleArray.getIndex(frameState.time);
        var url = this.timeSampleArray.getUrl(index);
        if (Cesium.defined(url)) {
          if (this._currentIndex !== index) {
            this.currentName = url;
            this._currentIndex = index;
          }
        }
      }
    };

    VolumeImageryLayer.prototype.update = function (frameState) {
      if (!this._imageryProvider._ready) {
        return;
      }

      if (Cesium.defaultValue(frameState.shouldAnimate, false)) {
        this.updateTime(frameState);
      }

      if (this._dirty) {
        this._dirty = false;
        this.updateData();
      }

      if (this._reCompute) {
        this._reCompute = false;
        if (Cesium.defined(this.imageryProvider._computeCommand)) {
          this._reprojectComputeCommands.push(this.imageryProvider._computeCommand);
        }
      }

      if (Cesium.defined(this._weatherVolume)) {
        frameState.showInner = this.showInner;
        this._weatherVolume.update(frameState);
      }

      if (this.buildChildVolume && !Cesium.defined(this._childWeatherVolume)) {
        this.addChildVolume(this.rectangle);
      }

      if (
        (this.buildChildVolume || this._showChildVolume) &&
        Cesium.defined(this._childWeatherVolume)
      ) {
        frameState.showInner = true;
        this._childWeatherVolume.update(frameState);
      }

      //test extrusion
      if (this._showVolumeRectangle) {
        if (!Cesium.defined(this._volumeRectangle)) {
          this._volumeRectangle = WeatherVolumeRectangle.create(
            this._weatherVolume
          );
        }
        this._volumeRectangle.update(frameState);
      }
    };

    VolumeImageryLayer.prototype.removeChildVolume = function () {
      this._childWeatherVolume =
        this._childWeatherVolume && this._childWeatherVolume.destroy();
    };

    VolumeImageryLayer.prototype.addChildVolume = function (rectangle) {
      this.removeChildVolume();
      var that = this;
      if (Cesium.defined(this._weatherVolume)) {
        var chopSource = this._weatherVolume.chop2(rectangle);
        if (Cesium.defined(chopSource)) {
          var volumeOptions = {
            name: this.name + "_child",
            varname: this.varname,
            source: chopSource,
            TransFunction: this.TransFunction,
            ValueAndColorRamp: this.ValueAndColorRampChild,
            region: chopSource.region,
          };

          if (Cesium.defined(this.ValueAndColorRampChild)) {
            chopSource.textureTF = undefined;
          }

          var weatherVolume = new WeatherVolume(this._we.scene, volumeOptions);
          weatherVolume.readyPromise.then(function (weatherVolume) {
            weatherVolume.setState(that._we.globalVolumeState.childState);
            that._childWeatherVolume = weatherVolume;
          });
        }
      }
    };

    var MimeTypes$1 = {
      avi: "video/x-msvideo",
      bmp: "image/bmp",
      bz2: "application/x-bzip2",
      chm: "application/vnd.ms-htmlhelp",
      css: "text/css",
      csv: "text/csv",
      doc: "application/msword",
      dvi: "application/x-dvi",
      eps: "application/postscript",
      flv: "video/x-flv",
      gif: "image/gif",
      gz: "application/x-gzip",
      htm: "text/html",
      html: "text/html",
      ico: "image/vnd.microsoft.icon",
      jnlp: "application/x-java-jnlp-file",
      jpeg: "image/jpeg",
      jpg: "image/jpeg",
      m3u: "audio/x-mpegurl",
      m4v: "video/mp4",
      mathml: "application/mathml+xml",
      mid: "audio/midi",
      midi: "audio/midi",
      mov: "video/quicktime",
      mp3: "audio/mpeg",
      mp4: "video/mp4",
      mp4v: "video/mp4",
      mpeg: "video/mpeg",
      mpg: "video/mpeg",
      odp: "application/vnd.oasis.opendocument.presentation",
      ods: "application/vnd.oasis.opendocument.spreadsheet",
      odt: "application/vnd.oasis.opendocument.text",
      ogg: "application/ogg",
      pdf: "application/pdf",
      png: "image/png",
      pps: "application/vnd.ms-powerpoint",
      ppt: "application/vnd.ms-powerpoint",
      ps: "application/postscript",
      qt: "video/quicktime",
      rdf: "application/rdf+xml",
      rss: "application/rss+xml",
      rtf: "application/rtf",
      svg: "image/svg+xml",
      swf: "application/x-shockwave-flash",
      text: "text/plain",
      tif: "image/tiff",
      tiff: "image/tiff",
      txt: "text/plain",
      wav: "audio/x-wav",
      wma: "audio/x-ms-wma",
      wmv: "video/x-ms-wmv",
      xml: "application/xml",
      zip: "application/zip",

      detectFromFilename: function (filename) {
        var ext = filename.toLowerCase();
        ext = Cesium.getExtensionFromUri(ext);
        return MimeTypes$1[ext];
      },
    };

    var parser;
    if (typeof DOMParser !== "undefined") {
      parser = new DOMParser();
    }

    var autolinker;

    var BILLBOARD_SIZE = 32;

    var BILLBOARD_NEAR_DISTANCE = 2414016;
    var BILLBOARD_NEAR_RATIO = 1.0;
    var BILLBOARD_FAR_DISTANCE = 1.6093e7;
    var BILLBOARD_FAR_RATIO = 0.1;

    var kmlNamespaces = [
      null,
      undefined,
      "http://www.opengis.net/kml/2.2",
      "http://earth.google.com/kml/2.2",
      "http://earth.google.com/kml/2.1",
      "http://earth.google.com/kml/2.0",
    ];
    var gxNamespaces = ["http://www.google.com/kml/ext/2.2"];
    var atomNamespaces = ["http://www.w3.org/2005/Atom"];
    var namespaces = {
      kml: kmlNamespaces,
      gx: gxNamespaces,
      atom: atomNamespaces,
      kmlgx: kmlNamespaces.concat(gxNamespaces),
    };

    // Ensure Specs/Data/KML/unsupported.kml is kept up to date with these supported types
    var featureTypes = {
      Document: processDocument,
      Folder: processFolder,
      Placemark: processPlacemark,
      NetworkLink: processNetworkLink,
      GroundOverlay: processGroundOverlay,
      PhotoOverlay: processUnsupportedFeature,
      ScreenOverlay: processUnsupportedFeature,
      Tour: processTour,
    };

    function DeferredLoading(dataSource) {
      this._dataSource = dataSource;
      this._deferred = Cesium.when.defer();
      this._stack = [];
      this._promises = [];
      this._timeoutSet = false;
      this._used = false;

      this._started = 0;
      this._timeThreshold = 1000; // Initial load is 1 second
    }

    Object.defineProperties(DeferredLoading.prototype, {
      dataSource: {
        get: function () {
          return this._dataSource;
        },
      },
    });

    DeferredLoading.prototype.addNodes = function (nodes, processingData) {
      this._stack.push({
        nodes: nodes,
        index: 0,
        processingData: processingData,
      });
      this._used = true;
    };

    DeferredLoading.prototype.addPromise = function (promise) {
      this._promises.push(promise);
    };

    DeferredLoading.prototype.wait = function () {
      // Case where we had a non-document/folder as the root
      var deferred = this._deferred;
      if (!this._used) {
        deferred.resolve();
      }

      return Cesium.when.join(deferred.promise, Cesium.when.all(this._promises));
    };

    DeferredLoading.prototype.process = function () {
      var isFirstCall = this._stack.length === 1;
      if (isFirstCall) {
        this._started = KmlDataSource._getTimestamp();
      }

      return this._process(isFirstCall);
    };

    DeferredLoading.prototype._giveUpTime = function () {
      if (this._timeoutSet) {
        // Timeout was already set so just return
        return;
      }

      this._timeoutSet = true;
      this._timeThreshold = 50; // After the first load lower threshold to 0.5 seconds
      var that = this;
      setTimeout(function () {
        that._timeoutSet = false;
        that._started = KmlDataSource._getTimestamp();
        that._process(true);
      }, 0);
    };

    DeferredLoading.prototype._nextNode = function () {
      var stack = this._stack;
      var top = stack[stack.length - 1];
      var index = top.index;
      var nodes = top.nodes;
      if (index === nodes.length) {
        return;
      }
      ++top.index;

      return nodes[index];
    };

    DeferredLoading.prototype._pop = function () {
      var stack = this._stack;
      stack.pop();

      // Return false if we are done
      if (stack.length === 0) {
        this._deferred.resolve();
        return false;
      }

      return true;
    };

    DeferredLoading.prototype._process = function (isFirstCall) {
      var dataSource = this.dataSource;
      var processingData = this._stack[this._stack.length - 1].processingData;

      var child = this._nextNode();
      while (Cesium.defined(child)) {
        var featureProcessor = featureTypes[child.localName];
        if (
          Cesium.defined(featureProcessor) &&
          (namespaces.kml.indexOf(child.namespaceURI) !== -1 ||
            namespaces.gx.indexOf(child.namespaceURI) !== -1)
        ) {
          featureProcessor(dataSource, child, processingData, this);

          // Give up time and continue loading later
          if (
            this._timeoutSet ||
            KmlDataSource._getTimestamp() > this._started + this._timeThreshold
          ) {
            this._giveUpTime();
            return;
          }
        }

        child = this._nextNode();
      }

      // If we are a recursive call from a subfolder, just return so the parent folder can continue processing
      // If we aren't then make another call to processNodes because there is stuff still left in the queue
      if (this._pop() && isFirstCall) {
        this._process(true);
      }
    };

    function isZipFile(blob) {
      var magicBlob = blob.slice(0, Math.min(4, blob.size));
      var deferred = Cesium.when.defer();
      var reader = new FileReader();
      reader.addEventListener("load", function () {
        deferred.resolve(
          new DataView(reader.result).getUint32(0, false) === 0x504b0304
        );
      });
      reader.addEventListener("error", function () {
        deferred.reject(reader.error);
      });
      reader.readAsArrayBuffer(magicBlob);
      return deferred.promise;
    }

    function readBlobAsText(blob) {
      var deferred = Cesium.when.defer();
      var reader = new FileReader();
      reader.addEventListener("load", function () {
        deferred.resolve(reader.result);
      });
      reader.addEventListener("error", function () {
        deferred.reject(reader.error);
      });
      reader.readAsText(blob);
      return deferred.promise;
    }

    function insertNamespaces(text) {
      var namespaceMap = {
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
      };
      var firstPart, lastPart, reg, declaration;

      for (var key in namespaceMap) {
        if (namespaceMap.hasOwnProperty(key)) {
          reg = RegExp("[< ]" + key + ":");
          declaration = "xmlns:" + key + "=";
          if (reg.test(text) && text.indexOf(declaration) === -1) {
            if (!Cesium.defined(firstPart)) {
              firstPart = text.substr(0, text.indexOf("<kml") + 4);
              lastPart = text.substr(firstPart.length);
            }
            firstPart += " " + declaration + '"' + namespaceMap[key] + '"';
          }
        }
      }

      if (Cesium.defined(firstPart)) {
        text = firstPart + lastPart;
      }

      return text;
    }

    function removeDuplicateNamespaces(text) {
      var index = text.indexOf("xmlns:");
      var endDeclaration = text.indexOf(">", index);
      var namespace, startIndex, endIndex;

      while (index !== -1 && index < endDeclaration) {
        namespace = text.slice(index, text.indexOf('"', index));
        startIndex = index;
        index = text.indexOf(namespace, index + 1);
        if (index !== -1) {
          endIndex = text.indexOf('"', text.indexOf('"', index) + 1);
          text = text.slice(0, index - 1) + text.slice(endIndex + 1, text.length);
          index = text.indexOf("xmlns:", startIndex - 1);
        } else {
          index = text.indexOf("xmlns:", startIndex + 1);
        }
      }

      return text;
    }

    function loadXmlFromZip(entry, uriResolver, deferred) {
      entry.getData(new Cesium.zip.TextWriter(), function (text) {
        text = insertNamespaces(text);
        text = removeDuplicateNamespaces(text);
        uriResolver.kml = parser.parseFromString(text, "application/xml");
        deferred.resolve();
      });
    }

    function loadDataUriFromZip(entry, uriResolver, deferred) {
      var mimeType = Cesium.defaultValue(
        MimeTypes$1.detectFromFilename(entry.filename),
        "application/octet-stream"
      );
      entry.getData(new Cesium.zip.Data64URIWriter(mimeType), function (dataUri) {
        uriResolver[entry.filename] = dataUri;
        deferred.resolve();
      });
    }

    function embedDataUris(div, elementType, attributeName, uriResolver) {
      var keys = uriResolver.keys;
      var baseUri = new Cesium.Uri(".");
      var elements = div.querySelectorAll(elementType);
      for (var i = 0; i < elements.length; i++) {
        var element = elements[i];
        var value = element.getAttribute(attributeName);
        var uri = new Cesium.Uri(value).resolve(baseUri).toString();
        var index = keys.indexOf(uri);
        if (index !== -1) {
          var key = keys[index];
          element.setAttribute(attributeName, uriResolver[key]);
          if (elementType === "a" && element.getAttribute("download") === null) {
            element.setAttribute("download", key);
          }
        }
      }
    }

    function applyBasePath(div, elementType, attributeName, sourceResource) {
      var elements = div.querySelectorAll(elementType);
      for (var i = 0; i < elements.length; i++) {
        var element = elements[i];
        var value = element.getAttribute(attributeName);
        var resource = resolveHref(value, sourceResource);
        element.setAttribute(attributeName, resource.url);
      }
    }

    // an optional context is passed to allow for some malformed kmls (those with multiple geometries with same ids) to still parse
    // correctly, as they do in Google Earth.
    function createEntity(node, entityCollection, context) {
      var id = queryStringAttribute(node, "id");
      id = Cesium.defined(id) && id.length !== 0 ? id : Cesium.createGuid();
      if (Cesium.defined(context)) {
        id = context + id;
      }

      // If we have a duplicate ID just generate one.
      // This isn't valid KML but Google Earth handles this case.
      var entity = entityCollection.getById(id);
      if (Cesium.defined(entity)) {
        id = Cesium.createGuid();
        if (Cesium.defined(context)) {
          id = context + id;
        }
      }

      entity = entityCollection.add(new Cesium.Entity({ id: id }));
      if (!Cesium.defined(entity.kml)) {
        entity.addProperty("kml");
        entity.kml = new KmlFeatureData();
      }
      return entity;
    }

    function isExtrudable(altitudeMode, gxAltitudeMode) {
      return (
        altitudeMode === "absolute" ||
        altitudeMode === "relativeToGround" ||
        gxAltitudeMode === "relativeToSeaFloor"
      );
    }

    function readCoordinate(value, ellipsoid) {
      //Google Earth treats empty or missing coordinates as 0.
      if (!Cesium.defined(value)) {
        return Cesium.Cartesian3.fromDegrees(0, 0, 0, ellipsoid);
      }

      var digits = value.match(/[^\s,\n]+/g);
      if (!Cesium.defined(digits)) {
        return Cesium.Cartesian3.fromDegrees(0, 0, 0, ellipsoid);
      }

      var longitude = parseFloat(digits[0]);
      var latitude = parseFloat(digits[1]);
      var height = parseFloat(digits[2]);

      longitude = isNaN(longitude) ? 0.0 : longitude;
      latitude = isNaN(latitude) ? 0.0 : latitude;
      height = isNaN(height) ? 0.0 : height;

      return Cesium.Cartesian3.fromDegrees(longitude, latitude, height, ellipsoid);
    }

    function readCoordinates(element, ellipsoid) {
      if (!Cesium.defined(element)) {
        return undefined;
      }

      var tuples = element.textContent.match(/[^\s\n]+/g);
      if (!Cesium.defined(tuples)) {
        return undefined;
      }

      var length = tuples.length;
      var result = new Array(length);
      var resultIndex = 0;
      for (var i = 0; i < length; i++) {
        result[resultIndex++] = readCoordinate(tuples[i], ellipsoid);
      }
      return result;
    }

    function queryNumericAttribute(node, attributeName) {
      if (!Cesium.defined(node)) {
        return undefined;
      }

      var value = node.getAttribute(attributeName);
      if (value !== null) {
        var result = parseFloat(value);
        return !isNaN(result) ? result : undefined;
      }
      return undefined;
    }

    function queryStringAttribute(node, attributeName) {
      if (!Cesium.defined(node)) {
        return undefined;
      }
      var value = node.getAttribute(attributeName);
      return value !== null ? value : undefined;
    }

    function queryFirstNode(node, tagName, namespace) {
      if (!Cesium.defined(node)) {
        return undefined;
      }
      var childNodes = node.childNodes;
      var length = childNodes.length;
      for (var q = 0; q < length; q++) {
        var child = childNodes[q];
        if (
          child.localName === tagName &&
          namespace.indexOf(child.namespaceURI) !== -1
        ) {
          return child;
        }
      }
      return undefined;
    }

    function queryNodes(node, tagName, namespace) {
      if (!Cesium.defined(node)) {
        return undefined;
      }
      var result = [];
      var childNodes = node.getElementsByTagNameNS("*", tagName);
      var length = childNodes.length;
      for (var q = 0; q < length; q++) {
        var child = childNodes[q];
        if (
          child.localName === tagName &&
          namespace.indexOf(child.namespaceURI) !== -1
        ) {
          result.push(child);
        }
      }
      return result;
    }

    function queryChildNodes(node, tagName, namespace) {
      if (!Cesium.defined(node)) {
        return [];
      }
      var result = [];
      var childNodes = node.childNodes;
      var length = childNodes.length;
      for (var q = 0; q < length; q++) {
        var child = childNodes[q];
        if (
          child.localName === tagName &&
          namespace.indexOf(child.namespaceURI) !== -1
        ) {
          result.push(child);
        }
      }
      return result;
    }

    function queryNumericValue(node, tagName, namespace) {
      var resultNode = queryFirstNode(node, tagName, namespace);
      if (Cesium.defined(resultNode)) {
        var result = parseFloat(resultNode.textContent);
        return !isNaN(result) ? result : undefined;
      }
      return undefined;
    }

    function queryStringValue(node, tagName, namespace) {
      var result = queryFirstNode(node, tagName, namespace);
      if (Cesium.defined(result)) {
        return result.textContent.trim();
      }
      return undefined;
    }

    function queryBooleanValue(node, tagName, namespace) {
      var result = queryFirstNode(node, tagName, namespace);
      if (Cesium.defined(result)) {
        var value = result.textContent.trim();
        return value === "1" || /^true$/i.test(value);
      }
      return undefined;
    }

    function resolveHref(href, sourceResource, uriResolver) {
      if (!Cesium.defined(href)) {
        return undefined;
      }

      var resource;
      if (Cesium.defined(uriResolver)) {
        // To resolve issues with KML sources Cesium.defined in Windows style paths.
        href = href.replace(/\\/g, "/");
        var blob = uriResolver[href];
        if (Cesium.defined(blob)) {
          resource = new Cesium.Resource({
            url: blob,
          });
        } else {
          // Needed for multiple levels of KML files in a KMZ
          var baseUri = new Cesium.Uri(sourceResource.getUrlComponent());
          var uri = new Cesium.Uri(href);
          blob = uriResolver[uri.resolve(baseUri)];
          if (Cesium.defined(blob)) {
            resource = new Cesium.Resource({
              url: blob,
            });
          }
        }
      }

      if (!Cesium.defined(resource)) {
        resource = sourceResource.getDerivedResource({
          url: href,
        });
      }

      return resource;
    }

    var colorOptions = {
      maximumRed: undefined,
      red: undefined,
      maximumGreen: undefined,
      green: undefined,
      maximumBlue: undefined,
      blue: undefined,
    };

    function parseColorString(value, isRandom) {
      if (!Cesium.defined(value) || /^\s*$/gm.test(value)) {
        return undefined;
      }

      if (value[0] === "#") {
        value = value.substring(1);
      }

      var alpha = parseInt(value.substring(0, 2), 16) / 255.0;
      var blue = parseInt(value.substring(2, 4), 16) / 255.0;
      var green = parseInt(value.substring(4, 6), 16) / 255.0;
      var red = parseInt(value.substring(6, 8), 16) / 255.0;

      if (!isRandom) {
        return new Cesium.Color(red, green, blue, alpha);
      }

      if (red > 0) {
        colorOptions.maximumRed = red;
        colorOptions.red = undefined;
      } else {
        colorOptions.maximumRed = undefined;
        colorOptions.red = 0;
      }
      if (green > 0) {
        colorOptions.maximumGreen = green;
        colorOptions.green = undefined;
      } else {
        colorOptions.maximumGreen = undefined;
        colorOptions.green = 0;
      }
      if (blue > 0) {
        colorOptions.maximumBlue = blue;
        colorOptions.blue = undefined;
      } else {
        colorOptions.maximumBlue = undefined;
        colorOptions.blue = 0;
      }
      colorOptions.alpha = alpha;
      return Cesium.Color.fromRandom(colorOptions);
    }

    function queryColorValue(node, tagName, namespace) {
      var value = queryStringValue(node, tagName, namespace);
      if (!Cesium.defined(value)) {
        return undefined;
      }
      return parseColorString(
        value,
        queryStringValue(node, "colorMode", namespace) === "random"
      );
    }

    function processTimeStamp(featureNode) {
      var node = queryFirstNode(featureNode, "TimeStamp", namespaces.kmlgx);
      var whenString = queryStringValue(node, "Cesium.when", namespaces.kmlgx);

      if (!Cesium.defined(node) || !Cesium.defined(whenString) || whenString.length === 0) {
        return undefined;
      }

      //According to the KML spec, a TimeStamp represents a "single moment in time"
      //However, since Cesium animates much differently than Google Earth, that doesn't
      //Make much sense here.  Instead, we use the TimeStamp as the moment the feature
      //comes into existence.  This works much better and gives a similar feel to
      //GE's experience.
      var when = Cesium.JulianDate.fromIso8601(whenString);
      var result = new Cesium.TimeIntervalCollection();
      result.addInterval(
        new Cesium.TimeInterval({
          start: Cesium.when,
          stop: Cesium.Iso8601.MAXIMUM_VALUE,
        })
      );
      return result;
    }

    function processTimeSpan(featureNode) {
      var node = queryFirstNode(featureNode, "TimeSpan", namespaces.kmlgx);
      if (!Cesium.defined(node)) {
        return undefined;
      }
      var result;

      var beginNode = queryFirstNode(node, "begin", namespaces.kmlgx);
      var beginDate = Cesium.defined(beginNode)
        ? Cesium.JulianDate.fromIso8601(beginNode.textContent)
        : undefined;

      var endNode = queryFirstNode(node, "end", namespaces.kmlgx);
      var endDate = Cesium.defined(endNode)
        ? Cesium.JulianDate.fromIso8601(endNode.textContent)
        : undefined;

      if (Cesium.defined(beginDate) && Cesium.defined(endDate)) {
        if (Cesium.JulianDate.lessThan(endDate, beginDate)) {
          var tmp = beginDate;
          beginDate = endDate;
          endDate = tmp;
        }
        result = new Cesium.TimeIntervalCollection();
        result.addInterval(
          new Cesium.TimeInterval({
            start: beginDate,
            stop: endDate,
          })
        );
      } else if (Cesium.defined(beginDate)) {
        result = new Cesium.TimeIntervalCollection();
        result.addInterval(
          new Cesium.TimeInterval({
            start: beginDate,
            stop: Cesium.Iso8601.MAXIMUM_VALUE,
          })
        );
      } else if (Cesium.defined(endDate)) {
        result = new Cesium.TimeIntervalCollection();
        result.addInterval(
          new Cesium.TimeInterval({
            start: Cesium.Iso8601.MINIMUM_VALUE,
            stop: endDate,
          })
        );
      }

      return result;
    }

    function createDefaultBillboard() {
      var billboard = new Cesium.BillboardGraphics();
      billboard.width = BILLBOARD_SIZE;
      billboard.height = BILLBOARD_SIZE;
      billboard.scaleByDistance = new Cesium.NearFarScalar(
        BILLBOARD_NEAR_DISTANCE,
        BILLBOARD_NEAR_RATIO,
        BILLBOARD_FAR_DISTANCE,
        BILLBOARD_FAR_RATIO
      );
      billboard.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(
        BILLBOARD_NEAR_DISTANCE,
        BILLBOARD_NEAR_RATIO,
        BILLBOARD_FAR_DISTANCE,
        BILLBOARD_FAR_RATIO
      );
      return billboard;
    }

    function createDefaultPolygon() {
      var polygon = new Cesium.PolygonGraphics();
      polygon.outline = true;
      polygon.outlineColor = Cesium.Color.WHITE;
      return polygon;
    }

    function createDefaultLabel() {
      var label = new Cesium.LabelGraphics();
      label.translucencyByDistance = new Cesium.NearFarScalar(3000000, 1.0, 5000000, 0.0);
      label.pixelOffset = new Cesium.Cartesian2(17, 0);
      label.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
      label.font = "16px sans-serif";
      label.style = Cesium.LabelStyle.FILL_AND_OUTLINE;
      return label;
    }

    function getIconHref(
      iconNode,
      dataSource,
      sourceResource,
      uriResolver,
      canRefresh
    ) {
      var href = queryStringValue(iconNode, "href", namespaces.kml);
      if (!Cesium.defined(href) || href.length === 0) {
        return undefined;
      }

      if (href.indexOf("root://icons/palette-") === 0) {
        var palette = href.charAt(21);

        // Get the icon number
        var x = Cesium.defaultValue(queryNumericValue(iconNode, "x", namespaces.gx), 0);
        var y = Cesium.defaultValue(queryNumericValue(iconNode, "y", namespaces.gx), 0);
        x = Math.min(x / 32, 7);
        y = 7 - Math.min(y / 32, 7);
        var iconNum = 8 * y + x;

        href =
          "https://maps.google.com/mapfiles/kml/pal" +
          palette +
          "/icon" +
          iconNum +
          ".png";
      }

      var hrefResource = resolveHref(href, sourceResource, uriResolver);

      if (canRefresh) {
        var refreshMode = queryStringValue(iconNode, "refreshMode", namespaces.kml);
        var viewRefreshMode = queryStringValue(
          iconNode,
          "viewRefreshMode",
          namespaces.kml
        );
        if (refreshMode === "onInterval" || refreshMode === "onExpire") {
          Cesium.oneTimeWarning(
            "kml-refreshMode-" + refreshMode,
            "KML - Unsupported Icon refreshMode: " + refreshMode
          );
        } else if (viewRefreshMode === "onStop" || viewRefreshMode === "onRegion") {
          Cesium.oneTimeWarning(
            "kml-refreshMode-" + viewRefreshMode,
            "KML - Unsupported Icon viewRefreshMode: " + viewRefreshMode
          );
        }

        var viewBoundScale = Cesium.defaultValue(
          queryStringValue(iconNode, "viewBoundScale", namespaces.kml),
          1.0
        );
        var defaultViewFormat =
          viewRefreshMode === "onStop"
            ? "BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]"
            : "";
        var viewFormat = Cesium.defaultValue(
          queryStringValue(iconNode, "viewFormat", namespaces.kml),
          defaultViewFormat
        );
        var httpQuery = queryStringValue(iconNode, "httpQuery", namespaces.kml);
        if (Cesium.defined(viewFormat)) {
          hrefResource.setQueryParameters(Cesium.queryToObject(cleanupString(viewFormat)));
        }
        if (Cesium.defined(httpQuery)) {
          hrefResource.setQueryParameters(Cesium.queryToObject(cleanupString(httpQuery)));
        }

        var ellipsoid = dataSource._ellipsoid;
        processNetworkLinkQueryString(
          hrefResource,
          dataSource._camera,
          dataSource._canvas,
          viewBoundScale,
          dataSource._lastCameraView.bbox,
          ellipsoid
        );

        return hrefResource;
      }

      return hrefResource;
    }

    function getNearFarScaler(node, name){
      var nearFarScalarNode = queryFirstNode(node, name, namespaces.kml);
      if(Cesium.defined(nearFarScalarNode)){
        var near = queryNumericAttribute(nearFarScalarNode, "near");
        var nearValue = queryNumericAttribute(nearFarScalarNode, "nearValue");
        var far = queryStringAttribute(nearFarScalarNode, "far");
        var farValue = queryStringAttribute(nearFarScalarNode, "farValue");
        near = Cesium.defaultValue(near, 0.0);
        nearValue = Cesium.defaultValue(nearValue, 1.0);
        far = Cesium.defaultValue(far, 1.0);
        farValue = Cesium.defaultValue(farValue, 0.0);
        return new Cesium.NearFarScalar(
          near,
          nearValue,
          far,
          farValue
        );
      }
    }

    function processLabel(
      dataSource,
      node,
      targetEntity,
      sourceResource,
      uriResolver
    ) {
      var label = targetEntity.label;
      if (!Cesium.defined(label)) {
        label = createDefaultLabel();
        targetEntity.label = label;
      }
      label.scale = Cesium.defaultValue(
        queryNumericValue(node, "scale", namespaces.kml),
        label.scale
      );
      label.fillColor = Cesium.defaultValue(
        queryColorValue(node, "color", namespaces.kml),
        label.fillColor
      );
      label.text = targetEntity.name;

      var scaleByDistanceScaler = getNearFarScaler(node, "scaleByDistance");
      if(Cesium.defined(scaleByDistanceScaler)){
        label.scaleByDistance = scaleByDistanceScaler;
      }
      
      var translucencyByDistanceScaler = getNearFarScaler(node, "translucencyByDistance");
      if(Cesium.defined(translucencyByDistanceScaler)){
        label.translucencyByDistance = translucencyByDistanceScaler;
      }  

      var pixelOffsetScaleByDistanceScaler = getNearFarScaler(node, "pixelOffsetScaleByDistance");
      if(Cesium.defined(pixelOffsetScaleByDistanceScaler)){
        label.pixelOffsetScaleByDistance = pixelOffsetScaleByDistanceScaler;
      }

      var disableDepthTestDistance = queryNumericValue(node, "disableDepthTestDistance", namespaces.kml);
      if(Cesium.defined(disableDepthTestDistance)){
        label.disableDepthTestDistance = disableDepthTestDistance;
      }

      var distanceDisplayConditionNode = queryFirstNode(node, "distanceDisplayCondition", namespaces.kml);
      if(Cesium.defined(distanceDisplayConditionNode)){
        var dnear = queryNumericAttribute(distanceDisplayConditionNode, "near");
        var dfar = queryNumericAttribute(distanceDisplayConditionNode, "far");
        label.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(dnear, dfar);
      }
    }

    function processBillboardIcon(
      dataSource,
      node,
      targetEntity,
      sourceResource,
      uriResolver
    ) {
      var scale = queryNumericValue(node, "scale", namespaces.kml);
      var heading = queryNumericValue(node, "heading", namespaces.kml);
      var color = queryColorValue(node, "color", namespaces.kml);

      var iconNode = queryFirstNode(node, "Icon", namespaces.kml);
      var icon = getIconHref(
        iconNode,
        dataSource,
        sourceResource,
        uriResolver,
        false
      );

      // If icon tags are present but blank, we do not want to show an icon
      if (Cesium.defined(iconNode) && !Cesium.defined(icon)) {
        icon = false;
      }

      var x = queryNumericValue(iconNode, "x", namespaces.gx);
      var y = queryNumericValue(iconNode, "y", namespaces.gx);
      var w = queryNumericValue(iconNode, "w", namespaces.gx);
      var h = queryNumericValue(iconNode, "h", namespaces.gx);

      var hotSpotNode = queryFirstNode(node, "hotSpot", namespaces.kml);
      var hotSpotX = queryNumericAttribute(hotSpotNode, "x");
      var hotSpotY = queryNumericAttribute(hotSpotNode, "y");
      var hotSpotXUnit = queryStringAttribute(hotSpotNode, "xunits");
      var hotSpotYUnit = queryStringAttribute(hotSpotNode, "yunits");

      var billboard = targetEntity.billboard;
      if (!Cesium.defined(billboard)) {
        billboard = createDefaultBillboard();
        targetEntity.billboard = billboard;
      }

      var scaleByDistanceScaler = getNearFarScaler(node, "scaleByDistance");
      if(Cesium.defined(scaleByDistanceScaler)){
        billboard.scaleByDistance = scaleByDistanceScaler;
      }
      
      var translucencyByDistanceScaler = getNearFarScaler(node, "translucencyByDistance");
      if(Cesium.defined(translucencyByDistanceScaler)){
        billboard.translucencyByDistance = translucencyByDistanceScaler;
      }  

      var pixelOffsetScaleByDistanceScaler = getNearFarScaler(node, "translpixelOffsetScaleByDistanceucencyByDistance");
      if(Cesium.defined(pixelOffsetScaleByDistanceScaler)){
        billboard.pixelOffsetScaleByDistance = pixelOffsetScaleByDistanceScaler;
      }

      var disableDepthTestDistance = queryNumericValue(node, "disableDepthTestDistance", namespaces.kml);
      if(Cesium.defined(disableDepthTestDistance)){
        billboard.disableDepthTestDistance = disableDepthTestDistance;
      }
     
      var distanceDisplayConditionNode = queryFirstNode(node, "distanceDisplayCondition", namespaces.kml);
      if(Cesium.defined(distanceDisplayConditionNode)){
        var dnear = queryNumericAttribute(distanceDisplayConditionNode, "near");
        var dfar = queryNumericAttribute(distanceDisplayConditionNode, "far");
        billboard.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(dnear, dfar);
      }
      
      billboard.image = icon;
      billboard.scale = scale;
      billboard.color = color;

      if (Cesium.defined(x) || Cesium.defined(y) || Cesium.defined(w) || Cesium.defined(h)) {
        billboard.imageSubRegion = new Cesium.BoundingRectangle(x, y, w, h);
      }

      //GE treats a heading of zero as no heading
      //You can still point north using a 360 degree angle (or any multiple of 360)
      if (Cesium.defined(heading) && heading !== 0) {
        billboard.rotation = Cesium.Math.toRadians(-heading);
        billboard.alignedAxis = Cesium.Cartesian3.UNIT_Z;
      }

      //Hotpot is the KML equivalent of pixel offset
      //The hotspot origin is the lower left, but we leave
      //our billboard origin at the center and simply
      //modify the pixel offset to take this into account
      scale = Cesium.defaultValue(scale, 1.0);

      var xOffset;
      var yOffset;
      if (Cesium.defined(hotSpotX)) {
        if (hotSpotXUnit === "pixels") {
          xOffset = -hotSpotX * scale;
        } else if (hotSpotXUnit === "insetPixels") {
          xOffset = (hotSpotX - BILLBOARD_SIZE) * scale;
        } else if (hotSpotXUnit === "fraction") {
          xOffset = -hotSpotX * BILLBOARD_SIZE * scale;
        }
        xOffset += BILLBOARD_SIZE * 0.5 * scale;
      }

      if (Cesium.defined(hotSpotY)) {
        if (hotSpotYUnit === "pixels") {
          yOffset = hotSpotY * scale;
        } else if (hotSpotYUnit === "insetPixels") {
          yOffset = (-hotSpotY + BILLBOARD_SIZE) * scale;
        } else if (hotSpotYUnit === "fraction") {
          yOffset = hotSpotY * BILLBOARD_SIZE * scale;
        }

        yOffset -= BILLBOARD_SIZE * 0.5 * scale;
      }

      if (Cesium.defined(xOffset) || Cesium.defined(yOffset)) {
        billboard.pixelOffset = new Cesium.Cartesian2(xOffset, yOffset);
      }
    }

    function applyStyle(
      dataSource,
      styleNode,
      targetEntity,
      sourceResource,
      uriResolver
    ) {
      for (var i = 0, len = styleNode.childNodes.length; i < len; i++) {
        var node = styleNode.childNodes.item(i);
        if (node.localName === "IconStyle") {
          processBillboardIcon(
            dataSource,
            node,
            targetEntity,
            sourceResource,
            uriResolver
          );
        } else if (node.localName === "LabelStyle") {
          processLabel(
            dataSource,
            node,
            targetEntity);
        } else if (node.localName === "LineStyle") {
          var polyline = targetEntity.polyline;
          if (!Cesium.defined(polyline)) {
            polyline = new Cesium.PolylineGraphics();
            targetEntity.polyline = polyline;
          }
          polyline.width = queryNumericValue(node, "width", namespaces.kml);
          polyline.material = queryColorValue(node, "color", namespaces.kml);
          if (Cesium.defined(queryColorValue(node, "outerColor", namespaces.gx))) {
            Cesium.oneTimeWarning(
              "kml-gx:outerColor",
              "KML - gx:outerColor is not supported in a LineStyle"
            );
          }
          if (Cesium.defined(queryNumericValue(node, "outerWidth", namespaces.gx))) {
            Cesium.oneTimeWarning(
              "kml-gx:outerWidth",
              "KML - gx:outerWidth is not supported in a LineStyle"
            );
          }
          if (Cesium.defined(queryNumericValue(node, "physicalWidth", namespaces.gx))) {
            Cesium.oneTimeWarning(
              "kml-gx:physicalWidth",
              "KML - gx:physicalWidth is not supported in a LineStyle"
            );
          }
          if (Cesium.defined(queryBooleanValue(node, "labelVisibility", namespaces.gx))) {
            Cesium.oneTimeWarning(
              "kml-gx:labelVisibility",
              "KML - gx:labelVisibility is not supported in a LineStyle"
            );
          }
        } else if (node.localName === "PolyStyle") {
          var polygon = targetEntity.polygon;
          if (!Cesium.defined(polygon)) {
            polygon = createDefaultPolygon();
            targetEntity.polygon = polygon;
          }
          polygon.material = Cesium.defaultValue(
            queryColorValue(node, "color", namespaces.kml),
            polygon.material
          );
          polygon.fill = Cesium.defaultValue(
            queryBooleanValue(node, "fill", namespaces.kml),
            polygon.fill
          );
          polygon.outline = Cesium.defaultValue(
            queryBooleanValue(node, "outline", namespaces.kml),
            polygon.outline
          );
        } else if (node.localName === "BalloonStyle") {
          var bgColor = Cesium.defaultValue(
            parseColorString(queryStringValue(node, "bgColor", namespaces.kml)),
            Cesium.Color.WHITE
          );
          var textColor = Cesium.defaultValue(
            parseColorString(queryStringValue(node, "textColor", namespaces.kml)),
            Cesium.Color.BLACK
          );
          var text = queryStringValue(node, "text", namespaces.kml);

          //This is purely an internal property used in style processing,
          //it never ends up on the final entity.
          targetEntity.addProperty("balloonStyle");
          targetEntity.balloonStyle = {
            bgColor: bgColor,
            textColor: textColor,
            text: text,
          };
        } else if (node.localName === "ListStyle") {
          var listItemType = queryStringValue(node, "listItemType", namespaces.kml);
          if (listItemType === "radioFolder" || listItemType === "checkOffOnly") {
            Cesium.oneTimeWarning(
              "kml-listStyle-" + listItemType,
              "KML - Unsupported ListStyle with listItemType: " + listItemType
            );
          }
        }
      }
    }

    //Processes and merges any inline styles for the provided node into the provided entity.
    function computeFinalStyle(
      dataSource,
      placeMark,
      styleCollection,
      sourceResource,
      uriResolver
    ) {
      var result = new Cesium.Entity();
      var styleEntity;

      //Google earth seems to always use the last inline Style/StyleMap only
      var styleIndex = -1;
      var childNodes = placeMark.childNodes;
      var length = childNodes.length;
      for (var q = 0; q < length; q++) {
        var child = childNodes[q];
        if (child.localName === "Style" || child.localName === "StyleMap") {
          styleIndex = q;
        }
      }

      if (styleIndex !== -1) {
        var inlineStyleNode = childNodes[styleIndex];
        if (inlineStyleNode.localName === "Style") {
          applyStyle(
            dataSource,
            inlineStyleNode,
            result,
            sourceResource,
            uriResolver
          );
        } else {
          // StyleMap
          var pairs = queryChildNodes(inlineStyleNode, "Pair", namespaces.kml);
          for (var p = 0; p < pairs.length; p++) {
            var pair = pairs[p];
            var key = queryStringValue(pair, "key", namespaces.kml);
            if (key === "normal") {
              var styleUrl = queryStringValue(pair, "styleUrl", namespaces.kml);
              if (Cesium.defined(styleUrl)) {
                styleEntity = styleCollection.getById(styleUrl);
                if (!Cesium.defined(styleEntity)) {
                  styleEntity = styleCollection.getById("#" + styleUrl);
                }
                if (Cesium.defined(styleEntity)) {
                  result.merge(styleEntity);
                }
              } else {
                var node = queryFirstNode(pair, "Style", namespaces.kml);
                applyStyle(dataSource, node, result, sourceResource, uriResolver);
              }
            } else {
              Cesium.oneTimeWarning(
                "kml-styleMap-" + key,
                "KML - Unsupported StyleMap key: " + key
              );
            }
          }
        }
      }

      //Google earth seems to always use the first external style only.
      var externalStyle = queryStringValue(placeMark, "styleUrl", namespaces.kml);
      if (Cesium.defined(externalStyle)) {
        var id = externalStyle;
        if (externalStyle[0] !== "#" && externalStyle.indexOf("#") !== -1) {
          var tokens = externalStyle.split("#");
          var uri = tokens[0];
          var resource = sourceResource.getDerivedResource({
            url: uri,
          });

          id = resource.getUrlComponent() + "#" + tokens[1];
        }

        styleEntity = styleCollection.getById(id);
        if (!Cesium.defined(styleEntity)) {
          styleEntity = styleCollection.getById("#" + id);
        }
        if (Cesium.defined(styleEntity)) {
          result.merge(styleEntity);
        }
      }

      return result;
    }

    //Asynchronously processes an external style file.
    function processExternalStyles(dataSource, resource, styleCollection) {
      return resource.fetchXML().then(function (styleKml) {
        return processStyles(dataSource, styleKml, styleCollection, resource, true);
      });
    }

    //Processes all shared and external styles and stores
    //their id into the provided styleCollection.
    //Returns an array of promises that will resolve Cesium.when
    //each style is loaded.
    function processStyles(
      dataSource,
      kml,
      styleCollection,
      sourceResource,
      isExternal,
      uriResolver
    ) {
      var i;
      var id;
      var styleEntity;

      var node;
      var styleNodes = queryNodes(kml, "Style", namespaces.kml);
      if (Cesium.defined(styleNodes)) {
        var styleNodesLength = styleNodes.length;
        for (i = 0; i < styleNodesLength; i++) {
          node = styleNodes[i];
          id = queryStringAttribute(node, "id");
          if (Cesium.defined(id)) {
            id = "#" + id;
            if (isExternal && Cesium.defined(sourceResource)) {
              id = sourceResource.getUrlComponent() + id;
            }
            if (!Cesium.defined(styleCollection.getById(id))) {
              styleEntity = new Cesium.Entity({
                id: id,
              });
              styleCollection.add(styleEntity);
              applyStyle(
                dataSource,
                node,
                styleEntity,
                sourceResource,
                uriResolver
              );
            }
          }
        }
      }

      var styleMaps = queryNodes(kml, "StyleMap", namespaces.kml);
      if (Cesium.defined(styleMaps)) {
        var styleMapsLength = styleMaps.length;
        for (i = 0; i < styleMapsLength; i++) {
          var styleMap = styleMaps[i];
          id = queryStringAttribute(styleMap, "id");
          if (Cesium.defined(id)) {
            var pairs = queryChildNodes(styleMap, "Pair", namespaces.kml);
            for (var p = 0; p < pairs.length; p++) {
              var pair = pairs[p];
              var key = queryStringValue(pair, "key", namespaces.kml);
              if (key === "normal") {
                id = "#" + id;
                if (isExternal && Cesium.defined(sourceResource)) {
                  id = sourceResource.getUrlComponent() + id;
                }
                if (!Cesium.defined(styleCollection.getById(id))) {
                  styleEntity = styleCollection.getOrCreateEntity(id);

                  var styleUrl = queryStringValue(pair, "styleUrl", namespaces.kml);
                  if (Cesium.defined(styleUrl)) {
                    if (styleUrl[0] !== "#") {
                      styleUrl = "#" + styleUrl;
                    }

                    if (isExternal && Cesium.defined(sourceResource)) {
                      styleUrl = sourceResource.getUrlComponent() + styleUrl;
                    }
                    var base = styleCollection.getById(styleUrl);

                    if (Cesium.defined(base)) {
                      styleEntity.merge(base);
                    }
                  } else {
                    node = queryFirstNode(pair, "Style", namespaces.kml);
                    applyStyle(
                      dataSource,
                      node,
                      styleEntity,
                      sourceResource,
                      uriResolver
                    );
                  }
                }
              } else {
                Cesium.oneTimeWarning(
                  "kml-styleMap-" + key,
                  "KML - Unsupported StyleMap key: " + key
                );
              }
            }
          }
        }
      }

      var promises = [];
      var styleUrlNodes = kml.getElementsByTagName("styleUrl");
      var styleUrlNodesLength = styleUrlNodes.length;
      for (i = 0; i < styleUrlNodesLength; i++) {
        var styleReference = styleUrlNodes[i].textContent;
        if (styleReference[0] !== "#") {
          //According to the spec, all local styles should start with a #
          //and everything else is an external style that has a # seperating
          //the URL of the document and the style.  However, Google Earth
          //also accepts styleUrls without a # as meaning a local style.
          var tokens = styleReference.split("#");
          if (tokens.length === 2) {
            var uri = tokens[0];
            var resource = sourceResource.getDerivedResource({
              url: uri,
            });

            promises.push(
              processExternalStyles(dataSource, resource, styleCollection)
            );
          }
        }
      }

      return promises;
    }

    function createDropLine(entityCollection, entity, styleEntity) {
      var entityPosition = new Cesium.ReferenceProperty(entityCollection, entity.id, [
        "position",
      ]);
      var surfacePosition = new Cesium.ScaledPositionProperty(entity.position);
      entity.polyline = Cesium.defined(styleEntity.polyline)
        ? styleEntity.polyline.clone()
        : new Cesium.PolylineGraphics();
      entity.polyline.positions = new Cesium.PositionPropertyArray([
        entityPosition,
        surfacePosition,
      ]);
    }

    function heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode) {
      if (
        (!Cesium.defined(altitudeMode) && !Cesium.defined(gxAltitudeMode)) ||
        altitudeMode === "clampToGround"
      ) {
        return Cesium.HeightReference.CLAMP_TO_GROUND;
      }

      if (altitudeMode === "relativeToGround") {
        return Cesium.HeightReference.RELATIVE_TO_GROUND;
      }

      if (altitudeMode === "absolute") {
        return Cesium.HeightReference.NONE;
      }

      if (gxAltitudeMode === "clampToSeaFloor") {
        Cesium.oneTimeWarning(
          "kml-gx:altitudeMode-clampToSeaFloor",
          "KML - <gx:altitudeMode>:clampToSeaFloor is currently not supported, using <kml:altitudeMode>:clampToGround."
        );
        return Cesium.HeightReference.CLAMP_TO_GROUND;
      }

      if (gxAltitudeMode === "relativeToSeaFloor") {
        Cesium.oneTimeWarning(
          "kml-gx:altitudeMode-relativeToSeaFloor",
          "KML - <gx:altitudeMode>:relativeToSeaFloor is currently not supported, using <kml:altitudeMode>:relativeToGround."
        );
        return Cesium.HeightReference.RELATIVE_TO_GROUND;
      }

      if (Cesium.defined(altitudeMode)) {
        Cesium.oneTimeWarning(
          "kml-altitudeMode-unknown",
          "KML - Unknown <kml:altitudeMode>:" +
            altitudeMode +
            ", using <kml:altitudeMode>:CLAMP_TO_GROUND."
        );
      } else {
        Cesium.oneTimeWarning(
          "kml-gx:altitudeMode-unknown",
          "KML - Unknown <gx:altitudeMode>:" +
            gxAltitudeMode +
            ", using <kml:altitudeMode>:CLAMP_TO_GROUND."
        );
      }

      // Clamp to ground is the default
      return Cesium.HeightReference.CLAMP_TO_GROUND;
    }

    function createPositionPropertyFromAltitudeMode(
      property,
      altitudeMode,
      gxAltitudeMode
    ) {
      if (
        gxAltitudeMode === "relativeToSeaFloor" ||
        altitudeMode === "absolute" ||
        altitudeMode === "relativeToGround"
      ) {
        //Just return the ellipsoid referenced property until we support MSL
        return property;
      }

      if (
        (Cesium.defined(altitudeMode) && altitudeMode !== "clampToGround") || //
        (Cesium.defined(gxAltitudeMode) && gxAltitudeMode !== "clampToSeaFloor")
      ) {
        Cesium.oneTimeWarning(
          "kml-altitudeMode-unknown",
          "KML - Unknown altitudeMode: " +
            Cesium.defaultValue(altitudeMode, gxAltitudeMode)
        );
      }

      // Clamp to ground is the default
      return new Cesium.ScaledPositionProperty(property);
    }

    function createPositionPropertyArrayFromAltitudeMode(
      properties,
      altitudeMode,
      gxAltitudeMode,
      ellipsoid
    ) {
      if (!Cesium.defined(properties)) {
        return undefined;
      }

      if (
        gxAltitudeMode === "relativeToSeaFloor" ||
        altitudeMode === "absolute" ||
        altitudeMode === "relativeToGround"
      ) {
        //Just return the ellipsoid referenced property until we support MSL
        return properties;
      }

      if (
        (Cesium.defined(altitudeMode) && altitudeMode !== "clampToGround") || //
        (Cesium.defined(gxAltitudeMode) && gxAltitudeMode !== "clampToSeaFloor")
      ) {
        Cesium.oneTimeWarning(
          "kml-altitudeMode-unknown",
          "KML - Unknown altitudeMode: " +
            Cesium.defaultValue(altitudeMode, gxAltitudeMode)
        );
      }

      // Clamp to ground is the default
      var propertiesLength = properties.length;
      for (var i = 0; i < propertiesLength; i++) {
        var property = properties[i];
        ellipsoid.scaleToGeodeticSurface(property, property);
      }
      return properties;
    }

    function processPositionGraphics(
      dataSource,
      entity,
      styleEntity,
      heightReference
    ) {
      var label = entity.label;
      if (!Cesium.defined(label)) {
        label = Cesium.defined(styleEntity.label)
          ? styleEntity.label.clone()
          : createDefaultLabel();
        entity.label = label;
      }
      label.text = entity.name;

      var billboard = entity.billboard;
      if (!Cesium.defined(billboard)) {
        billboard = Cesium.defined(styleEntity.billboard)
          ? styleEntity.billboard.clone()
          : createDefaultBillboard();
        entity.billboard = billboard;
      }

      if (!Cesium.defined(billboard.image)) {
        billboard.image = dataSource._pinBuilder.fromColor(Cesium.Color.YELLOW, 64);

        // If there were empty <Icon> tags in the KML, then billboard.image was set to false above
        // However, in this case, the false value would have been converted to a property afterwards
        // Thus, we check if billboard.image is Cesium.defined with value of false
      } else if (!billboard.image.getValue()) {
        billboard.image = undefined;
      }

      var scale = 1.0;
      if (Cesium.defined(billboard.scale)) {
        scale = billboard.scale.getValue();
        if (scale !== 0) {
          label.pixelOffset = new Cesium.Cartesian2(scale * 16 + 1, 0);
        } else {
          //Minor tweaks to better match Google Earth.
          label.pixelOffset = undefined;
          label.horizontalOrigin = undefined;
        }
      }

      var pixelOffset;
      if (Cesium.defined(billboard.pixelOffset)) {
        pixelOffset = billboard.pixelOffset.getValue();
        label.pixelOffset = new Cesium.Cartesian2(17, pixelOffset.y);
        //label.showBackground = true
      }
      
      if (Cesium.defined(heightReference) && dataSource._clampToGround) {
        billboard.heightReference = heightReference;
        label.heightReference = heightReference;
      }
    }

    function processPathGraphics(entity, styleEntity) {
      var path = entity.path;
      if (!Cesium.defined(path)) {
        path = new Cesium.PathGraphics();
        path.leadTime = 0;
        entity.path = path;
      }

      var polyline = styleEntity.polyline;
      if (Cesium.defined(polyline)) {
        path.material = polyline.material;
        path.width = polyline.width;
      }
    }

    function processPoint(
      dataSource,
      entityCollection,
      geometryNode,
      entity,
      styleEntity
    ) {
      var coordinatesString = queryStringValue(
        geometryNode,
        "coordinates",
        namespaces.kml
      );
      var altitudeMode = queryStringValue(
        geometryNode,
        "altitudeMode",
        namespaces.kml
      );
      var gxAltitudeMode = queryStringValue(
        geometryNode,
        "altitudeMode",
        namespaces.gx
      );
      var extrude = queryBooleanValue(geometryNode, "extrude", namespaces.kml);
      var ellipsoid = dataSource._ellipsoid;
      var position = readCoordinate(coordinatesString, ellipsoid);

      entity.position = position;
      processPositionGraphics(
        dataSource,
        entity,
        styleEntity,
        heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode)
      );

      if (extrude && isExtrudable(altitudeMode, gxAltitudeMode)) {
        createDropLine(entityCollection, entity, styleEntity);
      }

      return true;
    }

    function processLineStringOrLinearRing(
      dataSource,
      entityCollection,
      geometryNode,
      entity,
      styleEntity
    ) {
      var coordinatesNode = queryFirstNode(
        geometryNode,
        "coordinates",
        namespaces.kml
      );
      var altitudeMode = queryStringValue(
        geometryNode,
        "altitudeMode",
        namespaces.kml
      );
      var gxAltitudeMode = queryStringValue(
        geometryNode,
        "altitudeMode",
        namespaces.gx
      );
      var extrude = queryBooleanValue(geometryNode, "extrude", namespaces.kml);
      var tessellate = queryBooleanValue(
        geometryNode,
        "tessellate",
        namespaces.kml
      );
      var canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);
      var zIndex = queryNumericValue(geometryNode, "drawOrder", namespaces.gx);

      var ellipsoid = dataSource._ellipsoid;
      var coordinates = readCoordinates(coordinatesNode, ellipsoid);
      var polyline = styleEntity.polyline;
      if (canExtrude && extrude) {
        var wall = new Cesium.WallGraphics();
        entity.wall = wall;
        wall.positions = coordinates;
        var polygon = styleEntity.polygon;

        if (Cesium.defined(polygon)) {
          wall.fill = polygon.fill;
          wall.material = polygon.material;
        }

        //Always outline walls so they show up in 2D.
        wall.outline = true;
        if (Cesium.defined(polyline)) {
          wall.outlineColor = Cesium.defined(polyline.material)
            ? polyline.material.color
            : Cesium.Color.WHITE;
          wall.outlineWidth = polyline.width;
        } else if (Cesium.defined(polygon)) {
          wall.outlineColor = Cesium.defined(polygon.material)
            ? polygon.material.color
            : Cesium.Color.WHITE;
        }
      } else if (dataSource._clampToGround && !canExtrude && tessellate) {
        var polylineGraphics = new Cesium.PolylineGraphics();
        polylineGraphics.clampToGround = true;
        entity.polyline = polylineGraphics;
        polylineGraphics.positions = coordinates;
        if (Cesium.defined(polyline)) {
          polylineGraphics.material = Cesium.defined(polyline.material)
            ? polyline.material.color.getValue(Cesium.Iso8601.MINIMUM_VALUE)
            : Cesium.Color.WHITE;
          polylineGraphics.width = Cesium.defaultValue(polyline.width, 1.0);
        } else {
          polylineGraphics.material = Cesium.Color.WHITE;
          polylineGraphics.width = 1.0;
        }
        polylineGraphics.zIndex = zIndex;
      } else {
        if (Cesium.defined(zIndex)) {
          Cesium.oneTimeWarning(
            "kml-gx:drawOrder",
            "KML - gx:drawOrder is not supported in LineStrings Cesium.when clampToGround is false"
          );
        }
        if (dataSource._clampToGround && !tessellate) {
          Cesium.oneTimeWarning(
            "kml-line-tesselate",
            "Ignoring clampToGround for KML lines without the tessellate flag."
          );
        }

        polyline = Cesium.defined(polyline) ? polyline.clone() : new Cesium.PolylineGraphics();
        entity.polyline = polyline;
        polyline.positions = createPositionPropertyArrayFromAltitudeMode(
          coordinates,
          altitudeMode,
          gxAltitudeMode,
          ellipsoid
        );
        if (!tessellate || canExtrude) {
          polyline.arcType = Cesium.ArcType.NONE;
        }
        polyline.classificationType= Cesium.ClassificationType.TERRAIN;
        polyline.arcType = Cesium.ArcType.GEODESIC;
        polyline.clampToGround = true;
      }

      return true;
    }

    function processPolygon(
      dataSource,
      entityCollection,
      geometryNode,
      entity,
      styleEntity
    ) {
      var outerBoundaryIsNode = queryFirstNode(
        geometryNode,
        "outerBoundaryIs",
        namespaces.kml
      );
      var linearRingNode = queryFirstNode(
        outerBoundaryIsNode,
        "LinearRing",
        namespaces.kml
      );
      var coordinatesNode = queryFirstNode(
        linearRingNode,
        "coordinates",
        namespaces.kml
      );
      var ellipsoid = dataSource._ellipsoid;
      var coordinates = readCoordinates(coordinatesNode, ellipsoid);
      var extrude = queryBooleanValue(geometryNode, "extrude", namespaces.kml);
      var altitudeMode = queryStringValue(
        geometryNode,
        "altitudeMode",
        namespaces.kml
      );
      var gxAltitudeMode = queryStringValue(
        geometryNode,
        "altitudeMode",
        namespaces.gx
      );
      var canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);

      var polygon = Cesium.defined(styleEntity.polygon)
        ? styleEntity.polygon.clone()
        : createDefaultPolygon();

      var polyline = styleEntity.polyline;
      if (Cesium.defined(polyline)) {
        polygon.outlineColor = Cesium.defined(polyline.material)
          ? polyline.material.color
          : Cesium.Color.WHITE;
        polygon.outlineWidth = polyline.width;
      }
      entity.polygon = polygon;

      if (canExtrude) {
        polygon.perPositionHeight = true;
        polygon.extrudedHeight = extrude ? 0 : undefined;
      } else if (!dataSource._clampToGround) {
        polygon.height = 0;
      }

      if (Cesium.defined(coordinates)) {
        var hierarchy = new Cesium.PolygonHierarchy(coordinates);
        var innerBoundaryIsNodes = queryChildNodes(
          geometryNode,
          "innerBoundaryIs",
          namespaces.kml
        );
        for (var j = 0; j < innerBoundaryIsNodes.length; j++) {
          linearRingNode = queryChildNodes(
            innerBoundaryIsNodes[j],
            "LinearRing",
            namespaces.kml
          );
          for (var k = 0; k < linearRingNode.length; k++) {
            coordinatesNode = queryFirstNode(
              linearRingNode[k],
              "coordinates",
              namespaces.kml
            );
            coordinates = readCoordinates(coordinatesNode, ellipsoid);
            if (Cesium.defined(coordinates)) {
              hierarchy.holes.push(new Cesium.PolygonHierarchy(coordinates));
            }
          }
        }
        polygon.hierarchy = hierarchy;
      }

      return true;
    }

    function processTrack(
      dataSource,
      entityCollection,
      geometryNode,
      entity,
      styleEntity
    ) {
      var altitudeMode = queryStringValue(
        geometryNode,
        "altitudeMode",
        namespaces.kml
      );
      var gxAltitudeMode = queryStringValue(
        geometryNode,
        "altitudeMode",
        namespaces.gx
      );
      var coordNodes = queryChildNodes(geometryNode, "coord", namespaces.gx);
      var angleNodes = queryChildNodes(geometryNode, "angles", namespaces.gx);
      var timeNodes = queryChildNodes(geometryNode, "when", namespaces.kml);
      var extrude = queryBooleanValue(geometryNode, "extrude", namespaces.kml);
      var canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);
      var ellipsoid = dataSource._ellipsoid;

      if (angleNodes.length > 0) {
        Cesium.oneTimeWarning(
          "kml-gx:angles",
          "KML - gx:angles are not supported in gx:Tracks"
        );
      }

      var length = Math.min(coordNodes.length, timeNodes.length);
      var coordinates = [];
      var times = [];
      for (var i = 0; i < length; i++) {
        var position = readCoordinate(coordNodes[i].textContent, ellipsoid);
        coordinates.push(position);
        times.push(Cesium.JulianDate.fromIso8601(timeNodes[i].textContent));
      }
      var property = new Cesium.SampledPositionProperty();
      property.addSamples(times, coordinates);
      entity.position = property;
      processPositionGraphics(
        dataSource,
        entity,
        styleEntity,
        heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode)
      );
      processPathGraphics(entity, styleEntity);

      entity.availability = new Cesium.TimeIntervalCollection();

      if (timeNodes.length > 0) {
        entity.availability.addInterval(
          new Cesium.TimeInterval({
            start: times[0],
            stop: times[times.length - 1],
          })
        );
      }

      if (canExtrude && extrude) {
        createDropLine(entityCollection, entity, styleEntity);
      }

      return true;
    }

    function addToMultiTrack(
      times,
      positions,
      composite,
      availability,
      dropShowProperty,
      extrude,
      altitudeMode,
      gxAltitudeMode,
      includeEndPoints
    ) {
      var start = times[0];
      var stop = times[times.length - 1];

      var data = new Cesium.SampledPositionProperty();
      data.addSamples(times, positions);

      composite.intervals.addInterval(
        new Cesium.TimeInterval({
          start: start,
          stop: stop,
          isStartIncluded: includeEndPoints,
          isStopIncluded: includeEndPoints,
          data: createPositionPropertyFromAltitudeMode(
            data,
            altitudeMode,
            gxAltitudeMode
          ),
        })
      );
      availability.addInterval(
        new Cesium.TimeInterval({
          start: start,
          stop: stop,
          isStartIncluded: includeEndPoints,
          isStopIncluded: includeEndPoints,
        })
      );
      dropShowProperty.intervals.addInterval(
        new Cesium.TimeInterval({
          start: start,
          stop: stop,
          isStartIncluded: includeEndPoints,
          isStopIncluded: includeEndPoints,
          data: extrude,
        })
      );
    }

    function processMultiTrack(
      dataSource,
      entityCollection,
      geometryNode,
      entity,
      styleEntity
    ) {
      // Multitrack options do not work in GE as detailed in the spec,
      // rather than altitudeMode being at the MultiTrack level,
      // GE just defers all settings to the underlying track.

      var interpolate = queryBooleanValue(
        geometryNode,
        "interpolate",
        namespaces.gx
      );
      var trackNodes = queryChildNodes(geometryNode, "Track", namespaces.gx);

      var times;
      var lastStop;
      var lastStopPosition;
      var needDropLine = false;
      var dropShowProperty = new Cesium.TimeIntervalCollectionProperty();
      var availability = new Cesium.TimeIntervalCollection();
      var composite = new Cesium.CompositePositionProperty();
      var ellipsoid = dataSource._ellipsoid;
      for (var i = 0, len = trackNodes.length; i < len; i++) {
        var trackNode = trackNodes[i];
        var timeNodes = queryChildNodes(trackNode, "when", namespaces.kml);
        var coordNodes = queryChildNodes(trackNode, "coord", namespaces.gx);
        var altitudeMode = queryStringValue(
          trackNode,
          "altitudeMode",
          namespaces.kml
        );
        var gxAltitudeMode = queryStringValue(
          trackNode,
          "altitudeMode",
          namespaces.gx
        );
        var canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);
        var extrude = queryBooleanValue(trackNode, "extrude", namespaces.kml);

        var length = Math.min(coordNodes.length, timeNodes.length);

        var positions = [];
        times = [];
        for (var x = 0; x < length; x++) {
          var position = readCoordinate(coordNodes[x].textContent, ellipsoid);
          positions.push(position);
          times.push(Cesium.JulianDate.fromIso8601(timeNodes[x].textContent));
        }

        if (interpolate) {
          //If we are interpolating, then we need to fill in the end of
          //the last track and the beginning of this one with a sampled
          //property.  From testing in Google Earth, this property
          //is never extruded and always absolute.
          if (Cesium.defined(lastStop)) {
            addToMultiTrack(
              [lastStop, times[0]],
              [lastStopPosition, positions[0]],
              composite,
              availability,
              dropShowProperty,
              false,
              "absolute",
              undefined,
              false
            );
          }
          lastStop = times[length - 1];
          lastStopPosition = positions[positions.length - 1];
        }

        addToMultiTrack(
          times,
          positions,
          composite,
          availability,
          dropShowProperty,
          canExtrude && extrude,
          altitudeMode,
          gxAltitudeMode,
          true
        );
        needDropLine = needDropLine || (canExtrude && extrude);
      }

      entity.availability = availability;
      entity.position = composite;
      processPositionGraphics(dataSource, entity, styleEntity);
      processPathGraphics(entity, styleEntity);
      if (needDropLine) {
        createDropLine(entityCollection, entity, styleEntity);
        entity.polyline.show = dropShowProperty;
      }

      return true;
    }

    var geometryTypes = {
      Point: processPoint,
      LineString: processLineStringOrLinearRing,
      LinearRing: processLineStringOrLinearRing,
      Polygon: processPolygon,
      Track: processTrack,
      MultiTrack: processMultiTrack,
      MultiGeometry: processMultiGeometry,
      Model: processUnsupportedGeometry,
    };

    function processMultiGeometry(
      dataSource,
      entityCollection,
      geometryNode,
      entity,
      styleEntity,
      context
    ) {
      var childNodes = geometryNode.childNodes;
      var hasGeometry = false;
      for (var i = 0, len = childNodes.length; i < len; i++) {
        var childNode = childNodes.item(i);
        var geometryProcessor = geometryTypes[childNode.localName];
        if (Cesium.defined(geometryProcessor)) {
          var childEntity = createEntity(childNode, entityCollection, context);
          childEntity.parent = entity;
          childEntity.name = entity.name;
          childEntity.availability = entity.availability;
          childEntity.description = entity.description;
          childEntity.kml = entity.kml;
          if (
            geometryProcessor(
              dataSource,
              entityCollection,
              childNode,
              childEntity,
              styleEntity
            )
          ) {
            hasGeometry = true;
          }
        }
      }

      return hasGeometry;
    }

    function processUnsupportedGeometry(
      dataSource,
      entityCollection,
      geometryNode,
      entity,
      styleEntity
    ) {
      Cesium.oneTimeWarning(
        "kml-unsupportedGeometry",
        "KML - Unsupported geometry: " + geometryNode.localName
      );
      return false;
    }

    function processExtendedData(node, entity) {
      var extendedDataNode = queryFirstNode(node, "ExtendedData", namespaces.kml);

      if (!Cesium.defined(extendedDataNode)) {
        return undefined;
      }

      if (Cesium.defined(queryFirstNode(extendedDataNode, "SchemaData", namespaces.kml))) {
        Cesium.oneTimeWarning("kml-schemaData", "KML - SchemaData is unsupported");
      }
      if (Cesium.defined(queryStringAttribute(extendedDataNode, "xmlns:prefix"))) {
        Cesium.oneTimeWarning(
          "kml-extendedData",
          "KML - ExtendedData with xmlns:prefix is unsupported"
        );
      }

      var result = {};
      var dataNodes = queryChildNodes(extendedDataNode, "Data", namespaces.kml);
      if (Cesium.defined(dataNodes)) {
        var length = dataNodes.length;
        for (var i = 0; i < length; i++) {
          var dataNode = dataNodes[i];
          var name = queryStringAttribute(dataNode, "name");
          if (Cesium.defined(name)) {
            result[name] = {
              displayName: queryStringValue(
                dataNode,
                "displayName",
                namespaces.kml
              ),
              value: queryStringValue(dataNode, "value", namespaces.kml),
            };
          }
        }
      }
      entity.kml.extendedData = result;
    }

    var scratchDiv;
    if (typeof document !== "undefined") {
      scratchDiv = document.createElement("div");
    }

    function processDescription(
      node,
      entity,
      styleEntity,
      uriResolver,
      sourceResource
    ) {
      var i;
      var key;
      var keys;

      var kmlData = entity.kml;
      var extendedData = kmlData.extendedData;
      var description = queryStringValue(node, "description", namespaces.kml);

      var balloonStyle = Cesium.defaultValue(
        entity.balloonStyle,
        styleEntity.balloonStyle
      );

      var background = Cesium.Color.WHITE;
      var foreground = Cesium.Color.BLACK;
      var text = description;

      if (Cesium.defined(balloonStyle)) {
        background = Cesium.defaultValue(balloonStyle.bgColor, Cesium.Color.WHITE);
        foreground = Cesium.defaultValue(balloonStyle.textColor, Cesium.Color.BLACK);
        text = Cesium.defaultValue(balloonStyle.text, description);
      }

      var value;
      if (Cesium.defined(text)) {
        text = text.replace("$[name]", Cesium.defaultValue(entity.name, ""));
        text = text.replace("$[description]", Cesium.defaultValue(description, ""));
        text = text.replace("$[address]", Cesium.defaultValue(kmlData.address, ""));
        text = text.replace("$[Snippet]", Cesium.defaultValue(kmlData.snippet, ""));
        text = text.replace("$[id]", entity.id);

        //While not explicitly Cesium.defined by the OGC spec, in Google Earth
        //The appearance of geDirections adds the directions to/from links
        //We simply replace this string with nothing.
        text = text.replace("$[geDirections]", "");

        if (Cesium.defined(extendedData)) {
          var matches = text.match(/\$\[.+?\]/g);
          if (matches !== null) {
            for (i = 0; i < matches.length; i++) {
              var token = matches[i];
              var propertyName = token.substr(2, token.length - 3);
              var isDisplayName = /\/displayName$/.test(propertyName);
              propertyName = propertyName.replace(/\/displayName$/, "");

              value = extendedData[propertyName];
              if (Cesium.defined(value)) {
                value = isDisplayName ? value.displayName : value.value;
              }
              if (Cesium.defined(value)) {
                text = text.replace(token, Cesium.defaultValue(value, ""));
              }
            }
          }
        }
      } else if (Cesium.defined(extendedData)) {
        //If no description exists, build a table out of the extended data
        keys = Object.keys(extendedData);
        if (keys.length > 0) {
          text =
            '<table class="cesium-infoBox-defaultTable cesium-infoBox-defaultTable-lighter"><tbody>';
          for (i = 0; i < keys.length; i++) {
            key = keys[i];
            value = extendedData[key];
            text +=
              "<tr><th>" +
              Cesium.defaultValue(value.displayName, key) +
              "</th><td>" +
              Cesium.defaultValue(value.value, "") +
              "</td></tr>";
          }
          text += "</tbody></table>";
        }
      }

      if (!Cesium.defined(text)) {
        //No description
        return;
      }

      //Turns non-explicit links into clickable links.
      text = autolinker.link(text);

      //Use a temporary div to manipulate the links
      //so that they open in a new window.
      scratchDiv.innerHTML = text;
      var links = scratchDiv.querySelectorAll("a");
      for (i = 0; i < links.length; i++) {
        links[i].setAttribute("target", "_blank");
      }

      //Rewrite any KMZ embedded urls
      if (Cesium.defined(uriResolver) && uriResolver.keys.length > 1) {
        embedDataUris(scratchDiv, "a", "href", uriResolver);
        embedDataUris(scratchDiv, "img", "src", uriResolver);
      }

      //Make relative urls absolute using the sourceResource
      applyBasePath(scratchDiv, "a", "href", sourceResource);
      applyBasePath(scratchDiv, "img", "src", sourceResource);

      var tmp = '<div class="cesium-infoBox-description-lighter" style="';
      tmp += "overflow:auto;";
      tmp += "word-wrap:break-word;";
      tmp += "background-color:" + background.toCssColorString() + ";";
      tmp += "color:" + foreground.toCssColorString() + ";";
      tmp += '">';
      tmp += scratchDiv.innerHTML + "</div>";
      scratchDiv.innerHTML = "";

      //Set the final HTML as the description.
      entity.description = tmp;
    }

    function processFeature(dataSource, featureNode, processingData) {
      var entityCollection = processingData.entityCollection;
      var parent = processingData.parentEntity;
      var sourceResource = processingData.sourceResource;
      var uriResolver = processingData.uriResolver;

      var entity = createEntity(
        featureNode,
        entityCollection,
        processingData.context
      );
      var kmlData = entity.kml;
      var styleEntity = computeFinalStyle(
        dataSource,
        featureNode,
        processingData.styleCollection,
        sourceResource,
        uriResolver
      );

      var name = queryStringValue(featureNode, "name", namespaces.kml);
      entity.name = name;
      entity.parent = parent;

      var availability = processTimeSpan(featureNode);
      if (!Cesium.defined(availability)) {
        availability = processTimeStamp(featureNode);
      }
      entity.availability = availability;

      mergeAvailabilityWithParent(entity);

      // Per KML spec "A Feature is visible only if it and all its ancestors are visible."
      function ancestryIsVisible(parentEntity) {
        if (!parentEntity) {
          return true;
        }
        return parentEntity.show && ancestryIsVisible(parentEntity.parent);
      }

      var visibility = queryBooleanValue(featureNode, "visibility", namespaces.kml);
      entity.show = ancestryIsVisible(parent) && Cesium.defaultValue(visibility, true);
      //var open = queryBooleanValue(featureNode, 'open', namespaces.kml);

      var authorNode = queryFirstNode(featureNode, "author", namespaces.atom);
      var author = kmlData.author;
      author.name = queryStringValue(authorNode, "name", namespaces.atom);
      author.uri = queryStringValue(authorNode, "uri", namespaces.atom);
      author.email = queryStringValue(authorNode, "email", namespaces.atom);

      var linkNode = queryFirstNode(featureNode, "link", namespaces.atom);
      var link = kmlData.link;
      link.href = queryStringAttribute(linkNode, "href");
      link.hreflang = queryStringAttribute(linkNode, "hreflang");
      link.rel = queryStringAttribute(linkNode, "rel");
      link.type = queryStringAttribute(linkNode, "type");
      link.title = queryStringAttribute(linkNode, "title");
      link.length = queryStringAttribute(linkNode, "length");

      kmlData.address = queryStringValue(featureNode, "address", namespaces.kml);
      kmlData.phoneNumber = queryStringValue(
        featureNode,
        "phoneNumber",
        namespaces.kml
      );
      kmlData.snippet = queryStringValue(featureNode, "Snippet", namespaces.kml);

      processExtendedData(featureNode, entity);
      processDescription(
        featureNode,
        entity,
        styleEntity,
        uriResolver,
        sourceResource
      );

      var ellipsoid = dataSource._ellipsoid;
      processLookAt(featureNode, entity, ellipsoid);
      processCamera(featureNode, entity, ellipsoid);

      if (Cesium.defined(queryFirstNode(featureNode, "Region", namespaces.kml))) {
        Cesium.oneTimeWarning("kml-region", "KML - Placemark Regions are unsupported");
      }

      return {
        entity: entity,
        styleEntity: styleEntity,
      };
    }

    function processDocument(dataSource, node, processingData, deferredLoading) {
      deferredLoading.addNodes(node.childNodes, processingData);
      deferredLoading.process();
    }

    function processFolder(dataSource, node, processingData, deferredLoading) {
      var r = processFeature(dataSource, node, processingData);
      var newProcessingData = Cesium.clone(processingData);
      newProcessingData.parentEntity = r.entity;
      processDocument(dataSource, node, newProcessingData, deferredLoading);
    }

    function processPlacemark(
      dataSource,
      placemark,
      processingData,
      deferredLoading
    ) {
      var r = processFeature(dataSource, placemark, processingData);
      var entity = r.entity;
      var styleEntity = r.styleEntity;

      var hasGeometry = false;
      var childNodes = placemark.childNodes;
      for (var i = 0, len = childNodes.length; i < len && !hasGeometry; i++) {
        var childNode = childNodes.item(i);
        var geometryProcessor = geometryTypes[childNode.localName];
        if (Cesium.defined(geometryProcessor)) {
          // pass the placemark entity id as a context for case of defining multiple child entities together to handle case
          // where some malformed kmls reuse the same id across placemarks, which works in GE, but is not technically to spec.
          geometryProcessor(
            dataSource,
            processingData.entityCollection,
            childNode,
            entity,
            styleEntity,
            entity.id
          );
          hasGeometry = true;
        }
      }

      if (!hasGeometry) {
        entity.merge(styleEntity);
        processPositionGraphics(dataSource, entity, styleEntity);
      }
    }

    var playlistNodeProcessors = {
      FlyTo: processTourFlyTo,
      Wait: processTourWait,
      SoundCue: processTourUnsupportedNode,
      AnimatedUpdate: processTourUnsupportedNode,
      TourControl: processTourUnsupportedNode,
    };

    function processTour(dataSource, node, processingData, deferredLoading) {
      var name = queryStringValue(node, "name", namespaces.kml);
      var id = queryStringAttribute(node, "id");
      var tour = new Cesium.KmlTour(name, id);

      var playlistNode = queryFirstNode(node, "Playlist", namespaces.gx);
      if (playlistNode) {
        var ellipsoid = dataSource._ellipsoid;
        var childNodes = playlistNode.childNodes;
        for (var i = 0; i < childNodes.length; i++) {
          var entryNode = childNodes[i];
          if (entryNode.localName) {
            var playlistNodeProcessor = playlistNodeProcessors[entryNode.localName];
            if (playlistNodeProcessor) {
              playlistNodeProcessor(tour, entryNode, ellipsoid);
            } else {
              console.log(
                "Unknown KML Tour playlist entry type " + entryNode.localName
              );
            }
          }
        }
      }

      if (!Cesium.defined(dataSource.kmlTours)) {
        dataSource.kmlTours = [];
      }

      dataSource.kmlTours.push(tour);
    }

    function processTourUnsupportedNode(tour, entryNode) {
      Cesium.oneTimeWarning("KML Tour unsupported node " + entryNode.localName);
    }

    function processTourWait(tour, entryNode) {
      var duration = queryNumericValue(entryNode, "duration", namespaces.gx);
      tour.addPlaylistEntry(new Cesium.KmlTourWait(duration));
    }

    function processTourFlyTo(tour, entryNode, ellipsoid) {
      var duration = queryNumericValue(entryNode, "duration", namespaces.gx);
      var flyToMode = queryStringValue(entryNode, "flyToMode", namespaces.gx);

      var t = { kml: {} };

      processLookAt(entryNode, t, ellipsoid);
      processCamera(entryNode, t, ellipsoid);

      var view = t.kml.lookAt || t.kml.camera;

      var flyto = new Cesium.KmlTourFlyTo(duration, flyToMode, view);
      tour.addPlaylistEntry(flyto);
    }

    function processCamera(featureNode, entity, ellipsoid) {
      var camera = queryFirstNode(featureNode, "Camera", namespaces.kml);
      if (Cesium.defined(camera)) {
        var lon = Cesium.defaultValue(
          queryNumericValue(camera, "longitude", namespaces.kml),
          0.0
        );
        var lat = Cesium.defaultValue(
          queryNumericValue(camera, "latitude", namespaces.kml),
          0.0
        );
        var altitude = Cesium.defaultValue(
          queryNumericValue(camera, "altitude", namespaces.kml),
          0.0
        );

        var heading = Cesium.defaultValue(
          queryNumericValue(camera, "heading", namespaces.kml),
          0.0
        );
        var tilt = Cesium.defaultValue(
          queryNumericValue(camera, "tilt", namespaces.kml),
          0.0
        );
        var roll = Cesium.defaultValue(
          queryNumericValue(camera, "roll", namespaces.kml),
          0.0
        );

        var position = Cesium.Cartesian3.fromDegrees(lon, lat, altitude, ellipsoid);
        var hpr = Cesium.HeadingPitchRoll.fromDegrees(heading, tilt - 90.0, roll);

        entity.kml.camera = new Cesium.KmlCamera(position, hpr);
      }
    }

    function processLookAt(featureNode, entity, ellipsoid) {
      var lookAt = queryFirstNode(featureNode, "LookAt", namespaces.kml);
      if (Cesium.defined(lookAt)) {
        var lon = Cesium.defaultValue(
          queryNumericValue(lookAt, "longitude", namespaces.kml),
          0.0
        );
        var lat = Cesium.defaultValue(
          queryNumericValue(lookAt, "latitude", namespaces.kml),
          0.0
        );
        var altitude = Cesium.defaultValue(
          queryNumericValue(lookAt, "altitude", namespaces.kml),
          0.0
        );
        var heading = queryNumericValue(lookAt, "heading", namespaces.kml);
        var tilt = queryNumericValue(lookAt, "tilt", namespaces.kml);
        var range = Cesium.defaultValue(
          queryNumericValue(lookAt, "range", namespaces.kml),
          0.0
        );

        tilt = Cesium.Math.toRadians(Cesium.defaultValue(tilt, 0.0));
        heading = Cesium.Math.toRadians(Cesium.defaultValue(heading, 0.0));

        var hpr = new Cesium.HeadingPitchRange(
          heading,
          tilt - Cesium.Math.PI_OVER_TWO,
          range
        );
        var viewPoint = Cesium.Cartesian3.fromDegrees(lon, lat, altitude, ellipsoid);

        entity.kml.lookAt = new Cesium.KmlLookAt(viewPoint, hpr);
      }
    }

    function processGroundOverlay(
      dataSource,
      groundOverlay,
      processingData,
      deferredLoading
    ) {
      var r = processFeature(dataSource, groundOverlay, processingData);
      var entity = r.entity;

      var geometry;
      var isLatLonQuad = false;

      var ellipsoid = dataSource._ellipsoid;
      var positions = readCoordinates(
        queryFirstNode(groundOverlay, "LatLonQuad", namespaces.gx),
        ellipsoid
      );
      var zIndex = queryNumericValue(groundOverlay, "drawOrder", namespaces.kml);
      if (Cesium.defined(positions)) {
        geometry = createDefaultPolygon();
        geometry.hierarchy = new Cesium.PolygonHierarchy(positions);
        geometry.zIndex = zIndex;
        entity.polygon = geometry;
        isLatLonQuad = true;
      } else {
        geometry = new Cesium.RectangleGraphics();
        geometry.zIndex = zIndex;
        entity.rectangle = geometry;

        var latLonBox = queryFirstNode(groundOverlay, "LatLonBox", namespaces.kml);
        if (Cesium.defined(latLonBox)) {
          var west = queryNumericValue(latLonBox, "west", namespaces.kml);
          var south = queryNumericValue(latLonBox, "south", namespaces.kml);
          var east = queryNumericValue(latLonBox, "east", namespaces.kml);
          var north = queryNumericValue(latLonBox, "north", namespaces.kml);

          if (Cesium.defined(west)) {
            west = Cesium.Math.negativePiToPi(Cesium.Math.toRadians(west));
          }
          if (Cesium.defined(south)) {
            south = Cesium.Math.clampToLatitudeRange(Cesium.Math.toRadians(south));
          }
          if (Cesium.defined(east)) {
            east = Cesium.Math.negativePiToPi(Cesium.Math.toRadians(east));
          }
          if (Cesium.defined(north)) {
            north = Cesium.Math.clampToLatitudeRange(Cesium.Math.toRadians(north));
          }
          geometry.coordinates = new Cesium.Rectangle(west, south, east, north);

          var rotation = queryNumericValue(latLonBox, "rotation", namespaces.kml);
          if (Cesium.defined(rotation)) {
            var rotationRadians = Cesium.Math.toRadians(rotation);
            geometry.rotation = rotationRadians;
            geometry.stRotation = rotationRadians;
          }
        }
      }

      var iconNode = queryFirstNode(groundOverlay, "Icon", namespaces.kml);
      var href = getIconHref(
        iconNode,
        dataSource,
        processingData.sourceResource,
        processingData.uriResolver,
        true
      );
      if (Cesium.defined(href)) {
        if (isLatLonQuad) {
          Cesium.oneTimeWarning(
            "kml-gx:LatLonQuad",
            "KML - gx:LatLonQuad Icon does not support texture projection."
          );
        }
        var x = queryNumericValue(iconNode, "x", namespaces.gx);
        var y = queryNumericValue(iconNode, "y", namespaces.gx);
        var w = queryNumericValue(iconNode, "w", namespaces.gx);
        var h = queryNumericValue(iconNode, "h", namespaces.gx);

        if (Cesium.defined(x) || Cesium.defined(y) || Cesium.defined(w) || Cesium.defined(h)) {
          Cesium.oneTimeWarning(
            "kml-groundOverlay-xywh",
            "KML - gx:x, gx:y, gx:w, gx:h aren't supported for GroundOverlays"
          );
        }

        geometry.material = href;
        geometry.material.color = queryColorValue(
          groundOverlay,
          "color",
          namespaces.kml
        );
        geometry.material.transparent = true;
      } else {
        geometry.material = queryColorValue(groundOverlay, "color", namespaces.kml);
      }

      var altitudeMode = queryStringValue(
        groundOverlay,
        "altitudeMode",
        namespaces.kml
      );

      if (Cesium.defined(altitudeMode)) {
        if (altitudeMode === "absolute") {
          //Use height above ellipsoid until we support MSL.
          geometry.height = queryNumericValue(
            groundOverlay,
            "altitude",
            namespaces.kml
          );
          geometry.zIndex = undefined;
        } else if (altitudeMode !== "clampToGround") {
          Cesium.oneTimeWarning(
            "kml-altitudeMode-unknown",
            "KML - Unknown altitudeMode: " + altitudeMode
          );
        }
        // else just use the default of 0 until we support 'clampToGround'
      } else {
        altitudeMode = queryStringValue(
          groundOverlay,
          "altitudeMode",
          namespaces.gx
        );
        if (altitudeMode === "relativeToSeaFloor") {
          Cesium.oneTimeWarning(
            "kml-altitudeMode-relativeToSeaFloor",
            "KML - altitudeMode relativeToSeaFloor is currently not supported, treating as absolute."
          );
          geometry.height = queryNumericValue(
            groundOverlay,
            "altitude",
            namespaces.kml
          );
          geometry.zIndex = undefined;
        } else if (altitudeMode === "clampToSeaFloor") {
          Cesium.oneTimeWarning(
            "kml-altitudeMode-clampToSeaFloor",
            "KML - altitudeMode clampToSeaFloor is currently not supported, treating as clampToGround."
          );
        } else if (Cesium.defined(altitudeMode)) {
          Cesium.oneTimeWarning(
            "kml-altitudeMode-unknown",
            "KML - Unknown altitudeMode: " + altitudeMode
          );
        }
      }
    }

    function processUnsupportedFeature(
      dataSource,
      node,
      processingData,
      deferredLoading
    ) {
      dataSource._unsupportedNode.raiseEvent(
        dataSource,
        processingData.parentEntity,
        node,
        processingData.entityCollection,
        processingData.styleCollection,
        processingData.sourceResource,
        processingData.uriResolver
      );
      Cesium.oneTimeWarning(
        "kml-unsupportedFeature-" + node.nodeName,
        "KML - Unsupported feature: " + node.nodeName
      );
    }

    var RefreshMode = {
      INTERVAL: 0,
      EXPIRE: 1,
      STOP: 2,
    };

    function cleanupString(s) {
      if (!Cesium.defined(s) || s.length === 0) {
        return "";
      }

      var sFirst = s[0];
      if (sFirst === "&" || sFirst === "?") {
        s = s.substring(1);
      }

      return s;
    }

    var zeroRectangle;
    var scratchCartographic;
    var scratchCartesian2;
    var scratchCartesian3;

    function processNetworkLinkQueryString(
      resource,
      camera,
      canvas,
      viewBoundScale,
      bbox,
      ellipsoid
    ) {
      function fixLatitude(value) {
        if (value < -Cesium.Math.PI_OVER_TWO) {
          return -Cesium.Math.PI_OVER_TWO;
        } else if (value > Cesium.Math.PI_OVER_TWO) {
          return Cesium.Math.PI_OVER_TWO;
        }
        return value;
      }

      function fixLongitude(value) {
        if (value > Cesium.Math.PI) {
          return value - Cesium.Math.TWO_PI;
        } else if (value < -Cesium.Math.PI) {
          return value + Cesium.Math.TWO_PI;
        }

        return value;
      }

      var queryString = Cesium.objectToQuery(resource.queryParameters);

      // Cesium.objectToQuery escapes [ and ], so fix that
      queryString = queryString.replace(/%5B/g, "[").replace(/%5D/g, "]");

      if (Cesium.defined(camera) && camera._mode !== Cesium.SceneMode.MORPHING) {
        var centerCartesian;
        var centerCartographic;

        bbox = Cesium.defaultValue(bbox, zeroRectangle);
        if (Cesium.defined(canvas)) {
          scratchCartesian2.x = canvas.clientWidth * 0.5;
          scratchCartesian2.y = canvas.clientHeight * 0.5;
          centerCartesian = camera.pickEllipsoid(
            scratchCartesian2,
            ellipsoid,
            scratchCartesian3
          );
        }

        if (Cesium.defined(centerCartesian)) {
          centerCartographic = ellipsoid.cartesianToCartographic(
            centerCartesian,
            scratchCartographic
          );
        } else {
          centerCartographic = Cesium.Rectangle.center(bbox, scratchCartographic);
          centerCartesian = ellipsoid.cartographicToCartesian(centerCartographic);
        }

        if (
          Cesium.defined(viewBoundScale) &&
          !Cesium.Math.equalsEpsilon(viewBoundScale, 1.0, Cesium.Math.EPSILON9)
        ) {
          var newHalfWidth = bbox.width * viewBoundScale * 0.5;
          var newHalfHeight = bbox.height * viewBoundScale * 0.5;
          bbox = new Cesium.Rectangle(
            fixLongitude(centerCartographic.longitude - newHalfWidth),
            fixLatitude(centerCartographic.latitude - newHalfHeight),
            fixLongitude(centerCartographic.longitude + newHalfWidth),
            fixLatitude(centerCartographic.latitude + newHalfHeight)
          );
        }

        queryString = queryString.replace(
          "[bboxWest]",
          Cesium.Math.toDegrees(bbox.west).toString()
        );
        queryString = queryString.replace(
          "[bboxSouth]",
          Cesium.Math.toDegrees(bbox.south).toString()
        );
        queryString = queryString.replace(
          "[bboxEast]",
          Cesium.Math.toDegrees(bbox.east).toString()
        );
        queryString = queryString.replace(
          "[bboxNorth]",
          Cesium.Math.toDegrees(bbox.north).toString()
        );

        var lon = Cesium.Math.toDegrees(centerCartographic.longitude).toString();
        var lat = Cesium.Math.toDegrees(centerCartographic.latitude).toString();
        queryString = queryString.replace("[lookatLon]", lon);
        queryString = queryString.replace("[lookatLat]", lat);
        queryString = queryString.replace(
          "[lookatTilt]",
          Cesium.Math.toDegrees(camera.pitch).toString()
        );
        queryString = queryString.replace(
          "[lookatHeading]",
          Cesium.Math.toDegrees(camera.heading).toString()
        );
        queryString = queryString.replace(
          "[lookatRange]",
          Cesium.Cartesian3.distance(camera.positionWC, centerCartesian)
        );
        queryString = queryString.replace("[lookatTerrainLon]", lon);
        queryString = queryString.replace("[lookatTerrainLat]", lat);
        queryString = queryString.replace(
          "[lookatTerrainAlt]",
          centerCartographic.height.toString()
        );

        ellipsoid.cartesianToCartographic(camera.positionWC, scratchCartographic);
        queryString = queryString.replace(
          "[cameraLon]",
          Cesium.Math.toDegrees(scratchCartographic.longitude).toString()
        );
        queryString = queryString.replace(
          "[cameraLat]",
          Cesium.Math.toDegrees(scratchCartographic.latitude).toString()
        );
        queryString = queryString.replace(
          "[cameraAlt]",
          Cesium.Math.toDegrees(scratchCartographic.height).toString()
        );

        var frustum = camera.frustum;
        var aspectRatio = frustum.aspectRatio;
        var horizFov = "";
        var vertFov = "";
        if (Cesium.defined(aspectRatio)) {
          var fov = Cesium.Math.toDegrees(frustum.fov);
          if (aspectRatio > 1.0) {
            horizFov = fov;
            vertFov = fov / aspectRatio;
          } else {
            vertFov = fov;
            horizFov = fov * aspectRatio;
          }
        }
        queryString = queryString.replace("[horizFov]", horizFov.toString());
        queryString = queryString.replace("[vertFov]", vertFov.toString());
      } else {
        queryString = queryString.replace("[bboxWest]", "-180");
        queryString = queryString.replace("[bboxSouth]", "-90");
        queryString = queryString.replace("[bboxEast]", "180");
        queryString = queryString.replace("[bboxNorth]", "90");

        queryString = queryString.replace("[lookatLon]", "");
        queryString = queryString.replace("[lookatLat]", "");
        queryString = queryString.replace("[lookatRange]", "");
        queryString = queryString.replace("[lookatTilt]", "");
        queryString = queryString.replace("[lookatHeading]", "");
        queryString = queryString.replace("[lookatTerrainLon]", "");
        queryString = queryString.replace("[lookatTerrainLat]", "");
        queryString = queryString.replace("[lookatTerrainAlt]", "");

        queryString = queryString.replace("[cameraLon]", "");
        queryString = queryString.replace("[cameraLat]", "");
        queryString = queryString.replace("[cameraAlt]", "");
        queryString = queryString.replace("[horizFov]", "");
        queryString = queryString.replace("[vertFov]", "");
      }

      if (Cesium.defined(canvas)) {
        queryString = queryString.replace("[horizPixels]", canvas.clientWidth);
        queryString = queryString.replace("[vertPixels]", canvas.clientHeight);
      } else {
        queryString = queryString.replace("[horizPixels]", "");
        queryString = queryString.replace("[vertPixels]", "");
      }

      queryString = queryString.replace("[terrainEnabled]", "1");
      queryString = queryString.replace("[clientVersion]", "1");
      queryString = queryString.replace("[kmlVersion]", "2.2");
      queryString = queryString.replace("[clientName]", "Cesium");
      queryString = queryString.replace("[language]", "English");

      resource.setQueryParameters(Cesium.queryToObject(queryString));
    }

    function processNetworkLink(dataSource, node, processingData, deferredLoading) {
      var r = processFeature(dataSource, node, processingData);
      var networkEntity = r.entity;

      var sourceResource = processingData.sourceResource;
      var uriResolver = processingData.uriResolver;

      var link = queryFirstNode(node, "Link", namespaces.kml);

      if (!Cesium.defined(link)) {
        link = queryFirstNode(node, "Url", namespaces.kml);
      }
      if (Cesium.defined(link)) {
        var href = queryStringValue(link, "href", namespaces.kml);
        var viewRefreshMode;
        var viewBoundScale;
        if (Cesium.defined(href)) {
          var newSourceUri = href;
          href = resolveHref(href, sourceResource, processingData.uriResolver);

          // We need to pass in the original path if resolveHref returns a data uri because the network link
          //  references a document in a KMZ archive
          if (/^data:/.test(href.getUrlComponent())) {
            // So if sourceUri isn't the kmz file, then its another kml in the archive, so resolve it
            if (!/\.kmz/i.test(sourceResource.getUrlComponent())) {
              newSourceUri = sourceResource.getDerivedResource({
                url: newSourceUri,
              });
            }
          } else {
            newSourceUri = href.clone(); // Not a data uri so use the fully qualified uri
            viewRefreshMode = queryStringValue(
              link,
              "viewRefreshMode",
              namespaces.kml
            );
            viewBoundScale = Cesium.defaultValue(
              queryStringValue(link, "viewBoundScale", namespaces.kml),
              1.0
            );
            var defaultViewFormat =
              viewRefreshMode === "onStop"
                ? "BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]"
                : "";
            var viewFormat = Cesium.defaultValue(
              queryStringValue(link, "viewFormat", namespaces.kml),
              defaultViewFormat
            );
            var httpQuery = queryStringValue(link, "httpQuery", namespaces.kml);
            if (Cesium.defined(viewFormat)) {
              href.setQueryParameters(Cesium.queryToObject(cleanupString(viewFormat)));
            }
            if (Cesium.defined(httpQuery)) {
              href.setQueryParameters(Cesium.queryToObject(cleanupString(httpQuery)));
            }

            var ellipsoid = dataSource._ellipsoid;
            processNetworkLinkQueryString(
              href,
              dataSource._camera,
              dataSource._canvas,
              viewBoundScale,
              dataSource._lastCameraView.bbox,
              ellipsoid
            );
          }

          var options = {
            sourceUri: newSourceUri,
            uriResolver: uriResolver,
            context: networkEntity.id,
          };
          var networkLinkCollection = new Cesium.EntityCollection();
          var promise = load(dataSource, networkLinkCollection, href, options)
            .then(function (rootElement) {
              var entities = dataSource._entityCollection;
              var newEntities = networkLinkCollection.values;
              entities.suspendEvents();
              for (var i = 0; i < newEntities.length; i++) {
                var newEntity = newEntities[i];
                if (!Cesium.defined(newEntity.parent)) {
                  newEntity.parent = networkEntity;
                  mergeAvailabilityWithParent(newEntity);
                }

                entities.add(newEntity);
              }
              entities.resumeEvents();

              // Add network links to a list if we need they will need to be updated
              var refreshMode = queryStringValue(
                link,
                "refreshMode",
                namespaces.kml
              );
              var refreshInterval = Cesium.defaultValue(
                queryNumericValue(link, "refreshInterval", namespaces.kml),
                0
              );
              if (
                (refreshMode === "onInterval" && refreshInterval > 0) ||
                refreshMode === "onExpire" ||
                viewRefreshMode === "onStop"
              ) {
                var networkLinkControl = queryFirstNode(
                  rootElement,
                  "NetworkLinkControl",
                  namespaces.kml
                );
                var hasNetworkLinkControl = Cesium.defined(networkLinkControl);

                var now = Cesium.JulianDate.now();
                var networkLinkInfo = {
                  id: Cesium.createGuid(),
                  href: href,
                  cookie: {},
                  lastUpdated: now,
                  updating: false,
                  entity: networkEntity,
                  viewBoundScale: viewBoundScale,
                  needsUpdate: false,
                  cameraUpdateTime: now,
                };

                var minRefreshPeriod = 0;
                if (hasNetworkLinkControl) {
                  networkLinkInfo.cookie = Cesium.queryToObject(
                    Cesium.defaultValue(
                      queryStringValue(
                        networkLinkControl,
                        "cookie",
                        namespaces.kml
                      ),
                      ""
                    )
                  );
                  minRefreshPeriod = Cesium.defaultValue(
                    queryNumericValue(
                      networkLinkControl,
                      "minRefreshPeriod",
                      namespaces.kml
                    ),
                    0
                  );
                }

                if (refreshMode === "onInterval") {
                  if (hasNetworkLinkControl) {
                    refreshInterval = Math.max(minRefreshPeriod, refreshInterval);
                  }
                  networkLinkInfo.refreshMode = RefreshMode.INTERVAL;
                  networkLinkInfo.time = refreshInterval;
                } else if (refreshMode === "onExpire") {
                  var expires;
                  if (hasNetworkLinkControl) {
                    expires = queryStringValue(
                      networkLinkControl,
                      "expires",
                      namespaces.kml
                    );
                  }
                  if (Cesium.defined(expires)) {
                    try {
                      var date = Cesium.JulianDate.fromIso8601(expires);
                      var diff = Cesium.JulianDate.secondsDifference(date, now);
                      if (diff > 0 && diff < minRefreshPeriod) {
                        Cesium.JulianDate.addSeconds(now, minRefreshPeriod, date);
                      }
                      networkLinkInfo.refreshMode = RefreshMode.EXPIRE;
                      networkLinkInfo.time = date;
                    } catch (e) {
                      Cesium.oneTimeWarning(
                        "kml-refreshMode-onInterval-onExpire",
                        "KML - NetworkLinkControl expires is not a valid date"
                      );
                    }
                  } else {
                    Cesium.oneTimeWarning(
                      "kml-refreshMode-onExpire",
                      "KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element"
                    );
                  }
                } else if (dataSource._camera) {
                  // Only allow onStop refreshes if we have a camera
                  networkLinkInfo.refreshMode = RefreshMode.STOP;
                  networkLinkInfo.time = Cesium.defaultValue(
                    queryNumericValue(link, "viewRefreshTime", namespaces.kml),
                    0
                  );
                } else {
                  Cesium.oneTimeWarning(
                    "kml-refrehMode-onStop-noCamera",
                    "A NetworkLink with viewRefreshMode=onStop requires a camera be passed in Cesium.when creating the KmlDataSource"
                  );
                }

                if (Cesium.defined(networkLinkInfo.refreshMode)) {
                  dataSource._networkLinks.set(networkLinkInfo.id, networkLinkInfo);
                }
              } else if (viewRefreshMode === "onRegion") {
                Cesium.oneTimeWarning(
                  "kml-refrehMode-onRegion",
                  "KML - Unsupported viewRefreshMode: onRegion"
                );
              }
            })
            .otherwise(function (error) {
              Cesium.oneTimeWarning("An error occured during loading " + href.url);
              dataSource._error.raiseEvent(dataSource, error);
            });

          deferredLoading.addPromise(promise);
        }
      }
    }

    function processFeatureNode(dataSource, node, processingData, deferredLoading) {
      var featureProcessor = featureTypes[node.localName];
      if (Cesium.defined(featureProcessor)) {
        return featureProcessor(dataSource, node, processingData, deferredLoading);
      }

      return processUnsupportedFeature(
        dataSource,
        node,
        processingData);
    }

    function loadKml(
      dataSource,
      entityCollection,
      kml,
      sourceResource,
      uriResolver,
      context
    ) {
      entityCollection.removeAll();

      var documentElement = kml.documentElement;
      var document =
        documentElement.localName === "Document"
          ? documentElement
          : queryFirstNode(documentElement, "Document", namespaces.kml);
      var name = queryStringValue(document, "name", namespaces.kml);
      if (!Cesium.defined(name)) {
        name = Cesium.getFilenameFromUri(sourceResource.getUrlComponent());
      }

      // Only set the name from the root document
      if (!Cesium.defined(dataSource._name)) {
        dataSource._name = name;
      }

      var deferredLoading = new KmlDataSource._DeferredLoading(dataSource);
      var styleCollection = new Cesium.EntityCollection(dataSource);
      return Cesium.when
        .all(
          processStyles(
            dataSource,
            kml,
            styleCollection,
            sourceResource,
            false,
            uriResolver
          )
        )
        .then(function () {
          var element = kml.documentElement;
          if (element.localName === "kml") {
            var childNodes = element.childNodes;
            for (var i = 0; i < childNodes.length; i++) {
              var tmp = childNodes[i];
              if (Cesium.defined(featureTypes[tmp.localName])) {
                element = tmp;
                break;
              }
            }
          }

          var processingData = {
            parentEntity: undefined,
            entityCollection: entityCollection,
            styleCollection: styleCollection,
            sourceResource: sourceResource,
            uriResolver: uriResolver,
            context: context,
          };

          entityCollection.suspendEvents();
          processFeatureNode(dataSource, element, processingData, deferredLoading);
          entityCollection.resumeEvents();

          return deferredLoading.wait().then(function () {
            return kml.documentElement;
          });
        });
    }

    function loadKmz(dataSource, entityCollection, blob, sourceResource) {
      var deferred = Cesium.when.defer();
      Cesium.zip.createReader(
        new Cesium.zip.BlobReader(blob),
        function (reader) {
          reader.getEntries(function (entries) {
            var promises = [];
            var uriResolver = {};
            var docEntry;
            var docDefer;
            for (var i = 0; i < entries.length; i++) {
              var entry = entries[i];
              if (!entry.directory) {
                var innerDefer = Cesium.when.defer();
                promises.push(innerDefer.promise);
                if (/\.kml$/i.test(entry.filename)) {
                  // We use the first KML document we come across
                  //  https://developers.google.com/kml/documentation/kmzarchives
                  // Unless we come across a .kml file at the root of the archive because GE does this
                  if (!Cesium.defined(docEntry) || !/\//i.test(entry.filename)) {
                    if (Cesium.defined(docEntry)) {
                      // We found one at the root so load the initial kml as a data uri
                      loadDataUriFromZip(docEntry, uriResolver, docDefer);
                    }
                    docEntry = entry;
                    docDefer = innerDefer;
                  } else {
                    // Wasn't the first kml and wasn't at the root
                    loadDataUriFromZip(entry, uriResolver, innerDefer);
                  }
                } else {
                  loadDataUriFromZip(entry, uriResolver, innerDefer);
                }
              }
            }

            // Now load the root KML document
            if (Cesium.defined(docEntry)) {
              loadXmlFromZip(docEntry, uriResolver, docDefer);
            }
            Cesium.when
              .all(promises)
              .then(function () {
                reader.close();
                if (!Cesium.defined(uriResolver.kml)) {
                  deferred.reject(
                    new Cesium.RuntimeError("KMZ file does not contain a KML document.")
                  );
                  return;
                }
                uriResolver.keys = Object.keys(uriResolver);
                return loadKml(
                  dataSource,
                  entityCollection,
                  uriResolver.kml,
                  sourceResource,
                  uriResolver
                );
              })
              .then(deferred.resolve)
              .otherwise(deferred.reject);
          });
        },
        function (e) {
          deferred.reject(e);
        }
      );

      return deferred.promise;
    }

    function load(dataSource, entityCollection, data, options) {
      options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
      var sourceUri = options.sourceUri;
      var uriResolver = options.uriResolver;
      var context = options.context;

      var promise = data;
      if (typeof data === "string" || data instanceof Cesium.Resource) {
        data = Cesium.Resource.createIfNeeded(data);
        promise = data.fetchBlob();
        sourceUri = Cesium.defaultValue(sourceUri, data.clone());

        // Add resource credits to our list of credits to display
        var resourceCredits = dataSource.resourceCredits;
        var credits = data.credits;
        if (Cesium.defined(credits)) {
          var length = credits.length;
          for (var i = 0; i < length; i++) {
            resourceCredits.Credits.push(credits[i]);
          }
        }
      } else {
        sourceUri = Cesium.defaultValue(sourceUri, Cesium.Resource.DEFAULT.clone());
      }

      sourceUri = Cesium.Resource.createIfNeeded(sourceUri);

      return Cesium.when(promise)
        .then(function (dataToLoad) {
          if (dataToLoad instanceof Blob) {
            return isZipFile(dataToLoad).then(function (isZip) {
              if (isZip) {
                return loadKmz(dataSource, entityCollection, dataToLoad, sourceUri);
              }
              return readBlobAsText(dataToLoad).then(function (text) {
                //There's no official way to validate if a parse was successful.
                //The following check detects the error on various browsers.

                //Insert missing namespaces
                text = insertNamespaces(text);

                //Remove Duplicate Namespaces
                text = removeDuplicateNamespaces(text);

                //IE raises an exception
                var kml;
                var error;
                try {
                  kml = parser.parseFromString(text, "application/xml");
                } catch (e) {
                  error = e.toString();
                }

                //The parse succeeds on Chrome and Firefox, but the error
                //handling is different in each.
                if (
                  Cesium.defined(error) ||
                  kml.body ||
                  kml.documentElement.tagName === "parsererror"
                ) {
                  //Firefox has error information as the firstChild nodeValue.
                  var msg = Cesium.defined(error)
                    ? error
                    : kml.documentElement.firstChild.nodeValue;

                  //Chrome has it in the body text.
                  if (!msg) {
                    msg = kml.body.innerText;
                  }

                  //Return the error
                  throw new Cesium.RuntimeError(msg);
                }
                return loadKml(
                  dataSource,
                  entityCollection,
                  kml,
                  sourceUri,
                  uriResolver,
                  context
                );
              });
            });
          }
          return loadKml(
            dataSource,
            entityCollection,
            dataToLoad,
            sourceUri,
            uriResolver,
            context
          );
        })
        .otherwise(function (error) {
          dataSource._error.raiseEvent(dataSource, error);
          console.log(error);
          return Cesium.when.reject(error);
        });
    }

    /**
     * @typedef {Object} KmlDataSource.LoadOptions
     *
     * Initialization options for the `load` method.
     *
     * @property {Camera} camera The camera that is used for viewRefreshModes and sending camera properties to network links.
     * @property {HTMLCanvasElement} canvas The canvas that is used for sending viewer properties to network links.
     * @property {String} [sourceUri] Overrides the url to use for resolving relative links and other KML network features.
     * @property {Boolean} [clampToGround=false] true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground.
     * @property {Cesium.Ellipsoid} [ellipsoid=Cesium.Ellipsoid.WGS84] The global ellipsoid used for geographical calculations.
     * @property {Cesium.Credit|String} [credit] A credit for the data source, which is displayed on the canvas.
     */

    /**
     * A {@link Cesium.DataSource} which processes Keyhole Markup Language 2.2 (KML).
     * <p>
     * KML support in Cesium is incomplete, but a large amount of the standard,
     * as well as Google's <code>gx</code> extension namespace, is supported. See Github issue
     * {@link https://github.com/CesiumGS/cesium/issues/873|#873} for a
     * detailed list of what is and isn't support. Cesium will also write information to the
     * console Cesium.when it encounters most unsupported features.
     * </p>
     * <p>
     * Non visual feature data, such as <code>atom:author</code> and <code>ExtendedData</code>
     * is exposed via an instance of {@link KmlFeatureData}, which is added to each {@link Cesium.Entity}
     * under the <code>kml</code> property.
     * </p>
     *
     * @alias KmlDataSource
     * @constructor
     *
     * @param {Object} options An object with the following properties:
     * @param {Camera} options.camera The camera that is used for viewRefreshModes and sending camera properties to network links.
     * @param {HTMLCanvasElement} options.canvas The canvas that is used for sending viewer properties to network links.
     * @param {Cesium.Ellipsoid} [options.ellipsoid=Cesium.Ellipsoid.WGS84] The global ellipsoid used for geographical calculations.
     * @param {Cesium.Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.
     *
     * @see {@link http://www.opengeospatial.org/standards/kml/|Open Geospatial Consortium KML Standard}
     * @see {@link https://developers.google.com/kml/|Google KML Documentation}
     *
     * @demo {@link https://sandcastle.cesium.com/index.html?src=KML.html|Cesium Sandcastle KML Demo}
     *
     * @example
     * var viewer = new Cesium.Viewer('cesiumContainer');
     * viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/facilities.kmz',
     *      {
     *           camera: viewer.scene.camera,
     *           canvas: viewer.scene.canvas
     *      })
     * );
     */
    function KmlDataSource(options) {
      KmlDataSource._getTimestamp = Cesium.getTimestamp;
      autolinker = new Cesium.Autolinker({
        stripPrefix: false,
        email: false,
        replaceFn: function (match) {
          if (!match.protocolUrlMatch) {
            //Prevent matching of non-explicit urls.
            //i.e. foo.id won't match but http://foo.id will
            return false;
          }
        },
      });
      zeroRectangle = new Cesium.Rectangle();
      scratchCartographic = new Cesium.Cartographic();
      scratchCartesian2 = new Cesium.Cartesian2();
      scratchCartesian3 = new Cesium.Cartesian3();
      //

      options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
      var camera = options.camera;
      var canvas = options.canvas;

      this._changed = new Cesium.Event();
      this._error = new Cesium.Event();
      this._loading = new Cesium.Event();
      this._refresh = new Cesium.Event();
      this._unsupportedNode = new Cesium.Event();

      this._clock = undefined;
      this._entityCollection = new Cesium.EntityCollection(this);
      this._name = undefined;
      this._isLoading = false;
      this._pinBuilder = new Cesium.PinBuilder();
      this._networkLinks = new Cesium.AssociativeArray();
      this._entityCluster = new Cesium.EntityCluster();

      this._canvas = canvas;
      this._camera = camera;
      this._lastCameraView = {
        position: Cesium.defined(camera) ? Cesium.Cartesian3.clone(camera.positionWC) : undefined,
        direction: Cesium.defined(camera)
          ? Cesium.Cartesian3.clone(camera.directionWC)
          : undefined,
        up: Cesium.defined(camera) ? Cesium.Cartesian3.clone(camera.upWC) : undefined,
        bbox: Cesium.defined(camera)
          ? camera.computeViewRectangle()
          : Cesium.Rectangle.clone(Cesium.Rectangle.MAX_VALUE),
      };

      this._ellipsoid = Cesium.defaultValue(options.ellipsoid, Cesium.Ellipsoid.WGS84);

      // User specified credit
      var credit = options.credit;
      if (typeof credit === "string") {
        credit = new Cesium.Credit(credit);
      }
      this._credit = credit;

      // Create a list of Cesium.Credit's from the resource that the user can't remove
      this._resourceCredits = [];
    }

    /**
     * Creates a Promise to a new instance loaded with the provided KML data.
     *
     * @param {Cesium.Resource|String|Document|Blob} data A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.
     * @param {KmlDataSource.LoadOptions} [options] An object specifying configuration options
     *
     * @returns {Promise.<KmlDataSource>} A promise that will resolve to a new KmlDataSource instance once the KML is loaded.
     */
    KmlDataSource.load = function (data, options) {
      options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
      var dataSource = new KmlDataSource(options);
      return dataSource.load(data, options);
    };

    Object.defineProperties(KmlDataSource.prototype, {
      /**
       * Gets or sets a human-readable name for this instance.
       * This will be automatically be set to the KML document name on load.
       * @memberof KmlDataSource.prototype
       * @type {String}
       */
      name: {
        get: function () {
          return this._name;
        },
        set: function (value) {
          if (this._name !== value) {
            this._name = value;
            this._changed.raiseEvent(this);
          }
        },
      },
      /**
       * Gets the clock settings Cesium.defined by the loaded KML. This represents the total
       * availability interval for all time-dynamic data. If the KML does not contain
       * time-dynamic data, this value is undefined.
       * @memberof KmlDataSource.prototype
       * @type {Cesium.DataSourceClock}
       */
      clock: {
        get: function () {
          return this._clock;
        },
      },
      /**
       * Gets the collection of {@link Cesium.Entity} instances.
       * @memberof KmlDataSource.prototype
       * @type {Cesium.EntityCollection}
       */
      entities: {
        get: function () {
          return this._entityCollection;
        },
      },
      /**
       * Gets a value indicating if the data source is currently loading data.
       * @memberof KmlDataSource.prototype
       * @type {Boolean}
       */
      isLoading: {
        get: function () {
          return this._isLoading;
        },
      },
      /**
       * Gets an event that will be raised Cesium.when the underlying data changes.
       * @memberof KmlDataSource.prototype
       * @type {Cesium.Event}
       */
      changedEvent: {
        get: function () {
          return this._changed;
        },
      },
      /**
       * Gets an event that will be raised if an error is encountered during processing.
       * @memberof KmlDataSource.prototype
       * @type {Cesium.Event}
       */
      errorEvent: {
        get: function () {
          return this._error;
        },
      },
      /**
       * Gets an event that will be raised Cesium.when the data source either starts or stops loading.
       * @memberof KmlDataSource.prototype
       * @type {Cesium.Event}
       */
      loadingEvent: {
        get: function () {
          return this._loading;
        },
      },
      /**
       * Gets an event that will be raised Cesium.when the data source refreshes a network link.
       * @memberof KmlDataSource.prototype
       * @type {Cesium.Event}
       */
      refreshEvent: {
        get: function () {
          return this._refresh;
        },
      },
      /**
       * Gets an event that will be raised Cesium.when the data source finds an unsupported node type.
       * @memberof KmlDataSource.prototype
       * @type {Cesium.Event}
       */
      unsupportedNodeEvent: {
        get: function () {
          return this._unsupportedNode;
        },
      },
      /**
       * Gets whether or not this data source should be displayed.
       * @memberof KmlDataSource.prototype
       * @type {Boolean}
       */
      show: {
        get: function () {
          return this._entityCollection.show;
        },
        set: function (value) {
          this._entityCollection.show = value;
        },
      },

      /**
       * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
       *
       * @memberof KmlDataSource.prototype
       * @type {Cesium.EntityCluster}
       */
      clustering: {
        get: function () {
          return this._entityCluster;
        },
        set: function (value) {
          this._entityCluster = value;
        },
      },
      /**
       * Gets the credit that will be displayed for the data source
       * @memberof KmlDataSource.prototype
       * @type {Cesium.Credit}
       */
      credit: {
        get: function () {
          return this._credit;
        },
      },
    });

    /**
     * Asynchronously loads the provided KML data, replacing any existing data.
     *
     * @param {Cesium.Resource|String|Document|Blob} data A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.
     * @param {Object} [options] An object with the following properties:
     * @param {Cesium.Resource|String} [options.sourceUri] Overrides the url to use for resolving relative links and other KML network features.
     * @param {Boolean} [options.clampToGround=false] true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground. If true, lines will use corridors so use Cesium.Entity.corridor instead of Cesium.Entity.polyline.
     * @param {Cesium.Ellipsoid} [options.ellipsoid=Cesium.Ellipsoid.WGS84] The global ellipsoid used for geographical calculations.
     *
     * @returns {Promise.<KmlDataSource>} A promise that will resolve to this instances once the KML is loaded.
     */
    KmlDataSource.prototype.load = function (data, options) {
      options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
      Cesium.DataSource.setLoading(this, true);

      var oldName = this._name;
      this._name = undefined;
      this._clampToGround = Cesium.defaultValue(options.clampToGround, false);

      var that = this;
      return load(this, this._entityCollection, data, options)
        .then(function () {
          var clock;

          var availability = that._entityCollection.computeAvailability();

          var start = availability.start;
          var stop = availability.stop;
          var isMinStart = Cesium.JulianDate.equals(start, Cesium.Iso8601.MINIMUM_VALUE);
          var isMaxStop = Cesium.JulianDate.equals(stop, Cesium.Iso8601.MAXIMUM_VALUE);
          if (!isMinStart || !isMaxStop) {
            var date;

            //If start is min time just start at midnight this morning, local time
            if (isMinStart) {
              date = new Date();
              date.setHours(0, 0, 0, 0);
              start = Cesium.JulianDate.fromDate(date);
            }

            //If stop is max value just stop at midnight tonight, local time
            if (isMaxStop) {
              date = new Date();
              date.setHours(24, 0, 0, 0);
              stop = Cesium.JulianDate.fromDate(date);
            }

            clock = new Cesium.DataSourceClock();
            clock.startTime = start;
            clock.stopTime = stop;
            clock.currentTime = Cesium.JulianDate.clone(start);
            clock.clockRange = Cesium.ClockRange.LOOP_STOP;
            clock.clockStep = Cesium.ClockStep.SYSTEM_CLOCK_MULTIPLIER;
            clock.multiplier = Math.round(
              Math.min(
                Math.max(Cesium.JulianDate.secondsDifference(stop, start) / 60, 1),
                3.15569e7
              )
            );
          }

          var changed = false;
          if (clock !== that._clock) {
            that._clock = clock;
            changed = true;
          }

          if (oldName !== that._name) {
            changed = true;
          }

          if (changed) {
            that._changed.raiseEvent(that);
          }

          Cesium.DataSource.setLoading(that, false);

          return that;
        })
        .otherwise(function (error) {
          Cesium.DataSource.setLoading(that, false);
          that._error.raiseEvent(that, error);
          console.log(error);
          return Cesium.when.reject(error);
        });
    };

    function mergeAvailabilityWithParent(child) {
      var parent = child.parent;
      if (Cesium.defined(parent)) {
        var parentAvailability = parent.availability;
        if (Cesium.defined(parentAvailability)) {
          var childAvailability = child.availability;
          if (Cesium.defined(childAvailability)) {
            childAvailability.intersect(parentAvailability);
          } else {
            child.availability = parentAvailability;
          }
        }
      }
    }

    function getNetworkLinkUpdateCallback(
      dataSource,
      networkLink,
      newEntityCollection,
      networkLinks,
      processedHref
    ) {
      return function (rootElement) {
        if (!networkLinks.contains(networkLink.id)) {
          // Got into the odd case where a parent network link was updated while a child
          //  network link update was in flight, so just throw it away.
          return;
        }
        var remove = false;
        var networkLinkControl = queryFirstNode(
          rootElement,
          "NetworkLinkControl",
          namespaces.kml
        );
        var hasNetworkLinkControl = Cesium.defined(networkLinkControl);

        var minRefreshPeriod = 0;
        if (hasNetworkLinkControl) {
          if (
            Cesium.defined(queryFirstNode(networkLinkControl, "Update", namespaces.kml))
          ) {
            Cesium.oneTimeWarning(
              "kml-networkLinkControl-update",
              "KML - NetworkLinkControl updates aren't supported."
            );
            networkLink.updating = false;
            networkLinks.remove(networkLink.id);
            return;
          }
          networkLink.cookie = Cesium.queryToObject(
            Cesium.defaultValue(
              queryStringValue(networkLinkControl, "cookie", namespaces.kml),
              ""
            )
          );
          minRefreshPeriod = Cesium.defaultValue(
            queryNumericValue(
              networkLinkControl,
              "minRefreshPeriod",
              namespaces.kml
            ),
            0
          );
        }

        var now = Cesium.JulianDate.now();
        var refreshMode = networkLink.refreshMode;
        if (refreshMode === RefreshMode.INTERVAL) {
          if (Cesium.defined(networkLinkControl)) {
            networkLink.time = Math.max(minRefreshPeriod, networkLink.time);
          }
        } else if (refreshMode === RefreshMode.EXPIRE) {
          var expires;
          if (Cesium.defined(networkLinkControl)) {
            expires = queryStringValue(
              networkLinkControl,
              "expires",
              namespaces.kml
            );
          }
          if (Cesium.defined(expires)) {
            try {
              var date = Cesium.JulianDate.fromIso8601(expires);
              var diff = Cesium.JulianDate.secondsDifference(date, now);
              if (diff > 0 && diff < minRefreshPeriod) {
                Cesium.JulianDate.addSeconds(now, minRefreshPeriod, date);
              }
              networkLink.time = date;
            } catch (e) {
              Cesium.oneTimeWarning(
                "kml-networkLinkControl-expires",
                "KML - NetworkLinkControl expires is not a valid date"
              );
              remove = true;
            }
          } else {
            Cesium.oneTimeWarning(
              "kml-refreshMode-onExpire",
              "KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element"
            );
            remove = true;
          }
        }

        var networkLinkEntity = networkLink.entity;
        var entityCollection = dataSource._entityCollection;
        var newEntities = newEntityCollection.values;

        function removeChildren(entity) {
          entityCollection.remove(entity);
          var children = entity._children;
          var count = children.length;
          for (var i = 0; i < count; ++i) {
            removeChildren(children[i]);
          }
        }

        // Remove old entities
        entityCollection.suspendEvents();
        var entitiesCopy = entityCollection.values.slice();
        var i;
        for (i = 0; i < entitiesCopy.length; ++i) {
          var entityToRemove = entitiesCopy[i];
          if (entityToRemove.parent === networkLinkEntity) {
            entityToRemove.parent = undefined;
            removeChildren(entityToRemove);
          }
        }
        entityCollection.resumeEvents();

        // Add new entities
        entityCollection.suspendEvents();
        for (i = 0; i < newEntities.length; i++) {
          var newEntity = newEntities[i];
          if (!Cesium.defined(newEntity.parent)) {
            newEntity.parent = networkLinkEntity;
            mergeAvailabilityWithParent(newEntity);
          }
          entityCollection.add(newEntity);
        }
        entityCollection.resumeEvents();

        // No refresh information remove it, otherwise update lastUpdate time
        if (remove) {
          networkLinks.remove(networkLink.id);
        } else {
          networkLink.lastUpdated = now;
        }

        var availability = entityCollection.computeAvailability();

        var start = availability.start;
        var stop = availability.stop;
        var isMinStart = Cesium.JulianDate.equals(start, Cesium.Iso8601.MINIMUM_VALUE);
        var isMaxStop = Cesium.JulianDate.equals(stop, Cesium.Iso8601.MAXIMUM_VALUE);
        if (!isMinStart || !isMaxStop) {
          var clock = dataSource._clock;

          if (clock.startTime !== start || clock.stopTime !== stop) {
            clock.startTime = start;
            clock.stopTime = stop;
            dataSource._changed.raiseEvent(dataSource);
          }
        }

        networkLink.updating = false;
        networkLink.needsUpdate = false;
        dataSource._refresh.raiseEvent(
          dataSource,
          processedHref.getUrlComponent(true)
        );
      };
    }

    var entitiesToIgnore;

    /**
     * Updates any NetworkLink that require updating.
     *
     * @param {Cesium.JulianDate} time The simulation time.
     * @returns {Boolean} True if this data source is ready to be displayed at the provided time, false otherwise.
     */
    KmlDataSource.prototype.update = function (time) {
      if(Cesium.defined(entitiesToIgnore)){
        entitiesToIgnore = new Cesium.AssociativeArray();
      }
      var networkLinks = this._networkLinks;  
      if (networkLinks.length === 0) {
        return true;
      }

      var now = Cesium.JulianDate.now();
      var that = this;

      entitiesToIgnore.removeAll();

      function recurseIgnoreEntities(entity) {
        var children = entity._children;
        var count = children.length;
        for (var i = 0; i < count; ++i) {
          var child = children[i];
          entitiesToIgnore.set(child.id, child);
          recurseIgnoreEntities(child);
        }
      }

      var cameraViewUpdate = false;
      var lastCameraView = this._lastCameraView;
      var camera = this._camera;
      if (
        Cesium.defined(camera) &&
        !(
          camera.positionWC.equalsEpsilon(
            lastCameraView.position,
            Cesium.Math.EPSILON7
          ) &&
          camera.directionWC.equalsEpsilon(
            lastCameraView.direction,
            Cesium.Math.EPSILON7
          ) &&
          camera.upWC.equalsEpsilon(lastCameraView.up, Cesium.Math.EPSILON7)
        )
      ) {
        // Camera has changed so update the last view
        lastCameraView.position = Cesium.Cartesian3.clone(camera.positionWC);
        lastCameraView.direction = Cesium.Cartesian3.clone(camera.directionWC);
        lastCameraView.up = Cesium.Cartesian3.clone(camera.upWC);
        lastCameraView.bbox = camera.computeViewRectangle();
        cameraViewUpdate = true;
      }

      var newNetworkLinks = new Cesium.AssociativeArray();
      var changed = false;
      networkLinks.values.forEach(function (networkLink) {
        var entity = networkLink.entity;
        if (entitiesToIgnore.contains(entity.id)) {
          return;
        }

        if (!networkLink.updating) {
          var doUpdate = false;
          if (networkLink.refreshMode === RefreshMode.INTERVAL) {
            if (
              Cesium.JulianDate.secondsDifference(now, networkLink.lastUpdated) >
              networkLink.time
            ) {
              doUpdate = true;
            }
          } else if (networkLink.refreshMode === RefreshMode.EXPIRE) {
            if (Cesium.JulianDate.greaterThan(now, networkLink.time)) {
              doUpdate = true;
            }
          } else if (networkLink.refreshMode === RefreshMode.STOP) {
            if (cameraViewUpdate) {
              networkLink.needsUpdate = true;
              networkLink.cameraUpdateTime = now;
            }

            if (
              networkLink.needsUpdate &&
              Cesium.JulianDate.secondsDifference(now, networkLink.cameraUpdateTime) >=
                networkLink.time
            ) {
              doUpdate = true;
            }
          }

          if (doUpdate) {
            recurseIgnoreEntities(entity);
            networkLink.updating = true;
            var newEntityCollection = new Cesium.EntityCollection();
            var href = networkLink.href.clone();

            href.setQueryParameters(networkLink.cookie);
            var ellipsoid = Cesium.defaultValue(that._ellipsoid, Cesium.Ellipsoid.WGS84);
            processNetworkLinkQueryString(
              href,
              that._camera,
              that._canvas,
              networkLink.viewBoundScale,
              lastCameraView.bbox,
              ellipsoid
            );

            load(that, newEntityCollection, href, { context: entity.id })
              .then(
                getNetworkLinkUpdateCallback(
                  that,
                  networkLink,
                  newEntityCollection,
                  newNetworkLinks,
                  href
                )
              )
              .otherwise(function (error) {
                var msg =
                  "NetworkLink " + networkLink.href + " refresh failed: " + error;
                console.log(msg);
                that._error.raiseEvent(that, msg);
              });
            changed = true;
          }
        }
        newNetworkLinks.set(networkLink.id, networkLink);
      });

      if (changed) {
        this._networkLinks = newNetworkLinks;
        this._changed.raiseEvent(this);
      }

      return true;
    };

    /**
     * Contains KML Feature data loaded into the <code>Cesium.Entity.kml</code> property by {@link KmlDataSource}.
     * @alias KmlFeatureData
     * @constructor
     */
    function KmlFeatureData() {
      /**
       * @typedef KmlFeatureData.Author
       * @type {Object}
       * @property {String} name Gets the name.
       * @property {String} uri Gets the URI.
       * @property {Number} age Gets the email.
       */

      /**
       * Gets the atom syndication format author field.
       * @type {KmlFeatureData.Author}
       */
      this.author = {
        name: undefined,
        uri: undefined,
        email: undefined,
      };

      /**
       * @typedef KmlFeatureData.Link
       * @type {Object}
       * @property {String} href Gets the href.
       * @property {String} hreflang Gets the language of the linked resource.
       * @property {String} rel Gets the link relation.
       * @property {String} type Gets the link type.
       * @property {String} title Gets the link title.
       * @property {String} length Gets the link length.
       */

      /**
       * Gets the link.
       * @type {KmlFeatureData.Link}
       */
      this.link = {
        href: undefined,
        hreflang: undefined,
        rel: undefined,
        type: undefined,
        title: undefined,
        length: undefined,
      };

      /**
       * Gets the unstructured address field.
       * @type {String}
       */
      this.address = undefined;
      /**
       * Gets the phone number.
       * @type {String}
       */
      this.phoneNumber = undefined;
      /**
       * Gets the snippet.
       * @type {String}
       */
      this.snippet = undefined;
      /**
       * Gets the extended data, parsed into a JSON object.
       * Currently only the <code>Data</code> property is supported.
       * <code>SchemaData</code> and custom data are ignored.
       * @type {String}
       */
      this.extendedData = undefined;
    }

    // For testing
    KmlDataSource._DeferredLoading = DeferredLoading;

    function PipeLayer(options) {
      this._readyPromise = Cesium.when.defer();
      this._tileset = new Cesium.Cesium3DTileset(options);
      var that = this;
      this._tileset.readyPromise.then(function(tileset) {
        that._readyPromise.resolve(tileset);
      });
      if(options.id === 'JS'){
        this._tileset.style = new Cesium.Cesium3DTileStyle({
            color : {
                conditions : [
                    ['${id} === "instance"', 'color("white")'],
                    ['true', 'color("AQUA")']
                ]
            }
        });
      }else if(options.id === 'PS'){
        this._tileset.style = new Cesium.Cesium3DTileStyle({
            color : {
                conditions : [
                    ['${id} === "instance"', 'color("white")'],
                    ['true', 'color("CHOCOLATE")']
                ]
            }
        });
      }else if(options.id === 'DX'){
        this._tileset.style = new Cesium.Cesium3DTileStyle({
            color : {
                conditions : [
                    ['${id} === "instance"', 'color("white")'],
                    ['true', 'color("DARKGREEN")']
                ]
            }
        });
      }else if(options.id === 'GD' || options.id === 'LD'){
        this._tileset.style = new Cesium.Cesium3DTileStyle({
            color : {
                conditions : [
                    ['${id} === "instance"', 'color("white")'],
                    ['true', 'color("CRIMSON")']
                ]
            }
        });
      }
    }

    Object.defineProperties(PipeLayer.prototype, {
        readyPromise: {
          get: function () {
            return this._readyPromise;
          }
        },
    });

    PipeLayer.prototype.update = function (frameState) {
      if (Cesium.defined(this._tileset)) {
        this._tileset.update(frameState);
      }
    };

    function ThunderLayer(options) {
      this._billboards = undefined;
      this._lines = undefined;
      var url = options.url;
      this._canvas = options.canvas;
      this.createBillboardCallback = options.createBillboardCallback;
      this._size = Cesium.defaultValue(options.size, 12);

      this._data = options.data;
      if (Cesium.defined(this._data)) {
        this.loadJson(this._data);
      } else {
        var isBinary = Cesium.defaultValue(options.binary, false);
        if (!isBinary) {
          this.fetchJson(url);
        } else {
          this.fetchArrayBuffer(url);
        }
      }
    }

    ThunderLayer.prototype.fetchArrayBuffer = function (url) {
      if (!Cesium.defined(url)) {
        throw new Cesium.DeveloperError("url is required.");
      }

      var that = this;
      return Cesium.Resource.fetchArrayBuffer(url)
        .then(function (arrayBuffer) {
          return that.loadPnts(arrayBuffer, url);
        })
        .otherwise(function (error) {
          return Cesium.when.reject(error);
        });
    };

    ThunderLayer.prototype.fetchJson = function (url) {
      if (!Cesium.defined(url)) {
        throw new Cesium.DeveloperError("url is required.");
      }

      var that = this;
      return Cesium.Resource.fetchJson(url)
        .then(function (json) {
          return that.loadJson(json, url);
        })
        .otherwise(function (error) {
          return Cesium.when.reject(error);
        });
    };
    var sizeOfUint32$1 = Uint32Array.BYTES_PER_ELEMENT;
    ThunderLayer.prototype.loadPnts = function (arrayBuffer) {
      var byteOffset = 0;

      var uint8Array = new Uint8Array(arrayBuffer);
      var view = new DataView(arrayBuffer);
      byteOffset += sizeOfUint32$1; // Skip magic
      var version = view.getUint32(byteOffset, true);
      if (version !== 1) {
        throw new Cesium.RuntimeError(
          "Only Point Cloud tile version 1 is supported.  Version " +
            version +
            " is not."
        );
      }
      byteOffset += sizeOfUint32$1;

      // Skip byteLength
      byteOffset += sizeOfUint32$1;

      var featureTableJsonByteLength = view.getUint32(byteOffset, true);
      if (featureTableJsonByteLength === 0) {
        throw new Cesium.RuntimeError(
          "Feature table must have a byte length greater than zero"
        );
      }
      byteOffset += sizeOfUint32$1;
      var featureTableBinaryByteLength = view.getUint32(byteOffset, true);
      byteOffset += sizeOfUint32$1;
      var batchTableJsonByteLength = view.getUint32(byteOffset, true);
      byteOffset += sizeOfUint32$1;
      var batchTableBinaryByteLength = view.getUint32(byteOffset, true);
      byteOffset += sizeOfUint32$1;
      var featureTableString = Cesium.getStringFromTypedArray(
        uint8Array,
        byteOffset,
        featureTableJsonByteLength
      );
      var featureTableJson = JSON.parse(featureTableString);
      byteOffset += featureTableJsonByteLength;

      var featureTableBinary = new Uint8Array(
        arrayBuffer,
        byteOffset,
        featureTableBinaryByteLength
      );
      byteOffset += featureTableBinaryByteLength;

      // Get the batch table JSON and binary
      var batchTableJson;
      var batchTableBinary;
      if (batchTableJsonByteLength > 0) {
        // Has a batch table JSON
        var batchTableString = Cesium.getStringFromTypedArray(
          uint8Array,
          byteOffset,
          batchTableJsonByteLength
        );
        batchTableJson = JSON.parse(batchTableString);
        byteOffset += batchTableJsonByteLength;

        if (batchTableBinaryByteLength > 0) {
          // Has a batch table binary
          batchTableBinary = new Uint8Array(
            arrayBuffer,
            byteOffset,
            batchTableBinaryByteLength
          );
          byteOffset += batchTableBinaryByteLength;
        }
      }

      var featureTable = new Cesium.Cesium3DTileFeatureTable(
        featureTableJson,
        featureTableBinary
      );

      var pointsLength = featureTable.getGlobalProperty("POINTS_LENGTH");
      featureTable.featuresLength = pointsLength;

      var positions;
      var batchIds;
      var batchTable;

      positions = featureTable.getPropertyArray(
        "POSITION",
        Cesium.ComponentDatatype.FLOAT,
        3
      );

      var hasBatchIds = false;
      if (!hasBatchIds) {
        if (Cesium.defined(featureTableJson.BATCH_ID)) {
          batchIds = featureTable.getPropertyArray(
            "BATCH_ID",
            Cesium.ComponentDatatype.UNSIGNED_SHORT,
            1
          );
          hasBatchIds = true;
        }
      }

      if (hasBatchIds) {
        var batchLength = featureTable.getGlobalProperty("BATCH_LENGTH");
        if (!Cesium.defined(batchLength)) {
          throw new Cesium.RuntimeError(
            "Global property: BATCH_LENGTH must be defined when BATCH_ID is defined."
          );
        }

        if (Cesium.defined(batchTableBinary)) {
          // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed
          batchTableBinary = new Uint8Array(batchTableBinary);
        }

        batchTable = this._batchtable = new Cesium.Cesium3DTileBatchTable(
          this,
          batchLength,
          batchTableJson,
          batchTableBinary
        );
      }

      var scratchPosition = new Cesium.Cartesian3();
      for (var i = 0; i < pointsLength; ++i) {
        var batchId = batchIds[i];
        var position = Cesium.Cartesian3.unpack(positions, i * 3, scratchPosition);
        this.createBillboardCallback(this, {
          position: position,
          batchId: batchId,
          batchTable: batchTable,
        });
      }
    };

    ThunderLayer.prototype.loadJson = function (data) {
      if (!Cesium.defined(data)) {
        throw new Cesium.DeveloperError("data is required.");
      }

      for (var i = 0; i < data.length; i++) {
        var p = data[i];
        this.createBillboardCallback(this, p);
      }
    };

    Object.defineProperties(ThunderLayer.prototype, {
      billboardCollection: {
        get: function () {
          if (!Cesium.defined(this._billboards)) {
            this._billboards = new Cesium.BillboardCollection();
          }
          return this._billboards;
        },
      },
      lineCollection: {
        get: function () {
          if (!Cesium.defined(this._lines)) {
            this._lines = new Cesium.PolylineCollection();
          }
          return this._lines;
        },
      },
    });

    ThunderLayer.prototype.update = function (frameState) {
      if (Cesium.defined(this._billboards)) {
        this._billboards.update(frameState);
      }
      if (frameState.passes.render) {
        if (Cesium.defined(this._lines)) {
          this._lines.update(frameState);
        }
      }
    };

    ThunderLayer.prototype.destroy = function () {
      this._billboards = this._billboards && this._billboards.destroy();
      this._lines = this._lines && this._lines.destroy();
      return Cesium.destroyObject(this);
    };

    function getTyphoonColor(level) {
        let strokeStyle = '#FFE4B5FF';
        let fillStyle = '#FFE4B599';
        if (level == 8 || level == 9) {
            strokeStyle = '#0000FFFF';
            fillStyle = '#0000FF99';
        }
        else if (level == 10 || level == 11) {
            strokeStyle = '#00FF00FF';
            fillStyle = '#00FF0099';
        }
        else if (level == 12 || level == 13) {
            strokeStyle = '#FFA500FF';
            fillStyle = '#FFA50099';
        }
        else if (level == 14 || level == 15) {
            strokeStyle = '#DA70D6FF';
            fillStyle = '#DA70D699';
        }
        else if (level > 15) {
            strokeStyle = '#FF0000FF';
            fillStyle = '#FF000099';
        }

        return { strokeStyle, fillStyle };
    }
    function TyphoonLayer(options) {
        var linewidth = Cesium.defaultValue(options.width, 3);
        var outlineWidth = Cesium.defaultValue(options.width, 2);

        var pointColor = Cesium.defaultValue(options.pointColor, Cesium.Color.DODGERBLUE);
        var pointOutlineColor = Cesium.defaultValue(options.pointOutlineColor, Cesium.Color.BLACK);
        var pointOutlineWidth = Cesium.defaultValue(options.pointOutlineWidth, 1);
        var pointPixelSize = Cesium.defaultValue(options.pointPixelSize, 10);

        var routeColor = Cesium.defaultValue(options.routeColor, Cesium.Color.DODGERBLUE);
        var routeOutlineColor = Cesium.defaultValue(options.routeOutlineColor, Cesium.Color.DODGERBLUE);
        var positions = options.positions;
        var levels = options.levels;
        this._typhoonLevels = levels;
        var times = options.times;
        // route polyline
        var instance = new Cesium.GeometryInstance({
            geometry: new Cesium.GroundPolylineGeometry({
                positions: positions,
                width: linewidth,
            }),
        });

        this._routePolyline = new Cesium.GroundPolylinePrimitive({
            geometryInstances: instance,
            asynchronous: false,
        });
        this._routePolyline.appearance = new Cesium.PolylineMaterialAppearance({
            material: Cesium.Material.fromType(Cesium.Material.PolylineOutlineType),
        });
        this._routePolyline.appearance.material.uniforms.outlineWidth = outlineWidth;
        this._routePolyline.appearance.material.uniforms.color = routeColor;
        this._routePolyline.appearance.material.uniforms.outlineColor = routeOutlineColor;

        var property = this._sampleProperty = (Cesium.defined(times) && times.length === times.length)
            ? new Cesium.SampledPositionProperty() : undefined;

        var propertyIndex = undefined;

        if (Cesium.defined(options.indexChangedCallback)) {
            propertyIndex = this._samplePropertyIndex = new Cesium.SampledProperty(Number);
            this._indexChangedEvent = new Cesium.Event();
            this._removeEventSubscription = this._indexChangedEvent.addEventListener(
                options.indexChangedCallback,
                this
            );
        }

        this._currentIndex = -1;

        // route point collection
        this._pointCollection = new Cesium.PointPrimitiveCollection();
        for (let i = 0; i < positions.length; i++) {
            let color = pointColor;
            if (Cesium.defined(levels) && levels.length === positions.length) {
                const { strokeStyle } = getTyphoonColor(levels[i]);
                color = Cesium.Color.fromCssColorString(strokeStyle);
            }
            const pos = positions[i];
            this._pointCollection.add({
                id: i,
                position: pos,
                color: color,
                outlineColor: pointOutlineColor,
                outlineWidth: pointOutlineWidth,
                pixelSize: pointPixelSize
            });
            if (Cesium.defined(propertyIndex)) {
                propertyIndex.addSample(times[i], i);
            }
            if (Cesium.defined(property)) {
                property.addSample(times[i], pos);
            }
        }


        // typhoon point collection
        if (Cesium.defined(property)) {
            this._scratchMatrix = new Cesium.Matrix4();
            this._scratchMatrix2 = new Cesium.Matrix4();
            this._typhoonPointCollection = new Cesium.PointPrimitiveCollection();
            this._typhoonPointCollection.add({
                position: new Cesium.Cartesian3(0, 0, 0),
                color: Cesium.Color.TRANSPARENT,
                outlineColor: Cesium.Color.YELLOW,
                outlineWidth: 4,
                pixelSize: pointPixelSize
            });
        }

        this.typhoonImage = options.typhoonImage;
        this.updateCircleImgeGeometry(positions[0]);

        this._forecastRoutePoint = [];
        this._forecastRouteLine = [];
        this._windCircleKey = undefined;
        this._windCircleDirty = false;
        this._canvas = undefined;
        this._windCircleTexture = undefined;
        this._windCircleRadius = 30000.0;
        this._currentPosition = new Cesium.Cartesian3();
    }

    Object.defineProperties(TyphoonLayer.prototype, {
        routePolyline: {
            get: function () {
                return this._routePolyline;
            },
        },
        windCircleKey: {
            get: function () {
                return this._windCircleKey;
            },
            set: function (value) {
                if (this._windCircleKey !== value) {
                    this._windCircleKey = value;
                    this._windCircleDirty = true;
                }
            }
        },
        currentPosition: {
            get: function () {
                return this._currentPosition;
            },
        },
    });

    TyphoonLayer.prototype.createTyphoonCircle = function (windcirclekey, context) {
        const r = 512;
        if (!Cesium.defined(this._canvas)) {
            this._canvas = document.createElement('canvas');
            this._canvas.width = 2.0 * r;
            this._canvas.height = 2.0 * r;
            this._windCircleTexture = new Cesium.Texture({
                context: context,
                source: this._canvas,
            });
        }
        const c = this._canvas;
        const lineWidth = 4;
        var ctx = c.getContext("2d");
        ctx.clearRect(0, 0, c.width, c.height);
        if (Cesium.defined(windcirclekey)) {
            var drawA = function (drawR, ratio) {
                ctx.beginPath();
                const face = 100;
                const bigStep = face / 4;
                const angleStep = Math.PI * 2 / face;
                let angle = 0;
                for (let f = 0; f < face + 1; f++) {
                    const i = Math.floor(f / (face / 4));
                    const ra = ratio[i];
                    let x = r + Math.cos(angle) * drawR * ra;
                    let y = r + Math.sin(Math.PI * 2 - angle) * drawR * ra;
                    if (f % bigStep === 0) {
                        const ra = i === 0 ? ratio[ratio.length - 1] : ratio[i - 1];
                        let x = r + Math.cos(angle) * drawR * ra;
                        let y = r + Math.sin(Math.PI * 2 - angle) * drawR * ra;
                        ctx.lineTo(x, y);
                    }
                    ctx.lineTo(x, y);
                    angle += angleStep;
                }
                ctx.stroke();
                ctx.fill();
                ctx.closePath();
            };

            const enws7 = windcirclekey.enws7;
            const enws10 = windcirclekey.enws10;
            var max7 = 1.0;
            var max10 = 1.0;
            let ratio7 = [];
            let ratio10 = [];
            if (Cesium.defined(enws7)) {
                const e = parseFloat(enws7.e);
                const n = parseFloat(enws7.n);
                const w = parseFloat(enws7.w);
                const s = parseFloat(enws7.s);
                max7 = Math.max(e, Math.max(n, Math.max(w, s)));
                ratio7 = [e / max7, n / max7, w / max7, s / max7];
            }
            if (Cesium.defined(enws10)) {
                const e = parseFloat(enws10.e);
                const n = parseFloat(enws10.n);
                const w = parseFloat(enws10.w);
                const s = parseFloat(enws10.s);
                max10 = Math.max(e, Math.max(n, Math.max(w, s)));
                ratio10 = [e / max10, n / max10, w / max10, s / max10];
            }

            this._windCircleRadius = (max7 > max10 ? max7 : max10) * 1000.0;
            ctx.lineWidth = lineWidth;
            const level = Cesium.defined(this._typhoonLevels) ? this._typhoonLevels[this._currentIndex] : 0;
            const { fillStyle, strokeStyle } = getTyphoonColor(level);
            ctx.fillStyle = fillStyle;
            ctx.strokeStyle = strokeStyle;
            const drawR = r - lineWidth - 1;
            ctx.moveTo(r, r);
            const ration12 = max10 / max7;
            if (ratio7.length === 4) {
                drawA(drawR, ratio7);
            }
            if (ratio10.length === 4) {
                drawA(drawR * ration12, ratio10);
            }
        }
    };

    TyphoonLayer.prototype.updateCircleImgeGeometry = function (center) {
        if (!Cesium.defined(this.typhoonImage)) {
            return;
        }

        this._circlePrimitive = this._circlePrimitive && this._circlePrimitive.destroy();

        // typhoon circle
        var circle = new Cesium.CircleGeometry({
            center: center,
            radius: 35000.0,
        });

        this._circlePrimitive = new Cesium.GroundPrimitive({
            geometryInstances: [new Cesium.GeometryInstance({
                geometry: circle,
            })],
            asynchronous: false,
        });

        if (!Cesium.defined(this._circleAppearance)) {
            this._circleAppearance = new Cesium.MaterialAppearance({
                renderState: {
                    depthTest: { enabled: true },
                    depthMask: true,
                    blending: Cesium.BlendingState.ALPHA_BLEND,
                    cull: {
                        enabled: false,
                        face: Cesium.CullFace.FRONT,
                    },
                },
                translucent: false,
                material: Cesium.Material.fromType('Image')
            });
            this._circleAppearance.material.uniforms.image = this.typhoonImage;
            this.rotation = 0;
        }
        this._circlePrimitive.appearance = this._circleAppearance;
    };

    TyphoonLayer.prototype.updateWindCircleWindGeometry = function (center, context) {
        this._windCirclePrimitive = this._windCirclePrimitive && this._windCirclePrimitive.destroy();

        // typhoon circle
        var circle = new Cesium.CircleGeometry({
            center: center,
            radius: this._windCircleRadius,
        });

        this._windCirclePrimitive = new Cesium.GroundPrimitive({
            geometryInstances: [new Cesium.GeometryInstance({
                geometry: circle,
            })],
            asynchronous: false,
        });

        if (!Cesium.defined(this._windCircleAppearance)) {
            this.createTyphoonCircle('', context);
            this._windCircleAppearance = new Cesium.MaterialAppearance({
                renderState: {
                    depthTest: { enabled: true },
                    depthMask: true,
                    blending: Cesium.BlendingState.ALPHA_BLEND,
                    cull: {
                        enabled: true,
                        face: Cesium.CullFace.BACK,
                    },
                },
                translucent: false,
                material: new Cesium.Material({
                    fabric: {
                        uniforms: {
                            image: this._windCircleTexture,
                        },
                        source:
                            "czm_material czm_getMaterial(czm_materialInput materialInput) { \n" +
                            "    czm_material material = czm_getDefaultMaterial(materialInput); \n" +
                            "    vec2 st = materialInput.st; \n" +
                            "    vec4 color = texture2D(image, st); \n" +
                            "    color = czm_gammaCorrect(color); \n" +
                            "    material.diffuse = color.rgb; \n" +
                            "    material.alpha = color.a; \n" +
                            "    material.shininess = 8.0; \n" + // Sharpen highlight
                            "    return material; \n" +
                            "} \n"
                    },
                })
            });
        }
        this._windCirclePrimitive.appearance = this._windCircleAppearance;
    };

    TyphoonLayer.prototype.addForecastRoute = function (options) {
        const positions = options.positions;
        if (!Cesium.defined(positions) || positions.length < 1) {
            return;
        }
        var outlineColor = Cesium.defaultValue(options.outlineColor, Cesium.Color.BLACK);
        var outlineWidth = Cesium.defaultValue(options.outlineWidth, 1);
        var pointPixelSize = Cesium.defaultValue(options.pointPixelSize, 10);
        const color = Cesium.defaultValue(options.color, new Cesium.Color.fromRandom({ red: 1.0, blue: 1.0, green: 1.0 }));
        const pointCollection = new Cesium.PointPrimitiveCollection();
        pointCollection.add({
            position: positions[0],
            color: color,
            outlineColor: outlineColor,
            outlineWidth: outlineWidth,
            pixelSize: pointPixelSize
        });
        pointCollection.add({
            position: positions[positions.length - 1],
            color: color,
            outlineColor: outlineColor,
            outlineWidth: outlineWidth,
            pixelSize: pointPixelSize
        });
        this._forecastRoutePoint.push(pointCollection);

        // forecast route
        var linewidth = Cesium.defaultValue(options.width, 3);
        var instance = new Cesium.GeometryInstance({
            geometry: new Cesium.GroundPolylineGeometry({
                positions: positions,
                width: linewidth,
            }),
        });

        var routePolyline = new Cesium.GroundPolylinePrimitive({
            geometryInstances: instance,
            asynchronous: false,
        });
        routePolyline.appearance = new Cesium.PolylineMaterialAppearance({
            material: Cesium.Material.fromType(Cesium.Material.PolylineDashType),
        });
        routePolyline.appearance.material.uniforms.dashLength = 16;
        routePolyline.appearance.material.uniforms.color = color;
        this._forecastRouteLine.push(routePolyline);
    };

    TyphoonLayer.prototype.destroy = function () {
        this._forecastRoutePoint.forEach((element) => {
            element.destroy();
        });
        this._forecastRoutePoint = [];
        this._forecastRouteLine.forEach((element) => {
            element.destroy();
        });
        this._forecastRouteLine = [];
        this._circlePrimitive = this._circlePrimitive && this._circlePrimitive.destroy();
        this._routePolyline = this._routePolyline && this._routePolyline.destroy();
        this._pointCollection = this._pointCollection && this._pointCollection.destroy();
        this._typhoonPointCollection = this._typhoonPointCollection && this._typhoonPointCollection.destroy();
        if (Cesium.defined(this._removeEventSubscription)) {
            this._removeEventSubscription();
        }
        if (Cesium.defined(this._canvas)) {
            this._canvas.remove();
            this._canvas = undefined;
        }
        return Cesium.destroyObject(this);
    };

    TyphoonLayer.prototype.isDestroyed = function () {
        return false;
    };

    TyphoonLayer.prototype.update = function (frameState) {
        for (let i = 0; i < this._forecastRoutePoint.length; i++) {
            this._forecastRoutePoint[i].update(frameState);
        }
        if (Cesium.defined(this._pointCollection)) {
            this._pointCollection.update(frameState);
        }
        if (this._windCircleDirty) {
            this._windCircleDirty = false;
            this.createTyphoonCircle(this._windCircleKey);
            this._windCircleTexture.copyFrom(this._canvas);
        }
        // no allow to pick
        if (frameState.passes.render) {
            if (Cesium.defined(this._typhoonPointCollection)) {
                if (Cesium.defined(this._sampleProperty)) {
                    var pos = this._sampleProperty.getValue(frameState.time, this._currentPosition);
                    if (Cesium.defined(pos)) {
                        var matrix = Cesium.Matrix4.fromTranslation(pos, this._scratchMatrix);
                        this._typhoonPointCollection.modelMatrix = matrix;
                        this.updateCircleImgeGeometry(pos);
                        this.updateWindCircleWindGeometry(pos, frameState.context);
                    }
                    if (Cesium.defined(this._indexChangedEvent)) {
                        var index = Math.floor(this._samplePropertyIndex.getValue(frameState.time));
                        if (index !== this._currentIndex) {
                            this._indexChangedEvent.raiseEvent(
                                this,
                                "onLoadNew",
                                index,
                                pos
                            );
                            this._currentIndex = index;
                        }
                    }
                }

                this._typhoonPointCollection.update(frameState);
            }
            if (Cesium.defined(this._windCirclePrimitive)) {
                this._windCirclePrimitive.update(frameState);
            }
            if (Cesium.defined(this._circlePrimitive)) {
                if (Cesium.defined(this._circlePrimitive.geometryInstances) && this._circlePrimitive.geometryInstances.length > 0) {
                    var rotation = this.rotation + 0.03;
                    this.rotation = rotation % Cesium.Math.TWO_PI;
                    this._circlePrimitive.geometryInstances[0].geometry._ellipseGeometry._stRotation = this.rotation;
                }
                this._circlePrimitive.update(frameState);
            }

            if (Cesium.defined(this._routePolyline)) {
                this._routePolyline.update(frameState);
            }

            for (let i = 0; i < this._forecastRouteLine.length; i++) {
                this._forecastRouteLine[i].update(frameState);
            }
        }
    };

    function DetectiveLineLayer() {
        this._primitives = undefined;
        this.create(Config.DetectiveLineOptions);
    }

    DetectiveLineLayer.prototype.create = function (options) {
        const DetectiveLines = options.line;

        const primitives = [];
        Object.keys(DetectiveLines).forEach((element) => {
            const color1 = DetectiveLines[element].color;
            const color = Cesium.Color.fromCssColorString(color1);
            const positions = [];
            const linePositions = DetectiveLines[element].positions;
            for (let i = 0; i < linePositions.length; i++) {
                const longitude = linePositions[i][1];
                const latitude = linePositions[i][0];
                const position = Cesium.Cartesian3.fromDegrees(
                    longitude,
                    latitude,
                    0.0
                );
                positions.push(position);
            }

            var instance = new Cesium.GeometryInstance({
                geometry: new Cesium.GroundPolylineGeometry({
                    positions,
                    width: Cesium.defaultValue(options.width, 2.0),
                    vertexFormat1: Cesium.PolylineMaterialAppearance.VERTEX_FORMAT
                })
            });

            var polylinePrimitive = new Cesium.GroundPolylinePrimitive({ geometryInstances: instance, asynchronous: false });
            polylinePrimitive.appearance = new Cesium.PolylineMaterialAppearance({
                material: Cesium.Material.fromType(Cesium.Material.PolylineOutlineType)
            });
            polylinePrimitive.appearance.material.uniforms.color = color;
            polylinePrimitive.appearance.material.uniforms.outlineColor = color;
            polylinePrimitive.appearance.material.uniforms.outlineWidth = 2.0;
            primitives.push(polylinePrimitive);

            const xmax = linePositions[0][1];
            const xmin = xmax - 1.0;
            const ymax = linePositions[0][0];
            const ymin = linePositions[1][0];
            const rectangle1 = Cesium.Rectangle.fromDegrees(xmin, Math.min(ymin, ymax), xmax, Math.max(ymin, ymax));
            primitives.push(DetectiveLineLayer.createText(rectangle1, element.substr(1, element.length - 1), color1));
        });

        this._primitives = primitives;
    };

    function drawTextCanvas(text, style) {
        var canvas = document.createElement("canvas");
        canvas.width = 100;
        canvas.height = 600;
        var ctx = canvas.getContext("2d");
        ctx.font = "80px 楷体";
        ctx.fillStyle = style;
        ctx.textAlign = "center";
        const str = text;
        let offsetX = 40;
        let offsetY = 80;
        for (let i = 0; i < str.length; i++) {
            ctx.fillText(str[i], offsetX, offsetY);
            offsetY += 80;
        }
        return canvas;
    }

    DetectiveLineLayer.createText = function (rectangle, text, style) {
        var geometry = new Cesium.RectangleGeometry({
            rectangle,
        });
        var geometryInstances = [];
        geometryInstances.push(
            new Cesium.GeometryInstance({
                geometry,
            })
        );
        var options = {
            geometryInstances: geometryInstances,
            appearance: new Cesium.MaterialAppearance({
                renderState: {
                    depthTest: { enabled: true },
                    depthMask: true,
                    blending: Cesium.BlendingState.ALPHA_BLEND,
                    cull: {
                        enabled: false,
                        face: Cesium.CullFace.FRONT,
                    },
                },
                translucent: false,
            }),
            asynchronous: true,
        };

        const image = drawTextCanvas(text, style);

        var primitive = new Cesium.GroundPrimitive(options);
        primitive.appearance.material = new Cesium.Material({
            fabric: {
                type: "Image",
                uniforms: {
                    image,
                },
            },
        });

        return primitive;
    };

    DetectiveLineLayer.prototype.destroy = function () {
        if (Cesium.defined(this._primitives)) {
            this._primitives.forEach((primitive) => {
                primitive.destroy();
            });
            this._primitives = undefined;
        }
        return Cesium.destroyObject(this);
    };

    DetectiveLineLayer.prototype.isDestroyed = function () {
        return false;
    };

    DetectiveLineLayer.prototype.update = function (frameState) {
        if (frameState.passes.render && Cesium.defined(this._primitives)) {
            for (let i = 0; i < this._primitives.length; i++) {
                this._primitives[i].update(frameState);
            }
        }
    };

    function LayerManager(we) {
      VolumeImageryLayer.CreateClassPrototype();
      CloudImageryLayer.CreateClassPrototype();
      WindImageryLayer.CreateClassPrototype();

      this._we = we;
      this._lys = new Cesium.AssociativeArray();
      this._shouldAnimate = false;
      this._showTileCoord = false;
      this._showAnnotation = false;
      this._gridLayer = undefined;
      this._tileCoordLayer = undefined;
      this._annotationLayer = undefined;
      this._detectiveLineLayer = undefined;
    }

    Object.defineProperties(LayerManager.prototype, {
      shouldAnimate: {
        get: function () {
          return this._shouldAnimate;
        },
        set: function (value) {
          this._shouldAnimate = value;
        },
      },
      showAnnotation: {
        get: function () {
          return this._showAnnotation;
        },
        set: function (value) {
          this._showAnnotation = value;
          if (!Cesium.defined(this._annotationLayer)) {
            this._annotationLayer = this.addImageryProvider(CommonLayers.TDT_Cia, '注记');
          }
          this._annotationLayer.show = value;
          this._we.viewer.imageryLayers.raiseToTop(this._annotationLayer);
        },
      },
      showDetectiveLine: {
        get: function () {
          return Cesium.defined(this._detectiveLineLayer);
        },
        set: function (value) {
          if (value) {
            if (!Cesium.defined(this._detectiveLineLayer)) {
              this._detectiveLineLayer = this._we.viewer.scene.groundPrimitives.add(new DetectiveLineLayer());
            }
          } else {
            if (Cesium.defined(this._detectiveLineLayer)) {
              this._we.viewer.scene.groundPrimitives.remove(this._detectiveLineLayer);
              this._detectiveLineLayer = undefined;
            }
          }
        },
      },
      showTileCoord: {
        get: function () {
          return this._showTileCoord;
        },
        set: function (value) {
          if (this._showTileCoord === value) {
            return;
          }
          this._showTileCoord = value;
          if (!value) {
            this._we.viewer.imageryLayers.remove(this._tileCoordLayer, false);
            this._tileCoordLayer = this._tileCoordLayer && this._tileCoordLayer.destroy();
          } else {
            this._tileCoordLayer = this._we.viewer.imageryLayers.addImageryProvider(new Cesium.TileCoordinatesImageryProvider((
              { tilingScheme: new Cesium.WebMercatorTilingScheme({ ellipsoid: Cesium.Ellipsoid.WGS84 }) }
            )));
          }
        },
      },
    });

    LayerManager.prototype.getById = function (id) {
      if (!Cesium.defined(id)) {
        throw new Cesium.DeveloperError("id is required.");
      }
      return this._lys.get(id);
    };

    LayerManager.prototype.remove = function (id, destroy) {
      var layer = this.getById(id);
      if (layer instanceof Cesium.ImageryLayer) {
        this._we.viewer.imageryLayers.remove(
          layer,
          Cesium.defaultValue(destroy, true)
        );
      } else if (layer instanceof Cesium.Cesium3DTileset
        || layer instanceof ThunderLayer
        || layer instanceof TyphoonLayer) {
        this._we.viewer.scene.primitives.remove(layer);
      }

      if (!this._lys.remove(id)) {
        return false;
      }

      return true;
    };

    LayerManager.prototype.raiseToTop = function (id) {
      var imagrylayer = this.getById(id);
      if (imagrylayer instanceof Cesium.ImageryLayer) {
        this._we.viewer.imageryLayers.raiseToTop(imagrylayer);
      }
    };

    LayerManager.prototype.getVolumeLayerCollection = function () {
      var collection = [];
      for (var i = 0; i < this._lys.length; i++) {
        var layer = this._lys._array[i];
        if (layer instanceof VolumeImageryLayer) {
          collection.push(layer);
        }
      }
      return collection;
    };

    LayerManager.prototype.getTilesetLayerCollection = function () {
      var collection = [];
      for (var i = 0; i < this._lys.length; i++) {
        var layer = this._lys._array[i];
        if (layer instanceof Cesium.Cesium3DTileset) {
          collection.push(layer);
        }
      }
      return collection;
    };

    LayerManager.prototype.addTilesetLayer = function (options, id) {
      if (!Cesium.defined(id)) {
        id = Cesium.createGuid();
      }

      var layers = this._lys;
      if (layers.contains(id)) {
        throw new Cesium.RuntimeError(
          "An layer with id " + id + " already exists in this collection."
        );
      }

      var layer = new Cesium.Cesium3DTileset(options);
      layer.style = options.style;
      layers.set(id, layer);
      this._we.viewer.scene.primitives.add(layer);

      return layer;
    };

    LayerManager.prototype.addVolumeLayer = function (options, id) {
      if (!Cesium.defined(id)) {
        id = Cesium.createGuid();
      }

      var layers = this._lys;
      if (layers.contains(id)) {
        throw new Cesium.RuntimeError(
          "An layer with id " + id + " already exists in this collection."
        );
      }

      var layer = new VolumeImageryLayer(
        Object.assign(options, {
          we: this._we,
          maximumAnisotropy: 16,
        })
      );

      this._we.viewer.imageryLayers.add(layer);
      layers.set(id, layer);

      return layer;
    };

    LayerManager.prototype.addCloudLayer = function (options, id) {
      if (!Cesium.defined(id)) {
        id = Cesium.createGuid();
      }

      var layers = this._lys;
      if (layers.contains(id)) {
        throw new Cesium.RuntimeError(
          "An layer with id " + id + " already exists in this collection."
        );
      }

      var cloudLayer = new CloudImageryLayer(
        Object.assign(options, {
          scene: this._we.viewer.scene,
          ValueAndColorRamp: WeatherVolumeTransfunctions.ValueAndColorRamp_UV,
        })
      );

      this._we.viewer.imageryLayers.add(cloudLayer);
      layers.set(id, cloudLayer);

      return cloudLayer;
    };

    LayerManager.prototype.addPipeLayer = function (options, id) {
      if (!Cesium.defined(id)) {
        id = Cesium.createGuid();
      }

      var layers = this._lys;
      if (layers.contains(id)) {
        throw new Cesium.RuntimeError(
          "An layer with id " + id + " already exists in this collection."
        );
      }
      options.id = id;
      var layer = new PipeLayer(options);
      layers.set(id, layer);

      this._we.viewer.scene.primitives.add(layer._tileset);

      return layer;
    };

    LayerManager.prototype.addTyphoonLayer = function (options, id) {
      if (!Cesium.defined(id)) {
        id = Cesium.createGuid();
      }

      var layers = this._lys;
      if (layers.contains(id)) {
        throw new Cesium.RuntimeError(
          "An layer with id " + id + " already exists in this collection."
        );
      }
      options.id = id;
      var layer = new TyphoonLayer(options);
      layers.set(id, layer);

      this._we.viewer.scene.primitives.add(layer);

      return layer;
    };

    LayerManager.prototype.addWindLayer = function (options, id) {
      if (!Cesium.defined(id)) {
        id = Cesium.createGuid();
      }

      var layers = this._lys;
      if (layers.contains(id)) {
        throw new Cesium.RuntimeError(
          "An layer with id " + id + " already exists in this collection."
        );
      }

      var layer = new WindImageryLayer(
        Object.assign(options, {
          scene: this._we.viewer.scene,
          ValueAndColorRamp: WeatherVolumeTransfunctions.ValueAndColorRamp_UV,
        })
      );

      this._we.viewer.imageryLayers.add(layer);
      layers.set(id, layer);

      return layer;
    };

    LayerManager.prototype.addImageryProvider = function (provider, id) {
      if (!Cesium.defined(id)) {
        id = Cesium.createGuid();
      }

      var layers = this._lys;
      if (layers.contains(id)) {
        throw new Cesium.RuntimeError(
          "An layer with id " + id + " already exists in this collection."
        );
      }
      var imagrylayer = this._we.viewer.imageryLayers.addImageryProvider(provider);
      layers.set(id, imagrylayer);

      return imagrylayer;
    };

    LayerManager.prototype.addGeoJsonDataSource = function (url, options) {
      var that = this;

      var promise = Cesium.GeoJsonDataSource.load(url, options);
      promise.then(function (dataSource) {
        if (!Cesium.defined(options.id)) {
          options.id = Cesium.createGuid();
        }

        dataSource.name = options.id;
        dataSource.allowPicking = Cesium.defaultValue(options.allowPicking, true);

        that._we.viewer.dataSources.add(dataSource);

        var id = options.id;
        var layers = that._lys;
        if (layers.contains(id)) {
          throw new Cesium.RuntimeError(
            "An layer with id " + id + " already exists in this collection."
          );
        }
        layers.set(id, dataSource);
      });

      return promise;
    };

    LayerManager.prototype.addPointLayer = function (url, options) {
      var that = this;

      var pointlayer = new PointLayer(options);

      pointlayer.loadUrl(url);

      if (!Cesium.defined(options.id)) {
        options.id = Cesium.createGuid();
      }
      that._we.viewer.dataSources.add(pointlayer);

      var id = options.id;
      var layers = that._lys;
      if (layers.contains(id)) {
        throw new Cesium.RuntimeError(
          "An layer with id " + id + " already exists in this collection."
        );
      }
      layers.set(id, pointlayer);
    };

    LayerManager.prototype.addThunderLayer = function (options, id) {
      var that = this;

      if (!Cesium.defined(id)) {
        id = Cesium.createGuid();
      }

      var layer = new ThunderLayer(options);

      this._we.viewer.scene.primitives.add(layer);

      var layers = that._lys;
      if (layers.contains(id)) {
        throw new Cesium.RuntimeError(
          "An layer with id " + id + " already exists in this collection."
        );
      }
      layers.set(id, layer);
    };

    LayerManager.prototype.addCZMLLayer = function (url, options) {
      var that = this;

      var promise = Cesium.CzmlDataSource.load(url, options);

      promise.then(function (dataSource) {
        if (!Cesium.defined(options.id)) {
          options.id = Cesium.createGuid();
        }

        that._we.viewer.dataSources.add(dataSource);

        var id = options.id;
        var layers = that._lys;
        if (layers.contains(id)) {
          throw new Cesium.RuntimeError(
            "An layer with id " + id + " already exists in this collection."
          );
        }
        layers.set(id, dataSource);
      });

      return promise;
    };

    LayerManager.prototype.addKMLLayer = function (url, options) {
      var that = this;

      var promise = /*Cesium.*/ KmlDataSource.load(
        url,
        Object.assign(options, {
          camera: this._we.viewer.scene.camera,
          canvas: this._we.viewer.scene.canvas,
        })
      );

      promise.then(function (dataSource) {
        if (!Cesium.defined(options.id)) {
          options.id = Cesium.createGuid();
        }
        that._we.viewer.dataSources.add(dataSource);

        var id = options.id;
        var layers = that._lys;
        if (layers.contains(id)) {
          throw new Cesium.RuntimeError(
            "An layer with id " + id + " already exists in this collection."
          );
        }
        layers.set(id, dataSource);
      });

      return promise;
    };

    LayerManager.prototype.update = function (frameState) {
      var loading = false;
      var i = 0;
      for (; i < this._lys.length; i++) {
        var layer = this._lys._array[i];
        if (
          (layer instanceof VolumeImageryLayer ||
            layer instanceof WindImageryLayer ||
            layer instanceof CloudImageryLayer) &&
          Cesium.defined(layer.update)
        ) {
          frameState.shouldAnimate = this._shouldAnimate;
          layer.update(frameState);
          loading = layer._isLoading || loading;
        }
      }

      if (this._shouldAnimate) {
        this._we.viewer.clock.shouldAnimate = !loading;
      }
    };

    /**
     * @private
     */
    function Texture(options) {
      options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);


      var context = options.context;
      var width = options.width;
      var height = options.height;
      var depth = options.depth;
      var source = options.source;
      var isTexture3D = false;

      if (Cesium.defined(source)) {
        if (!Cesium.defined(width)) {
          width = Cesium.defaultValue(source.videoWidth, source.width);
        }
        if (!Cesium.defined(height)) {
          height = Cesium.defaultValue(source.videoHeight, source.height);
        }
        if (!Cesium.defined(depth)) {
          depth = Cesium.defaultValue(source.depth, 0);
        }
      }

      isTexture3D = Cesium.defined(depth) && depth > 1;

      var pixelFormat = Cesium.defaultValue(options.pixelFormat, Cesium.PixelFormat.RGBA);
      var pixelDatatype = Cesium.defaultValue(
        options.pixelDatatype,
        Cesium.PixelDatatype.UNSIGNED_BYTE
      );
      var internalFormat = Cesium.PixelFormat.toInternalFormat(
        pixelFormat,
        pixelDatatype,
        context
      );

      var isCompressed = Cesium.PixelFormat.isCompressedFormat(internalFormat);


      // Use premultiplied alpha for opaque textures should perform better on Chrome:
      // http://media.tojicode.com/webglCamp4/#20
      var preMultiplyAlpha =
        options.preMultiplyAlpha ||
        pixelFormat === Cesium.PixelFormat.RGB ||
        pixelFormat === Cesium.PixelFormat.LUMINANCE;
      var flipY = Cesium.defaultValue(options.flipY, true);

      var initialized = true;

      var gl = context._gl;
      var textureTarget = gl.TEXTURE_2D;

      if (isTexture3D) {
          textureTarget = gl.TEXTURE_3D;
      }

      var texture = gl.createTexture();

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(textureTarget, texture);

      var unpackAlignment = 4;
      if (Cesium.defined(source) && Cesium.defined(source.arrayBufferView) && !isCompressed) {
        unpackAlignment = Cesium.PixelFormat.alignmentInBytes(
          pixelFormat,
          pixelDatatype,
          width
        );
      }

      gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);

      if (Cesium.defined(source)) {
        if (Cesium.defined(source.arrayBufferView)) {
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

          // Source: typed array
          var arrayBufferView = source.arrayBufferView;
          if (isCompressed) {
            gl.compressedTexImage2D(
              textureTarget,
              0,
              internalFormat,
              width,
              height,
              0,
              arrayBufferView
            );
          } else {
            if (isTexture3D) {
                gl.texImage3D(textureTarget, 0, internalFormat, width, height, depth, 0, pixelFormat, pixelDatatype, arrayBufferView);
            }
            else {
              if (flipY) {
                arrayBufferView = Cesium.PixelFormat.flipY(
                  arrayBufferView,
                  pixelFormat,
                  pixelDatatype,
                  width,
                  height
                );
              }
              gl.texImage2D(
                textureTarget,
                0,
                internalFormat,
                width,
                height,
                0,
                pixelFormat,
                Cesium.PixelDatatype.toWebGLConstant(pixelDatatype, context),
                arrayBufferView
              );
            }
            if (Cesium.defined(source.mipLevels)) {
              var mipWidth = width;
              var mipHeight = height;
              for (var i = 0; i < source.mipLevels.length; ++i) {
                mipWidth = Math.floor(mipWidth / 2) | 0;
                if (mipWidth < 1) {
                  mipWidth = 1;
                }
                mipHeight = Math.floor(mipHeight / 2) | 0;
                if (mipHeight < 1) {
                  mipHeight = 1;
                }
                gl.texImage2D(
                  textureTarget,
                  i + 1,
                  internalFormat,
                  mipWidth,
                  mipHeight,
                  0,
                  pixelFormat,
                  Cesium.PixelDatatype.toWebGLConstant(pixelDatatype, context),
                  source.mipLevels[i]
                );
              }
            }
          }
        } else if (Cesium.defined(source.framebuffer)) {
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

          // Source: framebuffer
          if (source.framebuffer !== context.defaultFramebuffer) {
            source.framebuffer._bind();
          }

          gl.copyTexImage2D(
            textureTarget,
            0,
            internalFormat,
            source.xOffset,
            source.yOffset,
            width,
            height,
            0
          );

          if (source.framebuffer !== context.defaultFramebuffer) {
            source.framebuffer._unBind();
          }
        } else {
          // Only valid for DOM-Element uploads
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);

          // Source: ImageData, HTMLImageElement, HTMLCanvasElement, or HTMLVideoElement
          gl.texImage2D(
            textureTarget,
            0,
            internalFormat,
            pixelFormat,
            Cesium.PixelDatatype.toWebGLConstant(pixelDatatype, context),
            source
          );
        }
      } else {
        gl.texImage2D(
          textureTarget,
          0,
          internalFormat,
          width,
          height,
          0,
          pixelFormat,
          Cesium.PixelDatatype.toWebGLConstant(pixelDatatype, context),
          null
        );
        initialized = false;
      }
      gl.bindTexture(textureTarget, null);

      var sizeInBytes;
      if (isCompressed) {
        sizeInBytes = Cesium.PixelFormat.compressedTextureSizeInBytes(
          pixelFormat,
          width,
          height
        );
      } else {
        sizeInBytes = Cesium.PixelFormat.textureSizeInBytes(
          pixelFormat,
          pixelDatatype,
          width,
          height
        );
      }

      this._id = Cesium.createGuid();
      this._context = context;
      this._textureFilterAnisotropic = context._textureFilterAnisotropic;
      this._textureTarget = textureTarget;
      this._texture = texture;
      this._internalFormat = internalFormat;
      this._pixelFormat = pixelFormat;
      this._pixelDatatype = pixelDatatype;
      this._width = width;
      this._height = height;
      this._depth = depth;
      this._dimensions = new Cesium.Cartesian2(width, height);
      this._hasMipmap = false;
      this._sizeInBytes = sizeInBytes;
      this._preMultiplyAlpha = preMultiplyAlpha;
      this._flipY = flipY;
      this._initialized = initialized;
      this._sampler = undefined;

      this.sampler = Cesium.defined(options.sampler) ? options.sampler : new Cesium.Sampler();
    }

    /**
     * This function is identical to using the Texture constructor except that it can be
     * replaced with a mock/spy in tests.
     * @private
     */
    Texture.create = function (options) {
      return new Texture(options);
    };

    /**
     * Creates a texture, and copies a subimage of the framebuffer to it.  When called without arguments,
     * the texture is the same width and height as the framebuffer and contains its contents.
     *
     * @param {Object} options Object with the following properties:
     * @param {Context} options.context The context in which the Texture gets created.
     * @param {Cesium.PixelFormat} [options.pixelFormat=Cesium.PixelFormat.RGB] The texture's internal pixel format.
     * @param {Number} [options.framebufferXOffset=0] An offset in the x direction in the framebuffer where copying begins from.
     * @param {Number} [options.framebufferYOffset=0] An offset in the y direction in the framebuffer where copying begins from.
     * @param {Number} [options.width=canvas.clientWidth] The width of the texture in texels.
     * @param {Number} [options.height=canvas.clientHeight] The height of the texture in texels.
     * @param {Framebuffer} [options.framebuffer=defaultFramebuffer] The framebuffer from which to create the texture.  If this
     *        parameter is not specified, the default framebuffer is used.
     * @returns {Texture} A texture with contents from the framebuffer.
     *
     * @exception {Cesium.DeveloperError} Invalid pixelFormat.
     * @exception {Cesium.DeveloperError} pixelFormat cannot be DEPTH_COMPONENT, DEPTH_STENCIL or a compressed format.
     * @exception {Cesium.DeveloperError} framebufferXOffset must be greater than or equal to zero.
     * @exception {Cesium.DeveloperError} framebufferYOffset must be greater than or equal to zero.
     * @exception {Cesium.DeveloperError} framebufferXOffset + width must be less than or equal to canvas.clientWidth.
     * @exception {Cesium.DeveloperError} framebufferYOffset + height must be less than or equal to canvas.clientHeight.
     *
     *
     * @example
     * // Create a texture with the contents of the framebuffer.
     * var t = Texture.fromFramebuffer({
     *     context : context
     * });
     *
     * @see Cesium.Sampler
     *
     * @private
     */
    Texture.fromFramebuffer = function (options) {
      options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);


      var context = options.context;
      var gl = context._gl;

      var pixelFormat = Cesium.defaultValue(options.pixelFormat, Cesium.PixelFormat.RGB);
      var framebufferXOffset = Cesium.defaultValue(options.framebufferXOffset, 0);
      var framebufferYOffset = Cesium.defaultValue(options.framebufferYOffset, 0);
      var width = Cesium.defaultValue(options.width, gl.drawingBufferWidth);
      var height = Cesium.defaultValue(options.height, gl.drawingBufferHeight);
      var framebuffer = options.framebuffer;


      var texture = new Texture({
        context: context,
        width: width,
        height: height,
        pixelFormat: pixelFormat,
        source: {
          framebuffer: Cesium.defined(framebuffer)
            ? framebuffer
            : context.defaultFramebuffer,
          xOffset: framebufferXOffset,
          yOffset: framebufferYOffset,
          width: width,
          height: height,
        },
      });

      return texture;
    };

    Object.defineProperties(Texture.prototype, {
      /**
       * A unique id for the texture
       * @memberof Texture.prototype
       * @type {String}
       * @readonly
       * @private
       */
      id: {
        get: function () {
          return this._id;
        },
      },
      /**
       * The sampler to use when sampling this texture.
       * Create a sampler by calling {@link Cesium.Sampler}.  If this
       * parameter is not specified, a default sampler is used.  The default sampler clamps texture
       * coordinates in both directions, uses linear filtering for both magnification and minification,
       * and uses a maximum anisotropy of 1.0.
       * @memberof Texture.prototype
       * @type {Object}
       */
      sampler: {
        get: function () {
          return this._sampler;
        },
        set: function (sampler) {
          var minificationFilter = sampler.minificationFilter;
          var magnificationFilter = sampler.magnificationFilter;
          var context = this._context;
          var pixelFormat = this._pixelFormat;
          var pixelDatatype = this._pixelDatatype;

          var mipmap =
            minificationFilter ===
              Cesium.TextureMinificationFilter.NEAREST_MIPMAP_NEAREST ||
            minificationFilter ===
              Cesium.TextureMinificationFilter.NEAREST_MIPMAP_LINEAR ||
            minificationFilter ===
              Cesium.TextureMinificationFilter.LINEAR_MIPMAP_NEAREST ||
            minificationFilter === Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR;

          // float textures only support nearest filtering unless the linear extensions are supported, so override the sampler's settings
          if (
            (pixelDatatype === Cesium.PixelDatatype.FLOAT &&
              !context.textureFloatLinear) ||
            (pixelDatatype === Cesium.PixelDatatype.HALF_FLOAT &&
              !context.textureHalfFloatLinear)
          ) {
            minificationFilter = mipmap
              ? Cesium.TextureMinificationFilter.NEAREST_MIPMAP_NEAREST
              : Cesium.TextureMinificationFilter.NEAREST;
            magnificationFilter = Cesium.TextureMagnificationFilter.NEAREST;
          }

          // WebGL 2 depth texture only support nearest filtering. See section 3.8.13 OpenGL ES 3 spec
          if (context.webgl2) {
            if (Cesium.PixelFormat.isDepthFormat(pixelFormat)) {
              minificationFilter = Cesium.TextureMinificationFilter.NEAREST;
              magnificationFilter = Cesium.TextureMagnificationFilter.NEAREST;
            }
          }

          var gl = context._gl;
          var target = this._textureTarget;

          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(target, this._texture);
          gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minificationFilter);
          gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magnificationFilter);
          gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);
          gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);
          if (Cesium.defined(sampler.wrapR)) {
              gl.texParameteri(target, gl.TEXTURE_WRAP_R, sampler.wrapR);
          }
          if (Cesium.defined(this._textureFilterAnisotropic)) {
            gl.texParameteri(
              target,
              this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
              sampler.maximumAnisotropy
            );
          }
          gl.bindTexture(target, null);

          this._sampler = sampler;
        },
      },
      pixelFormat: {
        get: function () {
          return this._pixelFormat;
        },
      },
      pixelDatatype: {
        get: function () {
          return this._pixelDatatype;
        },
      },
      dimensions: {
        get: function () {
          return this._dimensions;
        },
      },
      preMultiplyAlpha: {
        get: function () {
          return this._preMultiplyAlpha;
        },
      },
      flipY: {
        get: function () {
          return this._flipY;
        },
      },
      width: {
        get: function () {
          return this._width;
        },
      },
      height: {
        get: function () {
          return this._height;
        },
      },
      sizeInBytes: {
        get: function () {
          if (this._hasMipmap) {
            return Math.floor((this._sizeInBytes * 4) / 3);
          }
          return this._sizeInBytes;
        },
      },
      _target: {
        get: function () {
          return this._textureTarget;
        },
      },
    });

    /**
     * Copy new image data into this texture, from a source {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement}, or {@link HTMLVideoElement}.
     * or an object with width, height, and arrayBufferView properties.
     *
     * @param {Object} source The source {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement}, or {@link HTMLVideoElement},
     *                        or an object with width, height, and arrayBufferView properties.
     * @param {Number} [xOffset=0] The offset in the x direction within the texture to copy into.
     * @param {Number} [yOffset=0] The offset in the y direction within the texture to copy into.
     *
     * @exception {Cesium.DeveloperError} Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.
     * @exception {Cesium.DeveloperError} Cannot call copyFrom with a compressed texture pixel format.
     * @exception {Cesium.DeveloperError} xOffset must be greater than or equal to zero.
     * @exception {Cesium.DeveloperError} yOffset must be greater than or equal to zero.
     * @exception {Cesium.DeveloperError} xOffset + source.width must be less than or equal to width.
     * @exception {Cesium.DeveloperError} yOffset + source.height must be less than or equal to height.
     * @exception {Cesium.DeveloperError} This texture was destroyed, i.e., destroy() was called.
     *
     * @example
     * texture.copyFrom({
     *   width : 1,
     *   height : 1,
     *   arrayBufferView : new Uint8Array([255, 0, 0, 255])
     * });
     */
    Texture.prototype.copyFrom = function (source, xOffset, yOffset) {
      xOffset = Cesium.defaultValue(xOffset, 0);
      yOffset = Cesium.defaultValue(yOffset, 0);


      var context = this._context;
      var gl = context._gl;
      var target = this._textureTarget;

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(target, this._texture);

      var width = source.width;
      var height = source.height;
      var arrayBufferView = source.arrayBufferView;

      var textureWidth = this._width;
      var textureHeight = this._height;
      var internalFormat = this._internalFormat;
      var pixelFormat = this._pixelFormat;
      var pixelDatatype = this._pixelDatatype;

      var preMultiplyAlpha = this._preMultiplyAlpha;
      var flipY = this._flipY;

      var unpackAlignment = 4;
      if (Cesium.defined(arrayBufferView)) {
        unpackAlignment = Cesium.PixelFormat.alignmentInBytes(
          pixelFormat,
          pixelDatatype,
          width
        );
      }

      gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);

      var uploaded = false;
      if (!this._initialized) {
        if (
          xOffset === 0 &&
          yOffset === 0 &&
          width === textureWidth &&
          height === textureHeight
        ) {
          // initialize the entire texture
          if (Cesium.defined(arrayBufferView)) {
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

            if (flipY) {
              arrayBufferView = Cesium.PixelFormat.flipY(
                arrayBufferView,
                pixelFormat,
                pixelDatatype,
                textureWidth,
                textureHeight
              );
            }
            gl.texImage2D(
              target,
              0,
              internalFormat,
              textureWidth,
              textureHeight,
              0,
              pixelFormat,
              Cesium.PixelDatatype.toWebGLConstant(pixelDatatype, context),
              arrayBufferView
            );
          } else {
            // Only valid for DOM-Element uploads
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);

            gl.texImage2D(
              target,
              0,
              internalFormat,
              pixelFormat,
              Cesium.PixelDatatype.toWebGLConstant(pixelDatatype, context),
              source
            );
          }
          uploaded = true;
        } else {
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

          // initialize the entire texture to zero
          var bufferView = Cesium.PixelFormat.createTypedArray(
            pixelFormat,
            pixelDatatype,
            textureWidth,
            textureHeight
          );
          gl.texImage2D(
            target,
            0,
            internalFormat,
            textureWidth,
            textureHeight,
            0,
            pixelFormat,
            Cesium.PixelDatatype.toWebGLConstant(pixelDatatype, context),
            bufferView
          );
        }
        this._initialized = true;
      }

      if (!uploaded) {
        if (Cesium.defined(arrayBufferView)) {
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

          var depth = source.depth;
          if (Cesium.defined(depth) && depth > 1) {
            gl.texSubImage3D(
              target,
              0,
              xOffset,
              yOffset,
              0,
              width,
              height,
              depth,
              pixelFormat,
              Cesium.PixelDatatype.toWebGLConstant(pixelDatatype, this._context),
              arrayBufferView
            );
          } else {
            if (flipY) {
              arrayBufferView = Cesium.PixelFormat.flipY(
                arrayBufferView,
                pixelFormat,
                pixelDatatype,
                width,
                height
              );
            }

            gl.texSubImage2D(
              target,
              0,
              xOffset,
              yOffset,
              width,
              height,
              pixelFormat,
              Cesium.PixelDatatype.toWebGLConstant(pixelDatatype, context),
              arrayBufferView
            );
          }
        } else {
          // Only valid for DOM-Element uploads
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);

          gl.texSubImage2D(
            target,
            0,
            xOffset,
            yOffset,
            pixelFormat,
            Cesium.PixelDatatype.toWebGLConstant(pixelDatatype, context),
            source
          );
        }
      }

      gl.bindTexture(target, null);
    };

    /**
     * @param {Number} [xOffset=0] The offset in the x direction within the texture to copy into.
     * @param {Number} [yOffset=0] The offset in the y direction within the texture to copy into.
     * @param {Number} [framebufferXOffset=0] optional
     * @param {Number} [framebufferYOffset=0] optional
     * @param {Number} [width=width] optional
     * @param {Number} [height=height] optional
     *
     * @exception {Cesium.DeveloperError} Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.
     * @exception {Cesium.DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.
     * @exception {Cesium.DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.
     * @exception {Cesium.DeveloperError} Cannot call copyFrom with a compressed texture pixel format.
     * @exception {Cesium.DeveloperError} This texture was destroyed, i.e., destroy() was called.
     * @exception {Cesium.DeveloperError} xOffset must be greater than or equal to zero.
     * @exception {Cesium.DeveloperError} yOffset must be greater than or equal to zero.
     * @exception {Cesium.DeveloperError} framebufferXOffset must be greater than or equal to zero.
     * @exception {Cesium.DeveloperError} framebufferYOffset must be greater than or equal to zero.
     * @exception {Cesium.DeveloperError} xOffset + width must be less than or equal to width.
     * @exception {Cesium.DeveloperError} yOffset + height must be less than or equal to height.
     */
    Texture.prototype.copyFromFramebuffer = function (
      xOffset,
      yOffset,
      framebufferXOffset,
      framebufferYOffset,
      width,
      height
    ) {
      xOffset = Cesium.defaultValue(xOffset, 0);
      yOffset = Cesium.defaultValue(yOffset, 0);
      framebufferXOffset = Cesium.defaultValue(framebufferXOffset, 0);
      framebufferYOffset = Cesium.defaultValue(framebufferYOffset, 0);
      width = Cesium.defaultValue(width, this._width);
      height = Cesium.defaultValue(height, this._height);


      var gl = this._context._gl;
      var target = this._textureTarget;

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(target, this._texture);
      gl.copyTexSubImage2D(
        target,
        0,
        xOffset,
        yOffset,
        framebufferXOffset,
        framebufferYOffset,
        width,
        height
      );
      gl.bindTexture(target, null);
      this._initialized = true;
    };

    /**
     * @param {Cesium.MipmapHint} [hint=Cesium.MipmapHint.DONT_CARE] optional.
     *
     * @exception {Cesium.DeveloperError} Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.
     * @exception {Cesium.DeveloperError} Cannot call generateMipmap when the texture pixel format is a compressed format.
     * @exception {Cesium.DeveloperError} hint is invalid.
     * @exception {Cesium.DeveloperError} This texture's width must be a power of two to call generateMipmap().
     * @exception {Cesium.DeveloperError} This texture's height must be a power of two to call generateMipmap().
     * @exception {Cesium.DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.generateMipmap = function (hint) {
      hint = Cesium.defaultValue(hint, Cesium.MipmapHint.DONT_CARE);


      this._hasMipmap = true;

      var gl = this._context._gl;
      var target = this._textureTarget;

      gl.hint(gl.GENERATE_MIPMAP_HINT, hint);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(target, this._texture);
      gl.generateMipmap(target);
      gl.bindTexture(target, null);
    };

    Texture.prototype.isDestroyed = function () {
      return false;
    };

    Texture.prototype.destroy = function () {
      this._context._gl.deleteTexture(this._texture);
      return Cesium.destroyObject(this);
    };

    /**
     * @private
     */
    function Sampler(options) {
      options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

      var wrapS = Cesium.defaultValue(options.wrapS, Cesium.TextureWrap.CLAMP_TO_EDGE);
      var wrapT = Cesium.defaultValue(options.wrapT, Cesium.TextureWrap.CLAMP_TO_EDGE);
      var wrapR = Cesium.defaultValue(options.wrapR, Cesium.TextureWrap.CLAMP_TO_EDGE);
      var minificationFilter = Cesium.defaultValue(
        options.minificationFilter,
        Cesium.TextureMinificationFilter.LINEAR
      );
      var magnificationFilter = Cesium.defaultValue(
        options.magnificationFilter,
        Cesium.TextureMagnificationFilter.LINEAR
      );
      var maximumAnisotropy = Cesium.defined(options.maximumAnisotropy)
        ? options.maximumAnisotropy
        : 1.0;

      this._wrapS = wrapS;
      this._wrapT = wrapT;
      this._wrapR = wrapR;
      this._minificationFilter = minificationFilter;
      this._magnificationFilter = magnificationFilter;
      this._maximumAnisotropy = maximumAnisotropy;
    }

    Object.defineProperties(Sampler.prototype, {
      wrapS: {
        get: function () {
          return this._wrapS;
        },
      },
      wrapT: {
        get: function () {
          return this._wrapT;
        },
      },
      wrapR: {
        get: function () {
          return this._wrapR;
        },
      },
      minificationFilter: {
        get: function () {
          return this._minificationFilter;
        },
      },
      magnificationFilter: {
        get: function () {
          return this._magnificationFilter;
        },
      },
      maximumAnisotropy: {
        get: function () {
          return this._maximumAnisotropy;
        },
      },
    });

    Sampler.equals = function (left, right) {
      return (
        left === right ||
        (Cesium.defined(left) &&
          Cesium.defined(right) &&
          left._wrapS === right._wrapS &&
          left._wrapT === right._wrapT &&
          left._minificationFilter === right._minificationFilter &&
          left._magnificationFilter === right._magnificationFilter &&
          left._maximumAnisotropy === right._maximumAnisotropy)
      );
    };

    Sampler.init = function(){
      Sampler.NEAREST = Object.freeze(
        new Sampler({
          wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
          wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
          wrapR: Cesium.TextureWrap.CLAMP_TO_EDGE,
          minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
          magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST,
        })
      );
    };

    function Material(options) {
      /**
       * The material type. Can be an existing type or a new type. If no type is specified in fabric, type is a GUID.
       * @type {String}
       * @default undefined
       */
      this.type = undefined;

      /**
       * The glsl shader source for this material.
       * @type {String}
       * @default undefined
       */
      this.shaderSource = undefined;

      /**
       * Maps sub-material names to Material objects.
       * @type {Object}
       * @default undefined
       */
      this.materials = undefined;

      /**
       * Maps uniform names to their values.
       * @type {Object}
       * @default undefined
       */
      this.uniforms = undefined;
      this._uniforms = undefined;

      /**
       * When <code>true</code> or a function that returns <code>true</code>,
       * the geometry is expected to appear translucent.
       * @type {Boolean|Function}
       * @default undefined
       */
      this.translucent = undefined;

      this._minificationFilter = Cesium.defaultValue(
        options.minificationFilter,
        Cesium.TextureMinificationFilter.LINEAR
      );
      this._magnificationFilter = Cesium.defaultValue(
        options.magnificationFilter,
        Cesium.TextureMagnificationFilter.LINEAR
      );

      this._strict = undefined;
      this._template = undefined;
      this._count = undefined;

      this._texturePaths = {};
      this._loadedImages = [];
      this._loadedCubeMaps = [];

      this._textures = {};

      this._updateFunctions = [];

      this._defaultTexture = undefined;

      initializeMaterial(options, this);
      Object.defineProperties(this, {
        type: {
          value: this.type,
          writable: false,
        },
      });

      if (!Cesium.defined(Material._uniformList[this.type])) {
        Material._uniformList[this.type] = Object.keys(this._uniforms);
      }
    }

    // Cached list of combined uniform names indexed by type.
    // Used to get the list of uniforms in the same order.
    Material._uniformList = {};

    /**
     * Creates a new material using an existing material type.
     * <br /><br />
     * Shorthand for: new Material({fabric : {type : type}});
     *
     * @param {String} type The base material type.
     * @param {Object} [uniforms] Overrides for the default uniforms.
     * @returns {Material} New material object.
     *
     * @exception {Cesium.DeveloperError} material with that type does not exist.
     *
     * @example
     * var material = Cesium.Material.fromType('Cesium.Color', {
     *     color : new Cesium.Cesium.Color(1.0, 0.0, 0.0, 1.0)
     * });
     */
    Material.fromType = function (type, uniforms) {
      var material = new Material({
        fabric: {
          type: type,
        },
      });

      if (Cesium.defined(uniforms)) {
        for (var name in uniforms) {
          if (uniforms.hasOwnProperty(name)) {
            material.uniforms[name] = uniforms[name];
          }
        }
      }

      return material;
    };

    /**
     * Gets whether or not this material is translucent.
     * @returns {Boolean} <code>true</code> if this material is translucent, <code>false</code> otherwise.
     */
    Material.prototype.isTranslucent = function () {
      if (Cesium.defined(this.translucent)) {
        if (typeof this.translucent === "function") {
          return this.translucent();
        }

        return this.translucent;
      }

      var translucent = true;
      var funcs = this._translucentFunctions;
      var length = funcs.length;
      for (var i = 0; i < length; ++i) {
        var func = funcs[i];
        if (typeof func === "function") {
          translucent = translucent && func();
        } else {
          translucent = translucent && func;
        }

        if (!translucent) {
          break;
        }
      }
      return translucent;
    };

    /**
     * @private
     */
    Material.prototype.update = function (context) {
      var i;
      var uniformId;

      var loadedImages = this._loadedImages;
      var length = loadedImages.length;

      for (i = 0; i < length; ++i) {
        var loadedImage = loadedImages[i];
        uniformId = loadedImage.id;
        var image = loadedImage.image;

        // Images transcoded from KTX2 can contain multiple mip levels:
        // https://github.khronos.org/KTX-Specification/#_mip_level_array
        var mipLevels;
        if (Array.isArray(image)) {
          // highest detail mip should be level 0
          mipLevels = image.slice(1, image.length).map(function (mipLevel) {
            return mipLevel.bufferView;
          });
          image = image[0];
        }

        var sampler = new Cesium.Sampler({
          minificationFilter: this._minificationFilter,
          magnificationFilter: this._magnificationFilter,
        });

        var texture;
        if (Cesium.defined(image.internalFormat)) {
          texture = new Cesium.Texture({
            context: context,
            pixelFormat: image.internalFormat,
            width: image.width,
            height: image.height,
            source: {
              arrayBufferView: image.bufferView,
              mipLevels: mipLevels,
            },
            sampler: sampler,
          });
        } else {
          texture = new Cesium.Texture({
            context: context,
            source: image,
            sampler: sampler,
          });
        }

        this._textures[uniformId] = texture;

        var uniformDimensionsName = uniformId + "Dimensions";
        if (this.uniforms.hasOwnProperty(uniformDimensionsName)) {
          var uniformDimensions = this.uniforms[uniformDimensionsName];
          uniformDimensions.x = texture._width;
          uniformDimensions.y = texture._height;
        }
      }

      loadedImages.length = 0;

      var loadedCubeMaps = this._loadedCubeMaps;
      length = loadedCubeMaps.length;

      for (i = 0; i < length; ++i) {
        var loadedCubeMap = loadedCubeMaps[i];
        uniformId = loadedCubeMap.id;
        var images = loadedCubeMap.images;

        var cubeMap = new Cesium.CubeMap({
          context: context,
          source: {
            positiveX: images[0],
            negativeX: images[1],
            positiveY: images[2],
            negativeY: images[3],
            positiveZ: images[4],
            negativeZ: images[5],
          },
          sampler: new Cesium.Sampler({
            minificationFilter: this._minificationFilter,
            magnificationFilter: this._magnificationFilter,
          }),
        });

        this._textures[uniformId] = cubeMap;
      }

      loadedCubeMaps.length = 0;

      var updateFunctions = this._updateFunctions;
      length = updateFunctions.length;
      for (i = 0; i < length; ++i) {
        updateFunctions[i](this, context);
      }

      var subMaterials = this.materials;
      for (var name in subMaterials) {
        if (subMaterials.hasOwnProperty(name)) {
          subMaterials[name].update(context);
        }
      }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link Cesium.DeveloperError} exception.
     *
     * @returns {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see Material#destroy
     */
    Material.prototype.isDestroyed = function () {
      return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link Cesium.DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @exception {Cesium.DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     *
     * @example
     * material = material && material.destroy();
     *
     * @see Material#isDestroyed
     */
    Material.prototype.destroy = function () {
      var textures = this._textures;
      for (var texture in textures) {
        if (textures.hasOwnProperty(texture)) {
          var instance = textures[texture];
          if (instance !== this._defaultTexture) {
            instance.destroy();
          }
        }
      }

      var materials = this.materials;
      for (var material in materials) {
        if (materials.hasOwnProperty(material)) {
          materials[material].destroy();
        }
      }
      return Cesium.destroyObject(this);
    };

    function initializeMaterial(options, result) {
      options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
      result._strict = Cesium.defaultValue(options.strict, false);
      result._count = Cesium.defaultValue(options.count, 0);
      result._template = Cesium.clone(
        Cesium.defaultValue(options.fabric, Cesium.defaultValue.EMPTY_OBJECT)
      );
      result._template.uniforms = Cesium.clone(
        Cesium.defaultValue(result._template.uniforms, Cesium.defaultValue.EMPTY_OBJECT)
      );
      result._template.materials = Cesium.clone(
        Cesium.defaultValue(result._template.materials, Cesium.defaultValue.EMPTY_OBJECT)
      );

      result.type = Cesium.defined(result._template.type)
        ? result._template.type
        : Cesium.createGuid();

      result.shaderSource = "";
      result.materials = {};
      result.uniforms = {};
      result._uniforms = {};
      result._translucentFunctions = [];

      var translucent;

      // If the cache contains this material type, build the material template off of the stored template.
      var cachedMaterial = Material._materialCache.getMaterial(result.type);
      if (Cesium.defined(cachedMaterial)) {
        var template = Cesium.clone(cachedMaterial.fabric, true);
        result._template = Cesium.combine(result._template, template, true);
        translucent = cachedMaterial.translucent;
      }

      // Make sure the template has no obvious errors. More error checking happens later.
      checkForTemplateErrors(result);

      // If the material has a new type, add it to the cache.
      if (!Cesium.defined(cachedMaterial)) {
        Material._materialCache.addMaterial(result.type, result);
      }

      createMethodDefinition(result);
      createUniforms(result);
      createSubMaterials(result);

      var defaultTranslucent =
        result._translucentFunctions.length === 0 ? true : undefined;
      translucent = Cesium.defaultValue(translucent, defaultTranslucent);
      translucent = Cesium.defaultValue(options.translucent, translucent);

      if (Cesium.defined(translucent)) {
        if (typeof translucent === "function") {
          var wrappedTranslucent = function () {
            return translucent(result);
          };
          result._translucentFunctions.push(wrappedTranslucent);
        } else {
          result._translucentFunctions.push(translucent);
        }
      }
    }

    function checkForValidProperties(object, properties, result, throwNotFound) {
      if (Cesium.defined(object)) {
        for (var property in object) {
          if (object.hasOwnProperty(property)) {
            var hasProperty = properties.indexOf(property) !== -1;
            if (
              (throwNotFound && !hasProperty) ||
              (!throwNotFound && hasProperty)
            ) {
              result(property, properties);
            }
          }
        }
      }
    }

    function invalidNameError(property, properties) {
    }

    function duplicateNameError(property, properties) {
    }

    var templateProperties = [
      "type",
      "materials",
      "uniforms",
      "components",
      "source",
    ];
    var componentProperties = [
      "diffuse",
      "specular",
      "shininess",
      "normal",
      "emission",
      "alpha",
    ];

    function checkForTemplateErrors(material) {
      var template = material._template;
      var uniforms = template.uniforms;
      var materials = template.materials;
      var components = template.components;

      // Make sure source and components do not exist in the same template.
      // Make sure all template and components properties are valid.
      checkForValidProperties(template, templateProperties, invalidNameError, true);
      checkForValidProperties(
        components,
        componentProperties,
        invalidNameError,
        true
      );

      // Make sure uniforms and materials do not share any of the same names.
      var materialNames = [];
      for (var property in materials) {
        if (materials.hasOwnProperty(property)) {
          materialNames.push(property);
        }
      }
      checkForValidProperties(uniforms, materialNames, duplicateNameError, false);
    }

    function isMaterialFused(shaderComponent, material) {
      var materials = material._template.materials;
      for (var subMaterialId in materials) {
        if (materials.hasOwnProperty(subMaterialId)) {
          if (shaderComponent.indexOf(subMaterialId) > -1) {
            return true;
          }
        }
      }

      return false;
    }

    // Create the czm_getMaterial method body using source or components.
    function createMethodDefinition(material) {
      var components = material._template.components;
      var source = material._template.source;
      if (Cesium.defined(source)) {
        material.shaderSource += source + "\n";
      } else {
        material.shaderSource +=
          "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n";
        material.shaderSource +=
          "czm_material material = czm_getDefaultMaterial(materialInput);\n";
        if (Cesium.defined(components)) {
          var isMultiMaterial =
            Object.keys(material._template.materials).length > 0;
          for (var component in components) {
            if (components.hasOwnProperty(component)) {
              if (component === "diffuse" || component === "emission") {
                var isFusion =
                  isMultiMaterial &&
                  isMaterialFused(components[component], material);
                var componentSource = isFusion
                  ? components[component]
                  : "czm_gammaCorrect(" + components[component] + ")";
                material.shaderSource +=
                  "material." + component + " = " + componentSource + "; \n";
              } else if (component === "alpha") {
                material.shaderSource +=
                  "material.alpha = " + components.alpha + "; \n";
              } else {
                material.shaderSource +=
                  "material." + component + " = " + components[component] + ";\n";
              }
            }
          }
        }
        material.shaderSource += "return material;\n}\n";
      }
    }

    var matrixMap;

    var ktx2Regex = /\.ktx2$/i;

    function createTexture2DUpdateFunction(uniformId) {
      var oldUniformValue;
      return function (material, context) {
        var uniforms = material.uniforms;
        var uniformValue = uniforms[uniformId];
        var uniformChanged = oldUniformValue !== uniformValue;
        oldUniformValue = uniformValue;
        var texture = material._textures[uniformId];

        var uniformDimensionsName;
        var uniformDimensions;

        if (uniformValue instanceof HTMLVideoElement) {
          // HTMLVideoElement.readyState >=2 means we have enough data for the current frame.
          // See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/readyState
          if (uniformValue.readyState >= 2) {
            if (uniformChanged && Cesium.defined(texture)) {
              if (texture !== context.defaultTexture) {
                texture.destroy();
              }
              texture = undefined;
            }

            if (!Cesium.defined(texture) || texture === context.defaultTexture) {
              var sampler = new Cesium.Sampler({
                minificationFilter: material._minificationFilter,
                magnificationFilter: material._magnificationFilter,
              });
              texture = new Cesium.Texture({
                context: context,
                source: uniformValue,
                sampler: sampler,
              });
              material._textures[uniformId] = texture;
              return;
            }

            texture.copyFrom({
              source: uniformValue,
            });
          } else if (!Cesium.defined(texture)) {
            material._textures[uniformId] = context.defaultTexture;
          }
          return;
        }

        if (uniformValue instanceof Cesium.Texture && uniformValue !== texture) {
          material._texturePaths[uniformId] = undefined;
          var tmp = material._textures[uniformId];
          if (tmp !== material._defaultTexture) {
            tmp.destroy();
          }
          material._textures[uniformId] = uniformValue;

          uniformDimensionsName = uniformId + "Dimensions";
          if (uniforms.hasOwnProperty(uniformDimensionsName)) {
            uniformDimensions = uniforms[uniformDimensionsName];
            uniformDimensions.x = uniformValue._width;
            uniformDimensions.y = uniformValue._height;
          }

          return;
        }

        if (!Cesium.defined(texture)) {
          material._texturePaths[uniformId] = undefined;
          if (!Cesium.defined(material._defaultTexture)) {
            material._defaultTexture = context.defaultTexture;
          }
          texture = material._textures[uniformId] = material._defaultTexture;

          uniformDimensionsName = uniformId + "Dimensions";
          if (uniforms.hasOwnProperty(uniformDimensionsName)) {
            uniformDimensions = uniforms[uniformDimensionsName];
            uniformDimensions.x = texture._width;
            uniformDimensions.y = texture._height;
          }
        }

        if (uniformValue === Material.DefaultImageId) {
          return;
        }

        // When using the entity layer, the Cesium.Resource objects get recreated on getValue because
        //  they are clonable. That's why we check the url property for Resources
        //  because the instances aren't the same and we keep trying to load the same
        //  image if it fails to load.
        var isResource = uniformValue instanceof Cesium.Resource;
        if (
          !Cesium.defined(material._texturePaths[uniformId]) ||
          (isResource &&
            uniformValue.url !== material._texturePaths[uniformId].url) ||
          (!isResource && uniformValue !== material._texturePaths[uniformId])
        ) {
          if (typeof uniformValue === "string" || isResource) {
            var resource = isResource
              ? uniformValue
              : Cesium.Resource.createIfNeeded(uniformValue);

            var promise;
            if (ktx2Regex.test(resource.url)) {
              promise = Cesium.loadKTX2(resource.url);
            } else {
              promise = resource.fetchImage();
            }

            Cesium.when(promise, function (image) {
              material._loadedImages.push({
                id: uniformId,
                image: image,
              });
            });
          } else if (
            uniformValue instanceof HTMLCanvasElement ||
            uniformValue instanceof HTMLImageElement
          ) {
            material._loadedImages.push({
              id: uniformId,
              image: uniformValue,
            });
          }

          material._texturePaths[uniformId] = uniformValue;
        }
      };
    }

    function createCubeMapUpdateFunction(uniformId) {
      return function (material, context) {
        var uniformValue = material.uniforms[uniformId];

        if (uniformValue instanceof Cesium.CubeMap) {
          var tmp = material._textures[uniformId];
          if (tmp !== material._defaultTexture) {
            tmp.destroy();
          }
          material._texturePaths[uniformId] = undefined;
          material._textures[uniformId] = uniformValue;
          return;
        }

        if (!Cesium.defined(material._textures[uniformId])) {
          material._texturePaths[uniformId] = undefined;
          material._textures[uniformId] = context.defaultCubeMap;
        }

        if (uniformValue === Material.DefaultCubeMapId) {
          return;
        }

        var path =
          uniformValue.positiveX +
          uniformValue.negativeX +
          uniformValue.positiveY +
          uniformValue.negativeY +
          uniformValue.positiveZ +
          uniformValue.negativeZ;

        if (path !== material._texturePaths[uniformId]) {
          var promises = [
            Cesium.Resource.createIfNeeded(uniformValue.positiveX).fetchImage(),
            Cesium.Resource.createIfNeeded(uniformValue.negativeX).fetchImage(),
            Cesium.Resource.createIfNeeded(uniformValue.positiveY).fetchImage(),
            Cesium.Resource.createIfNeeded(uniformValue.negativeY).fetchImage(),
            Cesium.Resource.createIfNeeded(uniformValue.positiveZ).fetchImage(),
            Cesium.Resource.createIfNeeded(uniformValue.negativeZ).fetchImage(),
          ];

          Cesium.when.all(promises).then(function (images) {
            material._loadedCubeMaps.push({
              id: uniformId,
              images: images,
            });
          });

          material._texturePaths[uniformId] = path;
        }
      };
    }

    function createUniforms(material) {
      var uniforms = material._template.uniforms;
      for (var uniformId in uniforms) {
        if (uniforms.hasOwnProperty(uniformId)) {
          createUniform(material, uniformId);
        }
      }
    }

    // Writes uniform declarations to the shader file and connects uniform values with
    // corresponding material properties through the returnUniforms function.
    function createUniform(material, uniformId) {
      var strict = material._strict;
      var materialUniforms = material._template.uniforms;
      var uniformValue = materialUniforms[uniformId];
      var uniformType = getUniformType(uniformValue);

      var replacedTokenCount;
      if (uniformType === "channels") {
        replacedTokenCount = replaceToken(material, uniformId, uniformValue, false);
      } else {
        // Since webgl doesn't allow texture dimension queries in glsl, create a uniform to do it.
        // Check if the shader source actually uses texture dimensions before creating the uniform.
        if (uniformType === "sampler2D" || uniformType === "sampler3D") {
          var imageDimensionsUniformName = uniformId + "Dimensions";
          if (getNumberOfTokens(material, imageDimensionsUniformName) > 0) {
            materialUniforms[imageDimensionsUniformName] = {
              type: "ivec3",
              x: 1,
              y: 1,
            };
            createUniform(material, imageDimensionsUniformName);
          }
        }

        // Add uniform declaration to source code.
        var uniformDeclarationRegex = new RegExp(
          "uniform\\s+" + uniformType + "\\s+" + uniformId + "\\s*;"
        );
        if (!uniformDeclarationRegex.test(material.shaderSource)) {
          var uniformDeclaration = "uniform " + uniformType + " " + uniformId + ";";
          if (uniformType === "sampler3D") {
            uniformDeclaration = 'precision highp sampler3D;' + uniformDeclaration;
          }
          material.shaderSource = uniformDeclaration + material.shaderSource;
        }

        var newUniformId = uniformId + "_" + material._count++;
        replacedTokenCount = replaceToken(material, uniformId, newUniformId);
        // Set uniform value
        material.uniforms[uniformId] = uniformValue;

        if (uniformType === "sampler2D" || uniformType === "sampler3D") {
          material._uniforms[newUniformId] = function () {
            return material._textures[uniformId];
          };
          material._updateFunctions.push(createTexture2DUpdateFunction(uniformId));
        } else if (uniformType === "samplerCube") {
          material._uniforms[newUniformId] = function () {
            return material._textures[uniformId];
          };
          material._updateFunctions.push(createCubeMapUpdateFunction(uniformId));
        } else if (uniformType.indexOf("mat") !== -1) {
          var scratchMatrix = new matrixMap[uniformType]();
          material._uniforms[newUniformId] = function () {
            return matrixMap[uniformType].fromColumnMajorArray(
              material.uniforms[uniformId],
              scratchMatrix
            );
          };
        } else {
          material._uniforms[newUniformId] = function () {
            return material.uniforms[uniformId];
          };
        }
      }
    }

    // Determines the uniform type based on the uniform in the template.
    function getUniformType(uniformValue) {
      var uniformType = uniformValue.type;
      if (!Cesium.defined(uniformType)) {
        var type = typeof uniformValue;
        if (type === "number") {
          uniformType = "float";
        } else if (type === "boolean") {
          uniformType = "bool";
        } else if (
          type === "string" ||
          uniformValue instanceof Cesium.Resource ||
          uniformValue instanceof HTMLCanvasElement ||
          uniformValue instanceof HTMLImageElement
        ) {
          if (/^([rgba]){1,4}$/i.test(uniformValue)) {
            uniformType = "channels";
          } else if (uniformValue === Material.DefaultCubeMapId) {
            uniformType = "samplerCube";
          } else if (uniformValue === 'sampler3D') {
            uniformType = "sampler3D";
          } else {
            uniformType = "sampler2D";
          }
        } else if (type === "object") {
          if (Array.isArray(uniformValue)) {
            if (
              uniformValue.length === 4 ||
              uniformValue.length === 9 ||
              uniformValue.length === 16
            ) {
              uniformType = "mat" + Math.sqrt(uniformValue.length);
            }
          } else {
            var numAttributes = 0;
            for (var attribute in uniformValue) {
              if (uniformValue.hasOwnProperty(attribute)) {
                numAttributes += 1;
              }
            }
            if (numAttributes >= 2 && numAttributes <= 4) {
              uniformType = "vec" + numAttributes;
            } else if (numAttributes === 6) {
              uniformType = "samplerCube";
            } else if (uniformValue instanceof Cesium.Texture) {
              uniformType = uniformValue._depth > 0 ? "sampler3D" : "sampler2D";
            } else if (uniformValue instanceof Cesium.Matrix4)
              uniformType = "mat4";
          }
        }
      }
      return uniformType;
    }

    // Create all sub-materials by combining source and uniforms together.
    function createSubMaterials(material) {
      var strict = material._strict;
      var subMaterialTemplates = material._template.materials;
      for (var subMaterialId in subMaterialTemplates) {
        if (subMaterialTemplates.hasOwnProperty(subMaterialId)) {
          // Construct the sub-material.
          var subMaterial = new Material({
            strict: strict,
            fabric: subMaterialTemplates[subMaterialId],
            count: material._count,
          });

          material._count = subMaterial._count;
          material._uniforms = Cesium.combine(
            material._uniforms,
            subMaterial._uniforms,
            true
          );
          material.materials[subMaterialId] = subMaterial;
          material._translucentFunctions = material._translucentFunctions.concat(
            subMaterial._translucentFunctions
          );

          // Make the material's czm_getMaterial unique by appending the sub-material type.
          var originalMethodName = "czm_getMaterial";
          var newMethodName = originalMethodName + "_" + material._count++;
          replaceToken(subMaterial, originalMethodName, newMethodName);
          material.shaderSource = subMaterial.shaderSource + material.shaderSource;

          // Replace each material id with an czm_getMaterial method call.
          var materialMethodCall = newMethodName + "(materialInput)";
          var tokensReplacedCount = replaceToken(
            material,
            subMaterialId,
            materialMethodCall
          );
        }
      }
    }

    // Used for searching or replacing a token in a material's shader source with something else.
    // If excludePeriod is true, do not accept tokens that are preceded by periods.
    // http://stackoverflow.com/questions/641407/javascript-negative-lookbehind-equivalent
    function replaceToken(material, token, newToken, excludePeriod) {
      excludePeriod = Cesium.defaultValue(excludePeriod, true);
      var count = 0;
      var suffixChars = "([\\w])?";
      var prefixChars = "([\\w" + (excludePeriod ? "." : "") + "])?";
      var regExp = new RegExp(prefixChars + token + suffixChars, "g");
      material.shaderSource = material.shaderSource.replace(regExp, function (
        $0,
        $1,
        $2
      ) {
        if ($1 || $2) {
          return $0;
        }
        count += 1;
        return newToken;
      });
      return count;
    }

    function getNumberOfTokens(material, token, excludePeriod) {
      return replaceToken(material, token, token, excludePeriod);
    }

    Material._materialCache = {
      _materials: {},
      addMaterial: function (type, materialTemplate) {
        this._materials[type] = materialTemplate;
      },
      getMaterial: function (type) {
        return this._materials[type];
      },
    };

    /**
     * Gets or sets the default texture uniform value.
     * @type {String}
     */
    Material.DefaultImageId = "czm_defaultImage";

    /**
     * Gets or sets the default cube map texture uniform value.
     * @type {String}
     */
    Material.DefaultCubeMapId = "czm_defaultCubeMap";


    Material.init = function() {
      matrixMap = {
        mat2: Cesium.Matrix2,
        mat3: Cesium.Matrix3,
        mat4: Cesium.Matrix4,
      };

      /**
       * Gets the name of the color material.
       * @type {String}
       * @readonly
       */
      Material.ColorType = "Cesium.Color";
      Material._materialCache.addMaterial(Material.ColorType, {
        fabric: {
          type: Material.ColorType,
          uniforms: {
            color: new Cesium.Color(1.0, 0.0, 0.0, 0.5),
          },
          components: {
            diffuse: "color.rgb",
            alpha: "color.a",
          },
        },
        translucent: function (material) {
          return material.uniforms.color.alpha < 1.0;
        },
      });

      /**
       * Gets the name of the image material.
       * @type {String}
       * @readonly
       */
      Material.ImageType = "Image";
      Material._materialCache.addMaterial(Material.ImageType, {
        fabric: {
          type: Material.ImageType,
          uniforms: {
            image: Material.DefaultImageId,
            repeat: new Cesium.Cartesian2(1.0, 1.0),
            color: new Cesium.Color(1.0, 1.0, 1.0, 1.0),
          },
          components: {
            diffuse:
              "texture2D(image, fract(repeat * materialInput.st)).rgb * color.rgb",
            alpha: "texture2D(image, fract(repeat * materialInput.st)).a * color.a",
          },
        },
        translucent: function (material) {
          return material.uniforms.color.alpha < 1.0;
        },
      });

      /**
       * Gets the name of the diffuce map material.
       * @type {String}
       * @readonly
       */
      Material.DiffuseMapType = "DiffuseMap";
      Material._materialCache.addMaterial(Material.DiffuseMapType, {
        fabric: {
          type: Material.DiffuseMapType,
          uniforms: {
            image: Material.DefaultImageId,
            channels: "rgb",
            repeat: new Cesium.Cartesian2(1.0, 1.0),
          },
          components: {
            diffuse: "texture2D(image, fract(repeat * materialInput.st)).channels",
          },
        },
        translucent: false,
      });

      /**
       * Gets the name of the alpha map material.
       * @type {String}
       * @readonly
       */
      Material.AlphaMapType = "AlphaMap";
      Material._materialCache.addMaterial(Material.AlphaMapType, {
        fabric: {
          type: Material.AlphaMapType,
          uniforms: {
            image: Material.DefaultImageId,
            channel: "a",
            repeat: new Cesium.Cartesian2(1.0, 1.0),
          },
          components: {
            alpha: "texture2D(image, fract(repeat * materialInput.st)).channel",
          },
        },
        translucent: true,
      });

      /**
       * Gets the name of the specular map material.
       * @type {String}
       * @readonly
       */
      Material.SpecularMapType = "SpecularMap";
      Material._materialCache.addMaterial(Material.SpecularMapType, {
        fabric: {
          type: Material.SpecularMapType,
          uniforms: {
            image: Material.DefaultImageId,
            channel: "r",
            repeat: new Cesium.Cartesian2(1.0, 1.0),
          },
          components: {
            specular: "texture2D(image, fract(repeat * materialInput.st)).channel",
          },
        },
        translucent: false,
      });

      /**
       * Gets the name of the emmision map material.
       * @type {String}
       * @readonly
       */
      Material.EmissionMapType = "EmissionMap";
      Material._materialCache.addMaterial(Material.EmissionMapType, {
        fabric: {
          type: Material.EmissionMapType,
          uniforms: {
            image: Material.DefaultImageId,
            channels: "rgb",
            repeat: new Cesium.Cartesian2(1.0, 1.0),
          },
          components: {
            emission: "texture2D(image, fract(repeat * materialInput.st)).channels",
          },
        },
        translucent: false,
      });

      /**
       * Gets the name of the bump map material.
       * @type {String}
       * @readonly
       */
      Material.BumpMapType = "BumpMap";
      Material._materialCache.addMaterial(Material.BumpMapType, {
        fabric: {
          type: Material.BumpMapType,
          uniforms: {
            image: Material.DefaultImageId,
            channel: "r",
            strength: 0.8,
            repeat: new Cesium.Cartesian2(1.0, 1.0),
          },
          source: Cesium._shadersBumpMapMaterial,
        },
        translucent: false,
      });

      /**
       * Gets the name of the normal map material.
       * @type {String}
       * @readonly
       */
      Material.NormalMapType = "NormalMap";
      Material._materialCache.addMaterial(Material.NormalMapType, {
        fabric: {
          type: Material.NormalMapType,
          uniforms: {
            image: Material.DefaultImageId,
            channels: "rgb",
            strength: 0.8,
            repeat: new Cesium.Cartesian2(1.0, 1.0),
          },
          source: Cesium._shadersNormalMapMaterial,
        },
        translucent: false,
      });

      /**
       * Gets the name of the grid material.
       * @type {String}
       * @readonly
       */
      Material.GridType = "Grid";
      Material._materialCache.addMaterial(Material.GridType, {
        fabric: {
          type: Material.GridType,
          uniforms: {
            color: new Cesium.Color(0.0, 1.0, 0.0, 1.0),
            cellAlpha: 0.1,
            lineCount: new Cesium.Cartesian2(8.0, 8.0),
            lineThickness: new Cesium.Cartesian2(1.0, 1.0),
            lineOffset: new Cesium.Cartesian2(0.0, 0.0),
          },
          source: Cesium._shadersGridMaterial,
        },
        translucent: function (material) {
          var uniforms = material.uniforms;
          return uniforms.color.alpha < 1.0 || uniforms.cellAlpha < 1.0;
        },
      });

      /**
       * Gets the name of the stripe material.
       * @type {String}
       * @readonly
       */
      Material.StripeType = "Stripe";
      Material._materialCache.addMaterial(Material.StripeType, {
        fabric: {
          type: Material.StripeType,
          uniforms: {
            horizontal: true,
            evenColor: new Cesium.Color(1.0, 1.0, 1.0, 0.5),
            oddColor: new Cesium.Color(0.0, 0.0, 1.0, 0.5),
            offset: 0.0,
            repeat: 5.0,
          },
          source: Cesium._shadersStripeMaterial,
        },
        translucent: function (material) {
          var uniforms = material.uniforms;
          return uniforms.evenColor.alpha < 1.0 || uniforms.oddColor.alpha < 1.0;
        },
      });

      /**
       * Gets the name of the checkerboard material.
       * @type {String}
       * @readonly
       */
      Material.CheckerboardType = "Checkerboard";
      Material._materialCache.addMaterial(Material.CheckerboardType, {
        fabric: {
          type: Material.CheckerboardType,
          uniforms: {
            lightColor: new Cesium.Color(1.0, 1.0, 1.0, 0.5),
            darkColor: new Cesium.Color(0.0, 0.0, 0.0, 0.5),
            repeat: new Cesium.Cartesian2(5.0, 5.0),
          },
          source: Cesium._shadersCheckerboardMaterial,
        },
        translucent: function (material) {
          var uniforms = material.uniforms;
          return uniforms.lightColor.alpha < 1.0 || uniforms.darkColor.alpha < 1.0;
        },
      });

      /**
       * Gets the name of the dot material.
       * @type {String}
       * @readonly
       */
      Material.DotType = "Dot";
      Material._materialCache.addMaterial(Material.DotType, {
        fabric: {
          type: Material.DotType,
          uniforms: {
            lightColor: new Cesium.Color(1.0, 1.0, 0.0, 0.75),
            darkColor: new Cesium.Color(0.0, 1.0, 1.0, 0.75),
            repeat: new Cesium.Cartesian2(5.0, 5.0),
          },
          source: Cesium._shadersDotMaterial,
        },
        translucent: function (material) {
          var uniforms = material.uniforms;
          return uniforms.lightColor.alpha < 1.0 || uniforms.darkColor.alpha < 1.0;
        },
      });

      /**
       * Gets the name of the water material.
       * @type {String}
       * @readonly
       */
      Material.WaterType = "Water";
      Material._materialCache.addMaterial(Material.WaterType, {
        fabric: {
          type: Material.WaterType,
          uniforms: {
            baseWaterColor: new Cesium.Color(0.2, 0.3, 0.6, 1.0),
            blendColor: new Cesium.Color(0.0, 1.0, 0.699, 1.0),
            specularMap: Material.DefaultImageId,
            normalMap: Material.DefaultImageId,
            frequency: 10.0,
            animationSpeed: 0.01,
            amplitude: 1.0,
            specularIntensity: 0.5,
            fadeFactor: 1.0,
          },
          source: Cesium._shadersWaterMaterial,
        },
        translucent: function (material) {
          var uniforms = material.uniforms;
          return (
            uniforms.baseWaterColor.alpha < 1.0 || uniforms.blendColor.alpha < 1.0
          );
        },
      });

      /**
       * Gets the name of the rim lighting material.
       * @type {String}
       * @readonly
       */
      Material.RimLightingType = "RimLighting";
      Material._materialCache.addMaterial(Material.RimLightingType, {
        fabric: {
          type: Material.RimLightingType,
          uniforms: {
            color: new Cesium.Color(1.0, 0.0, 0.0, 0.7),
            rimColor: new Cesium.Color(1.0, 1.0, 1.0, 0.4),
            width: 0.3,
          },
          source: Cesium._shadersRimLightingMaterial,
        },
        translucent: function (material) {
          var uniforms = material.uniforms;
          return uniforms.color.alpha < 1.0 || uniforms.rimColor.alpha < 1.0;
        },
      });

      /**
       * Gets the name of the fade material.
       * @type {String}
       * @readonly
       */
      Material.FadeType = "Fade";
      Material._materialCache.addMaterial(Material.FadeType, {
        fabric: {
          type: Material.FadeType,
          uniforms: {
            fadeInColor: new Cesium.Color(1.0, 0.0, 0.0, 1.0),
            fadeOutColor: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
            maximumDistance: 0.5,
            repeat: true,
            fadeDirection: {
              x: true,
              y: true,
            },
            time: new Cesium.Cartesian2(0.5, 0.5),
          },
          source: Cesium._shadersFadeMaterial,
        },
        translucent: function (material) {
          var uniforms = material.uniforms;
          return (
            uniforms.fadeInColor.alpha < 1.0 || uniforms.fadeOutColor.alpha < 1.0
          );
        },
      });

      /**
       * Gets the name of the polyline arrow material.
       * @type {String}
       * @readonly
       */
      Material.PolylineArrowType = "PolylineArrow";
      Material._materialCache.addMaterial(Material.PolylineArrowType, {
        fabric: {
          type: Material.PolylineArrowType,
          uniforms: {
            color: new Cesium.Color(1.0, 1.0, 1.0, 1.0),
          },
          source: Cesium._shadersPolylineArrowMaterial,
        },
        translucent: true,
      });

      /**
       * Gets the name of the polyline glow material.
       * @type {String}
       * @readonly
       */
      Material.PolylineDashType = "PolylineDash";
      Material._materialCache.addMaterial(Material.PolylineDashType, {
        fabric: {
          type: Material.PolylineDashType,
          uniforms: {
            color: new Cesium.Color(1.0, 0.0, 1.0, 1.0),
            gapColor: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
            dashLength: 16.0,
            dashPattern: 255.0,
          },
          source: Cesium._shadersPolylineDashMaterial,
        },
        translucent: true,
      });

      /**
       * Gets the name of the polyline glow material.
       * @type {String}
       * @readonly
       */
      Material.PolylineGlowType = "PolylineGlow";
      Material._materialCache.addMaterial(Material.PolylineGlowType, {
        fabric: {
          type: Material.PolylineGlowType,
          uniforms: {
            color: new Cesium.Color(0.0, 0.5, 1.0, 1.0),
            glowPower: 0.25,
            taperPower: 1.0,
          },
          source: Cesium._shadersPolylineGlowMaterial,
        },
        translucent: true,
      });

      /**
       * Gets the name of the polyline outline material.
       * @type {String}
       * @readonly
       */
      Material.PolylineOutlineType = "PolylineOutline";
      Material._materialCache.addMaterial(Material.PolylineOutlineType, {
        fabric: {
          type: Material.PolylineOutlineType,
          uniforms: {
            color: new Cesium.Color(1.0, 1.0, 1.0, 1.0),
            outlineColor: new Cesium.Color(1.0, 0.0, 0.0, 1.0),
            outlineWidth: 1.0,
          },
          source: Cesium._shadersPolylineOutlineMaterial,
        },
        translucent: function (material) {
          var uniforms = material.uniforms;
          return uniforms.color.alpha < 1.0 || uniforms.outlineColor.alpha < 1.0;
        },
      });

      /**
       * Gets the name of the elevation contour material.
       * @type {String}
       * @readonly
       */
      Material.ElevationContourType = "ElevationContour";
      Material._materialCache.addMaterial(Material.ElevationContourType, {
        fabric: {
          type: Material.ElevationContourType,
          uniforms: {
            spacing: 100.0,
            color: new Cesium.Color(1.0, 0.0, 0.0, 1.0),
            width: 1.0,
          },
          source: Cesium._shadersElevationContourMaterial,
        },
        translucent: false,
      });

      /**
       * Gets the name of the elevation contour material.
       * @type {String}
       * @readonly
       */
      Material.ElevationRampType = "ElevationRamp";
      Material._materialCache.addMaterial(Material.ElevationRampType, {
        fabric: {
          type: Material.ElevationRampType,
          uniforms: {
            image: Material.DefaultImageId,
            minimumHeight: 0.0,
            maximumHeight: 10000.0,
          },
          source: Cesium._shadersElevationRampMaterial,
        },
        translucent: false,
      });

      /**
       * Gets the name of the slope ramp material.
       * @type {String}
       * @readonly
       */
      Material.SlopeRampMaterialType = "SlopeRamp";
      Material._materialCache.addMaterial(Material.SlopeRampMaterialType, {
        fabric: {
          type: Material.SlopeRampMaterialType,
          uniforms: {
            image: Material.DefaultImageId,
          },
          source: Cesium._shadersSlopeRampMaterial,
        },
        translucent: false,
      });

      /**
       * Gets the name of the aspect ramp material.
       * @type {String}
       * @readonly
       */
      Material.AspectRampMaterialType = "AspectRamp";
      Material._materialCache.addMaterial(Material.AspectRampMaterialType, {
        fabric: {
          type: Material.AspectRampMaterialType,
          uniforms: {
            image: Material.DefaultImageId,
          },
          source: Cesium._shadersAspectRampMaterial,
        },
        translucent: false,
      });

      /**
       * Gets the name of the elevation band material.
       * @type {String}
       * @readonly
       */
      Material.ElevationBandType = "ElevationBand";
      Material._materialCache.addMaterial(Material.ElevationBandType, {
        fabric: {
          type: Material.ElevationBandType,
          uniforms: {
            heights: Material.DefaultImageId,
            colors: Material.DefaultImageId,
          },
          source: Cesium._shadersElevationBandMaterial,
        },
        translucent: true,
      });
    };

    function We(container, options) {
        //for history
        Cesium.Volume = WeatherVolumeInner;
        Cesium.Volume.Mode = {
            Cube: 0,
            Slice: 1,
            Box: 2,
            Cone: 3
          };
          
        Cesium.Volume.Quality = {
            Low: 0,
            Medium: 1,
            High: 2
          };
          
        //inject
        Cesium.Texture = Texture;
        Cesium.Sampler = Sampler;
        Cesium.Sampler.init();
        Cesium.Material = Material;
        Cesium.Material.init();
        
        Config.init();
        Directory.CesiumDir = Cesium.buildModuleUrl('');
        Cesium.Camera.DEFAULT_VIEW_RECTANGLE = Cesium.Rectangle.fromDegrees(111, 10.0, 114, 60.0);

        if(Cesium.defaultValue(options.CN_Zone,true)){
            We.setZh_CN();
        }

        if(!Cesium.defined(options.imageryProvider) && !Cesium.defined(options.selectedImageryProviderViewModel)){
            options.imageryProvider = CommonLayers.NaturalEarthII;
        }

        this._viewer = new Cesium.Viewer(container, options);
        this._viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
        this._viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
        this._viewer.cesiumWidget._creditContainer.style.display = "none";

        var emptyScene = Cesium.defaultValue(options.emptyScene,false);
        if(emptyScene){
            this._viewer.scene.postProcessStages.fxaa.enabled = true;
            this._viewer.scene.globe.show = false;
            this._viewer.scene.sun.show = false;
            this._viewer.scene.moon.show = false;
            this._viewer.scene.backgroundColor = new Cesium.Color(0.92, 0.93, 0.94, 1.0);
        }

        this._earthPinCollection = new EarthPinCollection(this);
        this._globalVolumeState = new WeatherVolumeStateMVVM(this);
        this._handlerManager = this._viewer.scene.primitives.add(new HandlerManager(this));
        this._weatherVolumeManager = this._viewer.scene.primitives.add(new WeatherVolumeManager(this));
        this._simpleDrawPrimitive = undefined;
        this._weatherSystem = undefined;
        this._layerManager = this._viewer.scene.primitives.add(new LayerManager(this));
        this._layerManager.shouldAnimate = Cesium.defaultValue(options.shouldAnimate,false);
        this._timeSystem = this._viewer.scene.primitives.add(new TimeSystem(this));
        this._frameListnerManager = undefined;

        var directionLight = Cesium.defaultValue(options.directionLight,false);
        if(directionLight){
            this._viewer.scene.light = new Cesium.DirectionalLight({
                direction: this._viewer.scene.camera.directionWC, //It should updated every frame
              });
            this._viewer.scene.globe.dynamicAtmosphereLighting = false;

            var directLightListener = new FrameListener;
            directLightListener.update = function (scene,time){
                scene.light.direction = Cesium.Cartesian3.clone(
                    scene.camera.directionWC,
                    scene.light.direction
                );
            };
            this.frameListenerManager.add(directLightListener);
        }

        if(Cesium.defaultValue(options.useRightTile,true)){
            this.viewer.scene.screenSpaceCameraController.zoomEventTypes = [Cesium.CameraEventType.WHEEL, Cesium.CameraEventType.PINCH];
            this.viewer.scene.screenSpaceCameraController.tiltEventTypes = [Cesium.CameraEventType.MIDDLE_DRAG,Cesium.CameraEventType.PINCH, Cesium.CameraEventType.RIGHT_DRAG];
        }
    }
    We.prototype.destroy = function () {
        this._echartsWrapper = this._echartsWrapper && this._echartsWrapper.destroy();
        this._globalVolumeState.destroy();
        this._viewer.destroy();
    };

    We.createSimpleDrawView = function (container,options) {
        if(!Cesium.defined(options)){
            options = {};
        }
        var we = new We(container, {
            baseLayerPicker: false,
            requestRenderMode: Cesium.defaultValue(options.requestRenderMode,true),
            scene3DOnly: true,
            geocoder: false,
            animation: false,
            timeline: false,
            navigationHelpButton: false,
            homeButton:false,
            fullscreenButton:false,
            shouldAnimate: false,
            emptyScene:true,
            contextOptions: {
                webgl: {
                    alpha: true,
                    antialias:true,
                    premultipliedAlpha:true,
                    preserveDrawingBuffer:true,
                    failIfMajorPerformanceCaveat:true
                },
                requestWebgl2: true
            }
        });
        we.backgroundColor = new Cesium.Color(0.0, 0.0, 0.0, 0.0);
        we.showSkyBox = false;
        we.enableControl = false;
        return we;
    };

    We.prototype.resetTerrain = function () {
        if(!(this.viewer.terrainProvider instanceof Cesium.EllipsoidTerrainProvider)){
            this.viewer.terrainProvider = new Cesium.EllipsoidTerrainProvider(this.viewer.scene.globe.ellipsoid);
        }
    };

    We.prototype.createEcharts = function (options) {
        if(!Cesium.defined(this._echartsWrapper))
            this._echartsWrapper = new WeatherLengthWayInEcharts(this,options);
        return this._echartsWrapper;
    };

    We.prototype.switchToSimpleDrawMode = function (value) {
        if(!value){
            if(Cesium.defined(this._simpleDrawPrimitive)){
                this.viewer.scene.primitives.removeAndDestroy(this._simpleDrawPrimitive);
                this._simpleDrawPrimitive = undefined;
            }
        }
        else {
            if(!Cesium.defined(this._simpleDrawPrimitive)){
                this.viewer.scene.camera.frustum.near = 100.0;
                this._simpleDrawPrimitive = this.viewer.scene.primitives.add(new SimpleDrawPrimitive({
                    camera : this.viewer.scene.camera,
                    color : Cesium.Color.YELLOW
                }));
            }
        }

        return this._simpleDrawPrimitive;
    };

    We.prototype.setHomeView = function (lontitude,latitude,range_factor,rect_factor) {
        var rfactor = Cesium.defaultValue(rect_factor,0.1);
        var factor = Cesium.defaultValue(range_factor,0.5);
        Cesium.Camera.DEFAULT_VIEW_RECTANGLE = 
        Cesium.Rectangle.fromDegrees(lontitude - rfactor, latitude - rfactor, lontitude + rfactor, latitude + rfactor);
            Cesium.Camera.DEFAULT_VIEW_FACTOR = Cesium.Math.clamp(factor,0.0,1.0);

        if(Cesium.defined(this.viewer.cesiumNavigation)){
            var relativeAmount = 1.5 + Cesium.Math.clamp(factor,0.0,1.0);
            this.viewer.cesiumNavigation.navigationViewModel.controls[0].relativeAmount = 1 / relativeAmount;
            this.viewer.cesiumNavigation.navigationViewModel.controls[2].relativeAmount = relativeAmount;
        }
        var that = this;
        this.viewer.cesiumWidget.canvas.setAttribute('tabindex', '0');
        this.viewer.cesiumWidget.canvas.addEventListener('keydown',function(e){
            if(e.keyCode === 32){
                that.viewer.camera.flyHome(0);
            }
        });
        this.viewer.cesiumWidget.canvas.addEventListener('click',function(e){
            that.viewer.cesiumWidget.canvas.focus();
        });
    };

    We.prototype.travelWorld = function () {
        var that = this;
        var vp = ViewPoint.clone(this.viewPoint);
        vp.height = 10000000.0;
        vp.latitudeD = 30.0;
        var duration = 30.0;
        var dest = vp.cartesion3;
        function quadraticIn(time) {
            return time;
        }
        function complete1(){
            vp.longitudeD += 179.0;
            var flyOverLongitude = vp.longitude;
            vp.longitudeD += 180.0;
            var dest = vp.cartesion3;
            that.viewer.camera.flyTo({
                destination : dest,
                duration: duration,
                flyOverLongitude: flyOverLongitude,
                complete: complete1,
                easingFunction: quadraticIn,
            });
        }
        this.viewer.camera.flyTo({
            destination : dest,
            duration: 0.5,
            complete: complete1
        });

        this.handlerManager.enableFlyHandler = true;
    };

    We.setZh_CN = function(){
        var TimeFormatter = function(time, viewModel) {
            return DateTimeFormatter(time, viewModel, true);
          }; 
        var DateTimeFormatter = function(datetime, viewModel, ignoredate) {
        var julianDT = new Cesium.JulianDate();
        Cesium.JulianDate.addHours(datetime, 8, julianDT);
        var gregorianDT = Cesium.JulianDate.toGregorianDate(julianDT);
        var objDT;
        if (ignoredate){
            objDT = '';
        }else {
            objDT = new Date(gregorianDT.year, gregorianDT.month - 1, gregorianDT.day);
            objDT = gregorianDT.year + '年' + objDT.toLocaleString('zh-cn', { month: 'short' }) + gregorianDT.day + '日';
            if (viewModel || gregorianDT.hour + gregorianDT.minute === 0){
            return objDT 
            }
        }
        return objDT + Cesium.sprintf('%02d:%02d', gregorianDT.hour, gregorianDT.minute);
        };
        Cesium.Timeline.prototype.makeLabel = DateTimeFormatter;
        Cesium.AnimationViewModel.defaultDateFormatter = DateTimeFormatter;
        Cesium.AnimationViewModel.defaultTimeFormatter = TimeFormatter;
    };

    Object.defineProperties(We.prototype, {
        viewer: {
            get: function () {
                return this._viewer;
            }
        },
        scene: {
            get: function () {
                return this._viewer.scene;
            }
        },
        globalVolumeState: {
            get: function(){
                return this._globalVolumeState;
            },
        },
        layerManager: {
            get: function(){
                return this._layerManager;
            },
        },
        echartsWrapper: {
            get: function(){
                return this._echartsWrapper;
            },
        },
        earthPinCollection: {
            get: function(){
                return this._earthPinCollection;
            },
        },
        frameListenerManager: {
            get: function(){
                if(!Cesium.defined(this._frameListnerManager)){
                    var frameListenerManager = this._frameListnerManager = new FrameListenerManager();
                    this._viewer.scene.preRender.addEventListener(function (scene, time) {
                        frameListenerManager.update(scene,time);
                    });
                }
                return this._frameListnerManager;
            },
        },
        weatherVolumeManager: {
            get: function(){
                return this._weatherVolumeManager;
            },
        },
        debugShowFramesPerSecond: {
            get: function () {
                return this.viewer.scene.debugShowFramesPerSecond;
            },
            set: function (value) {
                this.viewer.scene.debugShowFramesPerSecond = value;
            }
        },
        showTimeLine: {
            get: function () {
                if(Cesium.defined(this.viewer._timeline))
                    return this.viewer._timeline.container.style.display !== 'none';
                return false;
            },
            set: function (value) {
                if(Cesium.defined(this.viewer._timeline))
                    this.viewer._timeline.container.style.display = value ? 'block' : 'none';
            }
        },
        backgroundColor: {
            get: function () {
                return this._viewer.scene.backgroundColor;
            },
            set: function (value) {
                this._viewer.scene.backgroundColor = value;
            }
        },
        showSkyBox: {
            get: function () {
                return this._viewer.scene.skyBox.show;
            },
            set: function (value) {
                this._viewer.scene.skyBox.show = value;
            }
        },
        enableControl: {
            get: function () {
                return this.viewer.scene.screenSpaceCameraController.enableRotate;
            },
            set: function (value) {
                this.viewer.scene.screenSpaceCameraController.enableRotate = value;
                this.viewer.scene.screenSpaceCameraController.enableTranslate = value;
                this.viewer.scene.screenSpaceCameraController.enableZoom = value;
                this.viewer.scene.screenSpaceCameraController.enableTilt = value;
            }
        },
        display: {
            get: function () {
                return this.viewer.cesiumWidget.container.style.display !== 'none';
            },
            set: function (value) {
                this.viewer.cesiumWidget.useDefaultRenderLoop = value;
                this.viewer.cesiumWidget.container.style.display = value ? "block" : "none";
            }
        },
        handlerManager: {
            get: function () {
                return this._handlerManager;
            }
        },
        timeSystem: {
            get: function () {
                return this._timeSystem;
            }
        },
        showNavigationWidget: {
            get: function () {
                return Cesium.defined(this.viewer.cesiumNavigation) && this.viewer.cesiumNavigation.container.style.display !== 'none';
            },
            set: function (value) {
                if(!Cesium.defined(this.viewer.cesiumNavigation)){
                    var options = {};
                    options.enableCompass = true;
                    options.enableZoomControls = true;
                    options.enableDistanceLegend = true;
                    this.viewer.extend(viewerCesiumNavigationMixin,options);
                }
                this.viewer.cesiumNavigation.container.style.display = value ? "block" : "none";
            }
        },
        showDistanceLengthWidget: {
            get: function () {
                return this.viewer.cesiumNavigation.distanceLegendDiv.style.display !== 'none';
            },
            set: function (value) {
                this.viewer.cesiumNavigation.distanceLegendDiv.style.display = value ? "block" : "none";
            }
        },
        showZoomWidget: {
            get: function () {
                return this.viewer.cesiumNavigation.distanceLegendDiv.style.display !== 'none';
            },
            set: function (value) {
                this.viewer.cesiumNavigation.distanceLegendDiv.style.display = value ? "block" : "none";
            }
        },
        CesiumDirectory: {
            get: function () {
                return Directory.CesiumDir;
            },
            set: function (value) {
                Directory.CesiumDir = value;
            }
        },
        viewPoint: {
            get: function () {
                return ViewPoint.fromCamera(this.viewer.camera);
            }
        },
        weatherSystem: {
            get: function () {
                if(!Cesium.defined(this._weatherSystem)){
                    this._weatherSystem = new WeatherSystem(this);
                    this.viewer.scene.primitives.add(this._weatherSystem);
                }
                return this._weatherSystem;
            }
        },
        hasTerrain: {
            get: function () {
                return !(this.viewer.terrainProvider instanceof Cesium.EllipsoidTerrainProvider);
            }
        },
    });

    function globals(defs) {
      defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
      defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
      defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

      defs.WGS84 = defs['EPSG:4326'];
      defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
      defs.GOOGLE = defs['EPSG:3857'];
      defs['EPSG:900913'] = defs['EPSG:3857'];
      defs['EPSG:102113'] = defs['EPSG:3857'];
    }

    var PJD_3PARAM = 1;
    var PJD_7PARAM = 2;
    var PJD_GRIDSHIFT = 3;
    var PJD_WGS84 = 4; // WGS84 or equivalent
    var PJD_NODATUM = 5; // WGS84 or equivalent
    var SRS_WGS84_SEMIMAJOR = 6378137.0;  // only used in grid shift transforms
    var SRS_WGS84_SEMIMINOR = 6356752.314;  // only used in grid shift transforms
    var SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms
    var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
    var HALF_PI = Math.PI/2;
    // ellipoid pj_set_ell.c
    var SIXTH = 0.1666666666666666667;
    /* 1/6 */
    var RA4 = 0.04722222222222222222;
    /* 17/360 */
    var RA6 = 0.02215608465608465608;
    var EPSLN = 1.0e-10;
    // you'd think you could use Number.EPSILON above but that makes
    // Mollweide get into an infinate loop.

    var D2R = 0.01745329251994329577;
    var R2D = 57.29577951308232088;
    var FORTPI = Math.PI/4;
    var TWO_PI = Math.PI * 2;
    // SPI is slightly greater than Math.PI, so values that exceed the -180..180
    // degree range by a tiny amount don't get wrapped. This prevents points that
    // have drifted from their original location along the 180th meridian (due to
    // floating point error) from changing their sign.
    var SPI = 3.14159265359;

    var exports$1 = {};

    exports$1.greenwich = 0.0; //"0dE",
    exports$1.lisbon = -9.131906111111; //"9d07'54.862\"W",
    exports$1.paris = 2.337229166667; //"2d20'14.025\"E",
    exports$1.bogota = -74.080916666667; //"74d04'51.3\"W",
    exports$1.madrid = -3.687938888889; //"3d41'16.58\"W",
    exports$1.rome = 12.452333333333; //"12d27'8.4\"E",
    exports$1.bern = 7.439583333333; //"7d26'22.5\"E",
    exports$1.jakarta = 106.807719444444; //"106d48'27.79\"E",
    exports$1.ferro = -17.666666666667; //"17d40'W",
    exports$1.brussels = 4.367975; //"4d22'4.71\"E",
    exports$1.stockholm = 18.058277777778; //"18d3'29.8\"E",
    exports$1.athens = 23.7163375; //"23d42'58.815\"E",
    exports$1.oslo = 10.722916666667; //"10d43'22.5\"E"

    var units = {
      ft: {to_meter: 0.3048},
      'us-ft': {to_meter: 1200 / 3937}
    };

    var ignoredChar = /[\s_\-\/\(\)]/g;
    function match(obj, key) {
      if (obj[key]) {
        return obj[key];
      }
      var keys = Object.keys(obj);
      var lkey = key.toLowerCase().replace(ignoredChar, '');
      var i = -1;
      var testkey, processedKey;
      while (++i < keys.length) {
        testkey = keys[i];
        processedKey = testkey.toLowerCase().replace(ignoredChar, '');
        if (processedKey === lkey) {
          return obj[testkey];
        }
      }
    }

    function projStr(defData) {
      var self = {};
      var paramObj = defData.split('+').map(function(v) {
        return v.trim();
      }).filter(function(a) {
        return a;
      }).reduce(function(p, a) {
        var split = a.split('=');
        split.push(true);
        p[split[0].toLowerCase()] = split[1];
        return p;
      }, {});
      var paramName, paramVal, paramOutname;
      var params = {
        proj: 'projName',
        datum: 'datumCode',
        rf: function(v) {
          self.rf = parseFloat(v);
        },
        lat_0: function(v) {
          self.lat0 = v * D2R;
        },
        lat_1: function(v) {
          self.lat1 = v * D2R;
        },
        lat_2: function(v) {
          self.lat2 = v * D2R;
        },
        lat_ts: function(v) {
          self.lat_ts = v * D2R;
        },
        lon_0: function(v) {
          self.long0 = v * D2R;
        },
        lon_1: function(v) {
          self.long1 = v * D2R;
        },
        lon_2: function(v) {
          self.long2 = v * D2R;
        },
        alpha: function(v) {
          self.alpha = parseFloat(v) * D2R;
        },
        gamma: function(v) {
          self.rectified_grid_angle = parseFloat(v);
        },
        lonc: function(v) {
          self.longc = v * D2R;
        },
        x_0: function(v) {
          self.x0 = parseFloat(v);
        },
        y_0: function(v) {
          self.y0 = parseFloat(v);
        },
        k_0: function(v) {
          self.k0 = parseFloat(v);
        },
        k: function(v) {
          self.k0 = parseFloat(v);
        },
        a: function(v) {
          self.a = parseFloat(v);
        },
        b: function(v) {
          self.b = parseFloat(v);
        },
        r_a: function() {
          self.R_A = true;
        },
        zone: function(v) {
          self.zone = parseInt(v, 10);
        },
        south: function() {
          self.utmSouth = true;
        },
        towgs84: function(v) {
          self.datum_params = v.split(",").map(function(a) {
            return parseFloat(a);
          });
        },
        to_meter: function(v) {
          self.to_meter = parseFloat(v);
        },
        units: function(v) {
          self.units = v;
          var unit = match(units, v);
          if (unit) {
            self.to_meter = unit.to_meter;
          }
        },
        from_greenwich: function(v) {
          self.from_greenwich = v * D2R;
        },
        pm: function(v) {
          var pm = match(exports$1, v);
          self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
        },
        nadgrids: function(v) {
          if (v === '@null') {
            self.datumCode = 'none';
          }
          else {
            self.nadgrids = v;
          }
        },
        axis: function(v) {
          var legalAxis = "ewnsud";
          if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
            self.axis = v;
          }
        },
        approx: function() {
          self.approx = true;
        }
      };
      for (paramName in paramObj) {
        paramVal = paramObj[paramName];
        if (paramName in params) {
          paramOutname = params[paramName];
          if (typeof paramOutname === 'function') {
            paramOutname(paramVal);
          }
          else {
            self[paramOutname] = paramVal;
          }
        }
        else {
          self[paramName] = paramVal;
        }
      }
      if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
        self.datumCode = self.datumCode.toLowerCase();
      }
      return self;
    }

    var NEUTRAL = 1;
    var KEYWORD = 2;
    var NUMBER = 3;
    var QUOTED = 4;
    var AFTERQUOTE = 5;
    var ENDED = -1;
    var whitespace = /\s/;
    var latin = /[A-Za-z]/;
    var keyword = /[A-Za-z84]/;
    var endThings = /[,\]]/;
    var digets = /[\d\.E\-\+]/;
    // const ignoredChar = /[\s_\-\/\(\)]/g;
    function Parser(text) {
      if (typeof text !== 'string') {
        throw new Error('not a string');
      }
      this.text = text.trim();
      this.level = 0;
      this.place = 0;
      this.root = null;
      this.stack = [];
      this.currentObject = null;
      this.state = NEUTRAL;
    }
    Parser.prototype.readCharicter = function() {
      var char = this.text[this.place++];
      if (this.state !== QUOTED) {
        while (whitespace.test(char)) {
          if (this.place >= this.text.length) {
            return;
          }
          char = this.text[this.place++];
        }
      }
      switch (this.state) {
        case NEUTRAL:
          return this.neutral(char);
        case KEYWORD:
          return this.keyword(char)
        case QUOTED:
          return this.quoted(char);
        case AFTERQUOTE:
          return this.afterquote(char);
        case NUMBER:
          return this.number(char);
        case ENDED:
          return;
      }
    };
    Parser.prototype.afterquote = function(char) {
      if (char === '"') {
        this.word += '"';
        this.state = QUOTED;
        return;
      }
      if (endThings.test(char)) {
        this.word = this.word.trim();
        this.afterItem(char);
        return;
      }
      throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
    };
    Parser.prototype.afterItem = function(char) {
      if (char === ',') {
        if (this.word !== null) {
          this.currentObject.push(this.word);
        }
        this.word = null;
        this.state = NEUTRAL;
        return;
      }
      if (char === ']') {
        this.level--;
        if (this.word !== null) {
          this.currentObject.push(this.word);
          this.word = null;
        }
        this.state = NEUTRAL;
        this.currentObject = this.stack.pop();
        if (!this.currentObject) {
          this.state = ENDED;
        }

        return;
      }
    };
    Parser.prototype.number = function(char) {
      if (digets.test(char)) {
        this.word += char;
        return;
      }
      if (endThings.test(char)) {
        this.word = parseFloat(this.word);
        this.afterItem(char);
        return;
      }
      throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
    };
    Parser.prototype.quoted = function(char) {
      if (char === '"') {
        this.state = AFTERQUOTE;
        return;
      }
      this.word += char;
      return;
    };
    Parser.prototype.keyword = function(char) {
      if (keyword.test(char)) {
        this.word += char;
        return;
      }
      if (char === '[') {
        var newObjects = [];
        newObjects.push(this.word);
        this.level++;
        if (this.root === null) {
          this.root = newObjects;
        } else {
          this.currentObject.push(newObjects);
        }
        this.stack.push(this.currentObject);
        this.currentObject = newObjects;
        this.state = NEUTRAL;
        return;
      }
      if (endThings.test(char)) {
        this.afterItem(char);
        return;
      }
      throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
    };
    Parser.prototype.neutral = function(char) {
      if (latin.test(char)) {
        this.word = char;
        this.state = KEYWORD;
        return;
      }
      if (char === '"') {
        this.word = '';
        this.state = QUOTED;
        return;
      }
      if (digets.test(char)) {
        this.word = char;
        this.state = NUMBER;
        return;
      }
      if (endThings.test(char)) {
        this.afterItem(char);
        return;
      }
      throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
    };
    Parser.prototype.output = function() {
      while (this.place < this.text.length) {
        this.readCharicter();
      }
      if (this.state === ENDED) {
        return this.root;
      }
      throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
    };

    function parseString(txt) {
      var parser = new Parser(txt);
      return parser.output();
    }

    function mapit(obj, key, value) {
      if (Array.isArray(key)) {
        value.unshift(key);
        key = null;
      }
      var thing = key ? {} : obj;

      var out = value.reduce(function(newObj, item) {
        sExpr(item, newObj);
        return newObj
      }, thing);
      if (key) {
        obj[key] = out;
      }
    }

    function sExpr(v, obj) {
      if (!Array.isArray(v)) {
        obj[v] = true;
        return;
      }
      var key = v.shift();
      if (key === 'PARAMETER') {
        key = v.shift();
      }
      if (v.length === 1) {
        if (Array.isArray(v[0])) {
          obj[key] = {};
          sExpr(v[0], obj[key]);
          return;
        }
        obj[key] = v[0];
        return;
      }
      if (!v.length) {
        obj[key] = true;
        return;
      }
      if (key === 'TOWGS84') {
        obj[key] = v;
        return;
      }
      if (key === 'AXIS') {
        if (!(key in obj)) {
          obj[key] = [];
        }
        obj[key].push(v);
        return;
      }
      if (!Array.isArray(key)) {
        obj[key] = {};
      }

      var i;
      switch (key) {
        case 'UNIT':
        case 'PRIMEM':
        case 'VERT_DATUM':
          obj[key] = {
            name: v[0].toLowerCase(),
            convert: v[1]
          };
          if (v.length === 3) {
            sExpr(v[2], obj[key]);
          }
          return;
        case 'SPHEROID':
        case 'ELLIPSOID':
          obj[key] = {
            name: v[0],
            a: v[1],
            rf: v[2]
          };
          if (v.length === 4) {
            sExpr(v[3], obj[key]);
          }
          return;
        case 'PROJECTEDCRS':
        case 'PROJCRS':
        case 'GEOGCS':
        case 'GEOCCS':
        case 'PROJCS':
        case 'LOCAL_CS':
        case 'GEODCRS':
        case 'GEODETICCRS':
        case 'GEODETICDATUM':
        case 'EDATUM':
        case 'ENGINEERINGDATUM':
        case 'VERT_CS':
        case 'VERTCRS':
        case 'VERTICALCRS':
        case 'COMPD_CS':
        case 'COMPOUNDCRS':
        case 'ENGINEERINGCRS':
        case 'ENGCRS':
        case 'FITTED_CS':
        case 'LOCAL_DATUM':
        case 'DATUM':
          v[0] = ['name', v[0]];
          mapit(obj, key, v);
          return;
        default:
          i = -1;
          while (++i < v.length) {
            if (!Array.isArray(v[i])) {
              return sExpr(v, obj[key]);
            }
          }
          return mapit(obj, key, v);
      }
    }

    var D2R$1 = 0.01745329251994329577;



    function rename(obj, params) {
      var outName = params[0];
      var inName = params[1];
      if (!(outName in obj) && (inName in obj)) {
        obj[outName] = obj[inName];
        if (params.length === 3) {
          obj[outName] = params[2](obj[outName]);
        }
      }
    }

    function d2r(input) {
      return input * D2R$1;
    }

    function cleanWKT(wkt) {
      if (wkt.type === 'GEOGCS') {
        wkt.projName = 'longlat';
      } else if (wkt.type === 'LOCAL_CS') {
        wkt.projName = 'identity';
        wkt.local = true;
      } else {
        if (typeof wkt.PROJECTION === 'object') {
          wkt.projName = Object.keys(wkt.PROJECTION)[0];
        } else {
          wkt.projName = wkt.PROJECTION;
        }
      }
      if (wkt.AXIS) {
        var axisOrder = '';
        for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
          var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
          if (axis[0].indexOf('north') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north')) {
            axisOrder += 'n';
          } else if (axis[0].indexOf('south') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south')) {
            axisOrder += 's';
          } else if (axis[0].indexOf('east') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east')) {
            axisOrder += 'e';
          } else if (axis[0].indexOf('west') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west')) {
            axisOrder += 'w';
          }
        }
        if (axisOrder.length === 2) {
          axisOrder += 'u';
        }
        if (axisOrder.length === 3) {
          wkt.axis = axisOrder;
        }
      }
      if (wkt.UNIT) {
        wkt.units = wkt.UNIT.name.toLowerCase();
        if (wkt.units === 'metre') {
          wkt.units = 'meter';
        }
        if (wkt.UNIT.convert) {
          if (wkt.type === 'GEOGCS') {
            if (wkt.DATUM && wkt.DATUM.SPHEROID) {
              wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
            }
          } else {
            wkt.to_meter = wkt.UNIT.convert;
          }
        }
      }
      var geogcs = wkt.GEOGCS;
      if (wkt.type === 'GEOGCS') {
        geogcs = wkt;
      }
      if (geogcs) {
        //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
        //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
        //}
        if (geogcs.DATUM) {
          wkt.datumCode = geogcs.DATUM.name.toLowerCase();
        } else {
          wkt.datumCode = geogcs.name.toLowerCase();
        }
        if (wkt.datumCode.slice(0, 2) === 'd_') {
          wkt.datumCode = wkt.datumCode.slice(2);
        }
        if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
          wkt.datumCode = 'nzgd49';
        }
        if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
          if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
            wkt.sphere = true;
          }
          wkt.datumCode = 'wgs84';
        }
        if (wkt.datumCode.slice(-6) === '_ferro') {
          wkt.datumCode = wkt.datumCode.slice(0, - 6);
        }
        if (wkt.datumCode.slice(-8) === '_jakarta') {
          wkt.datumCode = wkt.datumCode.slice(0, - 8);
        }
        if (~wkt.datumCode.indexOf('belge')) {
          wkt.datumCode = 'rnb72';
        }
        if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
          wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
          if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
            wkt.ellps = 'intl';
          }

          wkt.a = geogcs.DATUM.SPHEROID.a;
          wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
        }

        if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
          wkt.datum_params = geogcs.DATUM.TOWGS84;
        }
        if (~wkt.datumCode.indexOf('osgb_1936')) {
          wkt.datumCode = 'osgb36';
        }
        if (~wkt.datumCode.indexOf('osni_1952')) {
          wkt.datumCode = 'osni52';
        }
        if (~wkt.datumCode.indexOf('tm65')
          || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
          wkt.datumCode = 'ire65';
        }
        if (wkt.datumCode === 'ch1903+') {
          wkt.datumCode = 'ch1903';
        }
        if (~wkt.datumCode.indexOf('israel')) {
          wkt.datumCode = 'isr93';
        }
      }
      if (wkt.b && !isFinite(wkt.b)) {
        wkt.b = wkt.a;
      }

      function toMeter(input) {
        var ratio = wkt.to_meter || 1;
        return input * ratio;
      }
      var renamer = function(a) {
        return rename(wkt, a);
      };
      var list = [
        ['standard_parallel_1', 'Standard_Parallel_1'],
        ['standard_parallel_1', 'Latitude of 1st standard parallel'],
        ['standard_parallel_2', 'Standard_Parallel_2'],
        ['standard_parallel_2', 'Latitude of 2nd standard parallel'],
        ['false_easting', 'False_Easting'],
        ['false_easting', 'False easting'],
        ['false-easting', 'Easting at false origin'],
        ['false_northing', 'False_Northing'],
        ['false_northing', 'False northing'],
        ['false_northing', 'Northing at false origin'],
        ['central_meridian', 'Central_Meridian'],
        ['central_meridian', 'Longitude of natural origin'],
        ['central_meridian', 'Longitude of false origin'],
        ['latitude_of_origin', 'Latitude_Of_Origin'],
        ['latitude_of_origin', 'Central_Parallel'],
        ['latitude_of_origin', 'Latitude of natural origin'],
        ['latitude_of_origin', 'Latitude of false origin'],
        ['scale_factor', 'Scale_Factor'],
        ['k0', 'scale_factor'],
        ['latitude_of_center', 'Latitude_Of_Center'],
        ['latitude_of_center', 'Latitude_of_center'],
        ['lat0', 'latitude_of_center', d2r],
        ['longitude_of_center', 'Longitude_Of_Center'],
        ['longitude_of_center', 'Longitude_of_center'],
        ['longc', 'longitude_of_center', d2r],
        ['x0', 'false_easting', toMeter],
        ['y0', 'false_northing', toMeter],
        ['long0', 'central_meridian', d2r],
        ['lat0', 'latitude_of_origin', d2r],
        ['lat0', 'standard_parallel_1', d2r],
        ['lat1', 'standard_parallel_1', d2r],
        ['lat2', 'standard_parallel_2', d2r],
        ['azimuth', 'Azimuth'],
        ['alpha', 'azimuth', d2r],
        ['srsCode', 'name']
      ];
      list.forEach(renamer);
      if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
        wkt.long0 = wkt.longc;
      }
      if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
        wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
        wkt.lat_ts = wkt.lat1;
      }
    }
    function wkt(wkt) {
      var lisp = parseString(wkt);
      var type = lisp.shift();
      var name = lisp.shift();
      lisp.unshift(['name', name]);
      lisp.unshift(['type', type]);
      var obj = {};
      sExpr(lisp, obj);
      cleanWKT(obj);
      return obj;
    }

    function defs(name) {
      /*global console*/
      var that = this;
      if (arguments.length === 2) {
        var def = arguments[1];
        if (typeof def === 'string') {
          if (def.charAt(0) === '+') {
            defs[name] = projStr(arguments[1]);
          }
          else {
            defs[name] = wkt(arguments[1]);
          }
        } else {
          defs[name] = def;
        }
      }
      else if (arguments.length === 1) {
        if (Array.isArray(name)) {
          return name.map(function(v) {
            if (Array.isArray(v)) {
              defs.apply(that, v);
            }
            else {
              defs(v);
            }
          });
        }
        else if (typeof name === 'string') {
          if (name in defs) {
            return defs[name];
          }
        }
        else if ('EPSG' in name) {
          defs['EPSG:' + name.EPSG] = name;
        }
        else if ('ESRI' in name) {
          defs['ESRI:' + name.ESRI] = name;
        }
        else if ('IAU2000' in name) {
          defs['IAU2000:' + name.IAU2000] = name;
        }
        else {
          console.log(name);
        }
        return;
      }


    }
    globals(defs);

    function testObj(code){
      return typeof code === 'string';
    }
    function testDef(code){
      return code in defs;
    }
    var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];
    function testWKT(code){
      return codeWords.some(function (word) {
        return code.indexOf(word) > -1;
      });
    }
    var codes = ['3857', '900913', '3785', '102113'];
    function checkMercator(item) {
      var auth = match(item, 'authority');
      if (!auth) {
        return;
      }
      var code = match(auth, 'epsg');
      return code && codes.indexOf(code) > -1;
    }
    function checkProjStr(item) {
      var ext = match(item, 'extension');
      if (!ext) {
        return;
      }
      return match(ext, 'proj4');
    }
    function testProj(code){
      return code[0] === '+';
    }
    function parse$2(code){
      if (testObj(code)) {
        //check to see if this is a WKT string
        if (testDef(code)) {
          return defs[code];
        }
        if (testWKT(code)) {
          var out = wkt(code);
          // test of spetial case, due to this being a very common and often malformed
          if (checkMercator(out)) {
            return defs['EPSG:3857'];
          }
          var maybeProjStr = checkProjStr(out);
          if (maybeProjStr) {
            return projStr(maybeProjStr);
          }
          return out;
        }
        if (testProj(code)) {
          return projStr(code);
        }
      }else {
        return code;
      }
    }

    function extend(destination, source) {
      destination = destination || {};
      var value, property;
      if (!source) {
        return destination;
      }
      for (property in source) {
        value = source[property];
        if (value !== undefined) {
          destination[property] = value;
        }
      }
      return destination;
    }

    function msfnz(eccent, sinphi, cosphi) {
      var con = eccent * sinphi;
      return cosphi / (Math.sqrt(1 - con * con));
    }

    function sign(x) {
      return x<0 ? -1 : 1;
    }

    function adjust_lon(x) {
      return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
    }

    function tsfnz(eccent, phi, sinphi) {
      var con = eccent * sinphi;
      var com = 0.5 * eccent;
      con = Math.pow(((1 - con) / (1 + con)), com);
      return (Math.tan(0.5 * (HALF_PI - phi)) / con);
    }

    function phi2z(eccent, ts) {
      var eccnth = 0.5 * eccent;
      var con, dphi;
      var phi = HALF_PI - 2 * Math.atan(ts);
      for (var i = 0; i <= 15; i++) {
        con = eccent * Math.sin(phi);
        dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
        phi += dphi;
        if (Math.abs(dphi) <= 0.0000000001) {
          return phi;
        }
      }
      //console.log("phi2z has NoConvergence");
      return -9999;
    }

    function init$1() {
      var con = this.b / this.a;
      this.es = 1 - con * con;
      if(!('x0' in this)){
        this.x0 = 0;
      }
      if(!('y0' in this)){
        this.y0 = 0;
      }
      this.e = Math.sqrt(this.es);
      if (this.lat_ts) {
        if (this.sphere) {
          this.k0 = Math.cos(this.lat_ts);
        }
        else {
          this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
        }
      }
      else {
        if (!this.k0) {
          if (this.k) {
            this.k0 = this.k;
          }
          else {
            this.k0 = 1;
          }
        }
      }
    }

    /* Mercator forward equations--mapping lat,long to x,y
      --------------------------------------------------*/

    function forward(p) {
      var lon = p.x;
      var lat = p.y;
      // convert to radians
      if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
        return null;
      }

      var x, y;
      if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
        return null;
      }
      else {
        if (this.sphere) {
          x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
          y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
        }
        else {
          var sinphi = Math.sin(lat);
          var ts = tsfnz(this.e, lat, sinphi);
          x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
          y = this.y0 - this.a * this.k0 * Math.log(ts);
        }
        p.x = x;
        p.y = y;
        return p;
      }
    }

    /* Mercator inverse equations--mapping x,y to lat/long
      --------------------------------------------------*/
    function inverse(p) {

      var x = p.x - this.x0;
      var y = p.y - this.y0;
      var lon, lat;

      if (this.sphere) {
        lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
      }
      else {
        var ts = Math.exp(-y / (this.a * this.k0));
        lat = phi2z(this.e, ts);
        if (lat === -9999) {
          return null;
        }
      }
      lon = adjust_lon(this.long0 + x / (this.a * this.k0));

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
    var merc = {
      init: init$1,
      forward: forward,
      inverse: inverse,
      names: names
    };

    function init$2() {
      //no-op for longlat
    }

    function identity(pt) {
      return pt;
    }
    var names$1 = ["longlat", "identity"];
    var longlat = {
      init: init$2,
      forward: identity,
      inverse: identity,
      names: names$1
    };

    var projs = [merc, longlat];
    var names$2 = {};
    var projStore = [];

    function add(proj, i) {
      var len = projStore.length;
      if (!proj.names) {
        console.log(i);
        return true;
      }
      projStore[len] = proj;
      proj.names.forEach(function(n) {
        names$2[n.toLowerCase()] = len;
      });
      return this;
    }

    function get(name) {
      if (!name) {
        return false;
      }
      var n = name.toLowerCase();
      if (typeof names$2[n] !== 'undefined' && projStore[names$2[n]]) {
        return projStore[names$2[n]];
      }
    }

    function start() {
      projs.forEach(add);
    }
    var projections = {
      start: start,
      add: add,
      get: get
    };

    var exports$2 = {};
    exports$2.MERIT = {
      a: 6378137.0,
      rf: 298.257,
      ellipseName: "MERIT 1983"
    };

    exports$2.SGS85 = {
      a: 6378136.0,
      rf: 298.257,
      ellipseName: "Soviet Geodetic System 85"
    };

    exports$2.GRS80 = {
      a: 6378137.0,
      rf: 298.257222101,
      ellipseName: "GRS 1980(IUGG, 1980)"
    };

    exports$2.IAU76 = {
      a: 6378140.0,
      rf: 298.257,
      ellipseName: "IAU 1976"
    };

    exports$2.airy = {
      a: 6377563.396,
      b: 6356256.910,
      ellipseName: "Airy 1830"
    };

    exports$2.APL4 = {
      a: 6378137,
      rf: 298.25,
      ellipseName: "Appl. Physics. 1965"
    };

    exports$2.NWL9D = {
      a: 6378145.0,
      rf: 298.25,
      ellipseName: "Naval Weapons Lab., 1965"
    };

    exports$2.mod_airy = {
      a: 6377340.189,
      b: 6356034.446,
      ellipseName: "Modified Airy"
    };

    exports$2.andrae = {
      a: 6377104.43,
      rf: 300.0,
      ellipseName: "Andrae 1876 (Den., Iclnd.)"
    };

    exports$2.aust_SA = {
      a: 6378160.0,
      rf: 298.25,
      ellipseName: "Australian Natl & S. Amer. 1969"
    };

    exports$2.GRS67 = {
      a: 6378160.0,
      rf: 298.2471674270,
      ellipseName: "GRS 67(IUGG 1967)"
    };

    exports$2.bessel = {
      a: 6377397.155,
      rf: 299.1528128,
      ellipseName: "Bessel 1841"
    };

    exports$2.bess_nam = {
      a: 6377483.865,
      rf: 299.1528128,
      ellipseName: "Bessel 1841 (Namibia)"
    };

    exports$2.clrk66 = {
      a: 6378206.4,
      b: 6356583.8,
      ellipseName: "Clarke 1866"
    };

    exports$2.clrk80 = {
      a: 6378249.145,
      rf: 293.4663,
      ellipseName: "Clarke 1880 mod."
    };

    exports$2.clrk58 = {
      a: 6378293.645208759,
      rf: 294.2606763692654,
      ellipseName: "Clarke 1858"
    };

    exports$2.CPM = {
      a: 6375738.7,
      rf: 334.29,
      ellipseName: "Comm. des Poids et Mesures 1799"
    };

    exports$2.delmbr = {
      a: 6376428.0,
      rf: 311.5,
      ellipseName: "Delambre 1810 (Belgium)"
    };

    exports$2.engelis = {
      a: 6378136.05,
      rf: 298.2566,
      ellipseName: "Engelis 1985"
    };

    exports$2.evrst30 = {
      a: 6377276.345,
      rf: 300.8017,
      ellipseName: "Everest 1830"
    };

    exports$2.evrst48 = {
      a: 6377304.063,
      rf: 300.8017,
      ellipseName: "Everest 1948"
    };

    exports$2.evrst56 = {
      a: 6377301.243,
      rf: 300.8017,
      ellipseName: "Everest 1956"
    };

    exports$2.evrst69 = {
      a: 6377295.664,
      rf: 300.8017,
      ellipseName: "Everest 1969"
    };

    exports$2.evrstSS = {
      a: 6377298.556,
      rf: 300.8017,
      ellipseName: "Everest (Sabah & Sarawak)"
    };

    exports$2.fschr60 = {
      a: 6378166.0,
      rf: 298.3,
      ellipseName: "Fischer (Mercury Datum) 1960"
    };

    exports$2.fschr60m = {
      a: 6378155.0,
      rf: 298.3,
      ellipseName: "Fischer 1960"
    };

    exports$2.fschr68 = {
      a: 6378150.0,
      rf: 298.3,
      ellipseName: "Fischer 1968"
    };

    exports$2.helmert = {
      a: 6378200.0,
      rf: 298.3,
      ellipseName: "Helmert 1906"
    };

    exports$2.hough = {
      a: 6378270.0,
      rf: 297.0,
      ellipseName: "Hough"
    };

    exports$2.intl = {
      a: 6378388.0,
      rf: 297.0,
      ellipseName: "International 1909 (Hayford)"
    };

    exports$2.kaula = {
      a: 6378163.0,
      rf: 298.24,
      ellipseName: "Kaula 1961"
    };

    exports$2.lerch = {
      a: 6378139.0,
      rf: 298.257,
      ellipseName: "Lerch 1979"
    };

    exports$2.mprts = {
      a: 6397300.0,
      rf: 191.0,
      ellipseName: "Maupertius 1738"
    };

    exports$2.new_intl = {
      a: 6378157.5,
      b: 6356772.2,
      ellipseName: "New International 1967"
    };

    exports$2.plessis = {
      a: 6376523.0,
      rf: 6355863.0,
      ellipseName: "Plessis 1817 (France)"
    };

    exports$2.krass = {
      a: 6378245.0,
      rf: 298.3,
      ellipseName: "Krassovsky, 1942"
    };

    exports$2.SEasia = {
      a: 6378155.0,
      b: 6356773.3205,
      ellipseName: "Southeast Asia"
    };

    exports$2.walbeck = {
      a: 6376896.0,
      b: 6355834.8467,
      ellipseName: "Walbeck"
    };

    exports$2.WGS60 = {
      a: 6378165.0,
      rf: 298.3,
      ellipseName: "WGS 60"
    };

    exports$2.WGS66 = {
      a: 6378145.0,
      rf: 298.25,
      ellipseName: "WGS 66"
    };

    exports$2.WGS7 = {
      a: 6378135.0,
      rf: 298.26,
      ellipseName: "WGS 72"
    };

    var WGS84 = exports$2.WGS84 = {
      a: 6378137.0,
      rf: 298.257223563,
      ellipseName: "WGS 84"
    };

    exports$2.sphere = {
      a: 6370997.0,
      b: 6370997.0,
      ellipseName: "Normal Sphere (r=6370997)"
    };

    function eccentricity(a, b, rf, R_A) {
      var a2 = a * a; // used in geocentric
      var b2 = b * b; // used in geocentric
      var es = (a2 - b2) / a2; // e ^ 2
      var e = 0;
      if (R_A) {
        a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
        a2 = a * a;
        es = 0;
      } else {
        e = Math.sqrt(es); // eccentricity
      }
      var ep2 = (a2 - b2) / b2; // used in geocentric
      return {
        es: es,
        e: e,
        ep2: ep2
      };
    }
    function sphere(a, b, rf, ellps, sphere) {
      if (!a) { // do we have an ellipsoid?
        var ellipse = match(exports$2, ellps);
        if (!ellipse) {
          ellipse = WGS84;
        }
        a = ellipse.a;
        b = ellipse.b;
        rf = ellipse.rf;
      }

      if (rf && !b) {
        b = (1.0 - 1.0 / rf) * a;
      }
      if (rf === 0 || Math.abs(a - b) < EPSLN) {
        sphere = true;
        b = a;
      }
      return {
        a: a,
        b: b,
        rf: rf,
        sphere: sphere
      };
    }

    var exports$3 = {};
    exports$3.wgs84 = {
      towgs84: "0,0,0",
      ellipse: "WGS84",
      datumName: "WGS84"
    };

    exports$3.ch1903 = {
      towgs84: "674.374,15.056,405.346",
      ellipse: "bessel",
      datumName: "swiss"
    };

    exports$3.ggrs87 = {
      towgs84: "-199.87,74.79,246.62",
      ellipse: "GRS80",
      datumName: "Greek_Geodetic_Reference_System_1987"
    };

    exports$3.nad83 = {
      towgs84: "0,0,0",
      ellipse: "GRS80",
      datumName: "North_American_Datum_1983"
    };

    exports$3.nad27 = {
      nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
      ellipse: "clrk66",
      datumName: "North_American_Datum_1927"
    };

    exports$3.potsdam = {
      towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
      ellipse: "bessel",
      datumName: "Potsdam Rauenberg 1950 DHDN"
    };

    exports$3.carthage = {
      towgs84: "-263.0,6.0,431.0",
      ellipse: "clark80",
      datumName: "Carthage 1934 Tunisia"
    };

    exports$3.hermannskogel = {
      towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
      ellipse: "bessel",
      datumName: "Hermannskogel"
    };

    exports$3.osni52 = {
      towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
      ellipse: "airy",
      datumName: "Irish National"
    };

    exports$3.ire65 = {
      towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
      ellipse: "mod_airy",
      datumName: "Ireland 1965"
    };

    exports$3.rassadiran = {
      towgs84: "-133.63,-157.5,-158.62",
      ellipse: "intl",
      datumName: "Rassadiran"
    };

    exports$3.nzgd49 = {
      towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
      ellipse: "intl",
      datumName: "New Zealand Geodetic Datum 1949"
    };

    exports$3.osgb36 = {
      towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
      ellipse: "airy",
      datumName: "Airy 1830"
    };

    exports$3.s_jtsk = {
      towgs84: "589,76,480",
      ellipse: 'bessel',
      datumName: 'S-JTSK (Ferro)'
    };

    exports$3.beduaram = {
      towgs84: '-106,-87,188',
      ellipse: 'clrk80',
      datumName: 'Beduaram'
    };

    exports$3.gunung_segara = {
      towgs84: '-403,684,41',
      ellipse: 'bessel',
      datumName: 'Gunung Segara Jakarta'
    };

    exports$3.rnb72 = {
      towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
      ellipse: "intl",
      datumName: "Reseau National Belge 1972"
    };

    function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
      var out = {};

      if (datumCode === undefined || datumCode === 'none') {
        out.datum_type = PJD_NODATUM;
      } else {
        out.datum_type = PJD_WGS84;
      }

      if (datum_params) {
        out.datum_params = datum_params.map(parseFloat);
        if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
          out.datum_type = PJD_3PARAM;
        }
        if (out.datum_params.length > 3) {
          if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
            out.datum_type = PJD_7PARAM;
            out.datum_params[3] *= SEC_TO_RAD;
            out.datum_params[4] *= SEC_TO_RAD;
            out.datum_params[5] *= SEC_TO_RAD;
            out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
          }
        }
      }

      if (nadgrids) {
        out.datum_type = PJD_GRIDSHIFT;
        out.grids = nadgrids;
      }
      out.a = a; //datum object also uses these values
      out.b = b;
      out.es = es;
      out.ep2 = ep2;
      return out;
    }

    /**
     * Resources for details of NTv2 file formats:
     * - https://web.archive.org/web/20140127204822if_/http://www.mgs.gov.on.ca:80/stdprodconsume/groups/content/@mgs/@iandit/documents/resourcelist/stel02_047447.pdf
     * - http://mimaka.com/help/gs/html/004_NTV2%20Data%20Format.htm
     */

    var loadedNadgrids = {};

    /**
     * Load a binary NTv2 file (.gsb) to a key that can be used in a proj string like +nadgrids=<key>. Pass the NTv2 file
     * as an ArrayBuffer.
     */
    function nadgrid(key, data) {
      var view = new DataView(data);
      var isLittleEndian = detectLittleEndian(view);
      var header = readHeader(view, isLittleEndian);
      if (header.nSubgrids > 1) {
        console.log('Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored');
      }
      var subgrids = readSubgrids(view, header, isLittleEndian);
      var nadgrid = {header: header, subgrids: subgrids};
      loadedNadgrids[key] = nadgrid;
      return nadgrid;
    }

    /**
     * Given a proj4 value for nadgrids, return an array of loaded grids
     */
    function getNadgrids(nadgrids) {
      // Format details: http://proj.maptools.org/gen_parms.html
      if (nadgrids === undefined) { return null; }
      var grids = nadgrids.split(',');
      return grids.map(parseNadgridString);
    }

    function parseNadgridString(value) {
      if (value.length === 0) {
        return null;
      }
      var optional = value[0] === '@';
      if (optional) {
        value = value.slice(1);
      }
      if (value === 'null') {
        return {name: 'null', mandatory: !optional, grid: null, isNull: true};
      }
      return {
        name: value,
        mandatory: !optional,
        grid: loadedNadgrids[value] || null,
        isNull: false
      };
    }

    function secondsToRadians(seconds) {
      return (seconds / 3600) * Math.PI / 180;
    }

    function detectLittleEndian(view) {
      var nFields = view.getInt32(8, false);
      if (nFields === 11) {
        return false;
      }
      nFields = view.getInt32(8, true);
      if (nFields !== 11) {
        console.warn('Failed to detect nadgrid endian-ness, defaulting to little-endian');
      }
      return true;
    }

    function readHeader(view, isLittleEndian) {
      return {
        nFields: view.getInt32(8, isLittleEndian),
        nSubgridFields: view.getInt32(24, isLittleEndian),
        nSubgrids: view.getInt32(40, isLittleEndian),
        shiftType: decodeString(view, 56, 56 + 8).trim(),
        fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
        fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
        toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
        toSemiMinorAxis: view.getFloat64(168, isLittleEndian),
      };
    }

    function decodeString(view, start, end) {
      return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));
    }

    function readSubgrids(view, header, isLittleEndian) {
      var gridOffset = 176;
      var grids = [];
      for (var i = 0; i < header.nSubgrids; i++) {
        var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
        var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
        var lngColumnCount = Math.round(
          1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
        var latColumnCount = Math.round(
          1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
        // Proj4 operates on radians whereas the coordinates are in seconds in the grid
        grids.push({
          ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
          del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
          lim: [lngColumnCount, latColumnCount],
          count: subHeader.gridNodeCount,
          cvs: mapNodes(nodes)
        });
      }
      return grids;
    }

    function mapNodes(nodes) {
      return nodes.map(function (r) {return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];});
    }

    function readGridHeader(view, offset, isLittleEndian) {
      return {
        name: decodeString(view, offset + 8, offset + 16).trim(),
        parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
        lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
        upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
        lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
        upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
        latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
        longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
        gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
      };
    }

    function readGridNodes(view, offset, gridHeader, isLittleEndian) {
      var nodesOffset = offset + 176;
      var gridRecordLength = 16;
      var gridShiftRecords = [];
      for (var i = 0; i < gridHeader.gridNodeCount; i++) {
        var record = {
          latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
          longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
          latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
          longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian),
        };
        gridShiftRecords.push(record);
      }
      return gridShiftRecords;
    }

    function Projection(srsCode,callback) {
      if (!(this instanceof Projection)) {
        return new Projection(srsCode);
      }
      callback = callback || function(error){
        if(error){
          throw error;
        }
      };
      var json = parse$2(srsCode);
      if(typeof json !== 'object'){
        callback(srsCode);
        return;
      }
      var ourProj = Projection.projections.get(json.projName);
      if(!ourProj){
        callback(srsCode);
        return;
      }
      if (json.datumCode && json.datumCode !== 'none') {
        var datumDef = match(exports$3, json.datumCode);
        if (datumDef) {
          json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(',') : null);
          json.ellps = datumDef.ellipse;
          json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
        }
      }
      json.k0 = json.k0 || 1.0;
      json.axis = json.axis || 'enu';
      json.ellps = json.ellps || 'wgs84';
      json.lat1 = json.lat1 || json.lat0; // Lambert_Conformal_Conic_1SP, for example, needs this

      var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
      var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
      var nadgrids = getNadgrids(json.nadgrids);
      var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2,
        nadgrids);

      extend(this, json); // transfer everything over from the projection because we don't know what we'll need
      extend(this, ourProj); // transfer all the methods from the projection

      // copy the 4 things over we calulated in deriveConstants.sphere
      this.a = sphere_.a;
      this.b = sphere_.b;
      this.rf = sphere_.rf;
      this.sphere = sphere_.sphere;

      // copy the 3 things we calculated in deriveConstants.eccentricity
      this.es = ecc.es;
      this.e = ecc.e;
      this.ep2 = ecc.ep2;

      // add in the datum object
      this.datum = datumObj;

      // init the projection
      this.init();

      // legecy callback from back in the day when it went to spatialreference.org
      callback(null, this);

    }
    Projection.projections = projections;
    Projection.projections.start();

    function compareDatums(source, dest) {
      if (source.datum_type !== dest.datum_type) {
        return false; // false, datums are not equal
      } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
        // the tolerance for es is to ensure that GRS80 and WGS84
        // are considered identical
        return false;
      } else if (source.datum_type === PJD_3PARAM) {
        return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
      } else if (source.datum_type === PJD_7PARAM) {
        return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
      } else {
        return true; // datums are equal
      }
    } // cs_compare_datums()

    /*
     * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
     * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
     * according to the current ellipsoid parameters.
     *
     *    Latitude  : Geodetic latitude in radians                     (input)
     *    Longitude : Geodetic longitude in radians                    (input)
     *    Height    : Geodetic height, in meters                       (input)
     *    X         : Calculated Geocentric X coordinate, in meters    (output)
     *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
     *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
     *
     */
    function geodeticToGeocentric(p, es, a) {
      var Longitude = p.x;
      var Latitude = p.y;
      var Height = p.z ? p.z : 0; //Z value not always supplied

      var Rn; /*  Earth radius at location  */
      var Sin_Lat; /*  Math.sin(Latitude)  */
      var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
      var Cos_Lat; /*  Math.cos(Latitude)  */

      /*
       ** Don't blow up if Latitude is just a little out of the value
       ** range as it may just be a rounding issue.  Also removed longitude
       ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
       */
      if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
        Latitude = -HALF_PI;
      } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
        Latitude = HALF_PI;
      } else if (Latitude < -HALF_PI) {
        /* Latitude out of range */
        //..reportError('geocent:lat out of range:' + Latitude);
        return { x: -Infinity, y: -Infinity, z: p.z };
      } else if (Latitude > HALF_PI) {
        /* Latitude out of range */
        return { x: Infinity, y: Infinity, z: p.z };
      }

      if (Longitude > Math.PI) {
        Longitude -= (2 * Math.PI);
      }
      Sin_Lat = Math.sin(Latitude);
      Cos_Lat = Math.cos(Latitude);
      Sin2_Lat = Sin_Lat * Sin_Lat;
      Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
      return {
        x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
        y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
        z: ((Rn * (1 - es)) + Height) * Sin_Lat
      };
    } // cs_geodetic_to_geocentric()

    function geocentricToGeodetic(p, es, a, b) {
      /* local defintions and variables */
      /* end-criterium of loop, accuracy of sin(Latitude) */
      var genau = 1e-12;
      var genau2 = (genau * genau);
      var maxiter = 30;

      var P; /* distance between semi-minor axis and location */
      var RR; /* distance between center and location */
      var CT; /* sin of geocentric latitude */
      var ST; /* cos of geocentric latitude */
      var RX;
      var RK;
      var RN; /* Earth radius at location */
      var CPHI0; /* cos of start or old geodetic latitude in iterations */
      var SPHI0; /* sin of start or old geodetic latitude in iterations */
      var CPHI; /* cos of searched geodetic latitude */
      var SPHI; /* sin of searched geodetic latitude */
      var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
      var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

      var X = p.x;
      var Y = p.y;
      var Z = p.z ? p.z : 0.0; //Z value not always supplied
      var Longitude;
      var Latitude;
      var Height;

      P = Math.sqrt(X * X + Y * Y);
      RR = Math.sqrt(X * X + Y * Y + Z * Z);

      /*      special cases for latitude and longitude */
      if (P / a < genau) {

        /*  special case, if P=0. (X=0., Y=0.) */
        Longitude = 0.0;

        /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
         *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
        if (RR / a < genau) {
          Latitude = HALF_PI;
          Height = -b;
          return {
            x: p.x,
            y: p.y,
            z: p.z
          };
        }
      } else {
        /*  ellipsoidal (geodetic) longitude
         *  interval: -PI < Longitude <= +PI */
        Longitude = Math.atan2(Y, X);
      }

      /* --------------------------------------------------------------
       * Following iterative algorithm was developped by
       * "Institut for Erdmessung", University of Hannover, July 1988.
       * Internet: www.ife.uni-hannover.de
       * Iterative computation of CPHI,SPHI and Height.
       * Iteration of CPHI and SPHI to 10**-12 radian resp.
       * 2*10**-7 arcsec.
       * --------------------------------------------------------------
       */
      CT = Z / RR;
      ST = P / RR;
      RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
      CPHI0 = ST * (1.0 - es) * RX;
      SPHI0 = CT * RX;
      iter = 0;

      /* loop to find sin(Latitude) resp. Latitude
       * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
      do {
        iter++;
        RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

        /*  ellipsoidal (geodetic) height */
        Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

        RK = es * RN / (RN + Height);
        RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
        CPHI = ST * (1.0 - RK) * RX;
        SPHI = CT * RX;
        SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
        CPHI0 = CPHI;
        SPHI0 = SPHI;
      }
      while (SDPHI * SDPHI > genau2 && iter < maxiter);

      /*      ellipsoidal (geodetic) latitude */
      Latitude = Math.atan(SPHI / Math.abs(CPHI));
      return {
        x: Longitude,
        y: Latitude,
        z: Height
      };
    } // cs_geocentric_to_geodetic()

    /****************************************************************/
    // pj_geocentic_to_wgs84( p )
    //  p = point to transform in geocentric coordinates (x,y,z)


    /** point object, nothing fancy, just allows values to be
        passed back and forth by reference rather than by value.
        Other point classes may be used as long as they have
        x and y properties, which will get modified in the transform method.
    */
    function geocentricToWgs84(p, datum_type, datum_params) {

      if (datum_type === PJD_3PARAM) {
        // if( x[io] === HUGE_VAL )
        //    continue;
        return {
          x: p.x + datum_params[0],
          y: p.y + datum_params[1],
          z: p.z + datum_params[2],
        };
      } else if (datum_type === PJD_7PARAM) {
        var Dx_BF = datum_params[0];
        var Dy_BF = datum_params[1];
        var Dz_BF = datum_params[2];
        var Rx_BF = datum_params[3];
        var Ry_BF = datum_params[4];
        var Rz_BF = datum_params[5];
        var M_BF = datum_params[6];
        // if( x[io] === HUGE_VAL )
        //    continue;
        return {
          x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
          y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
          z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
        };
      }
    } // cs_geocentric_to_wgs84

    /****************************************************************/
    // pj_geocentic_from_wgs84()
    //  coordinate system definition,
    //  point to transform in geocentric coordinates (x,y,z)
    function geocentricFromWgs84(p, datum_type, datum_params) {

      if (datum_type === PJD_3PARAM) {
        //if( x[io] === HUGE_VAL )
        //    continue;
        return {
          x: p.x - datum_params[0],
          y: p.y - datum_params[1],
          z: p.z - datum_params[2],
        };

      } else if (datum_type === PJD_7PARAM) {
        var Dx_BF = datum_params[0];
        var Dy_BF = datum_params[1];
        var Dz_BF = datum_params[2];
        var Rx_BF = datum_params[3];
        var Ry_BF = datum_params[4];
        var Rz_BF = datum_params[5];
        var M_BF = datum_params[6];
        var x_tmp = (p.x - Dx_BF) / M_BF;
        var y_tmp = (p.y - Dy_BF) / M_BF;
        var z_tmp = (p.z - Dz_BF) / M_BF;
        //if( x[io] === HUGE_VAL )
        //    continue;

        return {
          x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
          y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
          z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
        };
      } //cs_geocentric_from_wgs84()
    }

    function checkParams(type) {
      return (type === PJD_3PARAM || type === PJD_7PARAM);
    }

    function datum_transform(source, dest, point) {
      // Short cut if the datums are identical.
      if (compareDatums(source, dest)) {
        return point; // in this case, zero is sucess,
        // whereas cs_compare_datums returns 1 to indicate TRUE
        // confusing, should fix this
      }

      // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
      if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
        return point;
      }

      // If this datum requires grid shifts, then apply it to geodetic coordinates.
      var source_a = source.a;
      var source_es = source.es;
      if (source.datum_type === PJD_GRIDSHIFT) {
        var gridShiftCode = applyGridShift(source, false, point);
        if (gridShiftCode !== 0) {
          return undefined;
        }
        source_a = SRS_WGS84_SEMIMAJOR;
        source_es = SRS_WGS84_ESQUARED;
      }

      var dest_a = dest.a;
      var dest_b = dest.b;
      var dest_es = dest.es;
      if (dest.datum_type === PJD_GRIDSHIFT) {
        dest_a = SRS_WGS84_SEMIMAJOR;
        dest_b = SRS_WGS84_SEMIMINOR;
        dest_es = SRS_WGS84_ESQUARED;
      }

      // Do we need to go through geocentric coordinates?
      if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
        return point;
      }

      // Convert to geocentric coordinates.
      point = geodeticToGeocentric(point, source_es, source_a);
      // Convert between datums
      if (checkParams(source.datum_type)) {
        point = geocentricToWgs84(point, source.datum_type, source.datum_params);
      }
      if (checkParams(dest.datum_type)) {
        point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
      }
      point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);

      if (dest.datum_type === PJD_GRIDSHIFT) {
        var destGridShiftResult = applyGridShift(dest, true, point);
        if (destGridShiftResult !== 0) {
          return undefined;
        }
      }

      return point;
    }

    function applyGridShift(source, inverse, point) {
      if (source.grids === null || source.grids.length === 0) {
        console.log('Grid shift grids not found');
        return -1;
      }
      var input = {x: -point.x, y: point.y};
      var output = {x: Number.NaN, y: Number.NaN};
      var onlyMandatoryGrids = false;
      var attemptedGrids = [];
      for (var i = 0; i < source.grids.length; i++) {
        var grid = source.grids[i];
        attemptedGrids.push(grid.name);
        if (grid.isNull) {
          output = input;
          break;
        }
        onlyMandatoryGrids = grid.mandatory;
        if (grid.grid === null) {
          if (grid.mandatory) {
            console.log("Unable to find mandatory grid '" + grid.name + "'");
            return -1;
          }
          continue;
        }
        var subgrid = grid.grid.subgrids[0];
        // skip tables that don't match our point at all
        var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;
        var minX = subgrid.ll[0] - epsilon;
        var minY = subgrid.ll[1] - epsilon;
        var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
        var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
        if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x ) {
          continue;
        }
        output = applySubgridShift(input, inverse, subgrid);
        if (!isNaN(output.x)) {
          break;
        }
      }
      if (isNaN(output.x)) {
        console.log("Failed to find a grid shift table for location '"+
          -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
        return -1;
      }
      point.x = -output.x;
      point.y = output.y;
      return 0;
    }

    function applySubgridShift(pin, inverse, ct) {
      var val = {x: Number.NaN, y: Number.NaN};
      if (isNaN(pin.x)) { return val; }
      var tb = {x: pin.x, y: pin.y};
      tb.x -= ct.ll[0];
      tb.y -= ct.ll[1];
      tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
      var t = nadInterpolate(tb, ct);
      if (inverse) {
        if (isNaN(t.x)) {
          return val;
        }
        t.x = tb.x - t.x;
        t.y = tb.y - t.y;
        var i = 9, tol = 1e-12;
        var dif, del;
        do {
          del = nadInterpolate(t, ct);
          if (isNaN(del.x)) {
            console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
            break;
          }
          dif = {x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y)};
          t.x += dif.x;
          t.y += dif.y;
        } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
        if (i < 0) {
          console.log("Inverse grid shift iterator failed to converge.");
          return val;
        }
        val.x = adjust_lon(t.x + ct.ll[0]);
        val.y = t.y + ct.ll[1];
      } else {
        if (!isNaN(t.x)) {
          val.x = pin.x + t.x;
          val.y = pin.y + t.y;
        }
      }
      return val;
    }

    function nadInterpolate(pin, ct) {
      var t = {x: pin.x / ct.del[0], y: pin.y / ct.del[1]};
      var indx = {x: Math.floor(t.x), y: Math.floor(t.y)};
      var frct = {x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y};
      var val= {x: Number.NaN, y: Number.NaN};
      var inx;
      if (indx.x < 0 || indx.x >= ct.lim[0]) {
        return val;
      }
      if (indx.y < 0 || indx.y >= ct.lim[1]) {
        return val;
      }
      inx = (indx.y * ct.lim[0]) + indx.x;
      var f00 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
      inx++;
      var f10= {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
      inx += ct.lim[0];
      var f11 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
      inx--;
      var f01 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
      var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),
        m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;
      val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);
      val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);
      return val;
    }

    function adjust_axis(crs, denorm, point) {
      var xin = point.x,
        yin = point.y,
        zin = point.z || 0.0;
      var v, t, i;
      var out = {};
      for (i = 0; i < 3; i++) {
        if (denorm && i === 2 && point.z === undefined) {
          continue;
        }
        if (i === 0) {
          v = xin;
          if ("ew".indexOf(crs.axis[i]) !== -1) {
            t = 'x';
          } else {
            t = 'y';
          }

        }
        else if (i === 1) {
          v = yin;
          if ("ns".indexOf(crs.axis[i]) !== -1) {
            t = 'y';
          } else {
            t = 'x';
          }
        }
        else {
          v = zin;
          t = 'z';
        }
        switch (crs.axis[i]) {
        case 'e':
          out[t] = v;
          break;
        case 'w':
          out[t] = -v;
          break;
        case 'n':
          out[t] = v;
          break;
        case 's':
          out[t] = -v;
          break;
        case 'u':
          if (point[t] !== undefined) {
            out.z = v;
          }
          break;
        case 'd':
          if (point[t] !== undefined) {
            out.z = -v;
          }
          break;
        default:
          //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
          return null;
        }
      }
      return out;
    }

    function common$1 (array){
      var out = {
        x: array[0],
        y: array[1]
      };
      if (array.length>2) {
        out.z = array[2];
      }
      if (array.length>3) {
        out.m = array[3];
      }
      return out;
    }

    function checkSanity (point) {
      checkCoord(point.x);
      checkCoord(point.y);
    }
    function checkCoord(num) {
      if (typeof Number.isFinite === 'function') {
        if (Number.isFinite(num)) {
          return;
        }
        throw new TypeError('coordinates must be finite numbers');
      }
      if (typeof num !== 'number' || num !== num || !isFinite(num)) {
        throw new TypeError('coordinates must be finite numbers');
      }
    }

    function checkNotWGS(source, dest) {
      return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');
    }

    function transform(source, dest, point, enforceAxis) {
      var wgs84;
      if (Array.isArray(point)) {
        point = common$1(point);
      }
      checkSanity(point);
      // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
      if (source.datum && dest.datum && checkNotWGS(source, dest)) {
        wgs84 = new Projection('WGS84');
        point = transform(source, wgs84, point, enforceAxis);
        source = wgs84;
      }
      // DGR, 2010/11/12
      if (enforceAxis && source.axis !== 'enu') {
        point = adjust_axis(source, false, point);
      }
      // Transform source points to long/lat, if they aren't already.
      if (source.projName === 'longlat') {
        point = {
          x: point.x * D2R,
          y: point.y * D2R,
          z: point.z || 0
        };
      } else {
        if (source.to_meter) {
          point = {
            x: point.x * source.to_meter,
            y: point.y * source.to_meter,
            z: point.z || 0
          };
        }
        point = source.inverse(point); // Convert Cartesian to longlat
        if (!point) {
          return;
        }
      }
      // Adjust for the prime meridian if necessary
      if (source.from_greenwich) {
        point.x += source.from_greenwich;
      }

      // Convert datums if needed, and if possible.
      point = datum_transform(source.datum, dest.datum, point);
      if (!point) {
        return;
      }

      // Adjust for the prime meridian if necessary
      if (dest.from_greenwich) {
        point = {
          x: point.x - dest.from_greenwich,
          y: point.y,
          z: point.z || 0
        };
      }

      if (dest.projName === 'longlat') {
        // convert radians to decimal degrees
        point = {
          x: point.x * R2D,
          y: point.y * R2D,
          z: point.z || 0
        };
      } else { // else project
        point = dest.forward(point);
        if (dest.to_meter) {
          point = {
            x: point.x / dest.to_meter,
            y: point.y / dest.to_meter,
            z: point.z || 0
          };
        }
      }

      // DGR, 2010/11/12
      if (enforceAxis && dest.axis !== 'enu') {
        return adjust_axis(dest, true, point);
      }

      return point;
    }

    var wgs84 = Projection('WGS84');

    function transformer(from, to, coords, enforceAxis) {
      var transformedArray, out, keys;
      if (Array.isArray(coords)) {
        transformedArray = transform(from, to, coords, enforceAxis) || {x: NaN, y: NaN};
        if (coords.length > 2) {
          if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
            if (typeof transformedArray.z === 'number') {
              return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
            } else {
              return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
            }
          } else {
            return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
          }
        } else {
          return [transformedArray.x, transformedArray.y];
        }
      } else {
        out = transform(from, to, coords, enforceAxis);
        keys = Object.keys(coords);
        if (keys.length === 2) {
          return out;
        }
        keys.forEach(function (key) {
          if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
            if (key === 'x' || key === 'y' || key === 'z') {
              return;
            }
          } else {
            if (key === 'x' || key === 'y') {
              return;
            }
          }
          out[key] = coords[key];
        });
        return out;
      }
    }

    function checkProj(item) {
      if (item instanceof Projection) {
        return item;
      }
      if (item.oProj) {
        return item.oProj;
      }
      return Projection(item);
    }

    function proj4(fromProj, toProj, coord) {
      fromProj = checkProj(fromProj);
      var single = false;
      var obj;
      if (typeof toProj === 'undefined') {
        toProj = fromProj;
        fromProj = wgs84;
        single = true;
      } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
        coord = toProj;
        toProj = fromProj;
        fromProj = wgs84;
        single = true;
      }
      toProj = checkProj(toProj);
      if (coord) {
        return transformer(fromProj, toProj, coord);
      } else {
        obj = {
          forward: function (coords, enforceAxis) {
            return transformer(fromProj, toProj, coords, enforceAxis);
          },
          inverse: function (coords, enforceAxis) {
            return transformer(toProj, fromProj, coords, enforceAxis);
          }
        };
        if (single) {
          obj.oProj = toProj;
        }
        return obj;
      }
    }

    /**
     * UTM zones are grouped, and assigned to one of a group of 6
     * sets.
     *
     * {int} @private
     */
    var NUM_100K_SETS = 6;

    /**
     * The column letters (for easting) of the lower left value, per
     * set.
     *
     * {string} @private
     */
    var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

    /**
     * The row letters (for northing) of the lower left value, per
     * set.
     *
     * {string} @private
     */
    var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

    var A = 65; // A
    var I = 73; // I
    var O = 79; // O
    var V = 86; // V
    var Z$1 = 90; // Z
    var mgrs = {
      forward: forward$1,
      inverse: inverse$1,
      toPoint: toPoint
    };
    /**
     * Conversion of lat/lon to MGRS.
     *
     * @param {object} ll Object literal with lat and lon properties on a
     *     WGS84 ellipsoid.
     * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
     *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
     * @return {string} the MGRS string for the given location and accuracy.
     */
    function forward$1(ll, accuracy) {
      accuracy = accuracy || 5; // default accuracy 1m
      return encode$3(LLtoUTM({
        lat: ll[1],
        lon: ll[0]
      }), accuracy);
    }
    /**
     * Conversion of MGRS to lat/lon.
     *
     * @param {string} mgrs MGRS string.
     * @return {array} An array with left (longitude), bottom (latitude), right
     *     (longitude) and top (latitude) values in WGS84, representing the
     *     bounding box for the provided MGRS reference.
     */
    function inverse$1(mgrs) {
      var bbox = UTMtoLL(decode$3(mgrs.toUpperCase()));
      if (bbox.lat && bbox.lon) {
        return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
      }
      return [bbox.left, bbox.bottom, bbox.right, bbox.top];
    }
    function toPoint(mgrs) {
      var bbox = UTMtoLL(decode$3(mgrs.toUpperCase()));
      if (bbox.lat && bbox.lon) {
        return [bbox.lon, bbox.lat];
      }
      return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
    }/**
     * Conversion from degrees to radians.
     *
     * @private
     * @param {number} deg the angle in degrees.
     * @return {number} the angle in radians.
     */
    function degToRad(deg) {
      return (deg * (Math.PI / 180.0));
    }

    /**
     * Conversion from radians to degrees.
     *
     * @private
     * @param {number} rad the angle in radians.
     * @return {number} the angle in degrees.
     */
    function radToDeg(rad) {
      return (180.0 * (rad / Math.PI));
    }

    /**
     * Converts a set of Longitude and Latitude co-ordinates to UTM
     * using the WGS84 ellipsoid.
     *
     * @private
     * @param {object} ll Object literal with lat and lon properties
     *     representing the WGS84 coordinate to be converted.
     * @return {object} Object literal containing the UTM value with easting,
     *     northing, zoneNumber and zoneLetter properties, and an optional
     *     accuracy property in digits. Returns null if the conversion failed.
     */
    function LLtoUTM(ll) {
      var Lat = ll.lat;
      var Long = ll.lon;
      var a = 6378137.0; //ellip.radius;
      var eccSquared = 0.00669438; //ellip.eccsq;
      var k0 = 0.9996;
      var LongOrigin;
      var eccPrimeSquared;
      var N, T, C, A, M;
      var LatRad = degToRad(Lat);
      var LongRad = degToRad(Long);
      var LongOriginRad;
      var ZoneNumber;
      // (int)
      ZoneNumber = Math.floor((Long + 180) / 6) + 1;

      //Make sure the longitude 180.00 is in Zone 60
      if (Long === 180) {
        ZoneNumber = 60;
      }

      // Special zone for Norway
      if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
        ZoneNumber = 32;
      }

      // Special zones for Svalbard
      if (Lat >= 72.0 && Lat < 84.0) {
        if (Long >= 0.0 && Long < 9.0) {
          ZoneNumber = 31;
        }
        else if (Long >= 9.0 && Long < 21.0) {
          ZoneNumber = 33;
        }
        else if (Long >= 21.0 && Long < 33.0) {
          ZoneNumber = 35;
        }
        else if (Long >= 33.0 && Long < 42.0) {
          ZoneNumber = 37;
        }
      }

      LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
      // in middle of
      // zone
      LongOriginRad = degToRad(LongOrigin);

      eccPrimeSquared = (eccSquared) / (1 - eccSquared);

      N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
      T = Math.tan(LatRad) * Math.tan(LatRad);
      C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
      A = Math.cos(LatRad) * (LongRad - LongOriginRad);

      M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

      var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

      var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
      if (Lat < 0.0) {
        UTMNorthing += 10000000.0; //10000000 meter offset for
        // southern hemisphere
      }

      return {
        northing: Math.round(UTMNorthing),
        easting: Math.round(UTMEasting),
        zoneNumber: ZoneNumber,
        zoneLetter: getLetterDesignator(Lat)
      };
    }

    /**
     * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
     * class where the Zone can be specified as a single string eg."60N" which
     * is then broken down into the ZoneNumber and ZoneLetter.
     *
     * @private
     * @param {object} utm An object literal with northing, easting, zoneNumber
     *     and zoneLetter properties. If an optional accuracy property is
     *     provided (in meters), a bounding box will be returned instead of
     *     latitude and longitude.
     * @return {object} An object literal containing either lat and lon values
     *     (if no accuracy was provided), or top, right, bottom and left values
     *     for the bounding box calculated according to the provided accuracy.
     *     Returns null if the conversion failed.
     */
    function UTMtoLL(utm) {

      var UTMNorthing = utm.northing;
      var UTMEasting = utm.easting;
      var zoneLetter = utm.zoneLetter;
      var zoneNumber = utm.zoneNumber;
      // check the ZoneNummber is valid
      if (zoneNumber < 0 || zoneNumber > 60) {
        return null;
      }

      var k0 = 0.9996;
      var a = 6378137.0; //ellip.radius;
      var eccSquared = 0.00669438; //ellip.eccsq;
      var eccPrimeSquared;
      var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
      var N1, T1, C1, R1, D, M;
      var LongOrigin;
      var mu, phi1Rad;

      // remove 500,000 meter offset for longitude
      var x = UTMEasting - 500000.0;
      var y = UTMNorthing;

      // We must know somehow if we are in the Northern or Southern
      // hemisphere, this is the only time we use the letter So even
      // if the Zone letter isn't exactly correct it should indicate
      // the hemisphere correctly
      if (zoneLetter < 'N') {
        y -= 10000000.0; // remove 10,000,000 meter offset used
        // for southern hemisphere
      }

      // There are 60 zones with zone 1 being at West -180 to -174
      LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
      // in middle of
      // zone

      eccPrimeSquared = (eccSquared) / (1 - eccSquared);

      M = y / k0;
      mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

      phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
      // double phi1 = ProjMath.radToDeg(phi1Rad);

      N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
      T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
      C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
      R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
      D = x / (N1 * k0);

      var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
      lat = radToDeg(lat);

      var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
      lon = LongOrigin + radToDeg(lon);

      var result;
      if (utm.accuracy) {
        var topRight = UTMtoLL({
          northing: utm.northing + utm.accuracy,
          easting: utm.easting + utm.accuracy,
          zoneLetter: utm.zoneLetter,
          zoneNumber: utm.zoneNumber
        });
        result = {
          top: topRight.lat,
          right: topRight.lon,
          bottom: lat,
          left: lon
        };
      }
      else {
        result = {
          lat: lat,
          lon: lon
        };
      }
      return result;
    }

    /**
     * Calculates the MGRS letter designator for the given latitude.
     *
     * @private
     * @param {number} lat The latitude in WGS84 to get the letter designator
     *     for.
     * @return {char} The letter designator.
     */
    function getLetterDesignator(lat) {
      //This is here as an error flag to show that the Latitude is
      //outside MGRS limits
      var LetterDesignator = 'Z';

      if ((84 >= lat) && (lat >= 72)) {
        LetterDesignator = 'X';
      }
      else if ((72 > lat) && (lat >= 64)) {
        LetterDesignator = 'W';
      }
      else if ((64 > lat) && (lat >= 56)) {
        LetterDesignator = 'V';
      }
      else if ((56 > lat) && (lat >= 48)) {
        LetterDesignator = 'U';
      }
      else if ((48 > lat) && (lat >= 40)) {
        LetterDesignator = 'T';
      }
      else if ((40 > lat) && (lat >= 32)) {
        LetterDesignator = 'S';
      }
      else if ((32 > lat) && (lat >= 24)) {
        LetterDesignator = 'R';
      }
      else if ((24 > lat) && (lat >= 16)) {
        LetterDesignator = 'Q';
      }
      else if ((16 > lat) && (lat >= 8)) {
        LetterDesignator = 'P';
      }
      else if ((8 > lat) && (lat >= 0)) {
        LetterDesignator = 'N';
      }
      else if ((0 > lat) && (lat >= -8)) {
        LetterDesignator = 'M';
      }
      else if ((-8 > lat) && (lat >= -16)) {
        LetterDesignator = 'L';
      }
      else if ((-16 > lat) && (lat >= -24)) {
        LetterDesignator = 'K';
      }
      else if ((-24 > lat) && (lat >= -32)) {
        LetterDesignator = 'J';
      }
      else if ((-32 > lat) && (lat >= -40)) {
        LetterDesignator = 'H';
      }
      else if ((-40 > lat) && (lat >= -48)) {
        LetterDesignator = 'G';
      }
      else if ((-48 > lat) && (lat >= -56)) {
        LetterDesignator = 'F';
      }
      else if ((-56 > lat) && (lat >= -64)) {
        LetterDesignator = 'E';
      }
      else if ((-64 > lat) && (lat >= -72)) {
        LetterDesignator = 'D';
      }
      else if ((-72 > lat) && (lat >= -80)) {
        LetterDesignator = 'C';
      }
      return LetterDesignator;
    }

    /**
     * Encodes a UTM location as MGRS string.
     *
     * @private
     * @param {object} utm An object literal with easting, northing,
     *     zoneLetter, zoneNumber
     * @param {number} accuracy Accuracy in digits (1-5).
     * @return {string} MGRS string for the given UTM location.
     */
    function encode$3(utm, accuracy) {
      // prepend with leading zeroes
      var seasting = "00000" + utm.easting,
        snorthing = "00000" + utm.northing;

      return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
    }

    /**
     * Get the two letter 100k designator for a given UTM easting,
     * northing and zone number value.
     *
     * @private
     * @param {number} easting
     * @param {number} northing
     * @param {number} zoneNumber
     * @return the two letter 100k designator for the given UTM location.
     */
    function get100kID(easting, northing, zoneNumber) {
      var setParm = get100kSetForZone(zoneNumber);
      var setColumn = Math.floor(easting / 100000);
      var setRow = Math.floor(northing / 100000) % 20;
      return getLetter100kID(setColumn, setRow, setParm);
    }

    /**
     * Given a UTM zone number, figure out the MGRS 100K set it is in.
     *
     * @private
     * @param {number} i An UTM zone number.
     * @return {number} the 100k set the UTM zone is in.
     */
    function get100kSetForZone(i) {
      var setParm = i % NUM_100K_SETS;
      if (setParm === 0) {
        setParm = NUM_100K_SETS;
      }

      return setParm;
    }

    /**
     * Get the two-letter MGRS 100k designator given information
     * translated from the UTM northing, easting and zone number.
     *
     * @private
     * @param {number} column the column index as it relates to the MGRS
     *        100k set spreadsheet, created from the UTM easting.
     *        Values are 1-8.
     * @param {number} row the row index as it relates to the MGRS 100k set
     *        spreadsheet, created from the UTM northing value. Values
     *        are from 0-19.
     * @param {number} parm the set block, as it relates to the MGRS 100k set
     *        spreadsheet, created from the UTM zone. Values are from
     *        1-60.
     * @return two letter MGRS 100k code.
     */
    function getLetter100kID(column, row, parm) {
      // colOrigin and rowOrigin are the letters at the origin of the set
      var index = parm - 1;
      var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
      var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

      // colInt and rowInt are the letters to build to return
      var colInt = colOrigin + column - 1;
      var rowInt = rowOrigin + row;
      var rollover = false;

      if (colInt > Z$1) {
        colInt = colInt - Z$1 + A - 1;
        rollover = true;
      }

      if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
        colInt++;
      }

      if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
        colInt++;

        if (colInt === I) {
          colInt++;
        }
      }

      if (colInt > Z$1) {
        colInt = colInt - Z$1 + A - 1;
      }

      if (rowInt > V) {
        rowInt = rowInt - V + A - 1;
        rollover = true;
      }
      else {
        rollover = false;
      }

      if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
        rowInt++;
      }

      if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
        rowInt++;

        if (rowInt === I) {
          rowInt++;
        }
      }

      if (rowInt > V) {
        rowInt = rowInt - V + A - 1;
      }

      var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
      return twoLetter;
    }

    /**
     * Decode the UTM parameters from a MGRS string.
     *
     * @private
     * @param {string} mgrsString an UPPERCASE coordinate string is expected.
     * @return {object} An object literal with easting, northing, zoneLetter,
     *     zoneNumber and accuracy (in meters) properties.
     */
    function decode$3(mgrsString) {

      if (mgrsString && mgrsString.length === 0) {
        throw ("MGRSPoint coverting from nothing");
      }

      var length = mgrsString.length;

      var hunK = null;
      var sb = "";
      var testChar;
      var i = 0;

      // get Zone number
      while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
        if (i >= 2) {
          throw ("MGRSPoint bad conversion from: " + mgrsString);
        }
        sb += testChar;
        i++;
      }

      var zoneNumber = parseInt(sb, 10);

      if (i === 0 || i + 3 > length) {
        // A good MGRS string has to be 4-5 digits long,
        // ##AAA/#AAA at least.
        throw ("MGRSPoint bad conversion from: " + mgrsString);
      }

      var zoneLetter = mgrsString.charAt(i++);

      // Should we check the zone letter here? Why not.
      if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
        throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
      }

      hunK = mgrsString.substring(i, i += 2);

      var set = get100kSetForZone(zoneNumber);

      var east100k = getEastingFromChar(hunK.charAt(0), set);
      var north100k = getNorthingFromChar(hunK.charAt(1), set);

      // We have a bug where the northing may be 2000000 too low.
      // How
      // do we know when to roll over?

      while (north100k < getMinNorthing(zoneLetter)) {
        north100k += 2000000;
      }

      // calculate the char index for easting/northing separator
      var remainder = length - i;

      if (remainder % 2 !== 0) {
        throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
      }

      var sep = remainder / 2;

      var sepEasting = 0.0;
      var sepNorthing = 0.0;
      var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
      if (sep > 0) {
        accuracyBonus = 100000.0 / Math.pow(10, sep);
        sepEastingString = mgrsString.substring(i, i + sep);
        sepEasting = parseFloat(sepEastingString) * accuracyBonus;
        sepNorthingString = mgrsString.substring(i + sep);
        sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
      }

      easting = sepEasting + east100k;
      northing = sepNorthing + north100k;

      return {
        easting: easting,
        northing: northing,
        zoneLetter: zoneLetter,
        zoneNumber: zoneNumber,
        accuracy: accuracyBonus
      };
    }

    /**
     * Given the first letter from a two-letter MGRS 100k zone, and given the
     * MGRS table set for the zone number, figure out the easting value that
     * should be added to the other, secondary easting value.
     *
     * @private
     * @param {char} e The first letter from a two-letter MGRS 100´k zone.
     * @param {number} set The MGRS table set for the zone number.
     * @return {number} The easting value for the given letter and set.
     */
    function getEastingFromChar(e, set) {
      // colOrigin is the letter at the origin of the set for the
      // column
      var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
      var eastingValue = 100000.0;
      var rewindMarker = false;

      while (curCol !== e.charCodeAt(0)) {
        curCol++;
        if (curCol === I) {
          curCol++;
        }
        if (curCol === O) {
          curCol++;
        }
        if (curCol > Z$1) {
          if (rewindMarker) {
            throw ("Bad character: " + e);
          }
          curCol = A;
          rewindMarker = true;
        }
        eastingValue += 100000.0;
      }

      return eastingValue;
    }

    /**
     * Given the second letter from a two-letter MGRS 100k zone, and given the
     * MGRS table set for the zone number, figure out the northing value that
     * should be added to the other, secondary northing value. You have to
     * remember that Northings are determined from the equator, and the vertical
     * cycle of letters mean a 2000000 additional northing meters. This happens
     * approx. every 18 degrees of latitude. This method does *NOT* count any
     * additional northings. You have to figure out how many 2000000 meters need
     * to be added for the zone letter of the MGRS coordinate.
     *
     * @private
     * @param {char} n Second letter of the MGRS 100k zone
     * @param {number} set The MGRS table set number, which is dependent on the
     *     UTM zone number.
     * @return {number} The northing value for the given letter and set.
     */
    function getNorthingFromChar(n, set) {

      if (n > 'V') {
        throw ("MGRSPoint given invalid Northing " + n);
      }

      // rowOrigin is the letter at the origin of the set for the
      // column
      var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
      var northingValue = 0.0;
      var rewindMarker = false;

      while (curRow !== n.charCodeAt(0)) {
        curRow++;
        if (curRow === I) {
          curRow++;
        }
        if (curRow === O) {
          curRow++;
        }
        // fixing a bug making whole application hang in this loop
        // when 'n' is a wrong character
        if (curRow > V) {
          if (rewindMarker) { // making sure that this loop ends
            throw ("Bad character: " + n);
          }
          curRow = A;
          rewindMarker = true;
        }
        northingValue += 100000.0;
      }

      return northingValue;
    }

    /**
     * The function getMinNorthing returns the minimum northing value of a MGRS
     * zone.
     *
     * Ported from Geotrans' c Lattitude_Band_Value structure table.
     *
     * @private
     * @param {char} zoneLetter The MGRS zone to get the min northing for.
     * @return {number}
     */
    function getMinNorthing(zoneLetter) {
      var northing;
      switch (zoneLetter) {
      case 'C':
        northing = 1100000.0;
        break;
      case 'D':
        northing = 2000000.0;
        break;
      case 'E':
        northing = 2800000.0;
        break;
      case 'F':
        northing = 3700000.0;
        break;
      case 'G':
        northing = 4600000.0;
        break;
      case 'H':
        northing = 5500000.0;
        break;
      case 'J':
        northing = 6400000.0;
        break;
      case 'K':
        northing = 7300000.0;
        break;
      case 'L':
        northing = 8200000.0;
        break;
      case 'M':
        northing = 9100000.0;
        break;
      case 'N':
        northing = 0.0;
        break;
      case 'P':
        northing = 800000.0;
        break;
      case 'Q':
        northing = 1700000.0;
        break;
      case 'R':
        northing = 2600000.0;
        break;
      case 'S':
        northing = 3500000.0;
        break;
      case 'T':
        northing = 4400000.0;
        break;
      case 'U':
        northing = 5300000.0;
        break;
      case 'V':
        northing = 6200000.0;
        break;
      case 'W':
        northing = 7000000.0;
        break;
      case 'X':
        northing = 7900000.0;
        break;
      default:
        northing = -1.0;
      }
      if (northing >= 0.0) {
        return northing;
      }
      else {
        throw ("Invalid zone letter: " + zoneLetter);
      }

    }

    function Point(x, y, z) {
      if (!(this instanceof Point)) {
        return new Point(x, y, z);
      }
      if (Array.isArray(x)) {
        this.x = x[0];
        this.y = x[1];
        this.z = x[2] || 0.0;
      } else if(typeof x === 'object') {
        this.x = x.x;
        this.y = x.y;
        this.z = x.z || 0.0;
      } else if (typeof x === 'string' && typeof y === 'undefined') {
        var coords = x.split(',');
        this.x = parseFloat(coords[0], 10);
        this.y = parseFloat(coords[1], 10);
        this.z = parseFloat(coords[2], 10) || 0.0;
      } else {
        this.x = x;
        this.y = y;
        this.z = z || 0.0;
      }
      console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
    }

    Point.fromMGRS = function(mgrsStr) {
      return new Point(toPoint(mgrsStr));
    };
    Point.prototype.toMGRS = function(accuracy) {
      return forward$1([this.x, this.y], accuracy);
    };

    var C00 = 1;
    var C02 = 0.25;
    var C04 = 0.046875;
    var C06 = 0.01953125;
    var C08 = 0.01068115234375;
    var C22 = 0.75;
    var C44 = 0.46875;
    var C46 = 0.01302083333333333333;
    var C48 = 0.00712076822916666666;
    var C66 = 0.36458333333333333333;
    var C68 = 0.00569661458333333333;
    var C88 = 0.3076171875;

    function pj_enfn(es) {
      var en = [];
      en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
      en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
      var t = es * es;
      en[2] = t * (C44 - es * (C46 + es * C48));
      t *= es;
      en[3] = t * (C66 - es * C68);
      en[4] = t * es * C88;
      return en;
    }

    function pj_mlfn(phi, sphi, cphi, en) {
      cphi *= sphi;
      sphi *= sphi;
      return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
    }

    var MAX_ITER = 20;

    function pj_inv_mlfn(arg, es, en) {
      var k = 1 / (1 - es);
      var phi = arg;
      for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
        var s = Math.sin(phi);
        var t = 1 - es * s * s;
        //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
        //phi -= t * (t * Math.sqrt(t)) * k;
        t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
        phi -= t;
        if (Math.abs(t) < EPSLN) {
          return phi;
        }
      }
      //..reportError("cass:pj_inv_mlfn: Convergence error");
      return phi;
    }

    // Heavily based on this tmerc projection implementation

    function init$3() {
      this.x0 = this.x0 !== undefined ? this.x0 : 0;
      this.y0 = this.y0 !== undefined ? this.y0 : 0;
      this.long0 = this.long0 !== undefined ? this.long0 : 0;
      this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

      if (this.es) {
        this.en = pj_enfn(this.es);
        this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
      }
    }

    /**
        Transverse Mercator Forward  - long/lat to x/y
        long/lat in radians
      */
    function forward$2(p) {
      var lon = p.x;
      var lat = p.y;

      var delta_lon = adjust_lon(lon - this.long0);
      var con;
      var x, y;
      var sin_phi = Math.sin(lat);
      var cos_phi = Math.cos(lat);

      if (!this.es) {
        var b = cos_phi * Math.sin(delta_lon);

        if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
          return (93);
        }
        else {
          x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
          y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
          b = Math.abs(y);

          if (b >= 1) {
            if ((b - 1) > EPSLN) {
              return (93);
            }
            else {
              y = 0;
            }
          }
          else {
            y = Math.acos(y);
          }

          if (lat < 0) {
            y = -y;
          }

          y = this.a * this.k0 * (y - this.lat0) + this.y0;
        }
      }
      else {
        var al = cos_phi * delta_lon;
        var als = Math.pow(al, 2);
        var c = this.ep2 * Math.pow(cos_phi, 2);
        var cs = Math.pow(c, 2);
        var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
        var t = Math.pow(tq, 2);
        var ts = Math.pow(t, 2);
        con = 1 - this.es * Math.pow(sin_phi, 2);
        al = al / Math.sqrt(con);
        var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);

        x = this.a * (this.k0 * al * (1 +
          als / 6 * (1 - t + c +
          als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
          als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
          this.x0;

        y = this.a * (this.k0 * (ml - this.ml0 +
          sin_phi * delta_lon * al / 2 * (1 +
          als / 12 * (5 - t + 9 * c + 4 * cs +
          als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
          als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
          this.y0;
      }

      p.x = x;
      p.y = y;

      return p;
    }

    /**
        Transverse Mercator Inverse  -  x/y to long/lat
      */
    function inverse$2(p) {
      var con, phi;
      var lat, lon;
      var x = (p.x - this.x0) * (1 / this.a);
      var y = (p.y - this.y0) * (1 / this.a);

      if (!this.es) {
        var f = Math.exp(x / this.k0);
        var g = 0.5 * (f - 1 / f);
        var temp = this.lat0 + y / this.k0;
        var h = Math.cos(temp);
        con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
        lat = Math.asin(con);

        if (y < 0) {
          lat = -lat;
        }

        if ((g === 0) && (h === 0)) {
          lon = 0;
        }
        else {
          lon = adjust_lon(Math.atan2(g, h) + this.long0);
        }
      }
      else { // ellipsoidal form
        con = this.ml0 + y / this.k0;
        phi = pj_inv_mlfn(con, this.es, this.en);

        if (Math.abs(phi) < HALF_PI) {
          var sin_phi = Math.sin(phi);
          var cos_phi = Math.cos(phi);
          var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
          var c = this.ep2 * Math.pow(cos_phi, 2);
          var cs = Math.pow(c, 2);
          var t = Math.pow(tan_phi, 2);
          var ts = Math.pow(t, 2);
          con = 1 - this.es * Math.pow(sin_phi, 2);
          var d = x * Math.sqrt(con) / this.k0;
          var ds = Math.pow(d, 2);
          con = con * tan_phi;

          lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
            ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
            ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
            ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

          lon = adjust_lon(this.long0 + (d * (1 -
            ds / 6 * (1 + 2 * t + c -
            ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
            ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
        }
        else {
          lat = HALF_PI * sign(y);
          lon = 0;
        }
      }

      p.x = lon;
      p.y = lat;

      return p;
    }

    var names$3 = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
    var tmerc = {
      init: init$3,
      forward: forward$2,
      inverse: inverse$2,
      names: names$3
    };

    function sinh(x) {
      var r = Math.exp(x);
      r = (r - 1 / r) / 2;
      return r;
    }

    function hypot(x, y) {
      x = Math.abs(x);
      y = Math.abs(y);
      var a = Math.max(x, y);
      var b = Math.min(x, y) / (a ? a : 1);

      return a * Math.sqrt(1 + Math.pow(b, 2));
    }

    function log1py(x) {
      var y = 1 + x;
      var z = y - 1;

      return z === 0 ? x : x * Math.log(y) / z;
    }

    function asinhy(x) {
      var y = Math.abs(x);
      y = log1py(y * (1 + y / (hypot(1, y) + 1)));

      return x < 0 ? -y : y;
    }

    function gatg(pp, B) {
      var cos_2B = 2 * Math.cos(2 * B);
      var i = pp.length - 1;
      var h1 = pp[i];
      var h2 = 0;
      var h;

      while (--i >= 0) {
        h = -h2 + cos_2B * h1 + pp[i];
        h2 = h1;
        h1 = h;
      }

      return (B + h * Math.sin(2 * B));
    }

    function clens(pp, arg_r) {
      var r = 2 * Math.cos(arg_r);
      var i = pp.length - 1;
      var hr1 = pp[i];
      var hr2 = 0;
      var hr;

      while (--i >= 0) {
        hr = -hr2 + r * hr1 + pp[i];
        hr2 = hr1;
        hr1 = hr;
      }

      return Math.sin(arg_r) * hr;
    }

    function cosh(x) {
      var r = Math.exp(x);
      r = (r + 1 / r) / 2;
      return r;
    }

    function clens_cmplx(pp, arg_r, arg_i) {
      var sin_arg_r = Math.sin(arg_r);
      var cos_arg_r = Math.cos(arg_r);
      var sinh_arg_i = sinh(arg_i);
      var cosh_arg_i = cosh(arg_i);
      var r = 2 * cos_arg_r * cosh_arg_i;
      var i = -2 * sin_arg_r * sinh_arg_i;
      var j = pp.length - 1;
      var hr = pp[j];
      var hi1 = 0;
      var hr1 = 0;
      var hi = 0;
      var hr2;
      var hi2;

      while (--j >= 0) {
        hr2 = hr1;
        hi2 = hi1;
        hr1 = hr;
        hi1 = hi;
        hr = -hr2 + r * hr1 - i * hi1 + pp[j];
        hi = -hi2 + i * hr1 + r * hi1;
      }

      r = sin_arg_r * cosh_arg_i;
      i = cos_arg_r * sinh_arg_i;

      return [r * hr - i * hi, r * hi + i * hr];
    }

    // Heavily based on this etmerc projection implementation

    function init$4() {
      if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
        throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
      }
      if (this.approx) {
        // When '+approx' is set, use tmerc instead
        tmerc.init.apply(this);
        this.forward = tmerc.forward;
        this.inverse = tmerc.inverse;
      }

      this.x0 = this.x0 !== undefined ? this.x0 : 0;
      this.y0 = this.y0 !== undefined ? this.y0 : 0;
      this.long0 = this.long0 !== undefined ? this.long0 : 0;
      this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

      this.cgb = [];
      this.cbg = [];
      this.utg = [];
      this.gtu = [];

      var f = this.es / (1 + Math.sqrt(1 - this.es));
      var n = f / (2 - f);
      var np = n;

      this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
      this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

      np = np * n;
      this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
      this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

      np = np * n;
      this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
      this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

      np = np * n;
      this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
      this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

      np = np * n;
      this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
      this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

      np = np * n;
      this.cgb[5] = np * (601676 / 22275);
      this.cbg[5] = np * (444337 / 155925);

      np = Math.pow(n, 2);
      this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

      this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
      this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

      this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
      this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

      np = np * n;
      this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
      this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

      np = np * n;
      this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
      this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

      np = np * n;
      this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
      this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

      np = np * n;
      this.utg[5] = np * (-20648693 / 638668800);
      this.gtu[5] = np * (212378941 / 319334400);

      var Z = gatg(this.cbg, this.lat0);
      this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
    }

    function forward$3(p) {
      var Ce = adjust_lon(p.x - this.long0);
      var Cn = p.y;

      Cn = gatg(this.cbg, Cn);
      var sin_Cn = Math.sin(Cn);
      var cos_Cn = Math.cos(Cn);
      var sin_Ce = Math.sin(Ce);
      var cos_Ce = Math.cos(Ce);

      Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
      Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
      Ce = asinhy(Math.tan(Ce));

      var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);

      Cn = Cn + tmp[0];
      Ce = Ce + tmp[1];

      var x;
      var y;

      if (Math.abs(Ce) <= 2.623395162778) {
        x = this.a * (this.Qn * Ce) + this.x0;
        y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
      }
      else {
        x = Infinity;
        y = Infinity;
      }

      p.x = x;
      p.y = y;

      return p;
    }

    function inverse$3(p) {
      var Ce = (p.x - this.x0) * (1 / this.a);
      var Cn = (p.y - this.y0) * (1 / this.a);

      Cn = (Cn - this.Zb) / this.Qn;
      Ce = Ce / this.Qn;

      var lon;
      var lat;

      if (Math.abs(Ce) <= 2.623395162778) {
        var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);

        Cn = Cn + tmp[0];
        Ce = Ce + tmp[1];
        Ce = Math.atan(sinh(Ce));

        var sin_Cn = Math.sin(Cn);
        var cos_Cn = Math.cos(Cn);
        var sin_Ce = Math.sin(Ce);
        var cos_Ce = Math.cos(Ce);

        Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
        Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

        lon = adjust_lon(Ce + this.long0);
        lat = gatg(this.cgb, Cn);
      }
      else {
        lon = Infinity;
        lat = Infinity;
      }

      p.x = lon;
      p.y = lat;

      return p;
    }

    var names$4 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
    var etmerc = {
      init: init$4,
      forward: forward$3,
      inverse: inverse$3,
      names: names$4
    };

    function adjust_zone(zone, lon) {
      if (zone === undefined) {
        zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

        if (zone < 0) {
          return 0;
        } else if (zone > 60) {
          return 60;
        }
      }
      return zone;
    }

    var dependsOn = 'etmerc';


    function init$5() {
      var zone = adjust_zone(this.zone, this.long0);
      if (zone === undefined) {
        throw new Error('unknown utm zone');
      }
      this.lat0 = 0;
      this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R;
      this.x0 = 500000;
      this.y0 = this.utmSouth ? 10000000 : 0;
      this.k0 = 0.9996;

      etmerc.init.apply(this);
      this.forward = etmerc.forward;
      this.inverse = etmerc.inverse;
    }

    var names$5 = ["Universal Transverse Mercator System", "utm"];
    var utm = {
      init: init$5,
      names: names$5,
      dependsOn: dependsOn
    };

    function srat(esinp, exp) {
      return (Math.pow((1 - esinp) / (1 + esinp), exp));
    }

    var MAX_ITER$1 = 20;

    function init$6() {
      var sphi = Math.sin(this.lat0);
      var cphi = Math.cos(this.lat0);
      cphi *= cphi;
      this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
      this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
      this.phic0 = Math.asin(sphi / this.C);
      this.ratexp = 0.5 * this.C * this.e;
      this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
    }

    function forward$4(p) {
      var lon = p.x;
      var lat = p.y;

      p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
      p.x = this.C * lon;
      return p;
    }

    function inverse$4(p) {
      var DEL_TOL = 1e-14;
      var lon = p.x / this.C;
      var lat = p.y;
      var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
      for (var i = MAX_ITER$1; i > 0; --i) {
        lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
        if (Math.abs(lat - p.y) < DEL_TOL) {
          break;
        }
        p.y = lat;
      }
      /* convergence failed */
      if (!i) {
        return null;
      }
      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$6 = ["gauss"];
    var gauss = {
      init: init$6,
      forward: forward$4,
      inverse: inverse$4,
      names: names$6
    };

    function init$7() {
      gauss.init.apply(this);
      if (!this.rc) {
        return;
      }
      this.sinc0 = Math.sin(this.phic0);
      this.cosc0 = Math.cos(this.phic0);
      this.R2 = 2 * this.rc;
      if (!this.title) {
        this.title = "Oblique Stereographic Alternative";
      }
    }

    function forward$5(p) {
      var sinc, cosc, cosl, k;
      p.x = adjust_lon(p.x - this.long0);
      gauss.forward.apply(this, [p]);
      sinc = Math.sin(p.y);
      cosc = Math.cos(p.y);
      cosl = Math.cos(p.x);
      k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
      p.x = k * cosc * Math.sin(p.x);
      p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
      p.x = this.a * p.x + this.x0;
      p.y = this.a * p.y + this.y0;
      return p;
    }

    function inverse$5(p) {
      var sinc, cosc, lon, lat, rho;
      p.x = (p.x - this.x0) / this.a;
      p.y = (p.y - this.y0) / this.a;

      p.x /= this.k0;
      p.y /= this.k0;
      if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
        var c = 2 * Math.atan2(rho, this.R2);
        sinc = Math.sin(c);
        cosc = Math.cos(c);
        lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
        lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
      }
      else {
        lat = this.phic0;
        lon = 0;
      }

      p.x = lon;
      p.y = lat;
      gauss.inverse.apply(this, [p]);
      p.x = adjust_lon(p.x + this.long0);
      return p;
    }

    var names$7 = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative","Double_Stereographic"];
    var sterea = {
      init: init$7,
      forward: forward$5,
      inverse: inverse$5,
      names: names$7
    };

    function ssfn_(phit, sinphi, eccen) {
      sinphi *= eccen;
      return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
    }

    function init$8() {
      this.coslat0 = Math.cos(this.lat0);
      this.sinlat0 = Math.sin(this.lat0);
      if (this.sphere) {
        if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
          this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
        }
      }
      else {
        if (Math.abs(this.coslat0) <= EPSLN) {
          if (this.lat0 > 0) {
            //North pole
            //trace('stere:north pole');
            this.con = 1;
          }
          else {
            //South pole
            //trace('stere:south pole');
            this.con = -1;
          }
        }
        this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
        if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
          this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
        }
        this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
        this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
        this.cosX0 = Math.cos(this.X0);
        this.sinX0 = Math.sin(this.X0);
      }
    }

    // Stereographic forward equations--mapping lat,long to x,y
    function forward$6(p) {
      var lon = p.x;
      var lat = p.y;
      var sinlat = Math.sin(lat);
      var coslat = Math.cos(lat);
      var A, X, sinX, cosX, ts, rh;
      var dlon = adjust_lon(lon - this.long0);

      if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
        //case of the origine point
        //trace('stere:this is the origin point');
        p.x = NaN;
        p.y = NaN;
        return p;
      }
      if (this.sphere) {
        //trace('stere:sphere case');
        A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
        p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
        p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
        return p;
      }
      else {
        X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
        cosX = Math.cos(X);
        sinX = Math.sin(X);
        if (Math.abs(this.coslat0) <= EPSLN) {
          ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
          rh = 2 * this.a * this.k0 * ts / this.cons;
          p.x = this.x0 + rh * Math.sin(lon - this.long0);
          p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
          //trace(p.toString());
          return p;
        }
        else if (Math.abs(this.sinlat0) < EPSLN) {
          //Eq
          //trace('stere:equateur');
          A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
          p.y = A * sinX;
        }
        else {
          //other case
          //trace('stere:normal case');
          A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
          p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
        }
        p.x = A * cosX * Math.sin(dlon) + this.x0;
      }
      //trace(p.toString());
      return p;
    }

    //* Stereographic inverse equations--mapping x,y to lat/long
    function inverse$6(p) {
      p.x -= this.x0;
      p.y -= this.y0;
      var lon, lat, ts, ce, Chi;
      var rh = Math.sqrt(p.x * p.x + p.y * p.y);
      if (this.sphere) {
        var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
        lon = this.long0;
        lat = this.lat0;
        if (rh <= EPSLN) {
          p.x = lon;
          p.y = lat;
          return p;
        }
        lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
        if (Math.abs(this.coslat0) < EPSLN) {
          if (this.lat0 > 0) {
            lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
          }
          else {
            lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
          }
        }
        else {
          lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
        }
        p.x = lon;
        p.y = lat;
        return p;
      }
      else {
        if (Math.abs(this.coslat0) <= EPSLN) {
          if (rh <= EPSLN) {
            lat = this.lat0;
            lon = this.long0;
            p.x = lon;
            p.y = lat;
            //trace(p.toString());
            return p;
          }
          p.x *= this.con;
          p.y *= this.con;
          ts = rh * this.cons / (2 * this.a * this.k0);
          lat = this.con * phi2z(this.e, ts);
          lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
        }
        else {
          ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
          lon = this.long0;
          if (rh <= EPSLN) {
            Chi = this.X0;
          }
          else {
            Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
            lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
          }
          lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
        }
      }
      p.x = lon;
      p.y = lat;

      //trace(p.toString());
      return p;

    }

    var names$8 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
    var stere = {
      init: init$8,
      forward: forward$6,
      inverse: inverse$6,
      names: names$8,
      ssfn_: ssfn_
    };

    /*
      references:
        Formules et constantes pour le Calcul pour la
        projection cylindrique conforme à axe oblique et pour la transformation entre
        des systèmes de référence.
        http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
      */

    function init$9() {
      var phy0 = this.lat0;
      this.lambda0 = this.long0;
      var sinPhy0 = Math.sin(phy0);
      var semiMajorAxis = this.a;
      var invF = this.rf;
      var flattening = 1 / invF;
      var e2 = 2 * flattening - Math.pow(flattening, 2);
      var e = this.e = Math.sqrt(e2);
      this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
      this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
      this.b0 = Math.asin(sinPhy0 / this.alpha);
      var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
      var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
      var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
      this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
    }

    function forward$7(p) {
      var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
      var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
      var S = -this.alpha * (Sa1 + Sa2) + this.K;

      // spheric latitude
      var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

      // spheric longitude
      var I = this.alpha * (p.x - this.lambda0);

      // psoeudo equatorial rotation
      var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

      var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

      p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
      p.x = this.R * rotI + this.x0;
      return p;
    }

    function inverse$7(p) {
      var Y = p.x - this.x0;
      var X = p.y - this.y0;

      var rotI = Y / this.R;
      var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

      var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
      var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

      var lambda = this.lambda0 + I / this.alpha;

      var S = 0;
      var phy = b;
      var prevPhy = -1000;
      var iteration = 0;
      while (Math.abs(phy - prevPhy) > 0.0000001) {
        if (++iteration > 20) {
          //...reportError("omercFwdInfinity");
          return;
        }
        //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
        S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
        prevPhy = phy;
        phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
      }

      p.x = lambda;
      p.y = phy;
      return p;
    }

    var names$9 = ["somerc"];
    var somerc = {
      init: init$9,
      forward: forward$7,
      inverse: inverse$7,
      names: names$9
    };

    var TOL = 1e-7;

    function isTypeA(P) {
      var typeAProjections = ['Hotine_Oblique_Mercator','Hotine_Oblique_Mercator_Azimuth_Natural_Origin'];
      var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
      
      return 'no_uoff' in P || 'no_off' in P || typeAProjections.indexOf(projectionName) !== -1;
    }


    /* Initialize the Oblique Mercator  projection
        ------------------------------------------*/
    function init$a() {  
      var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma = 0,
        gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0, AB;
      
      // only Type A uses the no_off or no_uoff property
      // https://github.com/OSGeo/proj.4/issues/104
      this.no_off = isTypeA(this);
      this.no_rot = 'no_rot' in this;
      
      var alp = false;
      if ("alpha" in this) {
        alp = true;
      }

      var gam = false;
      if ("rectified_grid_angle" in this) {
        gam = true;
      }

      if (alp) {
        alpha_c = this.alpha;
      }
      
      if (gam) {
        gamma = (this.rectified_grid_angle * D2R);
      }
      
      if (alp || gam) {
        lamc = this.longc;
      } else {
        lam1 = this.long1;
        phi1 = this.lat1;
        lam2 = this.long2;
        phi2 = this.lat2;
        
        if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL ||
            Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL ||
            Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
          throw new Error();
        }
      }
      
      var one_es = 1.0 - this.es;
      com = Math.sqrt(one_es);
      
      if (Math.abs(this.lat0) > EPSLN) {
        sinph0 = Math.sin(this.lat0);
        cosph0 = Math.cos(this.lat0);
        con = 1 - this.es * sinph0 * sinph0;
        this.B = cosph0 * cosph0;
        this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
        this.A = this.B * this.k0 * com / con;
        D = this.B * com / (cosph0 * Math.sqrt(con));
        F = D * D -1;
        
        if (F <= 0) {
          F = 0;
        } else {
          F = Math.sqrt(F);
          if (this.lat0 < 0) {
            F = -F;
          }
        }
        
        this.E = F += D;
        this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
      } else {
        this.B = 1 / com;
        this.A = this.k0;
        this.E = D = F = 1;
      }
      
      if (alp || gam) {
        if (alp) {
          gamma0 = Math.asin(Math.sin(alpha_c) / D);
          if (!gam) {
            gamma = alpha_c;
          }
        } else {
          gamma0 = gamma;
          alpha_c = Math.asin(D * Math.sin(gamma0));
        }
        this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
      } else {
        H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
        L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
        F = this.E / H;
        p = (L - H) / (L + H);
        J = this.E * this.E;
        J = (J - L * H) / (J + L * H);
        con = lam1 - lam2;
        
        if (con < -Math.pi) {
          lam2 -=TWO_PI;
        } else if (con > Math.pi) {
          lam2 += TWO_PI;
        }
        
        this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
        gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
        gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
      }
      
      this.singam = Math.sin(gamma0);
      this.cosgam = Math.cos(gamma0);
      this.sinrot = Math.sin(gamma);
      this.cosrot = Math.cos(gamma);
      
      this.rB = 1 / this.B;
      this.ArB = this.A * this.rB;
      this.BrA = 1 / this.ArB;
      AB = this.A * this.B;
      
      if (this.no_off) {
        this.u_0 = 0;
      } else {
        this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
        
        if (this.lat0 < 0) {
          this.u_0 = - this.u_0;
        }  
      }
        
      F = 0.5 * gamma0;
      this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
      this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
    }


    /* Oblique Mercator forward equations--mapping lat,long to x,y
        ----------------------------------------------------------*/
    function forward$8(p) {
      var coords = {};
      var S, T, U, V, W, temp, u, v;
      p.x = p.x - this.lam0;
      
      if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
        W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);
        
        temp = 1 / W;
        S = 0.5 * (W - temp);
        T = 0.5 * (W + temp);
        V = Math.sin(this.B * p.x);
        U = (S * this.singam - V * this.cosgam) / T;
            
        if (Math.abs(Math.abs(U) - 1.0) < EPSLN) {
          throw new Error();
        }
        
        v = 0.5 * this.ArB * Math.log((1 - U)/(1 + U));
        temp = Math.cos(this.B * p.x);
        
        if (Math.abs(temp) < TOL) {
          u = this.A * p.x;
        } else {
          u = this.ArB * Math.atan2((S * this.cosgam + V * this.singam), temp);
        }    
      } else {
        v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
        u = this.ArB * p.y;
      }
         
      if (this.no_rot) {
        coords.x = u;
        coords.y = v;
      } else {
        u -= this.u_0;
        coords.x = v * this.cosrot + u * this.sinrot;
        coords.y = u * this.cosrot - v * this.sinrot;
      }
      
      coords.x = (this.a * coords.x + this.x0);
      coords.y = (this.a * coords.y + this.y0);
      
      return coords;
    }

    function inverse$8(p) {
      var u, v, Qp, Sp, Tp, Vp, Up;
      var coords = {};
      
      p.x = (p.x - this.x0) * (1.0 / this.a);
      p.y = (p.y - this.y0) * (1.0 / this.a);

      if (this.no_rot) {
        v = p.y;
        u = p.x;
      } else {
        v = p.x * this.cosrot - p.y * this.sinrot;
        u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
      }
      
      Qp = Math.exp(-this.BrA * v);
      Sp = 0.5 * (Qp - 1 / Qp);
      Tp = 0.5 * (Qp + 1 / Qp);
      Vp = Math.sin(this.BrA * u);
      Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
      
      if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
        coords.x = 0;
        coords.y = Up < 0 ? -HALF_PI : HALF_PI;
      } else {
        coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
        coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
        
        if (coords.y === Infinity) {
          throw new Error();
        }
            
        coords.x = -this.rB * Math.atan2((Sp * this.cosgam - Vp * this.singam), Math.cos(this.BrA * u));
      }
      
      coords.x += this.lam0;
      
      return coords;
    }

    var names$a = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
    var omerc = {
      init: init$a,
      forward: forward$8,
      inverse: inverse$8,
      names: names$a
    };

    function init$b() {
      
      //double lat0;                    /* the reference latitude               */
      //double long0;                   /* the reference longitude              */
      //double lat1;                    /* first standard parallel              */
      //double lat2;                    /* second standard parallel             */
      //double r_maj;                   /* major axis                           */
      //double r_min;                   /* minor axis                           */
      //double false_east;              /* x offset in meters                   */
      //double false_north;             /* y offset in meters                   */
      
      //the above value can be set with proj4.defs
      //example: proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

      if (!this.lat2) {
        this.lat2 = this.lat1;
      } //if lat2 is not defined
      if (!this.k0) {
        this.k0 = 1;
      }
      this.x0 = this.x0 || 0;
      this.y0 = this.y0 || 0;
      // Standard Parallels cannot be equal and on opposite sides of the equator
      if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
        return;
      }

      var temp = this.b / this.a;
      this.e = Math.sqrt(1 - temp * temp);

      var sin1 = Math.sin(this.lat1);
      var cos1 = Math.cos(this.lat1);
      var ms1 = msfnz(this.e, sin1, cos1);
      var ts1 = tsfnz(this.e, this.lat1, sin1);

      var sin2 = Math.sin(this.lat2);
      var cos2 = Math.cos(this.lat2);
      var ms2 = msfnz(this.e, sin2, cos2);
      var ts2 = tsfnz(this.e, this.lat2, sin2);

      var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

      if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
        this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
      }
      else {
        this.ns = sin1;
      }
      if (isNaN(this.ns)) {
        this.ns = sin1;
      }
      this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
      this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
      if (!this.title) {
        this.title = "Lambert Conformal Conic";
      }
    }

    // Lambert Conformal conic forward equations--mapping lat,long to x,y
    // -----------------------------------------------------------------
    function forward$9(p) {

      var lon = p.x;
      var lat = p.y;

      // singular cases :
      if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
        lat = sign(lat) * (HALF_PI - 2 * EPSLN);
      }

      var con = Math.abs(Math.abs(lat) - HALF_PI);
      var ts, rh1;
      if (con > EPSLN) {
        ts = tsfnz(this.e, lat, Math.sin(lat));
        rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
      }
      else {
        con = lat * this.ns;
        if (con <= 0) {
          return null;
        }
        rh1 = 0;
      }
      var theta = this.ns * adjust_lon(lon - this.long0);
      p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
      p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

      return p;
    }

    // Lambert Conformal Conic inverse equations--mapping x,y to lat/long
    // -----------------------------------------------------------------
    function inverse$9(p) {

      var rh1, con, ts;
      var lat, lon;
      var x = (p.x - this.x0) / this.k0;
      var y = (this.rh - (p.y - this.y0) / this.k0);
      if (this.ns > 0) {
        rh1 = Math.sqrt(x * x + y * y);
        con = 1;
      }
      else {
        rh1 = -Math.sqrt(x * x + y * y);
        con = -1;
      }
      var theta = 0;
      if (rh1 !== 0) {
        theta = Math.atan2((con * x), (con * y));
      }
      if ((rh1 !== 0) || (this.ns > 0)) {
        con = 1 / this.ns;
        ts = Math.pow((rh1 / (this.a * this.f0)), con);
        lat = phi2z(this.e, ts);
        if (lat === -9999) {
          return null;
        }
      }
      else {
        lat = -HALF_PI;
      }
      lon = adjust_lon(theta / this.ns + this.long0);

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$b = [
      "Lambert Tangential Conformal Conic Projection",
      "Lambert_Conformal_Conic",
      "Lambert_Conformal_Conic_1SP",
      "Lambert_Conformal_Conic_2SP",
      "lcc"
    ];

    var lcc = {
      init: init$b,
      forward: forward$9,
      inverse: inverse$9,
      names: names$b
    };

    function init$c() {
      this.a = 6377397.155;
      this.es = 0.006674372230614;
      this.e = Math.sqrt(this.es);
      if (!this.lat0) {
        this.lat0 = 0.863937979737193;
      }
      if (!this.long0) {
        this.long0 = 0.7417649320975901 - 0.308341501185665;
      }
      /* if scale not set default to 0.9999 */
      if (!this.k0) {
        this.k0 = 0.9999;
      }
      this.s45 = 0.785398163397448; /* 45 */
      this.s90 = 2 * this.s45;
      this.fi0 = this.lat0;
      this.e2 = this.es;
      this.e = Math.sqrt(this.e2);
      this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
      this.uq = 1.04216856380474;
      this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
      this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
      this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
      this.k1 = this.k0;
      this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
      this.s0 = 1.37008346281555;
      this.n = Math.sin(this.s0);
      this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
      this.ad = this.s90 - this.uq;
    }

    /* ellipsoid */
    /* calculate xy from lat/lon */
    /* Constants, identical to inverse transform function */
    function forward$a(p) {
      var gfi, u, deltav, s, d, eps, ro;
      var lon = p.x;
      var lat = p.y;
      var delta_lon = adjust_lon(lon - this.long0);
      /* Transformation */
      gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
      u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
      deltav = -delta_lon * this.alfa;
      s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
      d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
      eps = this.n * d;
      ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
      p.y = ro * Math.cos(eps) / 1;
      p.x = ro * Math.sin(eps) / 1;

      if (!this.czech) {
        p.y *= -1;
        p.x *= -1;
      }
      return (p);
    }

    /* calculate lat/lon from xy */
    function inverse$a(p) {
      var u, deltav, s, d, eps, ro, fi1;
      var ok;

      /* Transformation */
      /* revert y, x*/
      var tmp = p.x;
      p.x = p.y;
      p.y = tmp;
      if (!this.czech) {
        p.y *= -1;
        p.x *= -1;
      }
      ro = Math.sqrt(p.x * p.x + p.y * p.y);
      eps = Math.atan2(p.y, p.x);
      d = eps / Math.sin(this.s0);
      s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
      u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
      deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
      p.x = this.long0 - deltav / this.alfa;
      fi1 = u;
      ok = 0;
      var iter = 0;
      do {
        p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
        if (Math.abs(fi1 - p.y) < 0.0000000001) {
          ok = 1;
        }
        fi1 = p.y;
        iter += 1;
      } while (ok === 0 && iter < 15);
      if (iter >= 15) {
        return null;
      }

      return (p);
    }

    var names$c = ["Krovak", "krovak"];
    var krovak = {
      init: init$c,
      forward: forward$a,
      inverse: inverse$a,
      names: names$c
    };

    function mlfn(e0, e1, e2, e3, phi) {
      return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
    }

    function e0fn(x) {
      return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
    }

    function e1fn(x) {
      return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
    }

    function e2fn(x) {
      return (0.05859375 * x * x * (1 + 0.75 * x));
    }

    function e3fn(x) {
      return (x * x * x * (35 / 3072));
    }

    function gN(a, e, sinphi) {
      var temp = e * sinphi;
      return a / Math.sqrt(1 - temp * temp);
    }

    function adjust_lat(x) {
      return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
    }

    function imlfn(ml, e0, e1, e2, e3) {
      var phi;
      var dphi;

      phi = ml / e0;
      for (var i = 0; i < 15; i++) {
        dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
        phi += dphi;
        if (Math.abs(dphi) <= 0.0000000001) {
          return phi;
        }
      }

      //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
      return NaN;
    }

    function init$d() {
      if (!this.sphere) {
        this.e0 = e0fn(this.es);
        this.e1 = e1fn(this.es);
        this.e2 = e2fn(this.es);
        this.e3 = e3fn(this.es);
        this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
      }
    }

    /* Cassini forward equations--mapping lat,long to x,y
      -----------------------------------------------------------------------*/
    function forward$b(p) {

      /* Forward equations
          -----------------*/
      var x, y;
      var lam = p.x;
      var phi = p.y;
      lam = adjust_lon(lam - this.long0);

      if (this.sphere) {
        x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
        y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
      }
      else {
        //ellipsoid
        var sinphi = Math.sin(phi);
        var cosphi = Math.cos(phi);
        var nl = gN(this.a, this.e, sinphi);
        var tl = Math.tan(phi) * Math.tan(phi);
        var al = lam * Math.cos(phi);
        var asq = al * al;
        var cl = this.es * cosphi * cosphi / (1 - this.es);
        var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

        x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
        y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


      }

      p.x = x + this.x0;
      p.y = y + this.y0;
      return p;
    }

    /* Inverse equations
      -----------------*/
    function inverse$b(p) {
      p.x -= this.x0;
      p.y -= this.y0;
      var x = p.x / this.a;
      var y = p.y / this.a;
      var phi, lam;

      if (this.sphere) {
        var dd = y + this.lat0;
        phi = Math.asin(Math.sin(dd) * Math.cos(x));
        lam = Math.atan2(Math.tan(x), Math.cos(dd));
      }
      else {
        /* ellipsoid */
        var ml1 = this.ml0 / this.a + y;
        var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
        if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
          p.x = this.long0;
          p.y = HALF_PI;
          if (y < 0) {
            p.y *= -1;
          }
          return p;
        }
        var nl1 = gN(this.a, this.e, Math.sin(phi1));

        var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
        var tl1 = Math.pow(Math.tan(phi1), 2);
        var dl = x * this.a / nl1;
        var dsq = dl * dl;
        phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
        lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

      }

      p.x = adjust_lon(lam + this.long0);
      p.y = adjust_lat(phi);
      return p;

    }

    var names$d = ["Cassini", "Cassini_Soldner", "cass"];
    var cass = {
      init: init$d,
      forward: forward$b,
      inverse: inverse$b,
      names: names$d
    };

    function qsfnz(eccent, sinphi) {
      var con;
      if (eccent > 1.0e-7) {
        con = eccent * sinphi;
        return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
      }
      else {
        return (2 * sinphi);
      }
    }

    /*
      reference
        "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
        The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
      */

    var S_POLE = 1;

    var N_POLE = 2;
    var EQUIT = 3;
    var OBLIQ = 4;

    /* Initialize the Lambert Azimuthal Equal Area projection
      ------------------------------------------------------*/
    function init$e() {
      var t = Math.abs(this.lat0);
      if (Math.abs(t - HALF_PI) < EPSLN) {
        this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
      }
      else if (Math.abs(t) < EPSLN) {
        this.mode = this.EQUIT;
      }
      else {
        this.mode = this.OBLIQ;
      }
      if (this.es > 0) {
        var sinphi;

        this.qp = qsfnz(this.e, 1);
        this.mmf = 0.5 / (1 - this.es);
        this.apa = authset(this.es);
        switch (this.mode) {
        case this.N_POLE:
          this.dd = 1;
          break;
        case this.S_POLE:
          this.dd = 1;
          break;
        case this.EQUIT:
          this.rq = Math.sqrt(0.5 * this.qp);
          this.dd = 1 / this.rq;
          this.xmf = 1;
          this.ymf = 0.5 * this.qp;
          break;
        case this.OBLIQ:
          this.rq = Math.sqrt(0.5 * this.qp);
          sinphi = Math.sin(this.lat0);
          this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
          this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
          this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
          this.ymf = (this.xmf = this.rq) / this.dd;
          this.xmf *= this.dd;
          break;
        }
      }
      else {
        if (this.mode === this.OBLIQ) {
          this.sinph0 = Math.sin(this.lat0);
          this.cosph0 = Math.cos(this.lat0);
        }
      }
    }

    /* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
      -----------------------------------------------------------------------*/
    function forward$c(p) {

      /* Forward equations
          -----------------*/
      var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
      var lam = p.x;
      var phi = p.y;

      lam = adjust_lon(lam - this.long0);
      if (this.sphere) {
        sinphi = Math.sin(phi);
        cosphi = Math.cos(phi);
        coslam = Math.cos(lam);
        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
          y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
          if (y <= EPSLN) {
            return null;
          }
          y = Math.sqrt(2 / y);
          x = y * cosphi * Math.sin(lam);
          y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
        }
        else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
          if (this.mode === this.N_POLE) {
            coslam = -coslam;
          }
          if (Math.abs(phi + this.lat0) < EPSLN) {
            return null;
          }
          y = FORTPI - phi * 0.5;
          y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
          x = y * Math.sin(lam);
          y *= coslam;
        }
      }
      else {
        sinb = 0;
        cosb = 0;
        b = 0;
        coslam = Math.cos(lam);
        sinlam = Math.sin(lam);
        sinphi = Math.sin(phi);
        q = qsfnz(this.e, sinphi);
        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
          sinb = q / this.qp;
          cosb = Math.sqrt(1 - sinb * sinb);
        }
        switch (this.mode) {
        case this.OBLIQ:
          b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
          break;
        case this.EQUIT:
          b = 1 + cosb * coslam;
          break;
        case this.N_POLE:
          b = HALF_PI + phi;
          q = this.qp - q;
          break;
        case this.S_POLE:
          b = phi - HALF_PI;
          q = this.qp + q;
          break;
        }
        if (Math.abs(b) < EPSLN) {
          return null;
        }
        switch (this.mode) {
        case this.OBLIQ:
        case this.EQUIT:
          b = Math.sqrt(2 / b);
          if (this.mode === this.OBLIQ) {
            y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
          }
          else {
            y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
          }
          x = this.xmf * b * cosb * sinlam;
          break;
        case this.N_POLE:
        case this.S_POLE:
          if (q >= 0) {
            x = (b = Math.sqrt(q)) * sinlam;
            y = coslam * ((this.mode === this.S_POLE) ? b : -b);
          }
          else {
            x = y = 0;
          }
          break;
        }
      }

      p.x = this.a * x + this.x0;
      p.y = this.a * y + this.y0;
      return p;
    }

    /* Inverse equations
      -----------------*/
    function inverse$c(p) {
      p.x -= this.x0;
      p.y -= this.y0;
      var x = p.x / this.a;
      var y = p.y / this.a;
      var lam, phi, cCe, sCe, q, rho, ab;
      if (this.sphere) {
        var cosz = 0,
          rh, sinz = 0;

        rh = Math.sqrt(x * x + y * y);
        phi = rh * 0.5;
        if (phi > 1) {
          return null;
        }
        phi = 2 * Math.asin(phi);
        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
          sinz = Math.sin(phi);
          cosz = Math.cos(phi);
        }
        switch (this.mode) {
        case this.EQUIT:
          phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
          x *= sinz;
          y = cosz * rh;
          break;
        case this.OBLIQ:
          phi = (Math.abs(rh) <= EPSLN) ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
          x *= sinz * this.cosph0;
          y = (cosz - Math.sin(phi) * this.sinph0) * rh;
          break;
        case this.N_POLE:
          y = -y;
          phi = HALF_PI - phi;
          break;
        case this.S_POLE:
          phi -= HALF_PI;
          break;
        }
        lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
      }
      else {
        ab = 0;
        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
          x /= this.dd;
          y *= this.dd;
          rho = Math.sqrt(x * x + y * y);
          if (rho < EPSLN) {
            p.x = this.long0;
            p.y = this.lat0;
            return p;
          }
          sCe = 2 * Math.asin(0.5 * rho / this.rq);
          cCe = Math.cos(sCe);
          x *= (sCe = Math.sin(sCe));
          if (this.mode === this.OBLIQ) {
            ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
            q = this.qp * ab;
            y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
          }
          else {
            ab = y * sCe / rho;
            q = this.qp * ab;
            y = rho * cCe;
          }
        }
        else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
          if (this.mode === this.N_POLE) {
            y = -y;
          }
          q = (x * x + y * y);
          if (!q) {
            p.x = this.long0;
            p.y = this.lat0;
            return p;
          }
          ab = 1 - q / this.qp;
          if (this.mode === this.S_POLE) {
            ab = -ab;
          }
        }
        lam = Math.atan2(x, y);
        phi = authlat(Math.asin(ab), this.apa);
      }

      p.x = adjust_lon(this.long0 + lam);
      p.y = phi;
      return p;
    }

    /* determine latitude from authalic latitude */
    var P00 = 0.33333333333333333333;

    var P01 = 0.17222222222222222222;
    var P02 = 0.10257936507936507936;
    var P10 = 0.06388888888888888888;
    var P11 = 0.06640211640211640211;
    var P20 = 0.01641501294219154443;

    function authset(es) {
      var t;
      var APA = [];
      APA[0] = es * P00;
      t = es * es;
      APA[0] += t * P01;
      APA[1] = t * P10;
      t *= es;
      APA[0] += t * P02;
      APA[1] += t * P11;
      APA[2] = t * P20;
      return APA;
    }

    function authlat(beta, APA) {
      var t = beta + beta;
      return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
    }

    var names$e = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
    var laea = {
      init: init$e,
      forward: forward$c,
      inverse: inverse$c,
      names: names$e,
      S_POLE: S_POLE,
      N_POLE: N_POLE,
      EQUIT: EQUIT,
      OBLIQ: OBLIQ
    };

    function asinz(x) {
      if (Math.abs(x) > 1) {
        x = (x > 1) ? 1 : -1;
      }
      return Math.asin(x);
    }

    function init$f() {

      if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
        return;
      }
      this.temp = this.b / this.a;
      this.es = 1 - Math.pow(this.temp, 2);
      this.e3 = Math.sqrt(this.es);

      this.sin_po = Math.sin(this.lat1);
      this.cos_po = Math.cos(this.lat1);
      this.t1 = this.sin_po;
      this.con = this.sin_po;
      this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
      this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

      this.sin_po = Math.sin(this.lat2);
      this.cos_po = Math.cos(this.lat2);
      this.t2 = this.sin_po;
      this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
      this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

      this.sin_po = Math.sin(this.lat0);
      this.cos_po = Math.cos(this.lat0);
      this.t3 = this.sin_po;
      this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

      if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
        this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
      }
      else {
        this.ns0 = this.con;
      }
      this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
      this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
    }

    /* Albers Conical Equal Area forward equations--mapping lat,long to x,y
      -------------------------------------------------------------------*/
    function forward$d(p) {

      var lon = p.x;
      var lat = p.y;

      this.sin_phi = Math.sin(lat);
      this.cos_phi = Math.cos(lat);

      var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
      var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
      var theta = this.ns0 * adjust_lon(lon - this.long0);
      var x = rh1 * Math.sin(theta) + this.x0;
      var y = this.rh - rh1 * Math.cos(theta) + this.y0;

      p.x = x;
      p.y = y;
      return p;
    }

    function inverse$d(p) {
      var rh1, qs, con, theta, lon, lat;

      p.x -= this.x0;
      p.y = this.rh - p.y + this.y0;
      if (this.ns0 >= 0) {
        rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
        con = 1;
      }
      else {
        rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
        con = -1;
      }
      theta = 0;
      if (rh1 !== 0) {
        theta = Math.atan2(con * p.x, con * p.y);
      }
      con = rh1 * this.ns0 / this.a;
      if (this.sphere) {
        lat = Math.asin((this.c - con * con) / (2 * this.ns0));
      }
      else {
        qs = (this.c - con * con) / this.ns0;
        lat = this.phi1z(this.e3, qs);
      }

      lon = adjust_lon(theta / this.ns0 + this.long0);
      p.x = lon;
      p.y = lat;
      return p;
    }

    /* Function to compute phi1, the latitude for the inverse of the
       Albers Conical Equal-Area projection.
    -------------------------------------------*/
    function phi1z(eccent, qs) {
      var sinphi, cosphi, con, com, dphi;
      var phi = asinz(0.5 * qs);
      if (eccent < EPSLN) {
        return phi;
      }

      var eccnts = eccent * eccent;
      for (var i = 1; i <= 25; i++) {
        sinphi = Math.sin(phi);
        cosphi = Math.cos(phi);
        con = eccent * sinphi;
        com = 1 - con * con;
        dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
        phi = phi + dphi;
        if (Math.abs(dphi) <= 1e-7) {
          return phi;
        }
      }
      return null;
    }

    var names$f = ["Albers_Conic_Equal_Area", "Albers", "aea"];
    var aea = {
      init: init$f,
      forward: forward$d,
      inverse: inverse$d,
      names: names$f,
      phi1z: phi1z
    };

    /*
      reference:
        Wolfram Mathworld "Gnomonic Projection"
        http://mathworld.wolfram.com/GnomonicProjection.html
        Accessed: 12th November 2009
      */
    function init$g() {

      /* Place parameters in static storage for common use
          -------------------------------------------------*/
      this.sin_p14 = Math.sin(this.lat0);
      this.cos_p14 = Math.cos(this.lat0);
      // Approximation for projecting points to the horizon (infinity)
      this.infinity_dist = 1000 * this.a;
      this.rc = 1;
    }

    /* Gnomonic forward equations--mapping lat,long to x,y
        ---------------------------------------------------*/
    function forward$e(p) {
      var sinphi, cosphi; /* sin and cos value        */
      var dlon; /* delta longitude value      */
      var coslon; /* cos of longitude        */
      var ksp; /* scale factor          */
      var g;
      var x, y;
      var lon = p.x;
      var lat = p.y;
      /* Forward equations
          -----------------*/
      dlon = adjust_lon(lon - this.long0);

      sinphi = Math.sin(lat);
      cosphi = Math.cos(lat);

      coslon = Math.cos(dlon);
      g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
      ksp = 1;
      if ((g > 0) || (Math.abs(g) <= EPSLN)) {
        x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
        y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
      }
      else {

        // Point is in the opposing hemisphere and is unprojectable
        // We still need to return a reasonable point, so we project
        // to infinity, on a bearing
        // equivalent to the northern hemisphere equivalent
        // This is a reasonable approximation for short shapes and lines that
        // straddle the horizon.

        x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
        y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

      }
      p.x = x;
      p.y = y;
      return p;
    }

    function inverse$e(p) {
      var rh; /* Rho */
      var sinc, cosc;
      var c;
      var lon, lat;

      /* Inverse equations
          -----------------*/
      p.x = (p.x - this.x0) / this.a;
      p.y = (p.y - this.y0) / this.a;

      p.x /= this.k0;
      p.y /= this.k0;

      if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
        c = Math.atan2(rh, this.rc);
        sinc = Math.sin(c);
        cosc = Math.cos(c);

        lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
        lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
        lon = adjust_lon(this.long0 + lon);
      }
      else {
        lat = this.phic0;
        lon = 0;
      }

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$g = ["gnom"];
    var gnom = {
      init: init$g,
      forward: forward$e,
      inverse: inverse$e,
      names: names$g
    };

    function iqsfnz(eccent, q) {
      var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
      if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
        if (q < 0) {
          return (-1 * HALF_PI);
        }
        else {
          return HALF_PI;
        }
      }
      //var phi = 0.5* q/(1-eccent*eccent);
      var phi = Math.asin(0.5 * q);
      var dphi;
      var sin_phi;
      var cos_phi;
      var con;
      for (var i = 0; i < 30; i++) {
        sin_phi = Math.sin(phi);
        cos_phi = Math.cos(phi);
        con = eccent * sin_phi;
        dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
        phi += dphi;
        if (Math.abs(dphi) <= 0.0000000001) {
          return phi;
        }
      }

      //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
      return NaN;
    }

    /*
      reference:
        "Cartographic Projection Procedures for the UNIX Environment-
        A User's Manual" by Gerald I. Evenden,
        USGS Open File Report 90-284and Release 4 Interim Reports (2003)
    */
    function init$h() {
      //no-op
      if (!this.sphere) {
        this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
      }
    }

    /* Cylindrical Equal Area forward equations--mapping lat,long to x,y
        ------------------------------------------------------------*/
    function forward$f(p) {
      var lon = p.x;
      var lat = p.y;
      var x, y;
      /* Forward equations
          -----------------*/
      var dlon = adjust_lon(lon - this.long0);
      if (this.sphere) {
        x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
        y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
      }
      else {
        var qs = qsfnz(this.e, Math.sin(lat));
        x = this.x0 + this.a * this.k0 * dlon;
        y = this.y0 + this.a * qs * 0.5 / this.k0;
      }

      p.x = x;
      p.y = y;
      return p;
    }

    /* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
        ------------------------------------------------------------*/
    function inverse$f(p) {
      p.x -= this.x0;
      p.y -= this.y0;
      var lon, lat;

      if (this.sphere) {
        lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
        lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
      }
      else {
        lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
        lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
      }

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$h = ["cea"];
    var cea = {
      init: init$h,
      forward: forward$f,
      inverse: inverse$f,
      names: names$h
    };

    function init$i() {

      this.x0 = this.x0 || 0;
      this.y0 = this.y0 || 0;
      this.lat0 = this.lat0 || 0;
      this.long0 = this.long0 || 0;
      this.lat_ts = this.lat_ts || 0;
      this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

      this.rc = Math.cos(this.lat_ts);
    }

    // forward equations--mapping lat,long to x,y
    // -----------------------------------------------------------------
    function forward$g(p) {

      var lon = p.x;
      var lat = p.y;

      var dlon = adjust_lon(lon - this.long0);
      var dlat = adjust_lat(lat - this.lat0);
      p.x = this.x0 + (this.a * dlon * this.rc);
      p.y = this.y0 + (this.a * dlat);
      return p;
    }

    // inverse equations--mapping x,y to lat/long
    // -----------------------------------------------------------------
    function inverse$g(p) {

      var x = p.x;
      var y = p.y;

      p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
      p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
      return p;
    }

    var names$i = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
    var eqc = {
      init: init$i,
      forward: forward$g,
      inverse: inverse$g,
      names: names$i
    };

    var MAX_ITER$2 = 20;

    function init$j() {
      /* Place parameters in static storage for common use
          -------------------------------------------------*/
      this.temp = this.b / this.a;
      this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
      this.e = Math.sqrt(this.es);
      this.e0 = e0fn(this.es);
      this.e1 = e1fn(this.es);
      this.e2 = e2fn(this.es);
      this.e3 = e3fn(this.es);
      this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
    }

    /* Polyconic forward equations--mapping lat,long to x,y
        ---------------------------------------------------*/
    function forward$h(p) {
      var lon = p.x;
      var lat = p.y;
      var x, y, el;
      var dlon = adjust_lon(lon - this.long0);
      el = dlon * Math.sin(lat);
      if (this.sphere) {
        if (Math.abs(lat) <= EPSLN) {
          x = this.a * dlon;
          y = -1 * this.a * this.lat0;
        }
        else {
          x = this.a * Math.sin(el) / Math.tan(lat);
          y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
        }
      }
      else {
        if (Math.abs(lat) <= EPSLN) {
          x = this.a * dlon;
          y = -1 * this.ml0;
        }
        else {
          var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
          x = nl * Math.sin(el);
          y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
        }

      }
      p.x = x + this.x0;
      p.y = y + this.y0;
      return p;
    }

    /* Inverse equations
      -----------------*/
    function inverse$h(p) {
      var lon, lat, x, y, i;
      var al, bl;
      var phi, dphi;
      x = p.x - this.x0;
      y = p.y - this.y0;

      if (this.sphere) {
        if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
          lon = adjust_lon(x / this.a + this.long0);
          lat = 0;
        }
        else {
          al = this.lat0 + y / this.a;
          bl = x * x / this.a / this.a + al * al;
          phi = al;
          var tanphi;
          for (i = MAX_ITER$2; i; --i) {
            tanphi = Math.tan(phi);
            dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
            phi += dphi;
            if (Math.abs(dphi) <= EPSLN) {
              lat = phi;
              break;
            }
          }
          lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
        }
      }
      else {
        if (Math.abs(y + this.ml0) <= EPSLN) {
          lat = 0;
          lon = adjust_lon(this.long0 + x / this.a);
        }
        else {

          al = (this.ml0 + y) / this.a;
          bl = x * x / this.a / this.a + al * al;
          phi = al;
          var cl, mln, mlnp, ma;
          var con;
          for (i = MAX_ITER$2; i; --i) {
            con = this.e * Math.sin(phi);
            cl = Math.sqrt(1 - con * con) * Math.tan(phi);
            mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
            mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
            ma = mln / this.a;
            dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
            phi -= dphi;
            if (Math.abs(dphi) <= EPSLN) {
              lat = phi;
              break;
            }
          }

          //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
          cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
          lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
        }
      }

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$j = ["Polyconic", "poly"];
    var poly = {
      init: init$j,
      forward: forward$h,
      inverse: inverse$h,
      names: names$j
    };

    function init$k() {
      this.A = [];
      this.A[1] = 0.6399175073;
      this.A[2] = -0.1358797613;
      this.A[3] = 0.063294409;
      this.A[4] = -0.02526853;
      this.A[5] = 0.0117879;
      this.A[6] = -0.0055161;
      this.A[7] = 0.0026906;
      this.A[8] = -0.001333;
      this.A[9] = 0.00067;
      this.A[10] = -0.00034;

      this.B_re = [];
      this.B_im = [];
      this.B_re[1] = 0.7557853228;
      this.B_im[1] = 0;
      this.B_re[2] = 0.249204646;
      this.B_im[2] = 0.003371507;
      this.B_re[3] = -0.001541739;
      this.B_im[3] = 0.041058560;
      this.B_re[4] = -0.10162907;
      this.B_im[4] = 0.01727609;
      this.B_re[5] = -0.26623489;
      this.B_im[5] = -0.36249218;
      this.B_re[6] = -0.6870983;
      this.B_im[6] = -1.1651967;

      this.C_re = [];
      this.C_im = [];
      this.C_re[1] = 1.3231270439;
      this.C_im[1] = 0;
      this.C_re[2] = -0.577245789;
      this.C_im[2] = -0.007809598;
      this.C_re[3] = 0.508307513;
      this.C_im[3] = -0.112208952;
      this.C_re[4] = -0.15094762;
      this.C_im[4] = 0.18200602;
      this.C_re[5] = 1.01418179;
      this.C_im[5] = 1.64497696;
      this.C_re[6] = 1.9660549;
      this.C_im[6] = 2.5127645;

      this.D = [];
      this.D[1] = 1.5627014243;
      this.D[2] = 0.5185406398;
      this.D[3] = -0.03333098;
      this.D[4] = -0.1052906;
      this.D[5] = -0.0368594;
      this.D[6] = 0.007317;
      this.D[7] = 0.01220;
      this.D[8] = 0.00394;
      this.D[9] = -0.0013;
    }

    /**
        New Zealand Map Grid Forward  - long/lat to x/y
        long/lat in radians
      */
    function forward$i(p) {
      var n;
      var lon = p.x;
      var lat = p.y;

      var delta_lat = lat - this.lat0;
      var delta_lon = lon - this.long0;

      // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
      // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
      var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
      var d_lambda = delta_lon;
      var d_phi_n = 1; // d_phi^0

      var d_psi = 0;
      for (n = 1; n <= 10; n++) {
        d_phi_n = d_phi_n * d_phi;
        d_psi = d_psi + this.A[n] * d_phi_n;
      }

      // 2. Calculate theta
      var th_re = d_psi;
      var th_im = d_lambda;

      // 3. Calculate z
      var th_n_re = 1;
      var th_n_im = 0; // theta^0
      var th_n_re1;
      var th_n_im1;

      var z_re = 0;
      var z_im = 0;
      for (n = 1; n <= 6; n++) {
        th_n_re1 = th_n_re * th_re - th_n_im * th_im;
        th_n_im1 = th_n_im * th_re + th_n_re * th_im;
        th_n_re = th_n_re1;
        th_n_im = th_n_im1;
        z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
        z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
      }

      // 4. Calculate easting and northing
      p.x = (z_im * this.a) + this.x0;
      p.y = (z_re * this.a) + this.y0;

      return p;
    }

    /**
        New Zealand Map Grid Inverse  -  x/y to long/lat
      */
    function inverse$i(p) {
      var n;
      var x = p.x;
      var y = p.y;

      var delta_x = x - this.x0;
      var delta_y = y - this.y0;

      // 1. Calculate z
      var z_re = delta_y / this.a;
      var z_im = delta_x / this.a;

      // 2a. Calculate theta - first approximation gives km accuracy
      var z_n_re = 1;
      var z_n_im = 0; // z^0
      var z_n_re1;
      var z_n_im1;

      var th_re = 0;
      var th_im = 0;
      for (n = 1; n <= 6; n++) {
        z_n_re1 = z_n_re * z_re - z_n_im * z_im;
        z_n_im1 = z_n_im * z_re + z_n_re * z_im;
        z_n_re = z_n_re1;
        z_n_im = z_n_im1;
        th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
        th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
      }

      // 2b. Iterate to refine the accuracy of the calculation
      //        0 iterations gives km accuracy
      //        1 iteration gives m accuracy -- good enough for most mapping applications
      //        2 iterations bives mm accuracy
      for (var i = 0; i < this.iterations; i++) {
        var th_n_re = th_re;
        var th_n_im = th_im;
        var th_n_re1;
        var th_n_im1;

        var num_re = z_re;
        var num_im = z_im;
        for (n = 2; n <= 6; n++) {
          th_n_re1 = th_n_re * th_re - th_n_im * th_im;
          th_n_im1 = th_n_im * th_re + th_n_re * th_im;
          th_n_re = th_n_re1;
          th_n_im = th_n_im1;
          num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
          num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
        }

        th_n_re = 1;
        th_n_im = 0;
        var den_re = this.B_re[1];
        var den_im = this.B_im[1];
        for (n = 2; n <= 6; n++) {
          th_n_re1 = th_n_re * th_re - th_n_im * th_im;
          th_n_im1 = th_n_im * th_re + th_n_re * th_im;
          th_n_re = th_n_re1;
          th_n_im = th_n_im1;
          den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
          den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
        }

        // Complex division
        var den2 = den_re * den_re + den_im * den_im;
        th_re = (num_re * den_re + num_im * den_im) / den2;
        th_im = (num_im * den_re - num_re * den_im) / den2;
      }

      // 3. Calculate d_phi              ...                                    // and d_lambda
      var d_psi = th_re;
      var d_lambda = th_im;
      var d_psi_n = 1; // d_psi^0

      var d_phi = 0;
      for (n = 1; n <= 9; n++) {
        d_psi_n = d_psi_n * d_psi;
        d_phi = d_phi + this.D[n] * d_psi_n;
      }

      // 4. Calculate latitude and longitude
      // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
      var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
      var lon = this.long0 + d_lambda;

      p.x = lon;
      p.y = lat;

      return p;
    }

    var names$k = ["New_Zealand_Map_Grid", "nzmg"];
    var nzmg = {
      init: init$k,
      forward: forward$i,
      inverse: inverse$i,
      names: names$k
    };

    /*
      reference
        "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
        The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
      */


    /* Initialize the Miller Cylindrical projection
      -------------------------------------------*/
    function init$l() {
      //no-op
    }

    /* Miller Cylindrical forward equations--mapping lat,long to x,y
        ------------------------------------------------------------*/
    function forward$j(p) {
      var lon = p.x;
      var lat = p.y;
      /* Forward equations
          -----------------*/
      var dlon = adjust_lon(lon - this.long0);
      var x = this.x0 + this.a * dlon;
      var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

      p.x = x;
      p.y = y;
      return p;
    }

    /* Miller Cylindrical inverse equations--mapping x,y to lat/long
        ------------------------------------------------------------*/
    function inverse$j(p) {
      p.x -= this.x0;
      p.y -= this.y0;

      var lon = adjust_lon(this.long0 + p.x / this.a);
      var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$l = ["Miller_Cylindrical", "mill"];
    var mill = {
      init: init$l,
      forward: forward$j,
      inverse: inverse$j,
      names: names$l
    };

    var MAX_ITER$3 = 20;


    function init$m() {
      /* Place parameters in static storage for common use
        -------------------------------------------------*/


      if (!this.sphere) {
        this.en = pj_enfn(this.es);
      }
      else {
        this.n = 1;
        this.m = 0;
        this.es = 0;
        this.C_y = Math.sqrt((this.m + 1) / this.n);
        this.C_x = this.C_y / (this.m + 1);
      }

    }

    /* Sinusoidal forward equations--mapping lat,long to x,y
      -----------------------------------------------------*/
    function forward$k(p) {
      var x, y;
      var lon = p.x;
      var lat = p.y;
      /* Forward equations
        -----------------*/
      lon = adjust_lon(lon - this.long0);

      if (this.sphere) {
        if (!this.m) {
          lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
        }
        else {
          var k = this.n * Math.sin(lat);
          for (var i = MAX_ITER$3; i; --i) {
            var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
            lat -= V;
            if (Math.abs(V) < EPSLN) {
              break;
            }
          }
        }
        x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
        y = this.a * this.C_y * lat;

      }
      else {

        var s = Math.sin(lat);
        var c = Math.cos(lat);
        y = this.a * pj_mlfn(lat, s, c, this.en);
        x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
      }

      p.x = x;
      p.y = y;
      return p;
    }

    function inverse$k(p) {
      var lat, temp, lon, s;

      p.x -= this.x0;
      lon = p.x / this.a;
      p.y -= this.y0;
      lat = p.y / this.a;

      if (this.sphere) {
        lat /= this.C_y;
        lon = lon / (this.C_x * (this.m + Math.cos(lat)));
        if (this.m) {
          lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
        }
        else if (this.n !== 1) {
          lat = asinz(Math.sin(lat) / this.n);
        }
        lon = adjust_lon(lon + this.long0);
        lat = adjust_lat(lat);
      }
      else {
        lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
        s = Math.abs(lat);
        if (s < HALF_PI) {
          s = Math.sin(lat);
          temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
          //temp = this.long0 + p.x / (this.a * Math.cos(lat));
          lon = adjust_lon(temp);
        }
        else if ((s - EPSLN) < HALF_PI) {
          lon = this.long0;
        }
      }
      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$m = ["Sinusoidal", "sinu"];
    var sinu = {
      init: init$m,
      forward: forward$k,
      inverse: inverse$k,
      names: names$m
    };

    function init$n() {}
    /* Mollweide forward equations--mapping lat,long to x,y
        ----------------------------------------------------*/
    function forward$l(p) {

      /* Forward equations
          -----------------*/
      var lon = p.x;
      var lat = p.y;

      var delta_lon = adjust_lon(lon - this.long0);
      var theta = lat;
      var con = Math.PI * Math.sin(lat);

      /* Iterate using the Newton-Raphson method to find theta
          -----------------------------------------------------*/
      while (true) {
        var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
        theta += delta_theta;
        if (Math.abs(delta_theta) < EPSLN) {
          break;
        }
      }
      theta /= 2;

      /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
           this is done here because of precision problems with "cos(theta)"
           --------------------------------------------------------------------------*/
      if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
        delta_lon = 0;
      }
      var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
      var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

      p.x = x;
      p.y = y;
      return p;
    }

    function inverse$l(p) {
      var theta;
      var arg;

      /* Inverse equations
          -----------------*/
      p.x -= this.x0;
      p.y -= this.y0;
      arg = p.y / (1.4142135623731 * this.a);

      /* Because of division by zero problems, 'arg' can not be 1.  Therefore
           a number very close to one is used instead.
           -------------------------------------------------------------------*/
      if (Math.abs(arg) > 0.999999999999) {
        arg = 0.999999999999;
      }
      theta = Math.asin(arg);
      var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
      if (lon < (-Math.PI)) {
        lon = -Math.PI;
      }
      if (lon > Math.PI) {
        lon = Math.PI;
      }
      arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
      if (Math.abs(arg) > 1) {
        arg = 1;
      }
      var lat = Math.asin(arg);

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$n = ["Mollweide", "moll"];
    var moll = {
      init: init$n,
      forward: forward$l,
      inverse: inverse$l,
      names: names$n
    };

    function init$o() {

      /* Place parameters in static storage for common use
          -------------------------------------------------*/
      // Standard Parallels cannot be equal and on opposite sides of the equator
      if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
        return;
      }
      this.lat2 = this.lat2 || this.lat1;
      this.temp = this.b / this.a;
      this.es = 1 - Math.pow(this.temp, 2);
      this.e = Math.sqrt(this.es);
      this.e0 = e0fn(this.es);
      this.e1 = e1fn(this.es);
      this.e2 = e2fn(this.es);
      this.e3 = e3fn(this.es);

      this.sinphi = Math.sin(this.lat1);
      this.cosphi = Math.cos(this.lat1);

      this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
      this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

      if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
        this.ns = this.sinphi;
      }
      else {
        this.sinphi = Math.sin(this.lat2);
        this.cosphi = Math.cos(this.lat2);
        this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
        this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
        this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
      }
      this.g = this.ml1 + this.ms1 / this.ns;
      this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
      this.rh = this.a * (this.g - this.ml0);
    }

    /* Equidistant Conic forward equations--mapping lat,long to x,y
      -----------------------------------------------------------*/
    function forward$m(p) {
      var lon = p.x;
      var lat = p.y;
      var rh1;

      /* Forward equations
          -----------------*/
      if (this.sphere) {
        rh1 = this.a * (this.g - lat);
      }
      else {
        var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
        rh1 = this.a * (this.g - ml);
      }
      var theta = this.ns * adjust_lon(lon - this.long0);
      var x = this.x0 + rh1 * Math.sin(theta);
      var y = this.y0 + this.rh - rh1 * Math.cos(theta);
      p.x = x;
      p.y = y;
      return p;
    }

    /* Inverse equations
      -----------------*/
    function inverse$m(p) {
      p.x -= this.x0;
      p.y = this.rh - p.y + this.y0;
      var con, rh1, lat, lon;
      if (this.ns >= 0) {
        rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
        con = 1;
      }
      else {
        rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
        con = -1;
      }
      var theta = 0;
      if (rh1 !== 0) {
        theta = Math.atan2(con * p.x, con * p.y);
      }

      if (this.sphere) {
        lon = adjust_lon(this.long0 + theta / this.ns);
        lat = adjust_lat(this.g - rh1 / this.a);
        p.x = lon;
        p.y = lat;
        return p;
      }
      else {
        var ml = this.g - rh1 / this.a;
        lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
        lon = adjust_lon(this.long0 + theta / this.ns);
        p.x = lon;
        p.y = lat;
        return p;
      }

    }

    var names$o = ["Equidistant_Conic", "eqdc"];
    var eqdc = {
      init: init$o,
      forward: forward$m,
      inverse: inverse$m,
      names: names$o
    };

    /* Initialize the Van Der Grinten projection
      ----------------------------------------*/
    function init$p() {
      //this.R = 6370997; //Radius of earth
      this.R = this.a;
    }

    function forward$n(p) {

      var lon = p.x;
      var lat = p.y;

      /* Forward equations
        -----------------*/
      var dlon = adjust_lon(lon - this.long0);
      var x, y;

      if (Math.abs(lat) <= EPSLN) {
        x = this.x0 + this.R * dlon;
        y = this.y0;
      }
      var theta = asinz(2 * Math.abs(lat / Math.PI));
      if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
        x = this.x0;
        if (lat >= 0) {
          y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
        }
        else {
          y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
        }
        //  return(OK);
      }
      var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
      var asq = al * al;
      var sinth = Math.sin(theta);
      var costh = Math.cos(theta);

      var g = costh / (sinth + costh - 1);
      var gsq = g * g;
      var m = g * (2 / sinth - 1);
      var msq = m * m;
      var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
      if (dlon < 0) {
        con = -con;
      }
      x = this.x0 + con;
      //con = Math.abs(con / (Math.PI * this.R));
      var q = asq + g;
      con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
      if (lat >= 0) {
        //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
        y = this.y0 + con;
      }
      else {
        //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
        y = this.y0 - con;
      }
      p.x = x;
      p.y = y;
      return p;
    }

    /* Van Der Grinten inverse equations--mapping x,y to lat/long
      ---------------------------------------------------------*/
    function inverse$n(p) {
      var lon, lat;
      var xx, yy, xys, c1, c2, c3;
      var a1;
      var m1;
      var con;
      var th1;
      var d;

      /* inverse equations
        -----------------*/
      p.x -= this.x0;
      p.y -= this.y0;
      con = Math.PI * this.R;
      xx = p.x / con;
      yy = p.y / con;
      xys = xx * xx + yy * yy;
      c1 = -Math.abs(yy) * (1 + xys);
      c2 = c1 - 2 * yy * yy + xx * xx;
      c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
      d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
      a1 = (c1 - c2 * c2 / 3 / c3) / c3;
      m1 = 2 * Math.sqrt(-a1 / 3);
      con = ((3 * d) / a1) / m1;
      if (Math.abs(con) > 1) {
        if (con >= 0) {
          con = 1;
        }
        else {
          con = -1;
        }
      }
      th1 = Math.acos(con) / 3;
      if (p.y >= 0) {
        lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
      }
      else {
        lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
      }

      if (Math.abs(xx) < EPSLN) {
        lon = this.long0;
      }
      else {
        lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
      }

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$p = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
    var vandg = {
      init: init$p,
      forward: forward$n,
      inverse: inverse$n,
      names: names$p
    };

    function init$q() {
      this.sin_p12 = Math.sin(this.lat0);
      this.cos_p12 = Math.cos(this.lat0);
    }

    function forward$o(p) {
      var lon = p.x;
      var lat = p.y;
      var sinphi = Math.sin(p.y);
      var cosphi = Math.cos(p.y);
      var dlon = adjust_lon(lon - this.long0);
      var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
      if (this.sphere) {
        if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
          //North Pole case
          p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
          p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
          return p;
        }
        else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
          //South Pole case
          p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
          p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
          return p;
        }
        else {
          //default case
          cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
          c = Math.acos(cos_c);
          kp = c ? c / Math.sin(c) : 1;
          p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
          p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
          return p;
        }
      }
      else {
        e0 = e0fn(this.es);
        e1 = e1fn(this.es);
        e2 = e2fn(this.es);
        e3 = e3fn(this.es);
        if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
          //North Pole case
          Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
          Ml = this.a * mlfn(e0, e1, e2, e3, lat);
          p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
          p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
          return p;
        }
        else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
          //South Pole case
          Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
          Ml = this.a * mlfn(e0, e1, e2, e3, lat);
          p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
          p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
          return p;
        }
        else {
          //Default case
          tanphi = sinphi / cosphi;
          Nl1 = gN(this.a, this.e, this.sin_p12);
          Nl = gN(this.a, this.e, sinphi);
          psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
          Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
          if (Az === 0) {
            s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
          }
          else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
            s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
          }
          else {
            s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
          }
          G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
          H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
          GH = G * H;
          Hs = H * H;
          s2 = s * s;
          s3 = s2 * s;
          s4 = s3 * s;
          s5 = s4 * s;
          c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
          p.x = this.x0 + c * Math.sin(Az);
          p.y = this.y0 + c * Math.cos(Az);
          return p;
        }
      }


    }

    function inverse$o(p) {
      p.x -= this.x0;
      p.y -= this.y0;
      var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;
      if (this.sphere) {
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        if (rh > (2 * HALF_PI * this.a)) {
          return;
        }
        z = rh / this.a;

        sinz = Math.sin(z);
        cosz = Math.cos(z);

        lon = this.long0;
        if (Math.abs(rh) <= EPSLN) {
          lat = this.lat0;
        }
        else {
          lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
          con = Math.abs(this.lat0) - HALF_PI;
          if (Math.abs(con) <= EPSLN) {
            if (this.lat0 >= 0) {
              lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
            }
            else {
              lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
            }
          }
          else {
            /*con = cosz - this.sin_p12 * Math.sin(lat);
            if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
              //no-op, just keep the lon value as is
            } else {
              var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
              lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
            }*/
            lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
          }
        }

        p.x = lon;
        p.y = lat;
        return p;
      }
      else {
        e0 = e0fn(this.es);
        e1 = e1fn(this.es);
        e2 = e2fn(this.es);
        e3 = e3fn(this.es);
        if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
          //North pole case
          Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
          rh = Math.sqrt(p.x * p.x + p.y * p.y);
          M = Mlp - rh;
          lat = imlfn(M / this.a, e0, e1, e2, e3);
          lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
          p.x = lon;
          p.y = lat;
          return p;
        }
        else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
          //South pole case
          Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
          rh = Math.sqrt(p.x * p.x + p.y * p.y);
          M = rh - Mlp;

          lat = imlfn(M / this.a, e0, e1, e2, e3);
          lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
          p.x = lon;
          p.y = lat;
          return p;
        }
        else {
          //default case
          rh = Math.sqrt(p.x * p.x + p.y * p.y);
          Az = Math.atan2(p.x, p.y);
          N1 = gN(this.a, this.e, this.sin_p12);
          cosAz = Math.cos(Az);
          tmp = this.e * this.cos_p12 * cosAz;
          A = -tmp * tmp / (1 - this.es);
          B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
          D = rh / N1;
          Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
          F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
          psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
          lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
          sinpsi = Math.sin(psi);
          lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
          p.x = lon;
          p.y = lat;
          return p;
        }
      }

    }

    var names$q = ["Azimuthal_Equidistant", "aeqd"];
    var aeqd = {
      init: init$q,
      forward: forward$o,
      inverse: inverse$o,
      names: names$q
    };

    function init$r() {
      //double temp;      /* temporary variable    */

      /* Place parameters in static storage for common use
          -------------------------------------------------*/
      this.sin_p14 = Math.sin(this.lat0);
      this.cos_p14 = Math.cos(this.lat0);
    }

    /* Orthographic forward equations--mapping lat,long to x,y
        ---------------------------------------------------*/
    function forward$p(p) {
      var sinphi, cosphi; /* sin and cos value        */
      var dlon; /* delta longitude value      */
      var coslon; /* cos of longitude        */
      var ksp; /* scale factor          */
      var g, x, y;
      var lon = p.x;
      var lat = p.y;
      /* Forward equations
          -----------------*/
      dlon = adjust_lon(lon - this.long0);

      sinphi = Math.sin(lat);
      cosphi = Math.cos(lat);

      coslon = Math.cos(dlon);
      g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
      ksp = 1;
      if ((g > 0) || (Math.abs(g) <= EPSLN)) {
        x = this.a * ksp * cosphi * Math.sin(dlon);
        y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
      }
      p.x = x;
      p.y = y;
      return p;
    }

    function inverse$p(p) {
      var rh; /* height above ellipsoid      */
      var z; /* angle          */
      var sinz, cosz; /* sin of z and cos of z      */
      var con;
      var lon, lat;
      /* Inverse equations
          -----------------*/
      p.x -= this.x0;
      p.y -= this.y0;
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      z = asinz(rh / this.a);

      sinz = Math.sin(z);
      cosz = Math.cos(z);

      lon = this.long0;
      if (Math.abs(rh) <= EPSLN) {
        lat = this.lat0;
        p.x = lon;
        p.y = lat;
        return p;
      }
      lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
        }
        else {
          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
        }
        p.x = lon;
        p.y = lat;
        return p;
      }
      lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$r = ["ortho"];
    var ortho = {
      init: init$r,
      forward: forward$p,
      inverse: inverse$p,
      names: names$r
    };

    // QSC projection rewritten from the original PROJ4

    /* constants */
    var FACE_ENUM = {
        FRONT: 1,
        RIGHT: 2,
        BACK: 3,
        LEFT: 4,
        TOP: 5,
        BOTTOM: 6
    };

    var AREA_ENUM = {
        AREA_0: 1,
        AREA_1: 2,
        AREA_2: 3,
        AREA_3: 4
    };

    function init$s() {

      this.x0 = this.x0 || 0;
      this.y0 = this.y0 || 0;
      this.lat0 = this.lat0 || 0;
      this.long0 = this.long0 || 0;
      this.lat_ts = this.lat_ts || 0;
      this.title = this.title || "Quadrilateralized Spherical Cube";

      /* Determine the cube face from the center of projection. */
      if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
        this.face = FACE_ENUM.TOP;
      } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
        this.face = FACE_ENUM.BOTTOM;
      } else if (Math.abs(this.long0) <= FORTPI) {
        this.face = FACE_ENUM.FRONT;
      } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
        this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
      } else {
        this.face = FACE_ENUM.BACK;
      }

      /* Fill in useful values for the ellipsoid <-> sphere shift
       * described in [LK12]. */
      if (this.es !== 0) {
        this.one_minus_f = 1 - (this.a - this.b) / this.a;
        this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
      }
    }

    // QSC forward equations--mapping lat,long to x,y
    // -----------------------------------------------------------------
    function forward$q(p) {
      var xy = {x: 0, y: 0};
      var lat, lon;
      var theta, phi;
      var t, mu;
      /* nu; */
      var area = {value: 0};

      // move lon according to projection's lon
      p.x -= this.long0;

      /* Convert the geodetic latitude to a geocentric latitude.
       * This corresponds to the shift from the ellipsoid to the sphere
       * described in [LK12]. */
      if (this.es !== 0) {//if (P->es != 0) {
        lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
      } else {
        lat = p.y;
      }

      /* Convert the input lat, lon into theta, phi as used by QSC.
       * This depends on the cube face and the area on it.
       * For the top and bottom face, we can compute theta and phi
       * directly from phi, lam. For the other faces, we must use
       * unit sphere cartesian coordinates as an intermediate step. */
      lon = p.x; //lon = lp.lam;
      if (this.face === FACE_ENUM.TOP) {
        phi = HALF_PI - lat;
        if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
          area.value = AREA_ENUM.AREA_0;
          theta = lon - HALF_PI;
        } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
          area.value = AREA_ENUM.AREA_1;
          theta = (lon > 0.0 ? lon - SPI : lon + SPI);
        } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
          area.value = AREA_ENUM.AREA_2;
          theta = lon + HALF_PI;
        } else {
          area.value = AREA_ENUM.AREA_3;
          theta = lon;
        }
      } else if (this.face === FACE_ENUM.BOTTOM) {
        phi = HALF_PI + lat;
        if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
          area.value = AREA_ENUM.AREA_0;
          theta = -lon + HALF_PI;
        } else if (lon < FORTPI && lon >= -FORTPI) {
          area.value = AREA_ENUM.AREA_1;
          theta = -lon;
        } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
          area.value = AREA_ENUM.AREA_2;
          theta = -lon - HALF_PI;
        } else {
          area.value = AREA_ENUM.AREA_3;
          theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);
        }
      } else {
        var q, r, s;
        var sinlat, coslat;
        var sinlon, coslon;

        if (this.face === FACE_ENUM.RIGHT) {
          lon = qsc_shift_lon_origin(lon, +HALF_PI);
        } else if (this.face === FACE_ENUM.BACK) {
          lon = qsc_shift_lon_origin(lon, +SPI);
        } else if (this.face === FACE_ENUM.LEFT) {
          lon = qsc_shift_lon_origin(lon, -HALF_PI);
        }
        sinlat = Math.sin(lat);
        coslat = Math.cos(lat);
        sinlon = Math.sin(lon);
        coslon = Math.cos(lon);
        q = coslat * coslon;
        r = coslat * sinlon;
        s = sinlat;

        if (this.face === FACE_ENUM.FRONT) {
          phi = Math.acos(q);
          theta = qsc_fwd_equat_face_theta(phi, s, r, area);
        } else if (this.face === FACE_ENUM.RIGHT) {
          phi = Math.acos(r);
          theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
        } else if (this.face === FACE_ENUM.BACK) {
          phi = Math.acos(-q);
          theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
        } else if (this.face === FACE_ENUM.LEFT) {
          phi = Math.acos(-r);
          theta = qsc_fwd_equat_face_theta(phi, s, q, area);
        } else {
          /* Impossible */
          phi = theta = 0;
          area.value = AREA_ENUM.AREA_0;
        }
      }

      /* Compute mu and nu for the area of definition.
       * For mu, see Eq. (3-21) in [OL76], but note the typos:
       * compare with Eq. (3-14). For nu, see Eq. (3-38). */
      mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
      t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

      /* Apply the result to the real area. */
      if (area.value === AREA_ENUM.AREA_1) {
        mu += HALF_PI;
      } else if (area.value === AREA_ENUM.AREA_2) {
        mu += SPI;
      } else if (area.value === AREA_ENUM.AREA_3) {
        mu += 1.5 * SPI;
      }

      /* Now compute x, y from mu and nu */
      xy.x = t * Math.cos(mu);
      xy.y = t * Math.sin(mu);
      xy.x = xy.x * this.a + this.x0;
      xy.y = xy.y * this.a + this.y0;

      p.x = xy.x;
      p.y = xy.y;
      return p;
    }

    // QSC inverse equations--mapping x,y to lat/long
    // -----------------------------------------------------------------
    function inverse$q(p) {
      var lp = {lam: 0, phi: 0};
      var mu, nu, cosmu, tannu;
      var tantheta, theta, cosphi, phi;
      var t;
      var area = {value: 0};

      /* de-offset */
      p.x = (p.x - this.x0) / this.a;
      p.y = (p.y - this.y0) / this.a;

      /* Convert the input x, y to the mu and nu angles as used by QSC.
       * This depends on the area of the cube face. */
      nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
      mu = Math.atan2(p.y, p.x);
      if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
        area.value = AREA_ENUM.AREA_0;
      } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
        area.value = AREA_ENUM.AREA_1;
        mu -= HALF_PI;
      } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
        area.value = AREA_ENUM.AREA_2;
        mu = (mu < 0.0 ? mu + SPI : mu - SPI);
      } else {
        area.value = AREA_ENUM.AREA_3;
        mu += HALF_PI;
      }

      /* Compute phi and theta for the area of definition.
       * The inverse projection is not described in the original paper, but some
       * good hints can be found here (as of 2011-12-14):
       * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
       * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
      t = (SPI / 12) * Math.tan(mu);
      tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
      theta = Math.atan(tantheta);
      cosmu = Math.cos(mu);
      tannu = Math.tan(nu);
      cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
      if (cosphi < -1) {
        cosphi = -1;
      } else if (cosphi > +1) {
        cosphi = +1;
      }

      /* Apply the result to the real area on the cube face.
       * For the top and bottom face, we can compute phi and lam directly.
       * For the other faces, we must use unit sphere cartesian coordinates
       * as an intermediate step. */
      if (this.face === FACE_ENUM.TOP) {
        phi = Math.acos(cosphi);
        lp.phi = HALF_PI - phi;
        if (area.value === AREA_ENUM.AREA_0) {
          lp.lam = theta + HALF_PI;
        } else if (area.value === AREA_ENUM.AREA_1) {
          lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);
        } else if (area.value === AREA_ENUM.AREA_2) {
          lp.lam = theta - HALF_PI;
        } else /* area.value == AREA_ENUM.AREA_3 */ {
          lp.lam = theta;
        }
      } else if (this.face === FACE_ENUM.BOTTOM) {
        phi = Math.acos(cosphi);
        lp.phi = phi - HALF_PI;
        if (area.value === AREA_ENUM.AREA_0) {
          lp.lam = -theta + HALF_PI;
        } else if (area.value === AREA_ENUM.AREA_1) {
          lp.lam = -theta;
        } else if (area.value === AREA_ENUM.AREA_2) {
          lp.lam = -theta - HALF_PI;
        } else /* area.value == AREA_ENUM.AREA_3 */ {
          lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);
        }
      } else {
        /* Compute phi and lam via cartesian unit sphere coordinates. */
        var q, r, s;
        q = cosphi;
        t = q * q;
        if (t >= 1) {
          s = 0;
        } else {
          s = Math.sqrt(1 - t) * Math.sin(theta);
        }
        t += s * s;
        if (t >= 1) {
          r = 0;
        } else {
          r = Math.sqrt(1 - t);
        }
        /* Rotate q,r,s into the correct area. */
        if (area.value === AREA_ENUM.AREA_1) {
          t = r;
          r = -s;
          s = t;
        } else if (area.value === AREA_ENUM.AREA_2) {
          r = -r;
          s = -s;
        } else if (area.value === AREA_ENUM.AREA_3) {
          t = r;
          r = s;
          s = -t;
        }
        /* Rotate q,r,s into the correct cube face. */
        if (this.face === FACE_ENUM.RIGHT) {
          t = q;
          q = -r;
          r = t;
        } else if (this.face === FACE_ENUM.BACK) {
          q = -q;
          r = -r;
        } else if (this.face === FACE_ENUM.LEFT) {
          t = q;
          q = r;
          r = -t;
        }
        /* Now compute phi and lam from the unit sphere coordinates. */
        lp.phi = Math.acos(-s) - HALF_PI;
        lp.lam = Math.atan2(r, q);
        if (this.face === FACE_ENUM.RIGHT) {
          lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
        } else if (this.face === FACE_ENUM.BACK) {
          lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
        } else if (this.face === FACE_ENUM.LEFT) {
          lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
        }
      }

      /* Apply the shift from the sphere to the ellipsoid as described
       * in [LK12]. */
      if (this.es !== 0) {
        var invert_sign;
        var tanphi, xa;
        invert_sign = (lp.phi < 0 ? 1 : 0);
        tanphi = Math.tan(lp.phi);
        xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
        lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
        if (invert_sign) {
          lp.phi = -lp.phi;
        }
      }

      lp.lam += this.long0;
      p.x = lp.lam;
      p.y = lp.phi;
      return p;
    }

    /* Helper function for forward projection: compute the theta angle
     * and determine the area number. */
    function qsc_fwd_equat_face_theta(phi, y, x, area) {
      var theta;
      if (phi < EPSLN) {
        area.value = AREA_ENUM.AREA_0;
        theta = 0.0;
      } else {
        theta = Math.atan2(y, x);
        if (Math.abs(theta) <= FORTPI) {
          area.value = AREA_ENUM.AREA_0;
        } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
          area.value = AREA_ENUM.AREA_1;
          theta -= HALF_PI;
        } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
          area.value = AREA_ENUM.AREA_2;
          theta = (theta >= 0.0 ? theta - SPI : theta + SPI);
        } else {
          area.value = AREA_ENUM.AREA_3;
          theta += HALF_PI;
        }
      }
      return theta;
    }

    /* Helper function: shift the longitude. */
    function qsc_shift_lon_origin(lon, offset) {
      var slon = lon + offset;
      if (slon < -SPI) {
        slon += TWO_PI;
      } else if (slon > +SPI) {
        slon -= TWO_PI;
      }
      return slon;
    }

    var names$s = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
    var qsc = {
      init: init$s,
      forward: forward$q,
      inverse: inverse$q,
      names: names$s
    };

    // Robinson projection

    var COEFS_X = [
        [1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06],
        [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06],
        [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07],
        [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06],
        [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06],
        [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08],
        [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06],
        [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06],
        [0.9216, -0.00467746, -0.00010457, 4.81243e-06],
        [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06],
        [0.8679, -0.00609363, -0.000113898, 3.32484e-06],
        [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07],
        [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07],
        [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06],
        [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06],
        [0.6732, -0.00986209, -0.000199569, 1.91974e-05],
        [0.6213, -0.010418, 8.83923e-05, 6.24051e-06],
        [0.5722, -0.00906601, 0.000182, 6.24051e-06],
        [0.5322, -0.00677797, 0.000275608, 6.24051e-06]
    ];

    var COEFS_Y = [
        [-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11],
        [0.0620, 0.0124, -1.26793e-09, 4.22642e-10],
        [0.1240, 0.0124, 5.07171e-09, -1.60604e-09],
        [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09],
        [0.2480, 0.0124002, 7.10039e-08, -2.24e-08],
        [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08],
        [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07],
        [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07],
        [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07],
        [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07],
        [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07],
        [0.6769, 0.011713, -3.20223e-05, -5.16405e-07],
        [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07],
        [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06],
        [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09],
        [0.8936, 0.00969686, -6.4636e-05, -8.547e-06],
        [0.9394, 0.00840947, -0.000192841, -4.2106e-06],
        [0.9761, 0.00616527, -0.000256, -4.2106e-06],
        [1.0000, 0.00328947, -0.000319159, -4.2106e-06]
    ];

    var FXC = 0.8487;
    var FYC = 1.3523;
    var C1 = R2D/5; // rad to 5-degree interval
    var RC1 = 1/C1;
    var NODES = 18;

    var poly3_val = function(coefs, x) {
        return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
    };

    var poly3_der = function(coefs, x) {
        return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
    };

    function newton_rapshon(f_df, start, max_err, iters) {
        var x = start;
        for (; iters; --iters) {
            var upd = f_df(x);
            x -= upd;
            if (Math.abs(upd) < max_err) {
                break;
            }
        }
        return x;
    }

    function init$t() {
        this.x0 = this.x0 || 0;
        this.y0 = this.y0 || 0;
        this.long0 = this.long0 || 0;
        this.es = 0;
        this.title = this.title || "Robinson";
    }

    function forward$r(ll) {
        var lon = adjust_lon(ll.x - this.long0);

        var dphi = Math.abs(ll.y);
        var i = Math.floor(dphi * C1);
        if (i < 0) {
            i = 0;
        } else if (i >= NODES) {
            i = NODES - 1;
        }
        dphi = R2D * (dphi - RC1 * i);
        var xy = {
            x: poly3_val(COEFS_X[i], dphi) * lon,
            y: poly3_val(COEFS_Y[i], dphi)
        };
        if (ll.y < 0) {
            xy.y = -xy.y;
        }

        xy.x = xy.x * this.a * FXC + this.x0;
        xy.y = xy.y * this.a * FYC + this.y0;
        return xy;
    }

    function inverse$r(xy) {
        var ll = {
            x: (xy.x - this.x0) / (this.a * FXC),
            y: Math.abs(xy.y - this.y0) / (this.a * FYC)
        };

        if (ll.y >= 1) { // pathologic case
            ll.x /= COEFS_X[NODES][0];
            ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
        } else {
            // find table interval
            var i = Math.floor(ll.y * NODES);
            if (i < 0) {
                i = 0;
            } else if (i >= NODES) {
                i = NODES - 1;
            }
            for (;;) {
                if (COEFS_Y[i][0] > ll.y) {
                    --i;
                } else if (COEFS_Y[i+1][0] <= ll.y) {
                    ++i;
                } else {
                    break;
                }
            }
            // linear interpolation in 5 degree interval
            var coefs = COEFS_Y[i];
            var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i+1][0] - coefs[0]);
            // find t so that poly3_val(coefs, t) = ll.y
            t = newton_rapshon(function(x) {
                return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
            }, t, EPSLN, 100);

            ll.x /= poly3_val(COEFS_X[i], t);
            ll.y = (5 * i + t) * D2R;
            if (xy.y < 0) {
                ll.y = -ll.y;
            }
        }

        ll.x = adjust_lon(ll.x + this.long0);
        return ll;
    }

    var names$t = ["Robinson", "robin"];
    var robin = {
      init: init$t,
      forward: forward$r,
      inverse: inverse$r,
      names: names$t
    };

    function init$u() {
        this.name = 'geocent';

    }

    function forward$s(p) {
        var point = geodeticToGeocentric(p, this.es, this.a);
        return point;
    }

    function inverse$s(p) {
        var point = geocentricToGeodetic(p, this.es, this.a, this.b);
        return point;
    }

    var names$u = ["Geocentric", 'geocentric', "geocent", "Geocent"];
    var geocent = {
        init: init$u,
        forward: forward$s,
        inverse: inverse$s,
        names: names$u
    };

    var mode = {
      N_POLE: 0,
      S_POLE: 1,
      EQUIT: 2,
      OBLIQ: 3
    };

    var params = {
      h:     { def: 100000, num: true },           // default is Karman line, no default in PROJ.7
      azi:   { def: 0, num: true, degrees: true }, // default is North
      tilt:  { def: 0, num: true, degrees: true }, // default is Nadir
      long0: { def: 0, num: true },                // default is Greenwich, conversion to rad is automatic
      lat0:  { def: 0, num: true }                 // default is Equator, conversion to rad is automatic
    };

    function init$v() {
      Object.keys(params).forEach(function (p) {
        if (typeof this[p] === "undefined") {
          this[p] = params[p].def;
        } else if (params[p].num && isNaN(this[p])) {
          throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
        } else if (params[p].num) {
          this[p] = parseFloat(this[p]);
        }
        if (params[p].degrees) {
          this[p] = this[p] * D2R;
        }
      }.bind(this));

      if (Math.abs((Math.abs(this.lat0) - HALF_PI)) < EPSLN) {
        this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
      } else if (Math.abs(this.lat0) < EPSLN) {
        this.mode = mode.EQUIT;
      } else {
        this.mode = mode.OBLIQ;
        this.sinph0 = Math.sin(this.lat0);
        this.cosph0 = Math.cos(this.lat0);
      }

      this.pn1 = this.h / this.a;  // Normalize relative to the Earth's radius

      if (this.pn1 <= 0 || this.pn1 > 1e10) {
        throw new Error("Invalid height");
      }
      
      this.p = 1 + this.pn1;
      this.rp = 1 / this.p;
      this.h1 = 1 / this.pn1;
      this.pfact = (this.p + 1) * this.h1;
      this.es = 0;

      var omega = this.tilt;
      var gamma = this.azi;
      this.cg = Math.cos(gamma);
      this.sg = Math.sin(gamma);
      this.cw = Math.cos(omega);
      this.sw = Math.sin(omega);
    }

    function forward$t(p) {
      p.x -= this.long0;
      var sinphi = Math.sin(p.y);
      var cosphi = Math.cos(p.y);
      var coslam = Math.cos(p.x);
      var x, y;
      switch (this.mode) {
        case mode.OBLIQ:
          y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
          break;
        case mode.EQUIT:
          y = cosphi * coslam;
          break;
        case mode.S_POLE:
          y = -sinphi;
          break;
        case mode.N_POLE:
          y = sinphi;
          break;
      }
      y = this.pn1 / (this.p - y);
      x = y * cosphi * Math.sin(p.x);

      switch (this.mode) {
        case mode.OBLIQ:
          y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
          break;
        case mode.EQUIT:
          y *= sinphi;
          break;
        case mode.N_POLE:
          y *= -(cosphi * coslam);
          break;
        case mode.S_POLE:
          y *= cosphi * coslam;
          break;
      }

      // Tilt 
      var yt, ba;
      yt = y * this.cg + x * this.sg;
      ba = 1 / (yt * this.sw * this.h1 + this.cw);
      x = (x * this.cg - y * this.sg) * this.cw * ba;
      y = yt * ba;

      p.x = x * this.a;
      p.y = y * this.a;
      return p;
    }

    function inverse$t(p) {
      p.x /= this.a;
      p.y /= this.a;
      var r = { x: p.x, y: p.y };

      // Un-Tilt
      var bm, bq, yt;
      yt = 1 / (this.pn1 - p.y * this.sw);
      bm = this.pn1 * p.x * yt;
      bq = this.pn1 * p.y * this.cw * yt;
      p.x = bm * this.cg + bq * this.sg;
      p.y = bq * this.cg - bm * this.sg;

      var rh = hypot(p.x, p.y);
      if (Math.abs(rh) < EPSLN) {
        r.x = 0;
        r.y = p.y;
      } else {
        var cosz, sinz;
        sinz = 1 - rh * rh * this.pfact;
        sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
        cosz = Math.sqrt(1 - sinz * sinz);
        switch (this.mode) {
          case mode.OBLIQ:
            r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
            p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
            p.x *= sinz * this.cosph0;
            break;
          case mode.EQUIT:
            r.y = Math.asin(p.y * sinz / rh);
            p.y = cosz * rh;
            p.x *= sinz;
            break;
          case mode.N_POLE:
            r.y = Math.asin(cosz);
            p.y = -p.y;
            break;
          case mode.S_POLE:
            r.y = -Math.asin(cosz);
            break;
        }
        r.x = Math.atan2(p.x, p.y);
      }

      p.x = r.x + this.long0;
      p.y = r.y;
      return p;
    }

    var names$v = ["Tilted_Perspective", "tpers"];
    var tpers = {
      init: init$v,
      forward: forward$t,
      inverse: inverse$t,
      names: names$v
    };

    function includedProjections(proj4){
      proj4.Proj.projections.add(tmerc);
      proj4.Proj.projections.add(etmerc);
      proj4.Proj.projections.add(utm);
      proj4.Proj.projections.add(sterea);
      proj4.Proj.projections.add(stere);
      proj4.Proj.projections.add(somerc);
      proj4.Proj.projections.add(omerc);
      proj4.Proj.projections.add(lcc);
      proj4.Proj.projections.add(krovak);
      proj4.Proj.projections.add(cass);
      proj4.Proj.projections.add(laea);
      proj4.Proj.projections.add(aea);
      proj4.Proj.projections.add(gnom);
      proj4.Proj.projections.add(cea);
      proj4.Proj.projections.add(eqc);
      proj4.Proj.projections.add(poly);
      proj4.Proj.projections.add(nzmg);
      proj4.Proj.projections.add(mill);
      proj4.Proj.projections.add(sinu);
      proj4.Proj.projections.add(moll);
      proj4.Proj.projections.add(eqdc);
      proj4.Proj.projections.add(vandg);
      proj4.Proj.projections.add(aeqd);
      proj4.Proj.projections.add(ortho);
      proj4.Proj.projections.add(qsc);
      proj4.Proj.projections.add(robin);
      proj4.Proj.projections.add(geocent);
      proj4.Proj.projections.add(tpers);
    }

    proj4.defaultDatum = 'WGS84'; //default datum
    proj4.Proj = Projection;
    proj4.WGS84 = new proj4.Proj('WGS84');
    proj4.Point = Point;
    proj4.toPoint = common$1;
    proj4.defs = defs;
    proj4.nadgrid = nadgrid;
    proj4.transform = transform;
    proj4.mgrs = mgrs;
    proj4.version = '__VERSION__';
    includedProjections(proj4);

    function CoordTransfer() {

    }

    CoordTransfer.convert = function() {
        var firstProjection = 'PROJCS["NAD83 / Massachusetts Mainland",GEOGCS["NAD83",DATUM["North_American_Datum_1983",SPHEROID["GRS 1980",6378137,298.257222101,AUTHORITY["EPSG","7019"]],AUTHORITY["EPSG","6269"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.01745329251994328,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4269"]],UNIT["metre",1,AUTHORITY["EPSG","9001"]],PROJECTION["Lambert_Conformal_Conic_2SP"],PARAMETER["standard_parallel_1",42.68333333333333],PARAMETER["standard_parallel_2",41.71666666666667],PARAMETER["latitude_of_origin",41],PARAMETER["central_meridian",-71.5],PARAMETER["false_easting",200000],PARAMETER["false_northing",750000],AUTHORITY["EPSG","26986"],AXIS["X",EAST],AXIS["Y",NORTH]]';
        var secondProjection = "+proj=gnom +lat_0=90 +lon_0=0 +x_0=6300000 +y_0=6300000 +ellps=WGS84 +datum=WGS84 +units=m +no_defs";
        //I'm not going to redefine those two in latter examples.
        var a = proj4(firstProjection,secondProjection,[2,5]);
        console.info(a);
    };

    function ProcessTileFeatures(options){
        this.elementMap = {};
        var tileset = new Cesium.Cesium3DTileset(options);
        this._readyPromise = Cesium.when.defer();

        var that = this;
        this.property = Cesium.defaultValue(options.property,'name');
        
        tileset.tileLoad.addEventListener(function (tile) {
            that.processTileFeatures(tile, that.loadFeature);
            that._readyPromise.resolve({
                tile:tile,
                elementMap:that.elementMap
            });
        });

        this._tileset = tileset;
    }


    Object.defineProperties(ProcessTileFeatures.prototype, {
        tileset: {
            get: function () {
                return this._tileset;
            }
        },
        readyPromise: {
            get: function () {
                return this._readyPromise;
            }
        },
    });

    ProcessTileFeatures.prototype.loadFeature = function(feature,process) {
        var elementMap = process.elementMap;

        var element = feature.getProperty(process.property);
        var features = elementMap[element];
        if (!Cesium.defined(features)) {
            features = [];
            elementMap[element] = features;
        }
        
        features.push(feature);
    };

    ProcessTileFeatures.prototype.processTileFeatures = function(tile, callback) {
        var content = tile.content;
        var innerContents = content.innerContents;
        if (Cesium.defined(innerContents)) {
            var length = innerContents.length;
            for (var i = 0; i < length; ++i) {
                ProcessTileFeatures.processContentFeatures(innerContents[i], callback,this);
            }
        } 
        else {
            ProcessTileFeatures.processContentFeatures(content, callback,this);
        }
    };

    ProcessTileFeatures.prototype.stopAnimation = function() {
        if(Cesium.defined(this._offsetAnimation) && !this._offsetAnimation.isDestroyed()){
            this._offsetAnimation.destroy();
        }
    };

    ProcessTileFeatures.prototype.createAnimation = function(boomMap,fulltime,interpolation) {
        this.stopAnimation();

        var that = this;
       
        var offsetAnimation = this._offsetAnimation = new FrameListener;
        offsetAnimation.create = function(fulltime,interpolation,start){
            if(!Cesium.defined(this._sampleHeight)){
                var sampleHeight = new Cesium.SampledProperty(Number);
                var i = 0;
                for(;i< interpolation;i++){
                    var time = Cesium.JulianDate.addSeconds(start,i * fulltime / interpolation,new Cesium.JulianDate());
                    sampleHeight.addSample(time, i * interpolation * fulltime / interpolation);
                    this._end = time;
                }
                this._sampleHeight = sampleHeight;
            }
        };

        offsetAnimation.update = function (scene,time){
            this.create(fulltime,interpolation,time);
            var ratio = this._sampleHeight.getValue(time);

            if(Cesium.JulianDate.compare(time, this._end) >= 0){
                this.destroy();
            }
            if(Cesium.defined(ratio)){
                boomMap.forEach(function(element) {
                    var features = that.elementMap[element.name];
                    if(Cesium.defined(features)){
                        var offsetHeight = Math.abs(element.offset);
                        var featureOffset;
                        offsetHeight *= (ratio / interpolation);
                        var w = Math.floor(offsetHeight / 255.0);
                        var z = offsetHeight - w * 255.0;
                        if(element.offset < 0.0){
                            featureOffset = new Cesium.Cartesian4(0,0,z,w + 127);
                        }
                        else {
                            featureOffset = new Cesium.Cartesian4(0,0,z,w);
                        }
                        features.forEach(function(f){
                            f.offset = featureOffset;
                        });
                    }
                });
            }
        };
        
        return offsetAnimation;
    };


    ProcessTileFeatures.processContentFeatures = function(content, callback, process) {
        var featuresLength = content.featuresLength;
        for (var i = 0; i < featuresLength; ++i) {
            var feature = content.getFeature(i);
            callback(feature,process);
        }
    };

    function EditableCircle(options){
        this._collection = new Cesium.PointPrimitiveCollection();
        this._postionChangedEvent = new Cesium.Event();
        this._removeEventSubscription = this._postionChangedEvent.addEventListener(
            EditableCircle.prototype._onPostionChanged,
            this
        );
    }

    Object.defineProperties(EditableCircle.prototype, {
        position: {
            set: function (value) {
                if(!Cesium.defined(this._point)){
                    this._point = this._collection.add(
                        {
                            color : Cesium.Color.WHITE,
                            outlineWidth : 1.0,
                            outlineColor: Cesium.Color.BLACK,
                            pixelSize : 4,
                            id: this,
                            disableDepthTestDistance: Number.POSITIVE_INFINITY
                        }
                    );
                }
                this._point.position = value;
            },
        },
        extent: {
            set: function (value) {
               this._extent = value;
            },
        },
    });

    EditableCircle.prototype._onPostionChanged = function (
        entity,
        propertyName,
        newValue,
        oldValue
    ) {
        if(Cesium.defined(this.onPostionChanged)){
            this.onPostionChanged(
                entity,
                propertyName,
                newValue,
                oldValue
            );
        }
    };

    EditableCircle.prototype.updateCartesian = function (cartesian) {
        if(Cesium.defined(this._extent)){
            var cartographic = Cesium.Cartographic.fromCartesian(cartesian);
            if(cartographic.longitude < this._extent.west ||
                cartographic.longitude > this._extent.east ||
                cartographic.latitude < this._extent.south ||
                cartographic.latitude > this._extent.north){
                    return;
            }
        }
        this._point.position = cartesian;
        this._postionChangedEvent.raiseEvent(this, "onPostionChanged",cartesian,'');
    };

    EditableCircle.prototype.onHighlight = function () {
        this._point.color = Cesium.Color.AQUA;
    };

    EditableCircle.prototype.offHighlight = function () {
        this._point.color = Cesium.Color.WHITE;
    };

    EditableCircle.prototype.update = function (frameState) {
        this._collection.update(frameState);
    };

    EditableCircle.prototype.destroy = function () {
        this._removeEventSubscription();
        this._collection = this._collection && this._collection.destroy();
        return Cesium.destroyObject(this);
    };

    function MousePicker(scene, options) {
        this._scene = scene;
        this._handler1 = undefined;
    }
    MousePicker.prototype.destroy = function () {
        if (Cesium.defined(this._handler1)) { this._handler1.destroy(); this._handler1 = undefined; }
    };

    MousePicker.prototype.start = function () {
        var highlighted = {
            feature: undefined,
            originalColor: new Cesium.Color()
        };
        var that = this;
        this._handler1 = new Cesium.ScreenSpaceEventHandler(this._scene.canvas);
        this._handler1.setInputAction(function (movement) {
            if (Cesium.defined(highlighted.feature)) {
                highlighted.feature.color = highlighted.originalColor;
                highlighted.feature = undefined;
            }
            var pickedFeature = that._scene.pick(movement.endPosition);
            if (pickedFeature !== highlighted.feature) {
                highlighted.feature = pickedFeature;
                Cesium.Color.clone(pickedFeature.color, highlighted.originalColor);
                if(Cesium.defined(pickedFeature.id)){
                    //pickedFeature.primitive.color = Cesium.Color.YELLOW;
                    pickedFeature.id.model.color = Cesium.Color.YELLOW;
                    pickedFeature.id.model.silhouetteColor = Cesium.Color.BLUE;
                    pickedFeature.id.model.silhouetteSize = 2.0;
                    //pickedFeature.node.show = true;
                }else {
                    pickedFeature.color = Cesium.Color.YELLOW;
                }
            }
        }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    };

    function Travel360(options){

        this._viewPoint = options.viewPoint;
        this._startTime = undefined;
        
    }

    Travel360.prototype.update = function(scene, time){
        
    };

    Travel360.prototype.isDestroyed = function () {
        return false;
    };

    Travel360.prototype.destroy = function () {
        return Cesium.destroyObject(this);
    };

    var heatmap = createCommonjsModule(function (module) {
    (function (name, context, factory) {

      // Supports UMD. AMD, CommonJS/Node.js and browser context
      if ( module.exports) {
        module.exports = factory();
      } else {
        context[name] = factory();
      }

    })("h337", commonjsGlobal, function () {

    // Heatmap Config stores default values and will be merged with instance config
    var HeatmapConfig = {
      defaultRadius: 40,
      defaultRenderer: 'canvas2d',
      defaultGradient: { 0.25: "rgb(0,0,255)", 0.55: "rgb(0,255,0)", 0.85: "yellow", 1.0: "rgb(255,0,0)"},
      defaultMaxOpacity: 1,
      defaultMinOpacity: 0,
      defaultBlur: .85,
      defaultXField: 'x',
      defaultYField: 'y',
      defaultValueField: 'value', 
      plugins: {}
    };
    var Store = (function StoreClosure() {

      var Store = function Store(config) {
        this._coordinator = {};
        this._data = [];
        this._radi = [];
        this._min = 10;
        this._max = 1;
        this._xField = config['xField'] || config.defaultXField;
        this._yField = config['yField'] || config.defaultYField;
        this._valueField = config['valueField'] || config.defaultValueField;

        if (config["radius"]) {
          this._cfgRadius = config["radius"];
        }
      };

      var defaultRadius = HeatmapConfig.defaultRadius;

      Store.prototype = {
        // when forceRender = false -> called from setData, omits renderall event
        _organiseData: function(dataPoint, forceRender) {
            var x = dataPoint[this._xField];
            var y = dataPoint[this._yField];
            var radi = this._radi;
            var store = this._data;
            var max = this._max;
            var min = this._min;
            var value = dataPoint[this._valueField] || 1;
            var radius = dataPoint.radius || this._cfgRadius || defaultRadius;

            if (!store[x]) {
              store[x] = [];
              radi[x] = [];
            }

            if (!store[x][y]) {
              store[x][y] = value;
              radi[x][y] = radius;
            } else {
              store[x][y] += value;
            }
            var storedVal = store[x][y];

            if (storedVal > max) {
              if (!forceRender) {
                this._max = storedVal;
              } else {
                this.setDataMax(storedVal);
              }
              return false;
            } else if (storedVal < min) {
              if (!forceRender) {
                this._min = storedVal;
              } else {
                this.setDataMin(storedVal);
              }
              return false;
            } else {
              return { 
                x: x, 
                y: y,
                value: value, 
                radius: radius,
                min: min,
                max: max 
              };
            }
        },
        _unOrganizeData: function() {
          var unorganizedData = [];
          var data = this._data;
          var radi = this._radi;

          for (var x in data) {
            for (var y in data[x]) {

              unorganizedData.push({
                x: x,
                y: y,
                radius: radi[x][y],
                value: data[x][y]
              });

            }
          }
          return {
            min: this._min,
            max: this._max,
            data: unorganizedData
          };
        },
        _onExtremaChange: function() {
          this._coordinator.emit('extremachange', {
            min: this._min,
            max: this._max
          });
        },
        addData: function() {
          if (arguments[0].length > 0) {
            var dataArr = arguments[0];
            var dataLen = dataArr.length;
            while (dataLen--) {
              this.addData.call(this, dataArr[dataLen]);
            }
          } else {
            // add to store  
            var organisedEntry = this._organiseData(arguments[0], true);
            if (organisedEntry) {
              // if it's the first datapoint initialize the extremas with it
              if (this._data.length === 0) {
                this._min = this._max = organisedEntry.value;
              }
              this._coordinator.emit('renderpartial', {
                min: this._min,
                max: this._max,
                data: [organisedEntry]
              });
            }
          }
          return this;
        },
        setData: function(data) {
          var dataPoints = data.data;
          var pointsLen = dataPoints.length;


          // reset data arrays
          this._data = [];
          this._radi = [];

          for(var i = 0; i < pointsLen; i++) {
            this._organiseData(dataPoints[i], false);
          }
          this._max = data.max;
          this._min = data.min || 0;
          
          this._onExtremaChange();
          this._coordinator.emit('renderall', this._getInternalData());
          return this;
        },
        removeData: function() {
          // TODO: implement
        },
        setDataMax: function(max) {
          this._max = max;
          this._onExtremaChange();
          this._coordinator.emit('renderall', this._getInternalData());
          return this;
        },
        setDataMin: function(min) {
          this._min = min;
          this._onExtremaChange();
          this._coordinator.emit('renderall', this._getInternalData());
          return this;
        },
        setCoordinator: function(coordinator) {
          this._coordinator = coordinator;
        },
        _getInternalData: function() {
          return { 
            max: this._max,
            min: this._min, 
            data: this._data,
            radi: this._radi 
          };
        },
        getData: function() {
          return this._unOrganizeData();
        }/*,

          TODO: rethink.

        getValueAt: function(point) {
          var value;
          var radius = 100;
          var x = point.x;
          var y = point.y;
          var data = this._data;

          if (data[x] && data[x][y]) {
            return data[x][y];
          } else {
            var values = [];
            // radial search for datapoints based on default radius
            for(var distance = 1; distance < radius; distance++) {
              var neighbors = distance * 2 +1;
              var startX = x - distance;
              var startY = y - distance;

              for(var i = 0; i < neighbors; i++) {
                for (var o = 0; o < neighbors; o++) {
                  if ((i == 0 || i == neighbors-1) || (o == 0 || o == neighbors-1)) {
                    if (data[startY+i] && data[startY+i][startX+o]) {
                      values.push(data[startY+i][startX+o]);
                    }
                  } else {
                    continue;
                  } 
                }
              }
            }
            if (values.length > 0) {
              return Math.max.apply(Math, values);
            }
          }
          return false;
        }*/
      };


      return Store;
    })();

    var Canvas2dRenderer = (function Canvas2dRendererClosure() {

      var _getColorPalette = function(config) {
        var gradientConfig = config.gradient || config.defaultGradient;
        var paletteCanvas = document.createElement('canvas');
        var paletteCtx = paletteCanvas.getContext('2d');

        paletteCanvas.width = 256;
        paletteCanvas.height = 1;

        var gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);
        for (var key in gradientConfig) {
          gradient.addColorStop(key, gradientConfig[key]);
        }

        paletteCtx.fillStyle = gradient;
        paletteCtx.fillRect(0, 0, 256, 1);

        return paletteCtx.getImageData(0, 0, 256, 1).data;
      };

      var _getPointTemplate = function(radius, blurFactor) {
        var tplCanvas = document.createElement('canvas');
        var tplCtx = tplCanvas.getContext('2d');
        var x = radius;
        var y = radius;
        tplCanvas.width = tplCanvas.height = radius*2;

        if (blurFactor == 1) {
          tplCtx.beginPath();
          tplCtx.arc(x, y, radius, 0, 2 * Math.PI, false);
          tplCtx.fillStyle = 'rgba(0,0,0,1)';
          tplCtx.fill();
        } else {
          var gradient = tplCtx.createRadialGradient(x, y, radius*blurFactor, x, y, radius);
          gradient.addColorStop(0, 'rgba(0,0,0,1)');
          gradient.addColorStop(1, 'rgba(0,0,0,0)');
          tplCtx.fillStyle = gradient;
          tplCtx.fillRect(0, 0, 2*radius, 2*radius);
        }



        return tplCanvas;
      };

      var _prepareData = function(data) {
        var renderData = [];
        var min = data.min;
        var max = data.max;
        var radi = data.radi;
        var data = data.data;

        var xValues = Object.keys(data);
        var xValuesLen = xValues.length;

        while(xValuesLen--) {
          var xValue = xValues[xValuesLen];
          var yValues = Object.keys(data[xValue]);
          var yValuesLen = yValues.length;
          while(yValuesLen--) {
            var yValue = yValues[yValuesLen];
            var value = data[xValue][yValue];
            var radius = radi[xValue][yValue];
            renderData.push({
              x: xValue,
              y: yValue,
              value: value,
              radius: radius
            });
          }
        }

        return {
          min: min,
          max: max,
          data: renderData
        };
      };


      function Canvas2dRenderer(config) {
        var container = config.container;
        var shadowCanvas = this.shadowCanvas = document.createElement('canvas');
        var canvas = this.canvas = config.canvas || document.createElement('canvas');
        var renderBoundaries = this._renderBoundaries = [10000, 10000, 0, 0];

        var computed = getComputedStyle(config.container) || {};

        canvas.className = 'heatmap-canvas';

        this._width = canvas.width = shadowCanvas.width = config.width || +(computed.width.replace(/px/,''));
        this._height = canvas.height = shadowCanvas.height = config.height || +(computed.height.replace(/px/,''));

        this.shadowCtx = shadowCanvas.getContext('2d');
        this.ctx = canvas.getContext('2d');

        // @TODO:
        // conditional wrapper

        canvas.style.cssText = shadowCanvas.style.cssText = 'position:absolute;left:0;top:0;';

        container.style.position = 'relative';
        container.appendChild(canvas);

        this._palette = _getColorPalette(config);
        this._templates = {};

        this._setStyles(config);
      }
      Canvas2dRenderer.prototype = {
        renderPartial: function(data) {
          if (data.data.length > 0) {
            this._drawAlpha(data);
            this._colorize();
          }
        },
        renderAll: function(data) {
          // reset render boundaries
          this._clear();
          if (data.data.length > 0) {
            this._drawAlpha(_prepareData(data));
            this._colorize();
          }
        },
        _updateGradient: function(config) {
          this._palette = _getColorPalette(config);
        },
        updateConfig: function(config) {
          if (config['gradient']) {
            this._updateGradient(config);
          }
          this._setStyles(config);
        },
        setDimensions: function(width, height) {
          this._width = width;
          this._height = height;
          this.canvas.width = this.shadowCanvas.width = width;
          this.canvas.height = this.shadowCanvas.height = height;
        },
        _clear: function() {
          this.shadowCtx.clearRect(0, 0, this._width, this._height);
          this.ctx.clearRect(0, 0, this._width, this._height);
        },
        _setStyles: function(config) {
          this._blur = (config.blur == 0)?0:(config.blur || config.defaultBlur);

          if (config.backgroundColor) {
            this.canvas.style.backgroundColor = config.backgroundColor;
          }

          this._width = this.canvas.width = this.shadowCanvas.width = config.width || this._width;
          this._height = this.canvas.height = this.shadowCanvas.height = config.height || this._height;


          this._opacity = (config.opacity || 0) * 255;
          this._maxOpacity = (config.maxOpacity || config.defaultMaxOpacity) * 255;
          this._minOpacity = (config.minOpacity || config.defaultMinOpacity) * 255;
          this._useGradientOpacity = !!config.useGradientOpacity;
        },
        _drawAlpha: function(data) {
          var min = this._min = data.min;
          var max = this._max = data.max;
          var data = data.data || [];
          var dataLen = data.length;
          // on a point basis?
          var blur = 1 - this._blur;

          while(dataLen--) {

            var point = data[dataLen];

            var x = point.x;
            var y = point.y;
            var radius = point.radius;
            // if value is bigger than max
            // use max as value
            var value = Math.min(point.value, max);
            var rectX = x - radius;
            var rectY = y - radius;
            var shadowCtx = this.shadowCtx;




            var tpl;
            if (!this._templates[radius]) {
              this._templates[radius] = tpl = _getPointTemplate(radius, blur);
            } else {
              tpl = this._templates[radius];
            }
            // value from minimum / value range
            // => [0, 1]
            var templateAlpha = (value-min)/(max-min);
            // this fixes #176: small values are not visible because globalAlpha < .01 cannot be read from imageData
            shadowCtx.globalAlpha = templateAlpha < .01 ? .01 : templateAlpha;

            shadowCtx.drawImage(tpl, rectX, rectY);

            // update renderBoundaries
            if (rectX < this._renderBoundaries[0]) {
                this._renderBoundaries[0] = rectX;
              }
              if (rectY < this._renderBoundaries[1]) {
                this._renderBoundaries[1] = rectY;
              }
              if (rectX + 2*radius > this._renderBoundaries[2]) {
                this._renderBoundaries[2] = rectX + 2*radius;
              }
              if (rectY + 2*radius > this._renderBoundaries[3]) {
                this._renderBoundaries[3] = rectY + 2*radius;
              }

          }
        },
        _colorize: function() {
          var x = this._renderBoundaries[0];
          var y = this._renderBoundaries[1];
          var width = this._renderBoundaries[2] - x;
          var height = this._renderBoundaries[3] - y;
          var maxWidth = this._width;
          var maxHeight = this._height;
          var opacity = this._opacity;
          var maxOpacity = this._maxOpacity;
          var minOpacity = this._minOpacity;
          var useGradientOpacity = this._useGradientOpacity;

          if (x < 0) {
            x = 0;
          }
          if (y < 0) {
            y = 0;
          }
          if (x + width > maxWidth) {
            width = maxWidth - x;
          }
          if (y + height > maxHeight) {
            height = maxHeight - y;
          }

          var img = this.shadowCtx.getImageData(x, y, width, height);
          var imgData = img.data;
          var len = imgData.length;
          var palette = this._palette;


          for (var i = 3; i < len; i+= 4) {
            var alpha = imgData[i];
            var offset = alpha * 4;


            if (!offset) {
              continue;
            }

            var finalAlpha;
            if (opacity > 0) {
              finalAlpha = opacity;
            } else {
              if (alpha < maxOpacity) {
                if (alpha < minOpacity) {
                  finalAlpha = minOpacity;
                } else {
                  finalAlpha = alpha;
                }
              } else {
                finalAlpha = maxOpacity;
              }
            }

            imgData[i-3] = palette[offset];
            imgData[i-2] = palette[offset + 1];
            imgData[i-1] = palette[offset + 2];
            imgData[i] = useGradientOpacity ? palette[offset + 3] : finalAlpha;

          }

          //img.data = imgData;
          this.ctx.putImageData(img, x, y);

          this._renderBoundaries = [1000, 1000, 0, 0];

        },
        getValueAt: function(point) {
          var value;
          var shadowCtx = this.shadowCtx;
          var img = shadowCtx.getImageData(point.x, point.y, 1, 1);
          var data = img.data[3];
          var max = this._max;
          var min = this._min;

          value = (Math.abs(max-min) * (data/255)) >> 0;

          return value;
        },
        getDataURL: function() {
          return this.canvas.toDataURL();
        }
      };


      return Canvas2dRenderer;
    })();


    var Renderer = (function RendererClosure() {

      var rendererFn = false;

      if (HeatmapConfig['defaultRenderer'] === 'canvas2d') {
        rendererFn = Canvas2dRenderer;
      }

      return rendererFn;
    })();


    var Util = {
      merge: function() {
        var merged = {};
        var argsLen = arguments.length;
        for (var i = 0; i < argsLen; i++) {
          var obj = arguments[i];
          for (var key in obj) {
            merged[key] = obj[key];
          }
        }
        return merged;
      }
    };
    // Heatmap Constructor
    var Heatmap = (function HeatmapClosure() {

      var Coordinator = (function CoordinatorClosure() {

        function Coordinator() {
          this.cStore = {};
        }
        Coordinator.prototype = {
          on: function(evtName, callback, scope) {
            var cStore = this.cStore;

            if (!cStore[evtName]) {
              cStore[evtName] = [];
            }
            cStore[evtName].push((function(data) {
                return callback.call(scope, data);
            }));
          },
          emit: function(evtName, data) {
            var cStore = this.cStore;
            if (cStore[evtName]) {
              var len = cStore[evtName].length;
              for (var i=0; i<len; i++) {
                var callback = cStore[evtName][i];
                callback(data);
              }
            }
          }
        };

        return Coordinator;
      })();


      var _connect = function(scope) {
        var renderer = scope._renderer;
        var coordinator = scope._coordinator;
        var store = scope._store;

        coordinator.on('renderpartial', renderer.renderPartial, renderer);
        coordinator.on('renderall', renderer.renderAll, renderer);
        coordinator.on('extremachange', function(data) {
          scope._config.onExtremaChange &&
          scope._config.onExtremaChange({
            min: data.min,
            max: data.max,
            gradient: scope._config['gradient'] || scope._config['defaultGradient']
          });
        });
        store.setCoordinator(coordinator);
      };


      function Heatmap() {
        var config = this._config = Util.merge(HeatmapConfig, arguments[0] || {});
        this._coordinator = new Coordinator();
        if (config['plugin']) {
          var pluginToLoad = config['plugin'];
          if (!HeatmapConfig.plugins[pluginToLoad]) {
            throw new Error('Plugin \''+ pluginToLoad + '\' not found. Maybe it was not registered.');
          } else {
            var plugin = HeatmapConfig.plugins[pluginToLoad];
            // set plugin renderer and store
            this._renderer = new plugin.renderer(config);
            this._store = new plugin.store(config);
          }
        } else {
          this._renderer = new Renderer(config);
          this._store = new Store(config);
        }
        _connect(this);
      }
      // @TODO:
      // add API documentation
      Heatmap.prototype = {
        addData: function() {
          this._store.addData.apply(this._store, arguments);
          return this;
        },
        removeData: function() {
          this._store.removeData && this._store.removeData.apply(this._store, arguments);
          return this;
        },
        setData: function() {
          this._store.setData.apply(this._store, arguments);
          return this;
        },
        setDataMax: function() {
          this._store.setDataMax.apply(this._store, arguments);
          return this;
        },
        setDataMin: function() {
          this._store.setDataMin.apply(this._store, arguments);
          return this;
        },
        configure: function(config) {
          this._config = Util.merge(this._config, config);
          this._renderer.updateConfig(this._config);
          this._coordinator.emit('renderall', this._store._getInternalData());
          return this;
        },
        repaint: function() {
          this._coordinator.emit('renderall', this._store._getInternalData());
          return this;
        },
        getData: function() {
          return this._store.getData();
        },
        getDataURL: function() {
          return this._renderer.getDataURL();
        },
        getValueAt: function(point) {

          if (this._store.getValueAt) {
            return this._store.getValueAt(point);
          } else  if (this._renderer.getValueAt) {
            return this._renderer.getValueAt(point);
          } else {
            return null;
          }
        }
      };

      return Heatmap;

    })();


    // core
    var heatmapFactory = {
      create: function(config) {
        return new Heatmap(config);
      },
      register: function(pluginKey, plugin) {
        HeatmapConfig.plugins[pluginKey] = plugin;
      }
    };

    return heatmapFactory;


    });
    });

    function CanvasPrimitive(options){
        if(Cesium.defined(options.canvas)){
            this._canvas = options.canvas;
        }else {
            this._canvas = document.createElement('canvas');
            this._canvas.width = Cesium.defaultValue(options.width,512);
            this._canvas.height = Cesium.defaultValue(options.height,512);
        }

        this._primitive = new Cesium.Primitive(options);
        this._dirty = false;
            /*
                source1:
                "czm_material czm_getMaterial(czm_materialInput materialInput) { \n" +
                "    czm_material material = czm_getDefaultMaterial(materialInput); \n" +
                "    vec2 st = materialInput.st; \n" +
                "    vec2 repeat = vec2(10.0,10.0); \n" +
                "    float scaledWidth = fract(repeat.x * st.x); \n" +
                "    scaledWidth = abs(scaledWidth - floor(scaledWidth)); \n" +
                "    float scaledHeight = fract(repeat.y * st.y); \n" +
                "    scaledHeight = abs(scaledHeight - floor(scaledHeight)); \n" +
                "    float xGrid = floor(repeat.x * st.x); \n" +
                "    float yGrid = floor(repeat.y * st.y); \n" +
                "    float alpha = (xGrid/repeat.x + yGrid/repeat.y) * 0.5; \n" +
                "    vec4 color = texture2D(image, vec2(scaledWidth,scaledHeight)); \n" +
                "    st = vec2(scaledWidth,scaledHeight); \n" +
                "    st.x *= 3.0; \n" +
                "    st.x /= 11.0; \n" +
                "    st.x += xGrid/11.0; \n" +
                "    color = texture2D(image, st); \n" +
                "    color = czm_gammaCorrect(color); \n" +
                "    material.diffuse = color.rgb; \n" +
                "    material.alpha = alpha; \n" +
                "    material.shininess = 8.0; \n" + // Sharpen highlight
                "    return material; \n" +
                "} \n",
        */
    }

    Object.defineProperties(CanvasPrimitive.prototype, {
        canvas: {
            get: function () {
                return this._canvas;
            },
        },
        appearance: {
            get: function () {
                return this._primitive.appearance;
            },
        }
    });

    CanvasPrimitive.prototype.update = function (frameState) {
        if(!Cesium.defined(this._texture)){
            this._createTexture(frameState.context);
        }

        if(frameState.passes.render){
            this._primitive.update(frameState);
        }

        if(this._dirty){
            this._dirty = false;
            if(Cesium.defined(this._texture)){
                this._texture.copyFrom(this._canvas);
            }
        }
    };

    CanvasPrimitive.prototype._createTexture = function (context) {
        var sampler = new Cesium.Sampler({
            wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
            wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
            minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
            magnificationFilter: Cesium.TextureMagnificationFilter.LINEAR
        });

        this._texture = new Cesium.Texture({
            context: context,
            source: this._canvas,
            sampler: sampler,
        });

        this._primitive.appearance.material = new Cesium.Material({
            fabric: {
                uniforms: {
                    image: this._texture,
                },
                source:
                  "czm_material czm_getMaterial(czm_materialInput materialInput) { \n" +
                  "    czm_material material = czm_getDefaultMaterial(materialInput); \n" +
                  "    vec2 st = materialInput.st; \n" +
                  "    vec4 color = texture2D(image, st); \n" +
                  "    color = czm_gammaCorrect(color); \n" +
                  "    material.diffuse = color.rgb; \n" +
                  "    material.alpha = color.a; \n" +
                  "    material.shininess = 8.0; \n" + // Sharpen highlight
                  "    return material; \n" +
                  "} \n"
            },
        });
    };

    CanvasPrimitive.prototype.setDirty = function () {
        this._dirty = true;
    };

    CanvasPrimitive.prototype.isDestroyed = function () {
        return false;
    };

    CanvasPrimitive.prototype.destroy = function() {
        this._primitive = this._primitive && this._primitive.destroy();
        this._texture = this._texture && this._texture.destroy();
        this._canvas.remove();
        this._canvas = undefined;
        return Cesium.destroyObject(this);
    };

    function HeatMapLayer(options){
        var container = this.container = Cesium.defaultValue(options.container,document.createElement('DIV'));
        var gradient = Cesium.defaultValue(options.gradient,{
          // enter n keys between 0 and 1 here
          // for gradient color customization
          '0.3': 'blue',
          '0.5': 'green',
          '0.7': 'yellow',
          '0.95': 'red'
        });

        this.heatmapInstance = heatmap.create({
            // only container is required, the rest will be defaults
            container: container,
            maxOpacity: Cesium.defaultValue(options.maxOpacity,0.9),
            radius: Cesium.defaultValue(options.radius,30),
            // minimum opacity. any value > 0 will produce 
            // no transparent gradient transition
            minOpacity: Cesium.defaultValue(options.maxOpacity,0.1),
            gradient: gradient,
            width:Cesium.defaultValue(options.width,1024),
            height:Cesium.defaultValue(options.height,1024)
        });

        this._rectangle = Cesium.defaultValue(options.rectangle,
          Cesium.Rectangle.fromDegrees(-180, -90, 180, 90));
    }

    HeatMapLayer.prototype.setData = function(data){
      this.heatmapInstance.setData(data);
      this._dirty = true;
    };

    HeatMapLayer.prototype.create = function(){
        var rectangle = new Cesium.RectangleGeometry({
          rectangle: this._rectangle
        });

        var geometryInstances = [];
          geometryInstances.push(
            new Cesium.GeometryInstance({
              geometry: rectangle,
          })
        );
      
        var options = {
          geometryInstances: geometryInstances,
          appearance: new Cesium.MaterialAppearance({
            renderState: {
              depthTest: { enabled: true },
              depthMask: true,
              blending: Cesium.BlendingState.ALPHA_BLEND,
              cull: {
                enabled: false,
                face: Cesium.CullFace.FRONT,
              },
            },
            translucent: false,
          }),
          asynchronous: true,
        };
     
        options.canvas = this.heatmapInstance._renderer.canvas;
        this._primitive = new CanvasPrimitive(options);
    };

    HeatMapLayer.prototype.destroy = function () {
      this._primitive = this._primitive && this._primitive.destroy();
      this.heatmapInstance._renderer.canvas.remove();
      this.heatmapInstance._renderer.shadowCanvas.remove();
      this.container = undefined;
      return Cesium.destroyObject(this);
    };

    HeatMapLayer.prototype.isDestroyed = function () {
      return false;
    };

    HeatMapLayer.prototype.update = function (frameState) {
      if(this._dirty){
        if(!Cesium.defined(this._primitive)){
          this.create();
        }else {
          this._primitive.setDirty();
        }
        this._dirty = false;
      }

      if(Cesium.defined(this._primitive)){
        this._primitive.update(frameState);
      }
    };

    // Extend the Array class
    Array.prototype.max = function() {
        return Math.max.apply(null, this);
    };
    Array.prototype.min = function() {
        return Math.min.apply(null, this);
    };
    Array.prototype.mean = function() {
        var i, sum;
        for(i=0,sum=0;i<this.length;i++)
    	sum += this[i];
        return sum / this.length;
    };
    Array.prototype.pip = function(x, y) {
        var i, j, c = false;
        for(i=0,j=this.length-1;i<this.length;j=i++) {
    	if( ((this[i][1]>y) != (this[j][1]>y)) &&
    	    (x<(this[j][0]-this[i][0]) * (y-this[i][1]) / (this[j][1]-this[i][1]) + this[i][0]) ) {
    	    c = !c;
    	}
        }
        return c;
    };

    var kriging = function() {
        var kriging = {};

        var createArrayWithValues = function(value, n) {
            var array = [];
            for ( var i = 0; i < n; i++) {
                array.push(value);
            }
            return array;
        };
    	var i;
        // Matrix algebra
        var kriging_matrix_diag = function(c, n) {
            var Z = createArrayWithValues(0, n * n);
            for(i=0;i<n;i++) Z[i*n+i] = c;
            return Z;
        };
        var kriging_matrix_transpose = function(X, n, m) {
    	var i, j, Z = Array(m*n);
    	for(i=0;i<n;i++)
    	    for(j=0;j<m;j++)
    		Z[j*n+i] = X[i*m+j];
    	return Z;
        };
        var kriging_matrix_add = function(X, Y, n, m) {
    	var i, j, Z = Array(n*m);
    	for(i=0;i<n;i++)
    	    for(j=0;j<m;j++)
    		Z[i*m+j] = X[i*m+j] + Y[i*m+j];
    	return Z;
        };
        // Naive matrix multiplication
        var kriging_matrix_multiply = function(X, Y, n, m, p) {
    	var i, j, k, Z = Array(n*p);
    	for(i=0;i<n;i++) {
    	    for(j=0;j<p;j++) {
    		Z[i*p+j] = 0;
    		for(k=0;k<m;k++)
    		    Z[i*p+j] += X[i*m+k]*Y[k*p+j];
    	    }
    	}
    	return Z;
        };
        // Cholesky decomposition
        var kriging_matrix_chol = function(X, n) {
    	var i, j, k, p = Array(n);
    	for(i=0;i<n;i++) p[i] = X[i*n+i];
    	for(i=0;i<n;i++) {
    	    for(j=0;j<i;j++)
    		p[i] -= X[i*n+j]*X[i*n+j];
    	    if(p[i]<=0) return false;
    	    p[i] = Math.sqrt(p[i]);
    	    for(j=i+1;j<n;j++) {
    		for(k=0;k<i;k++)
    		    X[j*n+i] -= X[j*n+k]*X[i*n+k];
    		X[j*n+i] /= p[i];
    	    }
    	}
    	for(i=0;i<n;i++) X[i*n+i] = p[i];
    	return true;
        };
        // Inversion of cholesky decomposition
        var kriging_matrix_chol2inv = function(X, n) {
    	var i, j, k, sum;
    	for(i=0;i<n;i++) {
    	    X[i*n+i] = 1/X[i*n+i];
    	    for(j=i+1;j<n;j++) {
    		sum = 0;
    		for(k=i;k<j;k++)
    		    sum -= X[j*n+k]*X[k*n+i];
    		X[j*n+i] = sum/X[j*n+j];
    	    }
    	}
    	for(i=0;i<n;i++)
    	    for(j=i+1;j<n;j++)
    		X[i*n+j] = 0;
    	for(i=0;i<n;i++) {
    	    X[i*n+i] *= X[i*n+i];
    	    for(k=i+1;k<n;k++)
    		X[i*n+i] += X[k*n+i]*X[k*n+i];
    	    for(j=i+1;j<n;j++)
    		for(k=j;k<n;k++)
    		    X[i*n+j] += X[k*n+i]*X[k*n+j];
    	}
    	for(i=0;i<n;i++)
    	    for(j=0;j<i;j++)
    		X[i*n+j] = X[j*n+i];

        };
        // Inversion via gauss-jordan elimination
        var kriging_matrix_solve = function(X, n) {
    	var m = n;
    	var b = Array(n*n);
    	var indxc = Array(n);
    	var indxr = Array(n);
    	var ipiv = Array(n);
    	var i, icol, irow, j, k, l, ll;
    	var big, dum, pivinv, temp;

    	for(i=0;i<n;i++)
    	    for(j=0;j<n;j++) {
    		if(i==j) b[i*n+j] = 1;
    		else b[i*n+j] = 0;
    	    }
    	for(j=0;j<n;j++) ipiv[j] = 0;
    	for(i=0;i<n;i++) {
    	    big = 0;
    	    for(j=0;j<n;j++) {
    		if(ipiv[j]!=1) {
    		    for(k=0;k<n;k++) {
    			if(ipiv[k]==0) {
    			    if(Math.abs(X[j*n+k])>=big) {
    				big = Math.abs(X[j*n+k]);
    				irow = j;
    				icol = k;
    			    }
    			}
    		    }
    		}
    	    }
    	    ++(ipiv[icol]);

    	    if(irow!=icol) {
    		for(l=0;l<n;l++) {
    		    temp = X[irow*n+l];
    		    X[irow*n+l] = X[icol*n+l];
    		    X[icol*n+l] = temp;
    		}
    		for(l=0;l<m;l++) {
    		    temp = b[irow*n+l];
    		    b[irow*n+l] = b[icol*n+l];
    		    b[icol*n+l] = temp;
    		}
    	    }
    	    indxr[i] = irow;
    	    indxc[i] = icol;

    	    if(X[icol*n+icol]==0) return false; // Singular

    	    pivinv = 1 / X[icol*n+icol];
    	    X[icol*n+icol] = 1;
    	    for(l=0;l<n;l++) X[icol*n+l] *= pivinv;
    	    for(l=0;l<m;l++) b[icol*n+l] *= pivinv;

    	    for(ll=0;ll<n;ll++) {
    		if(ll!=icol) {
    		    dum = X[ll*n+icol];
    		    X[ll*n+icol] = 0;
    		    for(l=0;l<n;l++) X[ll*n+l] -= X[icol*n+l]*dum;
    		    for(l=0;l<m;l++) b[ll*n+l] -= b[icol*n+l]*dum;
    		}
    	    }
    	}
    	for(l=(n-1);l>=0;l--)
    	    if(indxr[l]!=indxc[l]) {
    		for(k=0;k<n;k++) {
    		    temp = X[k*n+indxr[l]];
    		    X[k*n+indxr[l]] = X[k*n+indxc[l]];
    		    X[k*n+indxc[l]] = temp;
    		}
    	    }

    	return true;
        };

        // Variogram models
        var kriging_variogram_gaussian = function(h, nugget, range, sill, A) {
    	return nugget + ((sill-nugget)/range)*
    	( 1.0 - Math.exp(-(1.0/A)*Math.pow(h/range, 2)) );
        };
        var kriging_variogram_exponential = function(h, nugget, range, sill, A) {
    	return nugget + ((sill-nugget)/range)*
    	( 1.0 - Math.exp(-(1.0/A) * (h/range)) );
        };
        var kriging_variogram_spherical = function(h, nugget, range, sill, A) {
    	if(h>range) return nugget + (sill-nugget)/range;
    	return nugget + ((sill-nugget)/range)*
    	( 1.5*(h/range) - 0.5*Math.pow(h/range, 3) );
        };

        // Train using gaussian processes with bayesian priors
        kriging.train = function(t, x, y, model, sigma2, alpha) {
    	var variogram = {
    	    t      : t,
    	    x      : x,
    	    y      : y,
    	    nugget : 0.0,
    	    range  : 0.0,
    	    sill   : 0.0,
    	    A      : 1/3,
    	    n      : 0
    	};
    	switch(model) {
    	case "gaussian":
    	    variogram.model = kriging_variogram_gaussian;
    	    break;
    	case "exponential":
    	    variogram.model = kriging_variogram_exponential;
    	    break;
    	case "spherical":
    	    variogram.model = kriging_variogram_spherical;
    	    break;
    	}
    	// Lag distance/semivariance
    	var i, j, k, l, n = t.length;
    	var distance = Array((n*n-n)/2);
    	for(i=0,k=0;i<n;i++)
    	    for(j=0;j<i;j++,k++) {
    		distance[k] = Array(2);
    		distance[k][0] = Math.pow(
    		    Math.pow(x[i]-x[j], 2)+
    		    Math.pow(y[i]-y[j], 2), 0.5);
    		distance[k][1] = Math.abs(t[i]-t[j]);
    	    }
    	distance.sort(function(a, b) { return a[0] - b[0]; });
    	variogram.range = distance[(n*n-n)/2-1][0];

    	// Bin lag distance
    	var lags = ((n*n-n)/2)>30?30:(n*n-n)/2;
    	var tolerance = variogram.range/lags;
    	var lag = createArrayWithValues(0,lags);
    	var semi = createArrayWithValues(0,lags);
    	if(lags<30) {
    	    for(l=0;l<lags;l++) {
    		lag[l] = distance[l][0];
    		semi[l] = distance[l][1];
    	    }
    	}
    	else {
    	    for(i=0,j=0,k=0,l=0;i<lags&&j<((n*n-n)/2);i++,k=0) {
    		while( distance[j][0]<=((i+1)*tolerance) ) {
    		    lag[l] += distance[j][0];
    		    semi[l] += distance[j][1];
    		    j++;k++;
    		    if(j>=((n*n-n)/2)) break;
    		}
    		if(k>0) {
    		    lag[l] /= k;
    		    semi[l] /= k;
    		    l++;
    		}
    	    }
    	    if(l<2) return variogram; // Error: Not enough points
    	}

    	// Feature transformation
    	n = l;
    	variogram.range = lag[n-1]-lag[0];
    	 var X = createArrayWithValues(1,2 * n);
    	var Y = Array(n);
    	var A = variogram.A;
    	for(i=0;i<n;i++) {
    	    switch(model) {
    	    case "gaussian":
    		X[i*2+1] = 1.0-Math.exp(-(1.0/A)*Math.pow(lag[i]/variogram.range, 2));
    		break;
    	    case "exponential":
    		X[i*2+1] = 1.0-Math.exp(-(1.0/A)*lag[i]/variogram.range);
    		break;
    	    case "spherical":
    		X[i*2+1] = 1.5*(lag[i]/variogram.range)-
    		    0.5*Math.pow(lag[i]/variogram.range, 3);
    		break;
    	    }	    Y[i] = semi[i];
    	}

    	// Least squares
    	var Xt = kriging_matrix_transpose(X, n, 2);
    	var Z = kriging_matrix_multiply(Xt, X, 2, n, 2);
    	Z = kriging_matrix_add(Z, kriging_matrix_diag(1/alpha, 2), 2, 2);
    	var cloneZ = Z.slice(0);
    	if(kriging_matrix_chol(Z, 2))
    	    kriging_matrix_chol2inv(Z, 2);
    	else {
    	    kriging_matrix_solve(cloneZ, 2);
    	    Z = cloneZ;
    	}
    	var W = kriging_matrix_multiply(kriging_matrix_multiply(Z, Xt, 2, 2, n), Y, 2, n, 1);

    	// Variogram parameters
    	variogram.nugget = W[0];
    	variogram.sill = W[1]*variogram.range+variogram.nugget;
    	variogram.n = x.length;

    	// Gram matrix with prior
    	n = x.length;
    	var K = Array(n*n);
    	for(i=0;i<n;i++) {
    	    for(j=0;j<i;j++) {
    		K[i*n+j] = variogram.model(Math.pow(Math.pow(x[i]-x[j], 2)+
    						    Math.pow(y[i]-y[j], 2), 0.5),
    					   variogram.nugget,
    					   variogram.range,
    					   variogram.sill,
    					   variogram.A);
    		K[j*n+i] = K[i*n+j];
    	    }
    	    K[i*n+i] = variogram.model(0, variogram.nugget,
    				       variogram.range,
    				       variogram.sill,
    				       variogram.A);
    	}

    	// Inverse penalized Gram matrix projected to target vector
    	var C = kriging_matrix_add(K, kriging_matrix_diag(sigma2, n), n, n);
    	var cloneC = C.slice(0);
    	if(kriging_matrix_chol(C, n))
    	    kriging_matrix_chol2inv(C, n);
    	else {
    	    kriging_matrix_solve(cloneC, n);
    	    C = cloneC;
    	}

    	// Copy unprojected inverted matrix as K
    	var K = C.slice(0);
    	var M = kriging_matrix_multiply(C, t, n, n, 1);
    	variogram.K = K;
    	variogram.M = M;

    	return variogram;
        };

        // Model prediction
        kriging.predict = function(x, y, variogram) {
    	var i, k = Array(variogram.n);
    	for(i=0;i<variogram.n;i++)
    	    k[i] = variogram.model(Math.pow(Math.pow(x-variogram.x[i], 2)+
    					    Math.pow(y-variogram.y[i], 2), 0.5),
    				   variogram.nugget, variogram.range,
    				   variogram.sill, variogram.A);
    	return kriging_matrix_multiply(k, variogram.M, 1, variogram.n, 1)[0];
        };
        kriging.variance = function(x, y, variogram) {
    	var i, k = Array(variogram.n);
    	for(i=0;i<variogram.n;i++)
    	    k[i] = variogram.model(Math.pow(Math.pow(x-variogram.x[i], 2)+
    					    Math.pow(y-variogram.y[i], 2), 0.5),
    				   variogram.nugget, variogram.range,
    				   variogram.sill, variogram.A);
    	return variogram.model(0, variogram.nugget, variogram.range,
    			variogram.sill, variogram.A)+
    	kriging_matrix_multiply(kriging_matrix_multiply(k, variogram.K,
    							1, variogram.n, variogram.n),
    				k, 1, variogram.n, 1)[0];
        };

        // Gridded matrices or contour paths
        kriging.grid = function(polygons, variogram, width) {
    	var i, j, k, n = polygons.length;
    	if(n==0) return;

    	// Boundaries of polygons space
    	var xlim = [polygons[0][0][0], polygons[0][0][0]];
    	var ylim = [polygons[0][0][1], polygons[0][0][1]];
    	for(i=0;i<n;i++) // Polygons
    	    for(j=0;j<polygons[i].length;j++) { // Vertices
    		if(polygons[i][j][0]<xlim[0])
    		    xlim[0] = polygons[i][j][0];
    		if(polygons[i][j][0]>xlim[1])
    		    xlim[1] = polygons[i][j][0];
    		if(polygons[i][j][1]<ylim[0])
    		    ylim[0] = polygons[i][j][1];
    		if(polygons[i][j][1]>ylim[1])
    		    ylim[1] = polygons[i][j][1];
    	    }

    	// Alloc for O(n^2) space
    	var xtarget, ytarget;
    	var a = Array(2), b = Array(2);
    	var lxlim = Array(2); // Local dimensions
    	var lylim = Array(2); // Local dimensions
    	var x = Math.ceil((xlim[1]-xlim[0])/width);
    	var y = Math.ceil((ylim[1]-ylim[0])/width);

    	var A = Array(x+1);
    	for(i=0;i<=x;i++) A[i] = Array(y+1);
    	for(i=0;i<n;i++) {
    	    // Range for polygons[i]
    	    lxlim[0] = polygons[i][0][0];
    	    lxlim[1] = lxlim[0];
    	    lylim[0] = polygons[i][0][1];
    	    lylim[1] = lylim[0];
    	    for(j=1;j<polygons[i].length;j++) { // Vertices
    		if(polygons[i][j][0]<lxlim[0])
    		    lxlim[0] = polygons[i][j][0];
    		if(polygons[i][j][0]>lxlim[1])
    		    lxlim[1] = polygons[i][j][0];
    		if(polygons[i][j][1]<lylim[0])
    		    lylim[0] = polygons[i][j][1];
    		if(polygons[i][j][1]>lylim[1])
    		    lylim[1] = polygons[i][j][1];
    	    }

    	    // Loop through polygon subspace
    	    a[0] = Math.floor(((lxlim[0]-((lxlim[0]-xlim[0])%width)) - xlim[0])/width);
    	    a[1] = Math.ceil(((lxlim[1]-((lxlim[1]-xlim[1])%width)) - xlim[0])/width);
    	    b[0] = Math.floor(((lylim[0]-((lylim[0]-ylim[0])%width)) - ylim[0])/width);
    	    b[1] = Math.ceil(((lylim[1]-((lylim[1]-ylim[1])%width)) - ylim[0])/width);
    	    for(j=a[0];j<=a[1];j++)
    		for(k=b[0];k<=b[1];k++) {
    		    xtarget = xlim[0] + j*width;
    		    ytarget = ylim[0] + k*width;
    		    if(polygons[i].pip(xtarget, ytarget))
    			A[j][k] = kriging.predict(xtarget,
    						  ytarget,
    						  variogram);
    		}
    	}
    	A.xlim = xlim;
    	A.ylim = ylim;
    	A.zlim = [variogram.t.min(), variogram.t.max()];
    	A.width = width;
    	return A;
        };
        kriging.contour = function(value, polygons, variogram) {

        };

        // Plotting on the DOM
        kriging.plot = function(canvas, grid, xlim, ylim, colors) {
    	// Clear screen
    	var ctx = canvas.getContext("2d");
    	ctx.clearRect(0, 0, canvas.width, canvas.height);

    	// Starting boundaries
    	var range = [xlim[1]-xlim[0], ylim[1]-ylim[0], grid.zlim[1]-grid.zlim[0]];
    	var i, j, x, y, z;
    	var n = grid.length;
    	var m = grid[0].length;
    	var wx = Math.ceil(grid.width*canvas.width/(xlim[1]-xlim[0]));
    	var wy = Math.ceil(grid.width*canvas.height/(ylim[1]-ylim[0]));
    	for(i=0;i<n;i++)
    	    for(j=0;j<m;j++) {
    		if(grid[i][j]==undefined) continue;
    		x = canvas.width*(i*grid.width+grid.xlim[0]-xlim[0])/range[0];
    		y = canvas.height*(1-(j*grid.width+grid.ylim[0]-ylim[0])/range[1]);
    		z = (grid[i][j]-grid.zlim[0])/range[2];
    		if(z<0.0) z = 0.0;
    		if(z>1.0) z = 1.0;

    		ctx.fillStyle = colors[Math.floor((colors.length-1)*z)];
    		ctx.fillRect(Math.round(x-wx/2), Math.round(y-wy/2), wx, wy);
    	    }

        };


        return kriging;
    }();

    function KrigingLayer(options) {
      this._rectangle = options.rectangle;
      var width = Cesium.defaultValue(options.width, 512);
      var height = Cesium.defaultValue(options.width, 512);
      this.canvas = Cesium.defaultValue(
        options.canvas,
        document.createElement("canvas")
      );
      this.canvas.width = width;
      this.canvas.height = height;

      this.krigingModel = Cesium.defaultValue(options.krigingModel, "exponential"); //model还可选'gaussian','spherical'
      this.krigingSigma2 = Cesium.defaultValue(options.krigingSigma2, 0);
      this.krigingAlpha = Cesium.defaultValue(options.krigingSigma2, 100);

      this._dirty = false;

      this.lngs = [];
      this.lats = [];
      this.values = [];
    }

    Object.defineProperties(KrigingLayer.prototype, {
      rectangle: {
        get: function () {
          return this._rectangle;
        },
        set: function (value) {
          this._rectangle = value;
        },
      },
    });

    KrigingLayer.prototype.push = function (t, x, y) {
      this.lngs.push(x);
      this.lats.push(y);
      this.values.push(t);
    };

    KrigingLayer.prototype.train = function (t, x, y) {
      this.variongram = kriging.train(
        Cesium.defaultValue(t, this.values),
        Cesium.defaultValue(x, this.lngs),
        Cesium.defaultValue(y, this.lats),
        this.krigingModel,
        this.krigingSigma2,
        this.krigingAlpha
      );
      return this.variongram;
    };

    KrigingLayer.prototype.grid = function (polygons, width) {
      if (!Cesium.defined(this.variongram)) {
        this.train();
      }
      this.grid = kriging.grid(polygons, this.variongram, width);
      return this.grid;
    };

    KrigingLayer.prototype.plot = function (xlim, ylim, colors) {
      kriging.plot(this.canvas, this.grid, xlim, ylim, colors);
      this._dirty = true;
    };

    KrigingLayer.prototype.create = function () {
      var rectangle = new Cesium.RectangleGeometry({
        rectangle: this._rectangle,
      });

      var geometryInstances = [];
      geometryInstances.push(
        new Cesium.GeometryInstance({
          geometry: rectangle,
        })
      );

      var options = {
        geometryInstances: geometryInstances,
        appearance: new Cesium.MaterialAppearance({
          renderState: {
            depthTest: { enabled: true },
            depthMask: true,
            blending: Cesium.BlendingState.ALPHA_BLEND,
            cull: {
              enabled: false,
              face: Cesium.CullFace.FRONT,
            },
          },
          translucent: false,
        }),
        asynchronous: true,
      };

      options.canvas = this.canvas;
      this._primitive = new CanvasPrimitive(options);
    };

    KrigingLayer.prototype.destroy = function () {
      this._primitive = this._primitive && this._primitive.destroy();
      return Cesium.destroyObject(this);
    };

    KrigingLayer.prototype.isDestroyed = function () {
      return false;
    };

    KrigingLayer.prototype.update = function (frameState) {
      if (this._dirty && Cesium.defined(this._rectangle)) {
        if (!Cesium.defined(this._primitive)) {
          this.create();
        } else {
          this._primitive.setDirty();
        }
        this._dirty = false;
      }

      if (Cesium.defined(this._primitive)) {
        this._primitive.update(frameState);
      }
    };

    //This file is automatically rebuilt by the WeatherEarth build process.
    var drawVS = "precision mediump float;\n\
\n\
attribute float position;\n\
attribute vec2 st;\n\
\n\
uniform sampler2D u_particles;\n\
uniform float u_particles_res;\n\
uniform vec4 u_range;\n\
\n\
varying vec2 v_particle_pos;\n\
varying vec2 textureCoordinate;\n\
\n\
void main() {\n\
    vec2 st2 = vec2(\n\
        fract(position / u_particles_res),\n\
        floor(position / u_particles_res) / u_particles_res);\n\
\n\
    // float rangeOffsetX = u_range.x;\n\
    // float rangeOffsetY = u_range.y;\n\
    // float rangeWidth = u_range.z;\n\
    // float rangeHeight = u_range.w;\n\
    // st2.x = rangeOffsetX + st2.x * rangeWidth;\n\
    // st2.y = rangeOffsetY + st2.y * rangeHeight;\n\
\n\
    vec4 color = texture2D(u_particles, st2);\n\
    // decode current particle position from the pixel's RGBA value\n\
    v_particle_pos = vec2(\n\
        color.r / 255.0 + color.b,\n\
        color.g / 255.0 + color.a);\n\
\n\
    textureCoordinate = v_particle_pos;\n\
    gl_PointSize = 2.0;\n\
    gl_Position = vec4(2.0 * v_particle_pos.x - 1.0, 1.0 - 2.0 * v_particle_pos.y, 0, 1);\n\
    \n\
}\n\
";

    //This file is automatically rebuilt by the WeatherEarth build process.
    var drawFS = "precision highp float;\n\
\n\
uniform sampler2D u_wind;\n\
uniform sampler2D u_color_ramp;\n\
uniform bool u_flipX;\n\
uniform bool u_use_color_ramp;\n\
uniform vec4 u_range;\n\
\n\
varying vec2 v_particle_pos;\n\
\n\
void main() {\n\
    float scaler = 140.0;\n\
    float clampMin = -70.0;\n\
\n\
    vec2 uv = v_particle_pos;\n\
    float rangeOffsetX = u_range.x;\n\
    float rangeOffsetY = u_range.y;\n\
    float rangeWidth = u_range.z;\n\
    float rangeHeight = u_range.w;\n\
    uv.x = uv.x * rangeWidth + rangeOffsetX;\n\
    uv.y = rangeOffsetY + uv.y * rangeHeight;\n\
    uv.x = mod(uv.x,1.0);\n\
    vec2 velocity = czm_unpackUV(texture2D(u_wind, uv),scaler,clampMin);\n\
    float speed_t = length(velocity) / 70.0;\n\
\n\
    if(u_use_color_ramp){\n\
        gl_FragColor = texture2D(u_color_ramp, vec2(speed_t,0.0));\n\
    }else{\n\
        gl_FragColor = vec4(1.0);\n\
    }\n\
    float alpha = speed_t + 0.8;\n\
\n\
    gl_FragColor.a = clamp(pow(alpha,8.0),0.2,1.0);\n\
}\n\
";

    //This file is automatically rebuilt by the WeatherEarth build process.
    var update_frag = "precision highp float;\n\
\n\
uniform sampler2D u_particles;\n\
uniform sampler2D u_wind;\n\
uniform vec2 u_wind_res;\n\
uniform vec2 u_wind_min;\n\
uniform vec2 u_wind_max;\n\
uniform float u_rand_seed;\n\
uniform float u_speed_factor;\n\
uniform float u_drop_rate;\n\
uniform float u_drop_rate_bump;\n\
uniform bool u_flipX;\n\
uniform vec4 u_range;\n\
\n\
varying vec2 v_tex_pos;\n\
\n\
// pseudo-random generator\n\
const vec3 rand_constants = vec3(12.9898, 78.233, 4375.85453);\n\
float rand(const vec2 co) {\n\
    float t = dot(rand_constants.xy, co);\n\
    return fract(sin(t) * (rand_constants.z + t));\n\
}\n\
\n\
// wind speed lookup; use manual bilinear filtering based on 4 adjacent pixels for smooth interpolation\n\
vec2 lookup_wind(const vec2 uv2) {\n\
    float scaler = 140.0;\n\
    float clampMin = -70.0;\n\
    vec2 px = 1.0 / u_wind_res;\n\
\n\
    vec2 uv = uv2;\n\
\n\
\n\
    float rangeOffsetX = u_range.x;\n\
    float rangeOffsetY = u_range.y;\n\
    float rangeWidth = u_range.z;\n\
    float rangeHeight = u_range.w;\n\
    uv.x = uv.x * rangeWidth + rangeOffsetX;\n\
    uv.y = rangeOffsetY + uv.y * rangeHeight;\n\
\n\
    vec2 vc = (floor(uv * u_wind_res)) * px;\n\
    vec2 f = fract(uv * u_wind_res);\n\
\n\
    vec4 color = texture2D(u_wind, vc);\n\
    vec2 tl = czm_unpackUV(color,scaler,clampMin);\n\
    color = texture2D(u_wind, vc + vec2(px.x, 0));\n\
    vec2 tr = czm_unpackUV(color,scaler,clampMin);\n\
    color = texture2D(u_wind, vc + vec2(0, px.y));\n\
    vec2 bl = czm_unpackUV(color,scaler,clampMin);\n\
    color = texture2D(u_wind, vc + px);\n\
    vec2 br = czm_unpackUV(color,scaler,clampMin);\n\
\n\
    return mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);\n\
}\n\
\n\
void main() {\n\
    vec4 color = texture2D(u_particles, v_tex_pos);\n\
    vec2 pos = vec2(\n\
        color.r / 255.0 + color.b,\n\
        color.g / 255.0 + color.a); // decode particle position from pixel RGBA\n\
\n\
    vec2 velocity = lookup_wind(pos);\n\
    float speed_t = length(velocity) / length(vec2(70.0,70.0));\n\
\n\
    float rangeWidth = u_range.z;\n\
    float rangeHeight = u_range.w;\n\
\n\
    float d1 = 180.0;\n\
    float d2 = 90.0;\n\
\n\
    // take EPSG:4236 distortion into account for calculating where the particle moved\n\
    float distortion = cos(radians(pos.y * d1 - d2));\n\
    vec2 offset = vec2(velocity.x / distortion, -velocity.y) * 0.0001 * u_speed_factor;\n\
\n\
    // update particle position, wrapping around the date line\n\
    pos = fract(1.0 + pos + offset);\n\
\n\
    // a random seed to use for the particle drop\n\
    vec2 seed = (pos + v_tex_pos) * u_rand_seed;\n\
\n\
    // drop rate is a chance a particle will restart at random position, to avoid degeneration\n\
    float drop_rate = u_drop_rate + speed_t * u_drop_rate_bump;\n\
    float drop = step(1.0 - drop_rate, rand(seed));\n\
\n\
    vec2 random_pos = vec2(\n\
        rand(seed + 1.3),\n\
        rand(seed + 2.1));\n\
    pos = mix(pos, random_pos, drop);\n\
\n\
    // encode the new particle position back into RGBA\n\
    gl_FragColor = vec4(\n\
        fract(pos * 255.0),\n\
        floor(pos * 255.0) / 255.0);\n\
}\n\
";

    //This file is automatically rebuilt by the WeatherEarth build process.
    var quad_vert = "attribute vec3 position;\n\
attribute vec2 st;\n\
\n\
varying vec2 v_tex_pos;\n\
varying vec2 textureCoordinate;\n\
\n\
void main() {\n\
    v_tex_pos = st;\n\
    textureCoordinate = st;\n\
	gl_Position = vec4(position, 1.0);\n\
}\n\
";

    function MapBoxWind(options) {
      var that = this;
      this.primitives = {};
      this.textures = {};
      this.framebuffers = {};
      this.u_wind_min = new Cesium.Cartesian2(-70.0, -70.0);
      this.u_wind_max = new Cesium.Cartesian2(70.0, 70.0);

      this.ValueAndColorRamp = Cesium.defaultValue(
        options.ValueAndColorRamp,
        WeatherVolumeTransfunctions.ValueAndColorRamp_UV
      );
      this.scene = options.scene;
      this.context = options.context;
      this._isZip = Cesium.defaultValue(options.zip, false);
      this._flipY = Cesium.defaultValue(options.flipY, false);
      this._currentName = this.name = options.name;
      this.ext = options.ext;
      this.varname = options.varname;

      WeatherData.requestWithParams(this.name, this.varname, this.ext).then(
        function (image) {
          that.success(image, options.context);
        }
      );

      this._flipX = Cesium.defaultValue(options.flipX, false);
      this.fadeOpacity = 0.996; // how fast the particle trails fade on each frame
      this.fadeOpacity = 0.976; // how fast the particle trails fade on each frame
      this.retinaSolution = 3.0;
      this._numParticles = 65536;
      this._numParticles = 262144;
      this._numParticles = 90000;
      this.screenWidth = 2048 * this.retinaSolution;
      this.screenHeight = 1024 * this.retinaSolution;
      this._isLoading = false;
      this._dirty = false;
      this._changeView = false;
      this.byteLength = 0;
      this.range = new Cesium.Cartesian4(0.0, 0.0, 1.0, 1.0);
      this.colorWithSpeed = Cesium.defaultValue(options.colorWithSpeed, false);
      this.extent = undefined;
    }

    Object.defineProperties(MapBoxWind.prototype, {
      currentName: {
        get: function () {
          return this._currentName;
        },
        set: function (value) {
          if (this._currentName !== value) {
            this._currentName = value;
            this._dirty = true;
          }
        },
      },
    });
    MapBoxWind.prototype.updateData = function () {
      if (this._isLoading) {
        return;
      }

      this.loadData(this._currentName);
    };

    MapBoxWind.prototype.loadData = function (name) {
      this._isLoading = true;
      this.name = name;
      var that = this;
      WeatherData.requestWithParams(this.name, this.varname, this.ext)
        .then(function (image) {
          that.success(image, that.context);
        })
        .otherwise(function (error) {
          console.log(error);
          this._isLoading = false;
        });
    };

    MapBoxWind.prototype.success = function (volumeData, context) {
      this._isLoading = false;

      var minLon = -180.0;
      var maxLon = 180.0;
      var minLat = -90.0;
      var maxLat = 90.0;
      var maxValue = 70.0;

      volumeData.source.internalFormat = Cesium.PixelFormat.RGBA;

      if (
        Cesium.defined(this.textureWind) &&
        this.byteLength === volumeData.source.arrayBufferView.length
      ) {
        this.textureWind.copyFrom(volumeData.source);
        return;
      } else {
        this.byteLength = volumeData.source.arrayBufferView.length;
        this.textureWind = new Cesium.Texture({
          context: context,
          sampler: new Cesium.Sampler({
            wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
            wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
            minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
            magnificationFilter: Cesium.TextureMagnificationFilter.LINEAR,
          }),
          source: volumeData.source,
          flipY: this._flipY,
        });
      }

      minLon = volumeData.extent.xmin;
      maxLon = volumeData.extent.xmax;
      minLat = volumeData.extent.ymin;
      maxLat = volumeData.extent.ymax;
      maxValue = volumeData.u_s_o.clampMax;
      if (maxLon > 180.0) {
        minLon -= 180.0;
        maxLon -= 180.0;
      }
      if (minLon < -180.0) {
        var fix = -180.0 - minLon;
        minLon += fix;
        maxLon += fix;
      }
      if (minLat < -90.0) {
        minLat = -90.0;
      }
      if (maxLat > 90.0) {
        maxLat = 90.0;
      }
      this.width = volumeData.source.width;
      this.height = volumeData.source.height;

      this.textureTF = WeatherVolumeLibrary.createTransferTexture(
        context,
        this.ValueAndColorRamp,
        maxValue,
        0,
        Cesium.TextureMinificationFilter.LINEAR,
        Cesium.TextureMagnificationFilter.LINEAR
      );

      this.createRendering(context);
      this.extent = Cesium.Rectangle.fromDegrees(minLon, minLat, maxLon, maxLat);
      this.rebuildRectangle(minLon, minLat, maxLon, maxLat);
      var that = this;
      this._moveEndSubscription = this.scene.camera.moveEnd.addEventListener(
        function () {
          that._changeView = true;
        }
      );
    };

    MapBoxWind.prototype.rebuildRectangle = function (
      minLon,
      minLat,
      maxLon,
      maxLat
    ) {
      this.primitives.groundPrimitive =
        this.primitives.groundPrimitive &&
        this.primitives.groundPrimitive.destroy();

      var rectangle = new Cesium.RectangleGeometry({
        rectangle: Cesium.Rectangle.fromDegrees(minLon, minLat, maxLon, maxLat),
      });
      var geometryInstances = [];
      geometryInstances.push(
        new Cesium.GeometryInstance({
          geometry: rectangle,
        })
      );

      if (!Cesium.defined(this.appearance)) {
        var that = this;
        this.appearance = new Cesium.MaterialAppearance({
          renderState: {
            depthTest: { enabled: true },
            depthMask: true,
            blending: Cesium.BlendingState.ALPHA_BLEND,
            cull: {
              enabled: true,
              face: Cesium.CullFace.BACK,
            },
          },
          translucent: false,
        });

        this.appearance.material = new Cesium.Material({
          fabric: {
            uniforms: {
              image: that.framebuffers.screenFramebuffer.getColorTexture(0),
              u_range: that.range,
              u_flipX: that._flipX,
            },
            source:
              "czm_material czm_getMaterial(czm_materialInput materialInput) { \n" +
              "    czm_material material = czm_getDefaultMaterial(materialInput); \n" +
              "    vec2 st = materialInput.st; \n" +
              "    if(u_flipX){ \n" +
              "     st.x = mod(st.x + 0.5,1.0); \n" +
              "    } \n" +
              "    vec4 color = texture2D(image, st); \n" +
              "    material.diffuse = color.rgb; \n" +
              "    material.alpha = color.a; \n" +
              "    return material; \n" +
              "} \n",
          },
        });
      }

      var options = {
        geometryInstances: geometryInstances,
        appearance: this.appearance,
        asynchronous: true,
      };

      this.primitives.groundPrimitive = new Cesium.GroundPrimitive(options);
    };
    MapBoxWind.prototype.createRendering = function (context) {
      var emptyPixels = new Uint8Array(this.screenWidth * this.screenHeight * 4);
      var colorTextureOptions = {
        context: context,
        width: this.screenWidth,
        height: this.screenHeight,
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE,
        flipY: false,
        sampler: new Cesium.Sampler({
          minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
          magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST,
        }),
      };

      var particleState = new Uint8Array(this._numParticles * 4);
      for (var i = 0; i < particleState.length; i++) {
        particleState[i] = Math.floor(Math.random() * 256); // randomize the initial particle positions
      }

      var particleRes = (this.particleStateResolution = Math.ceil(
        Math.sqrt(this._numParticles)
      ));

      var particlesTextureOptions = {
        context: context,
        width: particleRes,
        height: particleRes,
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE,
        flipY: false,
        sampler: new Cesium.Sampler({
          minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
          magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST,
        }),
      };

      this.backgroundTexture = Util.createTexture(colorTextureOptions, emptyPixels);
      this.screenTexture = Util.createTexture(colorTextureOptions, emptyPixels);
      this.particleStateTexture0 = Util.createTexture(
        particlesTextureOptions,
        particleState
      );
      this.particleStateTexture1 = Util.createTexture(
        particlesTextureOptions,
        particleState
      );

      this.framebuffers = {
        screenFramebuffer: Util.createFramebuffer(context, this.screenTexture),
        backgroundFramebuffer: Util.createFramebuffer(
          context,
          this.backgroundTexture
        ),
        particleFramebuffer0: Util.createFramebuffer(
          context,
          this.particleStateTexture0
        ),
        particleFramebuffer1: Util.createFramebuffer(
          context,
          this.particleStateTexture1
        ),
      };

      this.createCustomPrimitive();
    };

    MapBoxWind.prototype.createCustomPrimitive = function () {
      var screenfs =
        "uniform sampler2D screenTexture;\n\
    uniform float u_opacity;\n\
    varying vec2 v_tex_pos;\n\
    varying vec2 textureCoordinate;\n\
    void main() {\n\
    \n\
        vec4 color = texture2D(screenTexture,textureCoordinate);\n\
        gl_FragColor = vec4(color.rgb,floor(255.0 * color.a * u_opacity) / 255.0);\n\
    }";

      var that = this;

      this.primitives.updatePartical = new CustomPrimitive({
        commandType: "Draw",
        geometry: Util.getFullscreenQuad(),
        uniformMap: {
          u_wind: function () {
            return that.textureWind;
          },
          u_particles: function () {
            return that.framebuffers.particleFramebuffer1.getColorTexture(0);
          },
          u_rand_seed: function () {
            return Math.random();
          },
          u_wind_res: function () {
            return new Cesium.Cartesian2(that.width, that.height);
          },
          u_wind_min: function () {
            return new that.u_wind_min();
          },
          u_wind_max: function () {
            return new that.u_wind_max();
          },
          u_speed_factor: function () {
            return 0.25;
          },
          u_drop_rate: function () {
            return 0.003;
          },
          u_drop_rate_bump: function () {
            return 0.01;
          },
          u_flipX: function () {
            return that._flipX;
          },
          u_range: function () {
            return that.range;
          },
        },
        vertexShaderSource: new Cesium.ShaderSource({
          sources: [quad_vert],
        }),
        fragmentShaderSource: new Cesium.ShaderSource({
          sources: [update_frag],
        }),
        rawRenderState: Util.createRawRenderState({
          viewport: new Cesium.BoundingRectangle(
            0,
            0,
            this.particleStateResolution,
            this.particleStateResolution
          ),
          depthTest: {
            enabled: false,
          },
          depthMask: false,
          blending: {
            enabled: false,
          },
        }),
        framebuffer: this.framebuffers.particleFramebuffer0,
        autoClear: false,
      });

      this.primitives.drawScreen = new CustomPrimitive({
        commandType: "Draw",
        geometry: Util.getFullscreenQuad(),
        uniformMap: {
          screenTexture: function () {
            return that.framebuffers.backgroundFramebuffer.getColorTexture(0);
          },
          u_opacity: function () {
            return that.fadeOpacity;
          },
        },
        vertexShaderSource: new Cesium.ShaderSource({
          sources: [quad_vert],
        }),
        fragmentShaderSource: new Cesium.ShaderSource({
          sources: [screenfs],
        }),
        rawRenderState: Util.createRawRenderState({
          viewport: new Cesium.BoundingRectangle(
            0,
            0,
            this.screenWidth,
            this.screenHeight
          ),
          depthTest: {
            enabled: false,
          },
          depthMask: false,
          blending: {
            enabled: false,
          },
        }),
        framebuffer: this.framebuffers.screenFramebuffer,
        autoClear: false,
      });

      this.primitives.drawParticles = new CustomPrimitive({
        commandType: "Draw",
        geometry: this.createSegmentsGeometry(),
        primitiveType: Cesium.PrimitiveType.POINTS,
        uniformMap: {
          u_particles_res: function () {
            return that.particleStateResolution;
          },
          u_wind: function () {
            return that.textureWind;
          },
          u_particles: function () {
            return that.framebuffers.particleFramebuffer0.getColorTexture(0);
          },
          u_color_ramp: function () {
            return that.textureTF;
          },
          u_flipX: function () {
            return that._flipX;
          },
          u_use_color_ramp: function () {
            return that.colorWithSpeed;
          },
          u_range: function () {
            return that.range;
          },
        },
        vertexShaderSource: new Cesium.ShaderSource({
          sources: [drawVS],
        }),
        fragmentShaderSource: new Cesium.ShaderSource({
          sources: [drawFS],
        }),
        rawRenderState: Util.createRawRenderState({
          viewport: new Cesium.BoundingRectangle(
            0,
            0,
            this.screenWidth,
            this.screenHeight
          ),
          depthTest: {
            enabled: false,
          },
          depthMask: false,
          blending: {
            enabled: false,
          },
        }),
        framebuffer: this.framebuffers.screenFramebuffer,
        autoClear: false,
      });
    };

    MapBoxWind.prototype.createSegmentsGeometry = function () {
      var st = [];
      for (var s = 0; s < this.particleStateResolution; s++) {
        for (var t = 0; t < this.particleStateResolution; t++) {
          st.push(s / (this.particleStateResolution - 1));
          st.push(t / (this.particleStateResolution - 1));
        }
      }
      st = new Float32Array(st);

      var particleIndices = new Float32Array(this._numParticles);
      for (var i$1 = 0; i$1 < this._numParticles; i$1++) {
        particleIndices[i$1] = i$1;
      }

      var geometry = new Cesium.Geometry({
        attributes: new Cesium.GeometryAttributes({
          position: new Cesium.GeometryAttribute({
            componentDatatype: Cesium.ComponentDatatype.FLOAT,
            componentsPerAttribute: 1,
            values: particleIndices,
          }),
          st: new Cesium.GeometryAttribute({
            componentDatatype: Cesium.ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: st,
          }),
        }),
      });

      return geometry;
    };

    MapBoxWind.prototype.updateViewerParameters = function (frameState) {
      var viewRectangle = frameState.camera.computeViewRectangle(
        Cesium.Ellipsoid.WGS84
      );

      var west = viewRectangle.west;
      var east = viewRectangle.east;
      var south = viewRectangle.south;
      var north = viewRectangle.north;
      var height = viewRectangle.height;
      var width = viewRectangle.width;

      var extendHeight = height > Cesium.Math.PI / 32 ? height / 2 : 0;
      var extendedSouth = Cesium.Math.clampToLatitudeRange(south - extendHeight);
      var extendedNorth = Cesium.Math.clampToLatitudeRange(north + extendHeight);
      if (extendedSouth < -Cesium.Math.PI_OVER_THREE) {
        extendedSouth = -Cesium.Math.PI_OVER_TWO;
      }
      if (extendedNorth > Cesium.Math.PI_OVER_THREE) {
        extendedNorth = Cesium.Math.PI_OVER_TWO;
      }

      //extendedNorth = Cesium.Math.PI_OVER_TWO;
      //extendedSouth = -Cesium.Math.PI_OVER_TWO;
      var flag = false;
      var east2 = east;
      if (east < west) {
        east += Cesium.Math.TWO_PI;
        width = east - west;
        flag = true;
      }
      if (width > this.extent.width) {
        width = this.extent.width;
      }
      var viewRectangle2 = Cesium.Rectangle.fromRadians(
        west,
        extendedSouth,
        east,
        extendedNorth
      );
      var viewRectangle3 = Cesium.Rectangle.intersection(
        this.extent,
        viewRectangle2
      );
      west = viewRectangle3.west;
      extendedSouth = viewRectangle3.south;
      east = viewRectangle3.east;
      extendedNorth = viewRectangle3.north;

      this.rebuildRectangle(
        Cesium.Math.toDegrees(west),
        Cesium.Math.toDegrees(extendedSouth),
        Cesium.Math.toDegrees(flag ? east2 : east),
        Cesium.Math.toDegrees(extendedNorth)
      );

      this.range.x = (west - this.extent.west) / this.extent.width;
      this.range.y = (this.extent.north - extendedNorth) / this.extent.height;
      this.range.z = width / this.extent.width;
      this.range.w = (extendedNorth - extendedSouth) / this.extent.height;
    };

    MapBoxWind.prototype.update = function (frameState) {
      if (Cesium.defined(this.primitives.groundPrimitive)) {
        if (this._changeView) {
          this._changeView = false;
          this.updateViewerParameters(frameState);
          this._skipNextFrame = true;
          frameState.commandList.push(
            new Cesium.ClearCommand({
              color: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
              depth: 1.0,
              framebuffer: this.framebuffers.screenFramebuffer,
              pass: Cesium.Pass.OPAQUE,
            })
          );
        }

        if (this._dirty) {
          this._dirty = false;
          this.updateData();
        }

        this.primitives.drawScreen.update(frameState);
        this.primitives.drawParticles.update(frameState);

        var temp1;
        temp1 = this.framebuffers.screenFramebuffer;
        this.framebuffers.screenFramebuffer =
          this.framebuffers.backgroundFramebuffer;
        this.framebuffers.backgroundFramebuffer = temp1;

        // keep the framebuffers up to date
        this.primitives.drawScreen.commandToExecute.framebuffer =
          this.framebuffers.screenFramebuffer;
        this.primitives.drawParticles.commandToExecute.framebuffer =
          this.framebuffers.screenFramebuffer;

        this.primitives.updatePartical.update(frameState);

        var temp;
        temp = this.framebuffers.particleFramebuffer1;
        this.framebuffers.particleFramebuffer1 =
          this.framebuffers.particleFramebuffer0;
        this.framebuffers.particleFramebuffer0 = temp;

        // keep the framebuffers up to date
        this.primitives.updatePartical.commandToExecute.framebuffer =
          this.framebuffers.particleFramebuffer0;

        this.primitives.groundPrimitive.update(frameState);

        if (this._skipNextFrame) {
          this._skipNextFrame = false;
          frameState.commandList.push(
            new Cesium.ClearCommand({
              color: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
              depth: 1.0,
              framebuffer: this.framebuffers.screenFramebuffer,
              pass: Cesium.Pass.OPAQUE,
            })
          );
        }
      }
    };

    MapBoxWind.prototype.isDestroyed = function () {
      return false;
    };

    MapBoxWind.prototype.destroy = function () {
      this.primitives.drawScreen =
        this.primitives.drawScreen && this.primitives.drawScreen.destroy();
      this.primitives.drawParticles =
        this.primitives.drawParticles && this.primitives.drawParticles.destroy();
      this.primitives.updatePartical =
        this.primitives.updatePartical && this.primitives.updatePartical.destroy();
      this.primitives.groundPrimitive =
        this.primitives.groundPrimitive &&
        this.primitives.groundPrimitive.destroy();
      this.textureTF = this.textureTF && this.textureTF.destroy();
      this.textureWind = this.textureWind && this.textureWind.destroy();
      this.backgroundTexture =
        this.backgroundTexture && this.backgroundTexture.destroy();
      this.screenTexture = this.screenTexture && this.screenTexture.destroy();
      this.particleStateTexture0 =
        this.particleStateTexture0 && this.particleStateTexture0.destroy();
      this.particleStateTexture1 =
        this.particleStateTexture1 && this.particleStateTexture1.destroy();

      return Cesium.destroyObject(this);
    };

    var sizeOfUint32$2 = Uint32Array.BYTES_PER_ELEMENT;

    function PntsPrimitiveCollection(options){
        this._billboards = new Cesium.BillboardCollection();
        this._billboards.modelMatrix = options.modelMatrix;
        this._canvas = options.canvas;

        var that = this;

        var resource = Cesium.Resource.createIfNeeded(options.url);
        resource.fetchArrayBuffer().then(function (arrayBuffer){
            var byteOffset = Cesium.defaultValue(options.byteOffset, 0);

            var uint8Array = new Uint8Array(arrayBuffer);
            var view = new DataView(arrayBuffer);
            byteOffset += sizeOfUint32$2; // Skip magic
            var version = view.getUint32(byteOffset, true);
            if (version !== 1) {
                throw new Cesium.RuntimeError(
                  "Only Point Cloud tile version 1 is supported.  Version " +
                    version +
                    " is not."
                );
              }
            byteOffset += sizeOfUint32$2;

            // Skip byteLength
            byteOffset += sizeOfUint32$2;
        
            var featureTableJsonByteLength = view.getUint32(byteOffset, true);
            if (featureTableJsonByteLength === 0) {
            throw new Cesium.RuntimeError(
                "Feature table must have a byte length greater than zero"
            );
            }
            byteOffset += sizeOfUint32$2;
            var featureTableBinaryByteLength = view.getUint32(byteOffset, true);
            byteOffset += sizeOfUint32$2;
            var batchTableJsonByteLength = view.getUint32(byteOffset, true);
            byteOffset += sizeOfUint32$2;
            var batchTableBinaryByteLength = view.getUint32(byteOffset, true);
            byteOffset += sizeOfUint32$2;
            var featureTableString = Cesium.getStringFromTypedArray(
                uint8Array,
                byteOffset,
                featureTableJsonByteLength
              );
            var featureTableJson = JSON.parse(featureTableString);
            byteOffset += featureTableJsonByteLength;

            var featureTableBinary = new Uint8Array(
                arrayBuffer,
                byteOffset,
                featureTableBinaryByteLength
              );
            byteOffset += featureTableBinaryByteLength;

              // Get the batch table JSON and binary
            var batchTableJson;
            var batchTableBinary;
            if (batchTableJsonByteLength > 0) {
                // Has a batch table JSON
                var batchTableString = Cesium.getStringFromTypedArray(
                    uint8Array,
                    byteOffset,
                    batchTableJsonByteLength
                );
                batchTableJson = JSON.parse(batchTableString);
                byteOffset += batchTableJsonByteLength;

                if (batchTableBinaryByteLength > 0) {
                    // Has a batch table binary
                    batchTableBinary = new Uint8Array(
                        arrayBuffer,
                        byteOffset,
                        batchTableBinaryByteLength
                    );
                    byteOffset += batchTableBinaryByteLength;
                }
            }

            var featureTable = new Cesium.Cesium3DTileFeatureTable(
                featureTableJson,
                featureTableBinary
              );
            
            var pointsLength = featureTable.getGlobalProperty("POINTS_LENGTH");
            featureTable.featuresLength = pointsLength;

            var positions;
            var batchIds;
            var batchTable;

            positions = featureTable.getPropertyArray(
                "POSITION",
                Cesium.ComponentDatatype.FLOAT,
                3
            );

            var hasBatchIds = false;
            if (!hasBatchIds) {
                if (Cesium.defined(featureTableJson.BATCH_ID)) {
                  batchIds = featureTable.getPropertyArray(
                    "BATCH_ID",
                    Cesium.ComponentDatatype.UNSIGNED_SHORT,
                    1
                  );
                  hasBatchIds = true;
                }
            }

            if (hasBatchIds) {
                var batchLength = featureTable.getGlobalProperty("BATCH_LENGTH");
                if (!Cesium.defined(batchLength)) {
                  throw new Cesium.RuntimeError(
                    "Global property: BATCH_LENGTH must be defined when BATCH_ID is defined."
                  );
                }
            
                if (Cesium.defined(batchTableBinary)) {
                  // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed
                  batchTableBinary = new Uint8Array(batchTableBinary);
                }

                that._batchtable = batchTable = new Cesium.Cesium3DTileBatchTable(
                that,
                batchLength,
                batchTableJson,
                batchTableBinary
                );
            }

            var scratchPosition = new Cesium.Cartesian3();
            var size = 12;
            for (var i = 0; i < pointsLength; ++i) {
                var position = Cesium.Cartesian3.unpack(positions, i * 3, scratchPosition);
                var batchId = batchIds[i];
                var b = that._billboards.add({
                    position : position,
                    height : size,
                    width : size,
                });
                var intens = batchTable.getProperty(batchId,'intens');
                var height = batchTable.getProperty(batchId,'height');
                var offsetX = Math.ceil(Math.random()*10) % 4;
                var offsetY = 2;

                if(height === 0.0) {
                  offsetY = intens > 0 ? 0 : 1;
                }

                offsetY = 2 - offsetY;
                b.setImage('1',that._canvas);
                b.setImageSubRegion('1',new Cesium.BoundingRectangle(200 * offsetX,200 * offsetY,200,200));
            }

        });
    }

    Object.defineProperties(PntsPrimitiveCollection.prototype, {
      batchtable: {
        get: function () {
          return this._batchtable;
        }
      },
    });

    PntsPrimitiveCollection.prototype.update = function (frameState) {
        if(frameState.passes.render){
            this._billboards.update(frameState);
        }
    };

    PntsPrimitiveCollection.prototype.destroy = function () {
      this._billboards = this._billboards && this._billboards.destroy();
      return Cesium.destroyObject(this);
    };

    function PointDataSource(options) {
        //All public configuration is defined as ES5 properties
        //These are just the "private" variables and their defaults.
        this._name = options.name;
        this._changed = new Cesium.Event();
        this._error = new Cesium.Event();
        this._isLoading = false;
        this._loading = new Cesium.Event();
        this._entityCollection = new Cesium.EntityCollection();
        this._seriesNames = [];
        this._seriesToDisplay = undefined;
        this._offsetHeight = Cesium.defaultValue(options.offsetHeight,0);
        this._heightScale = Cesium.defaultValue(options.heightScale,10000);
        this._entityCluster = new Cesium.EntityCluster();
        this._show = true;
        this._random = Cesium.defaultValue(options.random,false);
        this._color = Cesium.defaultValue(options.color,Cesium.Color.RED);
        this._outlineColor = Cesium.defaultValue(options.outlineColor,Cesium.Color.YELLOW);
      }
      
      Object.defineProperties(PointDataSource.prototype, {
        //The below properties must be implemented by all DataSource instances
      
        /**
         * Gets a human-readable name for this instance.
         * @memberof PointDataSource.prototype
         * @type {String}
         */
        name: {
          get: function () {
            return this._name;
          },
        },
        /**
         * Since WebGL Globe JSON is not time-dynamic, this property is always undefined.
         * @memberof PointDataSource.prototype
         * @type {DataSourceClock}
         */
        clock: {
          value: undefined,
          writable: false,
        },
        /**
         * Gets the collection of Entity instances.
         * @memberof PointDataSource.prototype
         * @type {EntityCollection}
         */
        entities: {
          get: function () {
            return this._entityCollection;
          },
        },
        /**
         * Gets a value indicating if the data source is currently loading data.
         * @memberof PointDataSource.prototype
         * @type {Boolean}
         */
        isLoading: {
          get: function () {
            return this._isLoading;
          },
        },
        /**
         * Gets an event that will be raised when the underlying data changes.
         * @memberof PointDataSource.prototype
         * @type {Event}
         */
        changedEvent: {
          get: function () {
            return this._changed;
          },
        },
        /**
         * Gets an event that will be raised if an error is encountered during
         * processing.
         * @memberof PointDataSource.prototype
         * @type {Event}
         */
        errorEvent: {
          get: function () {
            return this._error;
          },
        },
        /**
         * Gets an event that will be raised when the data source either starts or
         * stops loading.
         * @memberof PointDataSource.prototype
         * @type {Event}
         */
        loadingEvent: {
          get: function () {
            return this._loading;
          },
        },
      
        //These properties are specific to this DataSource.
      
        /**
         * Gets the array of series names.
         * @memberof PointDataSource.prototype
         * @type {String[]}
         */
        seriesNames: {
          get: function () {
            return this._seriesNames;
          },
        },
        /**
         * Gets or sets the name of the series to display.  WebGL JSON is designed
         * so that only one series is viewed at a time.  Valid values are defined
         * in the seriesNames property.
         * @memberof PointDataSource.prototype
         * @type {String}
         */
        seriesToDisplay: {
          get: function () {
            return this._seriesToDisplay;
          },
          set: function (value) {
            this._seriesToDisplay = value;
      
            //Iterate over all entities and set their show property
            //to true only if they are part of the current series.
            var collection = this._entityCollection;
            var entities = collection.values;
            collection.suspendEvents();
            for (var i = 0; i < entities.length; i++) {
              var entity = entities[i];
              entity.show = value === entity.seriesName;
            }
            collection.resumeEvents();
          },
        },
        /**
         * Gets or sets the scale factor applied to the height of each line.
         * @memberof PointDataSource.prototype
         * @type {Number}
         */
        heightScale: {
          get: function () {
            return this._heightScale;
          },
          set: function (value) {
            if (value <= 0) {
              throw new Cesium.DeveloperError("value must be greater than 0");
            }
            this._heightScale = value;
          },
        },
        /**
         * Gets whether or not this data source should be displayed.
         * @memberof PointDataSource.prototype
         * @type {Boolean}
         */
        show: {
          get: function () {
            return this._show;
          },
          set: function (value) {
            this._show = value;
            var collection = this._entityCollection;
            var entities = collection.values;
            collection.suspendEvents();
            for (var i = 0; i < entities.length; i++) {
              var entity = entities[i];
              entity.show = value;
            }
            collection.resumeEvents();
          },
        },
        /**
         * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
         * @memberof PointDataSource.prototype
         * @type {EntityCluster}
         */
        clustering: {
          get: function () {
            return this._entityCluster;
          },
          set: function (value) {
            if (!Cesium.defined(value)) {
              throw new Cesium.DeveloperError("value must be defined.");
            }
            this._entityCluster = value;
          },
        },
      });
      
      /**
       * Asynchronously loads the GeoJSON at the provided url, replacing any existing data.
       * @param {Object} url The url to be processed.
       * @returns {Promise} a promise that will resolve when the GeoJSON is loaded.
       */
      PointDataSource.prototype.loadUrl = function (url) {
        if (!Cesium.defined(url)) {
          throw new Cesium.DeveloperError("url is required.");
        }
      
        var that = this;
        return Cesium.Resource.fetchJson(url)
          .then(function (json) {
            return that.load(json, url);
          })
          .otherwise(function (error) {
            //Otherwise will catch any errors or exceptions that occur
            //during the promise processing. When this happens,
            //we raise the error event and reject the promise.
            this._setLoading(false);
            that._error.raiseEvent(that, error);
            return Cesium.when.reject(error);
          });
      };
      
      /**
       * Loads the provided data, replacing any existing data.
       * @param {Array} data The object to be processed.
       */
      PointDataSource.prototype.load = function (data) {
      
        //Clear out any data that might already exist.
        this._setLoading(true);
        this._seriesNames.length = 0;
        this._seriesToDisplay = undefined;
      
        var heightScale = this.heightScale;
        var entities = this._entityCollection;
      
        //It's a good idea to suspend events when making changes to a
        //large amount of entities.  This will cause events to be batched up
        //into the minimal amount of function calls and all take place at the
        //end of processing (when resumeEvents is called).
        entities.suspendEvents();
        entities.removeAll();
      
        //WebGL Globe JSON is an array of series, where each series itself is an
        //array of two items, the first containing the series name and the second
        //being an array of repeating latitude, longitude, height values.
        //
        //Here's a more visual example.
        //[["series1",[latitude, longitude, height, ... ]
        // ["series2",[latitude, longitude, height, ... ]]
      
        // Loop over each series
        for (var x = 0; x < data.geometries.length; x++) {
          var coordinates = data.geometries[x].coordinates;
          var longitude = coordinates[0];
          var latitude = coordinates[1];
          var height = this._offsetHeight + Math.random();

          if(this._random){
            var i = Math.random();
            if(i < 0.9){
              continue;
            }
          }

          var color = this._color;
          var outlineColor = this._outlineColor;
          var surfacePosition = Cesium.Cartesian3.fromDegrees(
            longitude,
            latitude,
            height * heightScale
          );

          var entity = new Cesium.Entity({
            id: this._name + " index " + x.toString(),
            show: this._show,
            position: surfacePosition,
            point: {
                pixelSize: 8,
                outlineWidth: 2,
                color: color,
                outlineColor: outlineColor,
            }
          });

          //Add the entity to the collection.
          entities.add(entity);
        }
      
        //Once all data is processed, call resumeEvents and raise the changed event.
        entities.resumeEvents();
        this._changed.raiseEvent(this);
        this._setLoading(false);
      };
      
      PointDataSource.prototype._setLoading = function (isLoading) {
        if (this._isLoading !== isLoading) {
          this._isLoading = isLoading;
          this._loading.raiseEvent(this, isLoading);
        }
      };

    /**
     * This class is an example of a custom DataSource.  It loads JSON data as
     * defined by Google's WebGL Globe, https://github.com/dataarts/webgl-globe.
     * @alias WebGLGlobeDataSource
     * @constructor
     *
     * @param {String} [name] The name of this data source.  If undefined, a name
     *                        will be derived from the url.
     *
     * @example
     * var dataSource = new Cesium.WebGLGlobeDataSource();
     * dataSource.loadUrl('sample.json');
     * viewer.dataSources.add(dataSource);
     */
    function WebGLGlobeDataSource(name) {
        //All public configuration is defined as ES5 properties
        //These are just the "private" variables and their defaults.
        this._name = name;
        this._changed = new Cesium.Event();
        this._error = new Cesium.Event();
        this._isLoading = false;
        this._loading = new Cesium.Event();
        this._entityCollection = new Cesium.EntityCollection();
        this._seriesNames = [];
        this._seriesToDisplay = undefined;
        this._heightScale = 10000000;
        this._entityCluster = new Cesium.EntityCluster();
      }
      
      Object.defineProperties(WebGLGlobeDataSource.prototype, {
        //The below properties must be implemented by all DataSource instances
      
        /**
         * Gets a human-readable name for this instance.
         * @memberof WebGLGlobeDataSource.prototype
         * @type {String}
         */
        name: {
          get: function () {
            return this._name;
          },
        },
        /**
         * Since WebGL Globe JSON is not time-dynamic, this property is always undefined.
         * @memberof WebGLGlobeDataSource.prototype
         * @type {DataSourceClock}
         */
        clock: {
          value: undefined,
          writable: false,
        },
        /**
         * Gets the collection of Entity instances.
         * @memberof WebGLGlobeDataSource.prototype
         * @type {EntityCollection}
         */
        entities: {
          get: function () {
            return this._entityCollection;
          },
        },
        /**
         * Gets a value indicating if the data source is currently loading data.
         * @memberof WebGLGlobeDataSource.prototype
         * @type {Boolean}
         */
        isLoading: {
          get: function () {
            return this._isLoading;
          },
        },
        /**
         * Gets an event that will be raised when the underlying data changes.
         * @memberof WebGLGlobeDataSource.prototype
         * @type {Event}
         */
        changedEvent: {
          get: function () {
            return this._changed;
          },
        },
        /**
         * Gets an event that will be raised if an error is encountered during
         * processing.
         * @memberof WebGLGlobeDataSource.prototype
         * @type {Event}
         */
        errorEvent: {
          get: function () {
            return this._error;
          },
        },
        /**
         * Gets an event that will be raised when the data source either starts or
         * stops loading.
         * @memberof WebGLGlobeDataSource.prototype
         * @type {Event}
         */
        loadingEvent: {
          get: function () {
            return this._loading;
          },
        },
      
        //These properties are specific to this DataSource.
      
        /**
         * Gets the array of series names.
         * @memberof WebGLGlobeDataSource.prototype
         * @type {String[]}
         */
        seriesNames: {
          get: function () {
            return this._seriesNames;
          },
        },
        /**
         * Gets or sets the name of the series to display.  WebGL JSON is designed
         * so that only one series is viewed at a time.  Valid values are defined
         * in the seriesNames property.
         * @memberof WebGLGlobeDataSource.prototype
         * @type {String}
         */
        seriesToDisplay: {
          get: function () {
            return this._seriesToDisplay;
          },
          set: function (value) {
            this._seriesToDisplay = value;
      
            //Iterate over all entities and set their show property
            //to true only if they are part of the current series.
            var collection = this._entityCollection;
            var entities = collection.values;
            collection.suspendEvents();
            for (var i = 0; i < entities.length; i++) {
              var entity = entities[i];
              entity.show = value === entity.seriesName;
            }
            collection.resumeEvents();
          },
        },
        /**
         * Gets or sets the scale factor applied to the height of each line.
         * @memberof WebGLGlobeDataSource.prototype
         * @type {Number}
         */
        heightScale: {
          get: function () {
            return this._heightScale;
          },
          set: function (value) {
            if (value <= 0) {
              throw new Cesium.DeveloperError("value must be greater than 0");
            }
            this._heightScale = value;
          },
        },
        /**
         * Gets whether or not this data source should be displayed.
         * @memberof WebGLGlobeDataSource.prototype
         * @type {Boolean}
         */
        show: {
          get: function () {
            return this._entityCollection;
          },
          set: function (value) {
            this._entityCollection = value;
          },
        },
        /**
         * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
         * @memberof WebGLGlobeDataSource.prototype
         * @type {EntityCluster}
         */
        clustering: {
          get: function () {
            return this._entityCluster;
          },
          set: function (value) {
            if (!Cesium.defined(value)) {
              throw new Cesium.DeveloperError("value must be defined.");
            }
            this._entityCluster = value;
          },
        },
      });
      
      /**
       * Asynchronously loads the GeoJSON at the provided url, replacing any existing data.
       * @param {Object} url The url to be processed.
       * @returns {Promise} a promise that will resolve when the GeoJSON is loaded.
       */
      WebGLGlobeDataSource.prototype.loadUrl = function (url) {
        if (!Cesium.defined(url)) {
          throw new Cesium.DeveloperError("url is required.");
        }
      
        //Create a name based on the url
        var name = Cesium.getFilenameFromUri(url);
      
        //Set the name if it is different than the current name.
        if (this._name !== name) {
          this._name = name;
          this._changed.raiseEvent(this);
        }
      
        //Use 'when' to load the URL into a json object
        //and then process is with the `load` function.
        var that = this;
        return Cesium.Resource.fetchJson(url)
          .then(function (json) {
            return that.load(json, url);
          })
          .otherwise(function (error) {
            //Otherwise will catch any errors or exceptions that occur
            //during the promise processing. When this happens,
            //we raise the error event and reject the promise.
            this._setLoading(false);
            that._error.raiseEvent(that, error);
            return Cesium.when.reject(error);
          });
      };
      
      /**
       * Loads the provided data, replacing any existing data.
       * @param {Array} data The object to be processed.
       */
      WebGLGlobeDataSource.prototype.load = function (data) {
      
        //Clear out any data that might already exist.
        this._setLoading(true);
        this._seriesNames.length = 0;
        this._seriesToDisplay = undefined;
      
        var heightScale = this.heightScale;
        var entities = this._entityCollection;
      
        //It's a good idea to suspend events when making changes to a
        //large amount of entities.  This will cause events to be batched up
        //into the minimal amount of function calls and all take place at the
        //end of processing (when resumeEvents is called).
        entities.suspendEvents();
        entities.removeAll();
      
        //WebGL Globe JSON is an array of series, where each series itself is an
        //array of two items, the first containing the series name and the second
        //being an array of repeating latitude, longitude, height values.
        //
        //Here's a more visual example.
        //[["series1",[latitude, longitude, height, ... ]
        // ["series2",[latitude, longitude, height, ... ]]
      
        // Loop over each series
        for (var x = 0; x < data.length; x++) {
          var series = data[x];
          var seriesName = series[0];
          var coordinates = series[1];
      
          //Add the name of the series to our list of possible values.
          this._seriesNames.push(seriesName);
      
          //Make the first series the visible one by default
          var show = x === 0;
          if (show) {
            this._seriesToDisplay = seriesName;
          }
      
          //Now loop over each coordinate in the series and create
          // our entities from the data.
          for (var i = 0; i < coordinates.length; i += 3) {
            var latitude = coordinates[i];
            var longitude = coordinates[i + 1];
            var height = coordinates[i + 2];
      
            //Ignore lines of zero height.
            if (height === 0) {
              continue;
            }
      
            var color = Cesium.Color.fromHsl(0.6 - height * 0.5, 1.0, 0.5);
            var surfacePosition = Cesium.Cartesian3.fromDegrees(
              longitude,
              latitude,
              0
            );
            var heightPosition = Cesium.Cartesian3.fromDegrees(
              longitude,
              latitude,
              height * heightScale
            );
      
            //WebGL Globe only contains lines, so that's the only graphics we create.
            var polyline = new Cesium.PolylineGraphics();
            polyline.material = new Cesium.ColorMaterialProperty(color);
            polyline.width = new Cesium.ConstantProperty(2);
            polyline.arcType = new Cesium.ConstantProperty(
              Cesium.ArcType.NONE
            );
            polyline.positions = new Cesium.ConstantProperty([
              surfacePosition,
              heightPosition,
            ]);
      
           
            var entity = new Cesium.Entity({
              id: seriesName + " index " + i.toString(),
              show: show,
              polyline: polyline,
              seriesName: seriesName, //Custom property to indicate series name
            });
      
            //Add the entity to the collection.
            entities.add(entity);
          }
        }
      
        //Once all data is processed, call resumeEvents and raise the changed event.
        entities.resumeEvents();
        this._changed.raiseEvent(this);
        this._setLoading(false);
      };
      
      WebGLGlobeDataSource.prototype._setLoading = function (isLoading) {
        if (this._isLoading !== isLoading) {
          this._isLoading = isLoading;
          this._loading.raiseEvent(this, isLoading);
        }
      };

    /*  Global class for simulating the movement of particle through a 1km wind grid

        credit: All the credit for this work goes to: https://github.com/cambecc for creating the repo:
          https://github.com/cambecc/earth. The majority of this code is directly take nfrom there, since its awesome.

        This class takes a canvas element and an array of data (1km GFS from http://www.emc.ncep.noaa.gov/index.php?branch=GFS)
        and then uses a mercator (forward/reverse) projection to correctly map wind vectors in "map space".

        The "start" method takes the bounds of the map at its current extent and starts the whole gridding,
        interpolation and animation process.
    */

    var VELOCITY_SCALE = 0.011;             // scale for wind velocity (completely arbitrary--this value looks nice)
    var INTENSITY_SCALE_STEP = 10;            // step size of particle intensity color scale
    var MAX_WIND_INTENSITY = 40;              // wind velocity at which particle intensity is maximum (m/s)
    var MAX_PARTICLE_AGE = 100;                // max number of frames a particle is drawn before regeneration
    var PARTICLE_LINE_WIDTH = 2;              // line width of a drawn particle
    var PARTICLE_MULTIPLIER = 1/150;              // particle count scalar (completely arbitrary--this values looks nice)
    var PARTICLE_REDUCTION = 0.75;            // reduce particle count to this much of normal for mobile devices

    var NULL_WIND_VECTOR = [NaN, NaN, null];  // singleton for no wind in the form: [u, v, magnitude]

    function Windy( params ){
        this.params = params;
        var fadeFillStyle = "rgba(0, 0, 0, 0.97)";
        var g = this.params.canvas.getContext("2d");
        g.lineWidth = PARTICLE_LINE_WIDTH;
        g.fillStyle = fadeFillStyle;
        this.drawContext = g;
    }


    // interpolation for vectors like wind (u,v,m)
    Windy.prototype.bilinearInterpolateVector = function(x, y, g00, g10, g01, g11) {
        var rx = (1 - x);
        var ry = (1 - y);
        var a = rx * ry,  b = x * ry,  c = rx * y,  d = x * y;
        var u = g00[0] * a + g10[0] * b + g01[0] * c + g11[0] * d;
        var v = g00[1] * a + g10[1] * b + g01[1] * c + g11[1] * d;
        return [u, v, Math.sqrt(u * u + v * v)];
    };


    Windy.prototype.createWindBuilder = function(uComp, vComp) {
          var uData = uComp.data, vData = vComp.data;
          return {
              header: uComp.header,
              //recipe: recipeFor("wind-" + uComp.header.surface1Value),
              data: function(i) {
                  return [uData[i], vData[i]];
              },
              interpolate: this.bilinearInterpolateVector
          }
    };

    Windy.prototype.createBuilder = function(data) {
          var uComp = null, vComp = null;

          data.forEach(function(record) {
              switch (record.header.parameterCategory + "," + record.header.parameterNumber) {
                  case "2,2": uComp = record; break;
                  case "2,3": vComp = record; break;
              }
          });

          return this.createWindBuilder(uComp, vComp);
      };

      Windy.prototype.buildGrid = function(data, callback) {
          var builder = this.createBuilder(data);

          var header = builder.header;
          var λ0 = header.lo1, φ0 = header.la1;  // the grid's origin (e.g., 0.0E, 90.0N)
          var Δλ = header.dx, Δφ = header.dy;    // distance between grid points (e.g., 2.5 deg lon, 2.5 deg lat)
          var ni = header.nx, nj = header.ny;    // number of grid points W-E and N-S (e.g., 144 x 73)
          var date = new Date(header.refTime);
          date.setHours(date.getHours() + header.forecastTime);

          // Scan mode 0 assumed. Longitude increases from λ0, and latitude decreases from φ0.
          // http://www.nco.ncep.noaa.gov/pmb/docs/grib2/grib2_table3-4.shtml
          var grid = [], p = 0;
          var isContinuous = Math.floor(ni * Δλ) >= 360;
          for (var j = 0; j < nj; j++) {
              var row = [];
              for (var i = 0; i < ni; i++, p++) {
                  row[i] = builder.data(p);
              }
              if (isContinuous) {
                  // For wrapped grids, duplicate first column as last column to simplify interpolation logic
                  row.push(row[0]);
              }
              grid[j] = row;
          }

          function interpolate(λ, φ) {
              var i = floorMod(λ - λ0, 360) / Δλ;  // calculate longitude index in wrapped range [0, 360)
              var j = (φ0 - φ) / Δφ;                 // calculate latitude index in direction +90 to -90

              var fi = Math.floor(i), ci = fi + 1;
              var fj = Math.floor(j), cj = fj + 1;

              var row;
              if ((row = grid[fj])) {
                  var g00 = row[fi];
                  var g10 = row[ci];
                  if (isValue(g00) && isValue(g10) && (row = grid[cj])) {
                      var g01 = row[fi];
                      var g11 = row[ci];
                      if (isValue(g01) && isValue(g11)) {
                          // All four points found, so interpolate the value.
                          return builder.interpolate(i - fi, j - fj, g00, g10, g01, g11);
                      }
                  }
              }
              return null;
          }
          callback( {
              date: date,
              interpolate: interpolate
          });
    };


      /**
       * @returns {Boolean} true if the specified value is not null and not undefined.
       */
      var isValue = function(x) {
          return x !== null && x !== undefined;
      };

      /**
       * @returns {Number} returns remainder of floored division, i.e., floor(a / n). Useful for consistent modulo
       *          of negative numbers. See http://en.wikipedia.org/wiki/Modulo_operation.
       */
      var floorMod = function(a, n) {
          return a - n * Math.floor(a / n);
      };

      /**
       * @returns {Boolean} true if agent is probably a mobile device. Don't really care if this is accurate.
       */
      var isMobile = function() {
          return (/android|blackberry|iemobile|ipad|iphone|ipod|opera mini|webos/i).test(navigator.userAgent);
      };

      /**
       * Calculate distortion of the wind vector caused by the shape of the projection at point (x, y). The wind
       * vector is modified in place and returned by this function.
       */
      var distort = function(projection, λ, φ, x, y, scale, wind, windy) {
          var u = wind[0] * scale;
          var v = wind[1] * scale;
          var d = distortion(projection, λ, φ, x, y, windy);

          // Scale distortion vectors by u and v, then add.
          wind[0] = d[0] * u + d[2] * v;
          wind[1] = d[1] * u + d[3] * v;
          return wind;
      };

      var distortion = function(projection, λ, φ, x, y, windy) {
          var τ = 2 * Math.PI;
          var H = Math.pow(10, -5.2);
          var hλ = λ < 0 ? H : -H;
          var hφ = φ < 0 ? H : -H;

          var pλ = project(φ, λ + hλ,windy);
          var pφ = project(φ + hφ, λ, windy);
          
          // Meridian scale factor (see Snyder, equation 4-3), where R = 1. This handles issue where length of 1º λ
          // changes depending on φ. Without this, there is a pinching effect at the poles.
          var k = Math.cos(φ / 360 * τ);
          return [
              (pλ[0] - x) / hλ / k,
              (pλ[1] - y) / hλ / k,
              (pφ[0] - x) / hφ,
              (pφ[1] - y) / hφ
          ];
      };



      var createField = function(columns, bounds, callback) {

          /**
           * @returns {Array} wind vector [u, v, magnitude] at the point (x, y), or [NaN, NaN, null] if wind
           *          is undefined at that point.
           */
          function field(x, y) {
              var column = columns[Math.round(x)];
              return column && column[Math.round(y)] || NULL_WIND_VECTOR;
          }

          // Frees the massive "columns" array for GC. Without this, the array is leaked (in Chrome) each time a new
          // field is interpolated because the field closure's context is leaked, for reasons that defy explanation.
          field.release = function() {
              columns = [];
          };

          field.randomize = function(o) {  // UNDONE: this method is terrible
              var x, y;
              var safetyNet = 0;
              do {
                  x = Math.round(Math.floor(Math.random() * bounds.width) + bounds.x);
                  y = Math.round(Math.floor(Math.random() * bounds.height) + bounds.y);
              } while (field(x, y)[2] === null && safetyNet++ < 30);
              o.x = x;
              o.y = y;
              return o;
          };

          //field.overlay = mask.imageData;
          //return field;
          callback( bounds, field );
      };

      var buildBounds = function( bounds, width, height ) {
          var upperLeft = bounds[0];
          var lowerRight = bounds[1];
          var x = Math.round(upperLeft[0]); //Math.max(Math.floor(upperLeft[0], 0), 0);
          var y = Math.max(Math.floor(upperLeft[1], 0), 0);
          var xMax = Math.min(Math.ceil(lowerRight[0], width), width - 1);
          var yMax = Math.min(Math.ceil(lowerRight[1], height), height - 1);
          return {x: x, y: y, xMax: width, yMax: yMax, width: width, height: height};
      };

      var deg2rad = function( deg ){
        return (deg / 180) * Math.PI;
      };

      var rad2deg = function( ang ){
        return ang / (Math.PI/180.0);
      };

      var invert = function(x, y, windy){
        var mapLonDelta = windy.east - windy.west;
        var worldMapRadius = windy.width / rad2deg(mapLonDelta) * 360/(2 * Math.PI);
        var mapOffsetY = ( worldMapRadius / 2 * Math.log( (1 + Math.sin(windy.south) ) / (1 - Math.sin(windy.south))  ));
        var equatorY = windy.height + mapOffsetY;
        var a = (equatorY-y)/worldMapRadius;

        var lat = 180/Math.PI * (2 * Math.atan(Math.exp(a)) - Math.PI/2);
        var lon = rad2deg(windy.west) + x / windy.width * rad2deg(mapLonDelta);
        return [lon, lat];
      };

      var mercY = function( lat ) {
        return Math.log( Math.tan( lat / 2 + Math.PI / 4 ) );
      };


      var project = function( lat, lon, windy) { // both in radians, use deg2rad if neccessary
        var ymin = mercY(windy.south);
        var ymax = mercY(windy.north);
        var xFactor = windy.width / ( windy.east - windy.west );
        var yFactor = windy.height / ( ymax - ymin );

        var y = mercY( deg2rad(lat) );
        var x = (deg2rad(lon) - windy.west) * xFactor;
        var y = (ymax - y) * yFactor; // y points south
        return [x, y];
      };


      var interpolateField = function( grid, bounds, extent, callback ) {

        var projection = {};
        var velocityScale = VELOCITY_SCALE;

        var columns = [];
        var x = bounds.x;

        function interpolateColumn(x) {
            var column = [];
            for (var y = bounds.y; y <= bounds.yMax; y += 2) {
                    var coord = invert( x, y, extent );
                    if (coord) {
                        var λ = coord[0], φ = coord[1];
                        if (isFinite(λ)) {
                            var wind = grid.interpolate(λ, φ);
                            if (wind) {
                                wind = distort(projection, λ, φ, x, y, velocityScale, wind, extent);
                                column[y+1] = column[y] = wind;

                            }
                        }
                    }
            }
            columns[x+1] = columns[x] = column;
        }

        (function batchInterpolate() {
                    var start = Date.now();
                    while (x < bounds.width) {
                        interpolateColumn(x);
                        x += 2;
                        if ((Date.now() - start) > 1000) { //MAX_TASK_TIME) {
                            setTimeout(batchInterpolate, 25);
                            return;
                        }
                    }
              createField(columns, bounds, callback);
        })();
      };


    Windy.prototype.animate = function(bounds, field) {
        function asColorStyle(r, g, b, a) {
            return "rgba(" + 243 + ", " + 243 + ", " + 238 + ", " + a + ")";
        }

        function windIntensityColorScale(step, maxWind) {
            var result = [];
            for (var j = 225; j >= 100; j = j - step) {
              result.push(asColorStyle(j, j, j, 1));
            }
            result.indexFor = function(m) {  // map wind speed to a style
                return Math.floor(Math.min(m, maxWind) / maxWind * (result.length - 1));
            };
            return result;
        }

        var colorStyles = windIntensityColorScale(INTENSITY_SCALE_STEP, MAX_WIND_INTENSITY);
        var buckets = colorStyles.map(function() { return []; });
        this.colorStyles = colorStyles;
        this.buckets = buckets;
        
        var particleCount = Math.round(bounds.width * bounds.height * PARTICLE_MULTIPLIER);
        if (isMobile()) {
          particleCount *= PARTICLE_REDUCTION;
        }

        var particles = [];
        for (var i = 0; i < particleCount; i++) {
            particles.push(field.randomize({age: Math.floor(Math.random() * MAX_PARTICLE_AGE) + 0}));
        }
        this.particles = particles;
    };

    Windy.prototype.evolve = function() {
        var field = this.field;
        var colorStyles = this.colorStyles;
        var buckets = this.buckets;
        
        buckets.forEach(function(bucket) { bucket.length = 0; });
        this.particles.forEach(function(particle) {
            if (particle.age > MAX_PARTICLE_AGE) {
                field.randomize(particle).age = 0;
            }
            var x = particle.x;
            var y = particle.y;
            var v = field(x, y);  // vector at current position
            var m = v[2];
            if (m === null) {
                particle.age = MAX_PARTICLE_AGE;  // particle has escaped the grid, never to return...
            }
            else {
                var xt = x + v[0];
                var yt = y + v[1];
                if (field(xt, yt)[2] !== null) {
                    // Path from (x,y) to (xt,yt) is visible, so add this particle to the appropriate draw bucket.
                    particle.xt = xt;
                    particle.yt = yt;
                    buckets[colorStyles.indexFor(m)].push(particle);
                }
                 else {
                    // Particle isn't visible, but it still moves through the field.
                    particle.x = xt;
                    particle.y = yt;
                }
            }
            particle.age += 1;
        });
    };

    Windy.prototype.draw = function() {
        var g = this.drawContext;
        var bounds = this.bounds;

        // Fade existing particle trails.
        var prev = g.globalCompositeOperation;
        g.globalCompositeOperation = "destination-in";
        g.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
        g.globalCompositeOperation = prev;
        var colorStyles = this.colorStyles;
        // Draw new particle trails.
        this.buckets.forEach(function(bucket, i) {
            if (bucket.length > 0) {
                g.beginPath();
                g.strokeStyle = colorStyles[i];
                bucket.forEach(function(particle) {
                    g.moveTo(particle.x, particle.y);
                    g.lineTo(particle.xt, particle.yt);
                    particle.x = particle.xt;
                    particle.y = particle.yt;
                });
                g.stroke();
            }
        });
    };


    Windy.prototype.update = function(frameState){
        this.evolve();
        this.draw();
        if(this.primitive){
            this.primitive.setDirty();
            this.primitive.update(frameState);
        }
    };

    Windy.prototype.start = function( bounds, width, height, extent ){
        var mapBounds = {
          south: deg2rad(extent[0][1]),
          north: deg2rad(extent[1][1]),
          east: deg2rad(extent[1][0]),
          west: deg2rad(extent[0][0]),
          width: width,
          height: height
        };

        this.stop();
        var that = this;
        // build grid
        this.buildGrid( this.params.data, function(grid){
          // interpolateField
          interpolateField( grid, buildBounds( bounds, width, height), mapBounds, function( bounds, field ){
            // animate the canvas with random points
            that.bounds = bounds;
            that.field = field;
            that.animate( bounds, field);
          });

        });
    };

    Windy.prototype.stop = function(){
        if (this.field) this.field.release();
        if (this.timer) clearTimeout(this.timer);
    };

    //This file is automatically rebuilt by the WeatherEarth build process.
    var screen_frag = "precision mediump float;\n\
\n\
uniform sampler2D u_screen;\n\
uniform float u_opacity;\n\
\n\
varying vec2 v_tex_pos;\n\
\n\
void main() {\n\
    vec4 color = texture2D(u_screen, 1.0 - v_tex_pos);\n\
    // a hack to guarantee opacity fade out even with a value close to 1.0\n\
    gl_FragColor = vec4(floor(255.0 * color * u_opacity) / 255.0);\n\
}\n\
";

    function WeatherAxes(options) {
      this._polylines = new Cesium.PolylineCollection();
      this._stCartographic = options.stCartographic;
      this._edCartographic = options.edCartographic;
      this._dirty = true;
    }

    WeatherAxes.prototype.rebuild = function () {
      //this._polylines.removeAll();

      for (let i = 0; i < 1; i++) {
        var st = Cesium.Cartesian3.fromRadians(this._stCartographic.longitude,this._stCartographic.latitude,0.0);
        var ed = Cesium.Cartesian3.fromRadians(this._edCartographic.longitude,this._edCartographic.latitude,0.0);
        this._polylines.add({
          positions: [st, ed],
          width: 1,
        });
      }
    };

    WeatherAxes.prototype.isDestroyed = function () {
      return false;
    };

    WeatherAxes.prototype.destroy = function () {
      return Cesium.destroyObject(this);
    };

    WeatherAxes.prototype.update = function (frameState) {
      if (this._dirty) {
        this._dirty = false;
        this.rebuild();
      }
      this._polylines.update(frameState);
    };

    function WeatherVolumeAxesWall$1(options) {
        this._floors = options.floors;
        var scaleZ = options.scaleZ;

        var split = Cesium.defaultValue(options.split,false);

        var floors = [];
        for (var i = 0; i < this._floors.length; i++) {
          floors.push(this._floors[i] * scaleZ);
        }

        var positions = WeatherVolumeLibrary.computeWallPosition(options.st,options.ed,Cesium.Math.RADIANS_PER_DEGREE);

        var volumeWallAxisGeometry = new WeatherVolumeWallAxisGeometry({
          positions: positions,
          floors: floors,
          granularity: Cesium.Math.RADIANS_PER_DEGREE,
          split: split
        });

        var wallOutlineGeometry = WeatherVolumeWallAxisGeometry.createGeometry(volumeWallAxisGeometry);

        if(split){
          this.splitPositions = [volumeWallAxisGeometry.p1,volumeWallAxisGeometry.p3,volumeWallAxisGeometry.p7];
        }

        this._wallOutline = new Cesium.Primitive({
            geometryInstances: new Cesium.GeometryInstance({
              geometry: wallOutlineGeometry,
              attributes: {
                color: Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(1.0, 1.0, 1.0, 1.0)),
              },
            }), asynchronous: false
          });

        this._wallOutline.appearance = new Cesium.PerInstanceColorAppearance({
            flat: true,
            translucent: false,
            renderState: {
                lineWidth: 1.0,
            },
        });    
    }
    WeatherVolumeAxesWall$1.prototype.isDestroyed = function () {
      return false;
    };

    WeatherVolumeAxesWall$1.prototype.destroy = function () {
        if (Cesium.defined(this._wallOutline)) {
            this._wallOutline.destroy();
        }
        return Cesium.destroyObject(this);
    };

    WeatherVolumeAxesWall$1.prototype.update = function (frameState) {
        if (frameState.passes.render && Cesium.defined(this._wallOutline)) {
            this._wallOutline.update(frameState);
        }
    };

    function WeatherVolumeGrid$1(volume, context) {
      this._LabelDistanceDisplayFator = 3;
      this.init(volume, context);
    }

    function addLabel$1(labels,position,text,distanceToDisplay) {
      labels.add({
        position: position,
        font: Config.font,
        disableDepthTestDistance: Number.POSITIVE_INFINITY,
        disableDepthTestDistance1: 0,
        distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, distanceToDisplay),
        text: text,
        fillColor: Config.fillColor,
        outlineColor: Config.outlineColor,
        backgroundColor : Config.backgroundColor,
        showBackground: Config.showBackground,
        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
        horizontalOrigin: Cesium.HorizontalOrigin.RIGHT,
      });
    }

    WeatherVolumeGrid$1.prototype.init = function (volume, context) {
      var w = volume.meter.width;
      var h = volume.meter.height;
      var d = volume.meter.depth;
      var half_w = 0.5 * w;
      var half_h = 0.5 * h;

      var fixTopWidth = (volume.meter.width - volume.meter.topWidth) * 0.5 * 0.0;
      var distanceToDisplay = (w > h ? w : h) * this._LabelDistanceDisplayFator;
      var labels = new Cesium.LabelCollection();
      for (var i = 0; i < 4; i++) {
        var offset = 0.1;
        if (offset > 0) offset = 0.1 + i * 0.3;

        if(i!==3){
          addLabel$1(labels,new Cesium.Cartesian3(offset * w - half_w, 0.0 - half_h, 0.0),
          (volume.position.x + ((offset - 0.5) * volume.degreeWidth)).toFixed(2),
          distanceToDisplay);
        
          addLabel$1(labels,new Cesium.Cartesian3(0.0 - half_w, offset * h - half_h, 0.0),
          (volume.position.y + ((offset - 0.5) * volume.degreeHeight)).toFixed(2),
          distanceToDisplay);
        }

        offset = (i + 1) * 0.3;
        if (i == 3) offset = 1.0;

        addLabel$1(labels,new Cesium.Cartesian3(0.0 - half_w, 0.0 - half_h, offset * d),
        (offset * d * 0.001).toFixed(0) + 'km',
        distanceToDisplay);

        addLabel$1(labels,new Cesium.Cartesian3(half_w, 0.0 - half_h, offset * d),
        (offset * d * 0.001).toFixed(0) + 'km',
        distanceToDisplay);

        addLabel$1(labels,new Cesium.Cartesian3(0.0 - half_w, half_h, offset * d),
        (offset * d * 0.001).toFixed(0) + 'km',
        distanceToDisplay);
      }

      labels.modelMatrix = volume._modelmatrix;
      this._labels = labels;

      var vs = 'attribute vec3 position3DHigh;\
    attribute vec3 position3DLow;\
    void main()\
    {\
        vec4 p = czm_translateRelativeToEye(position3DHigh, position3DLow);\
        gl_Position = czm_modelViewProjectionRelativeToEye * p;\
    }';
      var fs = 'void main()\
    {\
        gl_FragColor = vec4(1,1,1,1);\
    }';

      var shaderProgram = Cesium.ShaderProgram.fromCache({
        context: context,
        vertexShaderSource: vs,
        fragmentShaderSource: fs
      });

      var renderState = Cesium.RenderState.fromCache({
        depthTest: {
          enabled: true
        },
        depthMask: true,
        cull: {
          enabled: true,
          face: Cesium.CullFace.FRONT
        }
      });

      var idx = [
        0, 1,
        2, 3,
        0, 2,
        1, 3,
        0, 4,
        2, 5,
        4, 5];

      var points = [
        0.0 - half_w, 0.0 - half_h, 0.0,
        1.0 * w - half_w, 0.0 - half_h, 0.0,
        0.0 - half_w, 0.0 - half_h, 1.0 * d,
        1.0 * w - half_w, 0.0 - half_h, 1.0 * d,
        0.0 + 0.5 * fixTopWidth - half_w, 1.0 * h - half_h, 0.0,
        0.0 + 0.5 * fixTopWidth - half_w, 1.0 * h - half_h, 1.0 * d];

      var lastidx = points.length / 3;
      var offset = 0.1;
      for (var i = 0; i < 3; i++) {
        if (i > 0)
          offset += 0.3;
        points.push(0.0 - half_w); points.push(0.0 - half_h); points.push((1.0 - offset) * d);
        points.push(1.0 * w - half_w); points.push(0.0 - half_h); points.push((1.0 - offset) * d);
        idx.push(lastidx++); idx.push(lastidx++);

        points.push(0.0 - half_w); points.push(0.0 - half_h); points.push((1.0 - offset) * d);
        points.push(0.0 + 0.5 * fixTopWidth - half_w); points.push(1.0 * h - half_h); points.push((1.0 - offset) * d);
        idx.push(lastidx++); idx.push(lastidx++);

        points.push(offset * w - half_w); points.push(0.0 - half_h); points.push(0.0);
        points.push(offset * w - half_w); points.push(0.0 - half_h); points.push(1.0 * d);
        idx.push(lastidx++); idx.push(lastidx++);

        points.push(0.0 + offset * 0.5 * fixTopWidth - half_w); points.push(offset * h - half_h); points.push(0.0);
        points.push(0.0 + offset * 0.5 * fixTopWidth - half_w); points.push(offset * h - half_h); points.push(1.0 * d);
        idx.push(lastidx++); idx.push(lastidx++);
      }

      var indexBuffer = Cesium.Buffer.createIndexBuffer({
        context: context,
        typedArray: new Uint32Array(idx),
        usage: Cesium.BufferUsage.STATIC_DRAW,
        indexDatatype: Cesium.IndexDatatype.UNSIGNED_INT
      });

      var vertexBuffer = Cesium.Buffer.createVertexBuffer({
        context: context,
        typedArray: Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, points),
        usage: Cesium.BufferUsage.STATIC_DRAW
      });

      var attributes = [];
      attributes.push({
        index: 0,
        vertexBuffer: vertexBuffer,
        componentDatatype: Cesium.ComponentDatatype.FLOAT,
        componentsPerAttribute: 3,
        normalize: false,
        instanceDivisor: 0
      });

      var vertexArray = new Cesium.VertexArray({
        context: context,
        attributes: attributes,
        indexBuffer: indexBuffer
      });

      this._command = new Cesium.DrawCommand({
        boundingVolume: volume._boundingVolume,
        primitiveType: Cesium.PrimitiveType.LINES,
        shaderProgram: shaderProgram,
        renderState: renderState,
        vertexArray: vertexArray,
        modelMatrix: volume._modelmatrix,
        pass: Cesium.Pass.OPAQUE
      });
    };

    WeatherVolumeGrid$1.prototype.update = function (frameState) {
      var commandList = frameState.commandList;
      commandList.push(this._command);
      this._labels.update(frameState);
    };

    WeatherVolumeGrid$1.prototype.updateMatrix = function (modelmatrix) {
      if (Cesium.defined(this._command)) this._command.modelMatrix = modelmatrix;
      if (Cesium.defined(this._labels)) this._labels.modelMatrix = modelmatrix;
    };

    WeatherVolumeGrid$1.prototype.destroy = function () {
        if(Cesium.defined(this._labels)){this._labels.destroy();this._labels=undefined;}
    };

    var css_248z$2 = ".common-popup {\r\n    position: absolute;\r\n    z-index: 999;\r\n}\r\n\r\n.popup-content-wrapper {\r\n    background: white;\r\n    color: rgb(51, 51, 51);\r\n    box-shadow: rgba(0, 0, 0, 0.4) 0px 3px 14px;\r\n    padding: 1px;\r\n    text-align: left;\r\n    border-radius: 12px;\r\n}\r\n\r\n.popup-content {\r\n    margin: 13px 19px;\r\n    min-width: 100px;\r\n}\r\n\r\n.popup-tip-wrapper {\r\n    width: 40px;\r\n    height: 20px;\r\n    position: absolute;\r\n    left: 50%;\r\n    margin-left: -20px;\r\n    overflow: hidden;\r\n    pointer-events: none\r\n}\r\n\r\n.popup-tip {\r\n    width: 17px;\r\n    height: 17px;\r\n    padding: 1px;\r\n    background-color: #ffffff;\r\n    margin: -10px auto 0;\r\n    transform: rotate(45deg)\r\n}\r\n\r\n.popup-close-button {\r\n    position: absolute;\r\n    right: 0;\r\n    top: 0;\r\n    width: 18px;\r\n    height: 14px;\r\n    padding: 4px 4px 0 0;\r\n    text-decoration: none;\r\n    font: 16px/14px Tahoma, Verdana, sans-serif;\r\n    color: #c3c3c3;\r\n    cursor: pointer;\r\n    font-weight: bold;\r\n    user-select: auto;\r\n}\r\n\r\n.popup-close-button:hover {\r\n    color: #999;\r\n}\r\n";
    styleInject(css_248z$2);

    function Popup(options) {
      if (!Cesium.defined(options)) {
        options = {};
      }
      this._callback = options.callback;
    }

    Object.defineProperties(Popup.prototype, {
      target: {
        get: function () {
          return this._target;
        },
      },
      content: {
        set: function (value) {
          if (Cesium.defined(this.target)) {
            this.target.firstChild.firstChild.innerHTML = value;
          }
        }
      },
    });

    Popup.prototype.createGraph = function (container, earthPin) {
      this._target = Popup.createWrapNode(this._callback);
      if (Cesium.defined(container)) {
        container.appendChild(this._target);
    }
    if (Cesium.defined(earthPin)) {
        this.content = earthPin.content;
    }
      return this._target;
    };

    Popup.createWrapNode = function (xcallback) {
      var targetDiv = document.createElement('div');
      targetDiv.className = 'common-popup';

      var contentWrapper = document.createElement('div');
      contentWrapper.className = 'popup-content-wrapper';
      var contentNode = document.createElement('div');
      contentNode.className = 'popup-content';
      contentWrapper.appendChild(contentNode);

      var tipContainer = document.createElement('div');
      tipContainer.className = 'popup-tip-wrapper';
      var tip = document.createElement('div');
      tip.className = 'popup-tip';
      tipContainer.appendChild(tip);

      var close = document.createElement('a');
      close.className = 'popup-close-button';
      // close.href = '#close';
      close.innerText = '×';
      targetDiv.appendChild(contentWrapper);
      targetDiv.appendChild(tipContainer);

      if (Cesium.defined(xcallback)) {
        targetDiv.appendChild(close);
        close.addEventListener('click', function () {
          xcallback();
        });
      }

      return targetDiv;
    };

    /**
     * A viewport aligned quad.
     *
     * @alias ViewportQuad
     * @constructor
     *
     * @param {Cesium.BoundingRectangle} [rectangle] The {@link Cesium.BoundingRectangle} defining the quad's position within the viewport.
     * @param {Cesium.Material} [Cesium.Material] The {@link Cesium.Material} defining the surface appearance of the viewport quad.
     *
     * @example
     * var viewportQuad = new Cesium.ViewportQuad(new Cesium.Cesium.BoundingRectangle(0, 0, 80, 40));
     * viewportQuad.Cesium.Material.uniforms.Cesium.Color = new Cesium.Cesium.Color(1.0, 0.0, 0.0, 1.0);
     */
    function ViewportQuad(rectangle, material,framebuffer) {
      /**
       * Determines if the viewport quad primitive will be shown.
       *
       * @type {Boolean}
       * @default true
       */
      this.show = true;

      if (!Cesium.defined(rectangle)) {
        rectangle = new Cesium.BoundingRectangle();
      }  
      
      /**
       * The Cesium.BoundingRectangle defining the quad's position within the viewport.
       *
       * @type {Cesium.BoundingRectangle}
       *
       * @example
       * viewportQuad.rectangle = new Cesium.Cesium.BoundingRectangle(0, 0, 80, 40);
       */
      this.rectangle = Cesium.BoundingRectangle.clone(rectangle);

      if (!Cesium.defined(material)) {
          material = Cesium.Material.fromType(Cesium.Material.ColorType, {
          color: new Cesium.Color(1.0, 1.0, 1.0, 1.0),
        });
      }

      /**
       * The surface appearance of the viewport quad.  This can be one of several built-in {@link Cesium.Material} objects or a custom Cesium.Material, scripted with
       * {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}.
       * <p>
       * The default Cesium.Material is <code>Cesium.Material.Cesium.ColorType</code>.
       * </p>
       *
       * @type Cesium.Material
       *
       * @example
       * // 1. Change the color of the default material to yellow
       * viewportQuad.material.uniforms.color = new Cesium.Cesium.Color(1.0, 1.0, 0.0, 1.0);
       *
       * // 2. Change Cesium.Material to horizontal stripes
       * viewportQuad.material = Cesium.material.fromType(Cesium.material.StripeType);
       *
       * @see {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}
       */
      this.material = material;
      this._material = undefined;

      this._overlayCommand = undefined;
      this._rs = undefined;
    }

    /**
     * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
     * get the draw commands needed to render this primitive.
     * <p>
     * Do not call this function directly.  This is documented just to
     * list the exceptions that may be propagated when the scene is rendered:
     * </p>
     *
     * @exception {Cesium.DeveloperError} this.Cesium.Material must be Cesium.defined.
     * @exception {Cesium.DeveloperError} this.rectangle must be Cesium.defined.
     */
    ViewportQuad.prototype.update = function (frameState) {
      if (!this.show) {
        return;
      }

      var rs = this._rs;
      if (!Cesium.defined(rs) || !Cesium.BoundingRectangle.equals(rs.viewport, this.rectangle)) {
        this._rs = Cesium.RenderState.fromCache({
          blending: Cesium.BlendingState.ALPHA_BLEND,
          viewport: this.rectangle,
          depthTest: {
            enabled:true
          }
        });
      }

      var pass = frameState.passes;
      if (pass.render) {
        var context = frameState.context;

        if (this._material !== this.material || !Cesium.defined(this._overlayCommand)) {
          // Recompile shader when Cesium.Material changes
          this._material = this.material;

          if (Cesium.defined(this._overlayCommand)) {
            this._overlayCommand.shaderProgram.destroy();
          }

          var fs = new Cesium.ShaderSource({
            sources: [this._material.shaderSource, Cesium._shadersViewportQuadFS],
          });
          this._overlayCommand = context.createViewportQuadCommand(fs, {
            renderState: this._rs,
            uniformMap: this._material._uniforms,
            owner: this,
          });
          this._overlayCommand.pass = Cesium.Pass.OVERLAY;
          if(Cesium.defined(this.framebuffer)){
            this._overlayCommand.framebuffer = this.framebuffer;
          }
        }

        if (Cesium.defined(this.preExecute)) {
          this.preExecute();
        }

        this._material.update(context);

        this._overlayCommand.uniformMap = this._material._uniforms;
        frameState.commandList.push(this._overlayCommand);
      }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link Cesium.DeveloperError} exception.
     *
     * @returns {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see ViewportQuad#destroy
     */
    ViewportQuad.prototype.isDestroyed = function () {
      return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link Cesium.DeveloperError} exception.  Therefore,
     * assign the return value (<code>unCesium.defined</code>) to the object as done in the example.
     *
     * @exception {Cesium.DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     *
     * @example
     * quad = quad && quad.destroy();
     *
     * @see ViewportQuad#isDestroyed
     */
    ViewportQuad.prototype.destroy = function () {
      if (Cesium.defined(this._overlayCommand)) {
        this._overlayCommand.shaderProgram =
          this._overlayCommand.shaderProgram &&
          this._overlayCommand.shaderProgram.destroy();
      }
      return Cesium.destroyObject(this);
    };

    /**
     * apng-canvas v2.1.2
     *
     * @copyright 2011-2019 David Mzareulyan
     * @link https://github.com/davidmz/apng-canvas
     * @license MIT
     */
    !function i(o,a,s){function u(n,t){if(!a[n]){if(!o[n]){var e="function"==typeof commonjsRequire&&commonjsRequire;if(!t&&e)return e(n,!0);if(c)return c(n,!0);throw new Error("Cannot find module '"+n+"'")}var r=a[n]={exports:{}};o[n][0].call(r.exports,function(t){var e=o[n][1][t];return u(e||t)},r,r.exports,i,o,a,s);}return a[n].exports}for(var c="function"==typeof commonjsRequire&&commonjsRequire,t=0;t<s.length;t++)u(s[t]);return u}({1:[function(Y,n,r){(function(G,q){var t,e;t=this,e=function(){function u(t){return "function"==typeof t}var n=Array.isArray?Array.isArray:function(t){return "[object Array]"===Object.prototype.toString.call(t)},r=0,e=void 0,i=void 0,a=function(t,e){l[r]=t,l[r+1]=e,2===(r+=2)&&(i?i(d):g());};var t="undefined"!=typeof window?window:void 0,o=t||{},s=o.MutationObserver||o.WebKitMutationObserver,c="undefined"==typeof self&&void 0!==G&&"[object process]"==={}.toString.call(G),f="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel;function h(){var t=setTimeout;return function(){return t(d,1)}}var l=new Array(1e3);function d(){for(var t=0;t<r;t+=2){(0, l[t])(l[t+1]),l[t]=void 0,l[t+1]=void 0;}r=0;}var p,v,A,m,g=void 0;function w(t,e){var n=this,r=new this.constructor(b);void 0===r[_]&&j(r);var i=n._state;if(i){var o=arguments[i-1];a(function(){return L(i,r,o,n._result)});}else U(n,r,t,e);return r}function y(t){if(t&&"object"==typeof t&&t.constructor===this)return t;var e=new this(b);return T(e,t),e}g=c?function(){return G.nextTick(d)}:s?(v=0,A=new s(d),m=document.createTextNode(""),A.observe(m,{characterData:!0}),function(){m.data=v=++v%2;}):f?((p=new MessageChannel).port1.onmessage=d,function(){return p.port2.postMessage(0)}):void 0===t&&"function"==typeof Y?function(){try{var t=Function("return this")().require("vertx");return void 0!==(e=t.runOnLoop||t.runOnContext)?function(){e(d);}:h()}catch(t){return h()}}():h();var _=Math.random().toString(36).substring(2);function b(){}var E=void 0,P=1,x=2;function N(t,r,i){a(function(e){var n=!1,t=function(t,e,n,r){try{t.call(e,n,r);}catch(t){return t}}(i,r,function(t){n||(n=!0,r!==t?T(e,t):O(e,t));},function(t){n||(n=!0,R(e,t));},e._label);!n&&t&&(n=!0,R(e,t));},t);}function C(t,e,n){e.constructor===t.constructor&&n===w&&e.constructor.resolve===y?function(e,t){t._state===P?O(e,t._result):t._state===x?R(e,t._result):U(t,void 0,function(t){return T(e,t)},function(t){return R(e,t)});}(t,e):void 0===n?O(t,e):u(n)?N(t,e,n):O(t,e);}function T(e,t){if(e===t)R(e,new TypeError("You cannot resolve a promise with itself"));else if(function(t){var e=typeof t;return null!==t&&("object"==e||"function"==e)}(t)){var n=void 0;try{n=t.then;}catch(t){return void R(e,t)}C(e,t,n);}else O(e,t);}function B(t){t._onerror&&t._onerror(t._result),I(t);}function O(t,e){t._state===E&&(t._result=e,t._state=P,0!==t._subscribers.length&&a(I,t));}function R(t,e){t._state===E&&(t._state=x,t._result=e,a(B,t));}function U(t,e,n,r){var i=t._subscribers,o=i.length;t._onerror=null,i[o]=e,i[o+P]=n,i[o+x]=r,0===o&&t._state&&a(I,t);}function I(t){var e=t._subscribers,n=t._state;if(0!==e.length){for(var r=void 0,i=void 0,o=t._result,a=0;a<e.length;a+=3)r=e[a],i=e[a+n],r?L(n,r,i,o):i(o);t._subscribers.length=0;}}function L(t,e,n,r){var i=u(n),o=void 0,a=void 0,s=!0;if(i){try{o=n(r);}catch(t){s=!1,a=t;}if(e===o)return void R(e,new TypeError("A promises callback cannot return that same promise."))}else o=r;e._state!==E||(i&&s?T(e,o):!1===s?R(e,a):t===P?O(e,o):t===x&&R(e,o));}var D=0;function j(t){t[_]=D++,t._state=void 0,t._result=void 0,t._subscribers=[];}var k=(F.prototype._enumerate=function(t){for(var e=0;this._state===E&&e<t.length;e++)this._eachEntry(t[e],e);},F.prototype._eachEntry=function(e,t){var n=this._instanceConstructor,r=n.resolve;if(r===y){var i=void 0,o=void 0,a=!1;try{i=e.then;}catch(t){a=!0,o=t;}if(i===w&&e._state!==E)this._settledAt(e._state,t,e._result);else if("function"!=typeof i)this._remaining--,this._result[t]=e;else if(n===S){var s=new n(b);a?R(s,o):C(s,e,i),this._willSettleAt(s,t);}else this._willSettleAt(new n(function(t){return t(e)}),t);}else this._willSettleAt(r(e),t);},F.prototype._settledAt=function(t,e,n){var r=this.promise;r._state===E&&(this._remaining--,t===x?R(r,n):this._result[e]=n),0===this._remaining&&O(r,this._result);},F.prototype._willSettleAt=function(t,e){var n=this;U(t,void 0,function(t){return n._settledAt(P,e,t)},function(t){return n._settledAt(x,e,t)});},F);function F(t,e){this._instanceConstructor=t,this.promise=new t(b),this.promise[_]||j(this.promise),n(e)?(this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?O(this.promise,this._result):(this.length=this.length||0,this._enumerate(e),0===this._remaining&&O(this.promise,this._result))):R(this.promise,new Error("Array Methods must be provided an Array"));}var S=(M.prototype.catch=function(t){return this.then(null,t)},M.prototype.finally=function(e){var n=this.constructor;return u(e)?this.then(function(t){return n.resolve(e()).then(function(){return t})},function(t){return n.resolve(e()).then(function(){throw t})}):this.then(e,e)},M);function M(t){this[_]=D++,this._result=this._state=void 0,this._subscribers=[],b!==t&&("function"!=typeof t&&function(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}(),this instanceof M?function(e,t){try{t(function(t){T(e,t);},function(t){R(e,t);});}catch(t){R(e,t);}}(this,t):function(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}());}return S.prototype.then=w,S.all=function(t){return new k(this,t).promise},S.race=function(i){var o=this;return n(i)?new o(function(t,e){for(var n=i.length,r=0;r<n;r++)o.resolve(i[r]).then(t,e);}):new o(function(t,e){return e(new TypeError("You must pass an array to race."))})},S.resolve=y,S.reject=function(t){var e=new this(b);return R(e,t),e},S._setScheduler=function(t){i=t;},S._setAsap=function(t){a=t;},S._asap=a,S.polyfill=function(){var t=void 0;if(void 0!==q)t=q;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")();}catch(t){throw new Error("polyfill failed because global object is unavailable in this environment")}var e=t.Promise;if(e){var n=null;try{n=Object.prototype.toString.call(e.resolve());}catch(t){}if("[object Promise]"===n&&!e.cast)return}t.Promise=S;},S.Promise=S},"object"==typeof r&&void 0!==n?n.exports=e():t.ES6Promise=e();}).call(this,Y("VCmEsw"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{VCmEsw:2}],2:[function(t,e,n){var r=e.exports={};function i(){}r.nextTick=function(){var t="undefined"!=typeof window&&window.setImmediate,e="undefined"!=typeof window&&window.postMessage&&window.addEventListener;if(t)return function(t){return window.setImmediate(t)};if(e){var n=[];return window.addEventListener("message",function(t){var e=t.source;e!==window&&null!==e||"process-tick"!==t.data||(t.stopPropagation(),0<n.length&&n.shift()());},!0),function(t){n.push(t),window.postMessage("process-tick","*");}}return function(t){setTimeout(t,0);}}(),r.title="browser",r.browser=!0,r.env={},r.argv=[],r.on=i,r.addListener=i,r.once=i,r.off=i,r.removeListener=i,r.removeAllListeners=i,r.emit=i,r.binding=function(t){throw new Error("process.binding is not supported")},r.cwd=function(){return "/"},r.chdir=function(t){throw new Error("process.chdir is not supported")};},{}],3:[function(t,e,n){e.exports=function(){this.width=0,this.height=0,this.numPlays=0,this.playTime=0,this.frames=[],this.play=function(){s||u||(this.rewind(),s=!0,requestAnimationFrame(e));},this.rewind=function(){o=i=0,a=null,u=s=!1;},this.addContext=function(t){if(0<c.length){var e=c[0].getImageData(0,0,this.width,this.height);t.putImageData(e,0,0);}c.push(t),t._apng_animation=this;},this.removeContext=function(t){var e=c.indexOf(t);-1!==e&&(c.splice(e,1),0===c.length&&this.rewind(),"_apng_animation"in t&&delete t._apng_animation);},this.isPlayed=function(){return s},this.isFinished=function(){return u};var r=this,i=0,o=0,a=null,s=!1,u=!1,c=[],e=function(t){for(;s&&i<=t;)n(t);s&&requestAnimationFrame(e);},n=function(t){var e=o++%r.frames.length,n=r.frames[e];if(0==r.numPlays||o/r.frames.length<=r.numPlays){for(0==e&&(c.forEach(function(t){t.clearRect(0,0,r.width,r.height);}),a=null,2==n.disposeOp&&(n.disposeOp=1)),a&&1==a.disposeOp?c.forEach(function(t){t.clearRect(a.left,a.top,a.width,a.height);}):a&&2==a.disposeOp&&c.forEach(function(t){t.putImageData(a.iData,a.left,a.top);}),(a=n).iData=null,2==a.disposeOp&&(a.iData=c[0].getImageData(n.left,n.top,n.width,n.height)),0==n.blendOp&&c.forEach(function(t){t.clearRect(n.left,n.top,n.width,n.height);}),c.forEach(function(t){t.drawImage(n.img,n.left,n.top);}),0==i&&(i=t);t>i+r.playTime;)i+=r.playTime;i+=n.delay;}else u=!(s=!1);};};},{}],4:[function(t,e,n){for(var a=new Uint32Array(256),r=0;r<256;r++){for(var i=r,o=0;o<8;o++)i=1&i?3988292384^i>>>1:i>>>1;a[r]=i;}e.exports=function(t,e,n){for(var r=-1,i=e=e||0,o=e+(n=n||t.length-e);i<o;i++)r=r>>>8^a[255&(r^t[i])];return -1^r};},{}],5:[function(a,t,e){(function(t){var e=a("./support-test"),n=a("./parser"),r=a("./loader"),i=t.APNG={};i.checkNativeFeatures=e.checkNativeFeatures,i.ifNeeded=e.ifNeeded,i.parseBuffer=function(t){return n(t)};var o={};i.parseURL=function(t){return t in o||(o[t]=r(t).then(n)),o[t]},i.animateContext=function(t,e){return i.parseURL(t).then(function(t){return t.addContext(e),t.play(),t})},i.animateImage=function(s){return s.setAttribute("data-is-apng","progress"),i.parseURL(s.src).then(function(t){s.setAttribute("data-is-apng","yes");var e=document.createElement("canvas");e.width=t.width,e.height=t.height,Array.prototype.slice.call(s.attributes).forEach(function(t){-1==["alt","src","usemap","ismap","data-is-apng","width","height"].indexOf(t.nodeName)&&e.setAttributeNode(t.cloneNode(!1));}),e.setAttribute("data-apng-src",s.src),""!=s.alt&&e.appendChild(document.createTextNode(s.alt));var n="",r="",i=0,o="";""!=s.style.width&&"auto"!=s.style.width?n=s.style.width:s.hasAttribute("width")&&(n=s.getAttribute("width")+"px"),""!=s.style.height&&"auto"!=s.style.height?r=s.style.height:s.hasAttribute("height")&&(r=s.getAttribute("height")+"px"),""!=n&&""==r&&(i=parseFloat(n),o=n.match(/\D+$/)[0],r=Math.round(e.height*i/e.width)+o),""!=r&&""==n&&(i=parseFloat(r),o=r.match(/\D+$/)[0],n=Math.round(e.width*i/e.height)+o),e.style.width=n,e.style.height=r;var a=s.parentNode;a.insertBefore(e,s),a.removeChild(s),t.addContext(e.getContext("2d")),t.play();},function(){s.setAttribute("data-is-apng","no");})},i.releaseCanvas=function(t){var e=t.getContext("2d");"_apng_animation"in e&&e._apng_animation.removeContext(e);};}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{"./loader":6,"./parser":7,"./support-test":8}],6:[function(t,e,n){var i=i||t("es6-promise").Promise;e.exports=function(r){return new i(function(t,e){var n=new XMLHttpRequest;n.open("GET",r),n.responseType="arraybuffer",n.onload=function(){200==this.status?t(this.response):e(this);},n.send();})};},{"es6-promise":1}],7:[function(t,e,n){var r=r||t("es6-promise").Promise,m=t("./animation"),o=t("./crc32"),g=new Uint8Array([137,80,78,71,13,10,26,10]);e.exports=function(t){var A=new Uint8Array(t);return new r(function(t,e){for(var n=0;n<g.length;n++)if(g[n]!=A[n])return void e("Not a PNG file (invalid file signature)");var r=!1;if(w(A,function(t){return "acTL"!=t||!(r=!0)}),r){var a=[],s=[],u=null,c=null,f=new m;if(w(A,function(t,e,n,r){switch(t){case"IHDR":u=e.subarray(n+8,n+8+r),f.width=y(e,n+8),f.height=y(e,n+12);break;case"acTL":f.numPlays=y(e,n+8+4);break;case"fcTL":c&&f.frames.push(c),(c={}).width=y(e,n+8+4),c.height=y(e,n+8+8),c.left=y(e,n+8+12),c.top=y(e,n+8+16);var i=_(e,n+8+20),o=_(e,n+8+22);0==o&&(o=100),c.delay=1e3*i/o,c.delay<=10&&(c.delay=100),f.playTime+=c.delay,c.disposeOp=b(e,n+8+24),c.blendOp=b(e,n+8+25),c.dataParts=[];break;case"fdAT":c&&c.dataParts.push(e.subarray(n+8+4,n+8+r));break;case"IDAT":c&&c.dataParts.push(e.subarray(n+8,n+8+r));break;case"IEND":s.push(E(e,n,12+r));break;default:a.push(E(e,n,12+r));}}),c&&f.frames.push(c),0!=f.frames.length)for(var i=0,o=new Blob(a),h=new Blob(s),l=0;l<f.frames.length;l++){c=f.frames[l];var d=[];d.push(g),u.set(P(c.width),0),u.set(P(c.height),4),d.push(x("IHDR",u)),d.push(o);for(var p=0;p<c.dataParts.length;p++)d.push(x("IDAT",c.dataParts[p]));d.push(h);var v=URL.createObjectURL(new Blob(d,{type:"image/png"}));delete c.dataParts,d=null,c.img=document.createElement("img"),c.img.onload=function(){URL.revokeObjectURL(this.src),++i==f.frames.length&&t(f);},c.img.onerror=function(){e("Image creation error");},c.img.src=v;}else e("Not an animated PNG");}else e("Not an animated PNG");})};var w=function(t,e){var n=8;do{var r=y(t,n),i=a(t,n+4,4),o=e(i,t,n,r);n+=12+r;}while(!1!==o&&"IEND"!=i&&n<t.length)},y=function(t,e){var n=0;n+=t[0+e]<<24>>>0;for(var r=1;r<4;r++)n+=t[r+e]<<8*(3-r);return n},_=function(t,e){for(var n=0,r=0;r<2;r++)n+=t[r+e]<<8*(1-r);return n},b=function(t,e){return t[e]},E=function(t,e,n){var r=new Uint8Array(n);return r.set(t.subarray(e,e+n)),r},a=function(t,e,n){var r=Array.prototype.slice.call(t.subarray(e,e+n));return String.fromCharCode.apply(String,r)},P=function(t){return [t>>>24&255,t>>>16&255,t>>>8&255,255&t]},x=function(t,e){var n=t.length+e.length,r=new Uint8Array(new ArrayBuffer(n+8));r.set(P(e.length),0),r.set(function(t){for(var e=[],n=0;n<t.length;n++)e.push(t.charCodeAt(n));return e}(t),4),r.set(e,8);var i=o(r,4,n);return r.set(P(i),n+4),r};},{"./animation":3,"./crc32":4,"es6-promise":1}],8:[function(o,a,t){(function(t){var e,n,r=r||o("es6-promise").Promise,i=(e=function(e){var n=document.createElement("canvas"),r={TypedArrays:"ArrayBuffer"in t,BlobURLs:"URL"in t,requestAnimationFrame:"requestAnimationFrame"in t,pageProtocol:"http:"==location.protocol||"https:"==location.protocol,canvas:"getContext"in document.createElement("canvas"),APNG:!1};if(r.canvas){var i=new Image;i.onload=function(){var t=n.getContext("2d");t.drawImage(i,0,0),r.APNG=0===t.getImageData(0,0,1,1).data[3],e(r);},i.src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACGFjVEwAAAABAAAAAcMq2TYAAAANSURBVAiZY2BgYPgPAAEEAQB9ssjfAAAAGmZjVEwAAAAAAAAAAQAAAAEAAAAAAAAAAAD6A+gBAbNU+2sAAAARZmRBVAAAAAEImWNgYGBgAAAABQAB6MzFdgAAAABJRU5ErkJggg==";}else e(r);},n=null,function(t){return n=n||new r(e),t&&n.then(t),n});a.exports={checkNativeFeatures:i,ifNeeded:function(r){return void 0===r&&(r=!1),i().then(function(t){if(t.APNG&&!r)reject();else {var e=!0;for(var n in t)t.hasOwnProperty(n)&&"APNG"!=n&&(e=e&&t[n]);}})}};}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{"es6-promise":1}]},{},[5]);

    function ApngPrimitive(options){
        this._apng = undefined;
        var that = this;
        APNG.parseURL(options.url).then(function(animation){
            that._apng = animation;
        });

        this._currentFrame = 0;
        this._lastUpdateTime = 0;
        this._primitive = new Cesium.Primitive(options);
    }

    ApngPrimitive.prototype.update = function (frameState) {
        if(!Cesium.defined(this._apng)){
            return;
        }

        if(!Cesium.defined(this._texture)){
            this._createTexture(frameState.context);
        }

        if(frameState.passes.render){
            this._primitive.update(frameState);
        }

        var currentFrame = this._apng.frames[this._currentFrame];
        var elapseTime = (new Date()).getTime() - this._lastUpdateTime;
        if (elapseTime > currentFrame.delay) {
            this._currentFrame++;
            if(this._currentFrame >= this._apng.frames.length){
                this._currentFrame = 0;
            }
            currentFrame = this._apng.frames[this._currentFrame];
            this._texture.copyFrom(currentFrame.img);
            this._lastUpdateTime = (new Date()).getTime();
        }

    };

    ApngPrimitive.prototype._createTexture = function (context) {
        var sampler = new Cesium.Sampler({
            wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
            wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
            minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
            magnificationFilter: Cesium.TextureMagnificationFilter.LINEAR
        });
        
        this._texture = new Cesium.Texture({
            context: context,
            source: this._apng.frames[0].img,
            sampler: sampler,
        });

        this._primitive.appearance.material = new Cesium.Material({
            fabric: {
                uniforms: {
                    image: this._texture,
                },
                source:
                "czm_material czm_getMaterial(czm_materialInput materialInput) { \n" +
                  "    czm_material material = czm_getDefaultMaterial(materialInput); \n" +
                  "    vec2 st = materialInput.st; \n" +
                  "    vec4 color = texture2D(image, st); \n" +
                  "    color = czm_gammaCorrect(color); \n" +
                  "    material.diffuse = color.rgb; \n" +
                  "    material.alpha = color.a; \n" +
                  "    material.shininess = 8.0; \n" + // Sharpen highlight
                  "    return material; \n" +
                  "} \n"
            },
        });
    };

    ApngPrimitive.prototype.isDestroyed = function () {
        return false;
    };

    ApngPrimitive.prototype.destroy = function() {
        this._primitive = this._primitive && this._primitive.destroy();
        this._texture = this._texture && this._texture.destroy();
        this._apng = undefined;
        return Cesium.destroyObject(this);
    };

    var libgif = createCommonjsModule(function (module, exports) {
    /*
    	SuperGif

    	Example usage:

    		<img src="./example1_preview.gif" rel:animated_src="./example1.gif" width="360" height="360" rel:auto_play="1" />

    		<script type="text/javascript">
    			$$('img').each(function (img_tag) {
    				if (/.*\.gif/.test(img_tag.src)) {
    					var rub = new SuperGif({ gif: img_tag } );
    					rub.load();
    				}
    			});
    		</script>

    	Image tag attributes:

    		rel:animated_src -	If this url is specified, it's loaded into the player instead of src.
    							This allows a preview frame to be shown until animated gif data is streamed into the canvas

    		rel:auto_play -		Defaults to 1 if not specified. If set to zero, a call to the play() method is needed

    	Constructor options args

    		gif 				Required. The DOM element of an img tag.
    		loop_mode			Optional. Setting this to false will force disable looping of the gif.
    		auto_play 			Optional. Same as the rel:auto_play attribute above, this arg overrides the img tag info.
    		max_width			Optional. Scale images over max_width down to max_width. Helpful with mobile.
     		on_end				Optional. Add a callback for when the gif reaches the end of a single loop (one iteration). The first argument passed will be the gif HTMLElement.
    		loop_delay			Optional. The amount of time to pause (in ms) after each single loop (iteration).
    		draw_while_loading	Optional. Determines whether the gif will be drawn to the canvas whilst it is loaded.
    		show_progress_bar	Optional. Only applies when draw_while_loading is set to true.

    	Instance methods

    		// loading
    		load( callback )		Loads the gif specified by the src or rel:animated_src sttributie of the img tag into a canvas element and then calls callback if one is passed
    		load_url( src, callback )	Loads the gif file specified in the src argument into a canvas element and then calls callback if one is passed

    		// play controls
    		play -				Start playing the gif
    		pause -				Stop playing the gif
    		move_to(i) -		Move to frame i of the gif
    		move_relative(i) -	Move i frames ahead (or behind if i < 0)

    		// getters
    		get_canvas			The canvas element that the gif is playing in. Handy for assigning event handlers to.
    		get_playing			Whether or not the gif is currently playing
    		get_loading			Whether or not the gif has finished loading/parsing
    		get_auto_play		Whether or not the gif is set to play automatically
    		get_length			The number of frames in the gif
    		get_current_frame	The index of the currently displayed frame of the gif
    		get_frames	        An array containing the data for all parsed frames
    		get_duration	    Returns the duration of the gif in hundredths of a second (standard for GIF spec)
    		get_duration_ms	    Returns the duration of the gif in milliseconds

    		For additional customization (viewport inside iframe) these params may be passed:
    		c_w, c_h - width and height of canvas
    		vp_t, vp_l, vp_ w, vp_h - top, left, width and height of the viewport

    		A bonus: few articles to understand what is going on
    			http://enthusiasms.org/post/16976438906
    			http://www.matthewflickinger.com/lab/whatsinagif/bits_and_bytes.asp
    			http://humpy77.deviantart.com/journal/Frame-Delay-Times-for-Animated-GIFs-214150546

    */
    (function (root, factory) {
        {
            module.exports = factory();
        }
    }(commonjsGlobal, function () {
        // Generic functions
        var bitsToNum = function (ba) {
            return ba.reduce(function (s, n) {
                return s * 2 + n;
            }, 0);
        };

        var byteToBitArr = function (bite) {
            var a = [];
            for (var i = 7; i >= 0; i--) {
                a.push( !! (bite & (1 << i)));
            }
            return a;
        };

        // Stream
        /**
         * @constructor
         */
        // Make compiler happy.
        var Stream = function (data) {
            this.data = data;
            this.len = this.data.length;
            this.pos = 0;

            this.readByte = function () {
                if (this.pos >= this.data.length) {
                    throw new Error('Attempted to read past end of stream.');
                }
                if (data instanceof Uint8Array)
                    return data[this.pos++];
                else
                    return data.charCodeAt(this.pos++) & 0xFF;
            };

            this.readBytes = function (n) {
                var bytes = [];
                for (var i = 0; i < n; i++) {
                    bytes.push(this.readByte());
                }
                return bytes;
            };

            this.read = function (n) {
                var s = '';
                for (var i = 0; i < n; i++) {
                    s += String.fromCharCode(this.readByte());
                }
                return s;
            };

            this.readUnsigned = function () { // Little-endian.
                var a = this.readBytes(2);
                return (a[1] << 8) + a[0];
            };
        };

        var lzwDecode = function (minCodeSize, data) {
            // TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?
            var pos = 0; // Maybe this streaming thing should be merged with the Stream?
            var readCode = function (size) {
                var code = 0;
                for (var i = 0; i < size; i++) {
                    if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {
                        code |= 1 << i;
                    }
                    pos++;
                }
                return code;
            };

            var output = [];

            var clearCode = 1 << minCodeSize;
            var eoiCode = clearCode + 1;

            var codeSize = minCodeSize + 1;

            var dict = [];

            var clear = function () {
                dict = [];
                codeSize = minCodeSize + 1;
                for (var i = 0; i < clearCode; i++) {
                    dict[i] = [i];
                }
                dict[clearCode] = [];
                dict[eoiCode] = null;

            };

            var code;
            var last;

            while (true) {
                last = code;
                code = readCode(codeSize);

                if (code === clearCode) {
                    clear();
                    continue;
                }
                if (code === eoiCode) break;

                if (code < dict.length) {
                    if (last !== clearCode) {
                        dict.push(dict[last].concat(dict[code][0]));
                    }
                }
                else {
                    if (code !== dict.length) throw new Error('Invalid LZW code.');
                    dict.push(dict[last].concat(dict[last][0]));
                }
                output.push.apply(output, dict[code]);

                if (dict.length === (1 << codeSize) && codeSize < 12) {
                    // If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.
                    codeSize++;
                }
            }

            // I don't know if this is technically an error, but some GIFs do it.
            //if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');
            return output;
        };


        // The actual parsing; returns an object with properties.
        var parseGIF = function (st, handler) {
            handler || (handler = {});

            // LZW (GIF-specific)
            var parseCT = function (entries) { // Each entry is 3 bytes, for RGB.
                var ct = [];
                for (var i = 0; i < entries; i++) {
                    ct.push(st.readBytes(3));
                }
                return ct;
            };

            var readSubBlocks = function () {
                var size, data;
                data = '';
                do {
                    size = st.readByte();
                    data += st.read(size);
                } while (size !== 0);
                return data;
            };

            var parseHeader = function () {
                var hdr = {};
                hdr.sig = st.read(3);
                hdr.ver = st.read(3);
                if (hdr.sig !== 'GIF') throw new Error('Not a GIF file.'); // XXX: This should probably be handled more nicely.
                hdr.width = st.readUnsigned();
                hdr.height = st.readUnsigned();

                var bits = byteToBitArr(st.readByte());
                hdr.gctFlag = bits.shift();
                hdr.colorRes = bitsToNum(bits.splice(0, 3));
                hdr.sorted = bits.shift();
                hdr.gctSize = bitsToNum(bits.splice(0, 3));

                hdr.bgColor = st.readByte();
                hdr.pixelAspectRatio = st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
                if (hdr.gctFlag) {
                    hdr.gct = parseCT(1 << (hdr.gctSize + 1));
                }
                handler.hdr && handler.hdr(hdr);
            };

            var parseExt = function (block) {
                var parseGCExt = function (block) {
                    var blockSize = st.readByte(); // Always 4
                    var bits = byteToBitArr(st.readByte());
                    block.reserved = bits.splice(0, 3); // Reserved; should be 000.
                    block.disposalMethod = bitsToNum(bits.splice(0, 3));
                    block.userInput = bits.shift();
                    block.transparencyGiven = bits.shift();

                    block.delayTime = st.readUnsigned();

                    block.transparencyIndex = st.readByte();

                    block.terminator = st.readByte();

                    handler.gce && handler.gce(block);
                };

                var parseComExt = function (block) {
                    block.comment = readSubBlocks();
                    handler.com && handler.com(block);
                };

                var parsePTExt = function (block) {
                    // No one *ever* uses this. If you use it, deal with parsing it yourself.
                    var blockSize = st.readByte(); // Always 12
                    block.ptHeader = st.readBytes(12);
                    block.ptData = readSubBlocks();
                    handler.pte && handler.pte(block);
                };

                var parseAppExt = function (block) {
                    var parseNetscapeExt = function (block) {
                        var blockSize = st.readByte(); // Always 3
                        block.unknown = st.readByte(); // ??? Always 1? What is this?
                        block.iterations = st.readUnsigned();
                        block.terminator = st.readByte();
                        handler.app && handler.app.NETSCAPE && handler.app.NETSCAPE(block);
                    };

                    var parseUnknownAppExt = function (block) {
                        block.appData = readSubBlocks();
                        // FIXME: This won't work if a handler wants to match on any identifier.
                        handler.app && handler.app[block.identifier] && handler.app[block.identifier](block);
                    };

                    var blockSize = st.readByte(); // Always 11
                    block.identifier = st.read(8);
                    block.authCode = st.read(3);
                    switch (block.identifier) {
                        case 'NETSCAPE':
                            parseNetscapeExt(block);
                            break;
                        default:
                            parseUnknownAppExt(block);
                            break;
                    }
                };

                var parseUnknownExt = function (block) {
                    block.data = readSubBlocks();
                    handler.unknown && handler.unknown(block);
                };

                block.label = st.readByte();
                switch (block.label) {
                    case 0xF9:
                        block.extType = 'gce';
                        parseGCExt(block);
                        break;
                    case 0xFE:
                        block.extType = 'com';
                        parseComExt(block);
                        break;
                    case 0x01:
                        block.extType = 'pte';
                        parsePTExt(block);
                        break;
                    case 0xFF:
                        block.extType = 'app';
                        parseAppExt(block);
                        break;
                    default:
                        block.extType = 'unknown';
                        parseUnknownExt(block);
                        break;
                }
            };

            var parseImg = function (img) {
                var deinterlace = function (pixels, width) {
                    // Of course this defeats the purpose of interlacing. And it's *probably*
                    // the least efficient way it's ever been implemented. But nevertheless...
                    var newPixels = new Array(pixels.length);
                    var rows = pixels.length / width;
                    var cpRow = function (toRow, fromRow) {
                        var fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);
                        newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
                    };

                    // See appendix E.
                    var offsets = [0, 4, 2, 1];
                    var steps = [8, 8, 4, 2];

                    var fromRow = 0;
                    for (var pass = 0; pass < 4; pass++) {
                        for (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
                            cpRow(toRow, fromRow);
                            fromRow++;
                        }
                    }

                    return newPixels;
                };

                img.leftPos = st.readUnsigned();
                img.topPos = st.readUnsigned();
                img.width = st.readUnsigned();
                img.height = st.readUnsigned();

                var bits = byteToBitArr(st.readByte());
                img.lctFlag = bits.shift();
                img.interlaced = bits.shift();
                img.sorted = bits.shift();
                img.reserved = bits.splice(0, 2);
                img.lctSize = bitsToNum(bits.splice(0, 3));

                if (img.lctFlag) {
                    img.lct = parseCT(1 << (img.lctSize + 1));
                }

                img.lzwMinCodeSize = st.readByte();

                var lzwData = readSubBlocks();

                img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);

                if (img.interlaced) { // Move
                    img.pixels = deinterlace(img.pixels, img.width);
                }

                handler.img && handler.img(img);
            };

            var parseBlock = function () {
                var block = {};
                block.sentinel = st.readByte();

                switch (String.fromCharCode(block.sentinel)) { // For ease of matching
                    case '!':
                        block.type = 'ext';
                        parseExt(block);
                        break;
                    case ',':
                        block.type = 'img';
                        parseImg(block);
                        break;
                    case ';':
                        block.type = 'eof';
                        handler.eof && handler.eof(block);
                        break;
                    default:
                        throw new Error('Unknown block: 0x' + block.sentinel.toString(16)); // TODO: Pad this with a 0.
                }

                if (block.type !== 'eof') setTimeout(parseBlock, 0);
            };

            var parse = function () {
                parseHeader();
                setTimeout(parseBlock, 0);
            };

            parse();
        };

        var SuperGif = function ( opts ) {
            var options = {
                //viewport position
                vp_l: 0,
                vp_t: 0,
                vp_w: null,
                vp_h: null,
                //canvas sizes
                c_w: null,
                c_h: null
            };
            for (var i in opts ) { options[i] = opts[i]; }
            if (options.vp_w && options.vp_h) options.is_vp = true;

            var stream;
            var hdr;

            var loadError = null;
            var loading = false;

            var transparency = null;
            var delay = null;
            var disposalMethod = null;
            var disposalRestoreFromIdx = null;
            var lastDisposalMethod = null;
            var frame = null;
            var lastImg = null;

            var playing = true;

            var ctx_scaled = false;

            var frames = [];
            var frameOffsets = []; // elements have .x and .y properties

            var gif = options.gif;
            if (typeof options.auto_play == 'undefined')
                options.auto_play = (!gif.getAttribute('rel:auto_play') || gif.getAttribute('rel:auto_play') == '1');

            var onEndListener = (options.hasOwnProperty('on_end') ? options.on_end : null);
            var loopDelay = (options.hasOwnProperty('loop_delay') ? options.loop_delay : 0);
            var overrideLoopMode = (options.hasOwnProperty('loop_mode') ? options.loop_mode : 'auto');
            var drawWhileLoading = (options.hasOwnProperty('draw_while_loading') ? options.draw_while_loading : true);
            var showProgressBar = drawWhileLoading ? (options.hasOwnProperty('show_progress_bar') ? options.show_progress_bar : true) : false;
            var progressBarHeight = (options.hasOwnProperty('progressbar_height') ? options.progressbar_height : 25);
            var progressBarBackgroundColor = (options.hasOwnProperty('progressbar_background_color') ? options.progressbar_background_color : 'rgba(255,255,255,0.4)');
            var progressBarForegroundColor = (options.hasOwnProperty('progressbar_foreground_color') ? options.progressbar_foreground_color : 'rgba(255,0,22,.8)');

            var clear = function () {
                transparency = null;
                delay = null;
                lastDisposalMethod = disposalMethod;
                disposalMethod = null;
                frame = null;
            };

            // XXX: There's probably a better way to handle catching exceptions when
            // callbacks are involved.
            var doParse = function () {
                try {
                    parseGIF(stream, handler);
                }
                catch (err) {
                    doLoadError('parse');
                }
            };

            var setSizes = function(w, h) {
                canvas.width = w * get_canvas_scale();
                canvas.height = h * get_canvas_scale();
                toolbar.style.minWidth = ( w * get_canvas_scale() ) + 'px';

                tmpCanvas.width = w;
                tmpCanvas.height = h;
                tmpCanvas.style.width = w + 'px';
                tmpCanvas.style.height = h + 'px';
                tmpCanvas.getContext('2d').setTransform(1, 0, 0, 1, 0, 0);
            };

            var setFrameOffset = function(frame, offset) {
                if (!frameOffsets[frame]) {
                    frameOffsets[frame] = offset;
                    return;
                }
                if (typeof offset.x !== 'undefined') {
                    frameOffsets[frame].x = offset.x;
                }
                if (typeof offset.y !== 'undefined') {
                    frameOffsets[frame].y = offset.y;
                }
            };

            var doShowProgress = function (pos, length, draw) {
                if (draw && showProgressBar) {
                    var height = progressBarHeight;
                    var left, mid, top, width;
                    if (options.is_vp) {
                        if (!ctx_scaled) {
                            top = (options.vp_t + options.vp_h - height);
                            height = height;
                            left = options.vp_l;
                            mid = left + (pos / length) * options.vp_w;
                            width = canvas.width;
                        } else {
                            top = (options.vp_t + options.vp_h - height) / get_canvas_scale();
                            height = height / get_canvas_scale();
                            left = (options.vp_l / get_canvas_scale() );
                            mid = left + (pos / length) * (options.vp_w / get_canvas_scale());
                            width = canvas.width / get_canvas_scale();
                        }
                    }
                    else {
                        top = (canvas.height - height) / (ctx_scaled ? get_canvas_scale() : 1);
                        mid = ((pos / length) * canvas.width) / (ctx_scaled ? get_canvas_scale() : 1);
                        width = canvas.width / (ctx_scaled ? get_canvas_scale() : 1 );
                        height /= ctx_scaled ? get_canvas_scale() : 1;
                    }

                    ctx.fillStyle = progressBarBackgroundColor;
                    ctx.fillRect(mid, top, width - mid, height);

                    ctx.fillStyle = progressBarForegroundColor;
                    ctx.fillRect(0, top, mid, height);
                }
            };

            var doLoadError = function (originOfError) {
                var drawError = function () {
                    ctx.fillStyle = 'black';
                    ctx.fillRect(0, 0, options.c_w ? options.c_w : hdr.width, options.c_h ? options.c_h : hdr.height);
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 3;
                    ctx.moveTo(0, 0);
                    ctx.lineTo(options.c_w ? options.c_w : hdr.width, options.c_h ? options.c_h : hdr.height);
                    ctx.moveTo(0, options.c_h ? options.c_h : hdr.height);
                    ctx.lineTo(options.c_w ? options.c_w : hdr.width, 0);
                    ctx.stroke();
                };

                loadError = originOfError;
                hdr = {
                    width: gif.width,
                    height: gif.height
                }; // Fake header.
                frames = [];
                drawError();
            };

            var doHdr = function (_hdr) {
                hdr = _hdr;
                setSizes(hdr.width, hdr.height);
            };

            var doGCE = function (gce) {
                pushFrame();
                clear();
                transparency = gce.transparencyGiven ? gce.transparencyIndex : null;
                delay = gce.delayTime;
                disposalMethod = gce.disposalMethod;
                // We don't have much to do with the rest of GCE.
            };

            var pushFrame = function () {
                if (!frame) return;
                frames.push({
                                data: frame.getImageData(0, 0, hdr.width, hdr.height),
                                delay: delay
                            });
                frameOffsets.push({ x: 0, y: 0 });
            };

            var doImg = function (img) {
                if (!frame) frame = tmpCanvas.getContext('2d');

                var currIdx = frames.length;

                //ct = color table, gct = global color table
                var ct = img.lctFlag ? img.lct : hdr.gct; // TODO: What if neither exists?

                /*
                Disposal method indicates the way in which the graphic is to
                be treated after being displayed.

                Values :    0 - No disposal specified. The decoder is
                                not required to take any action.
                            1 - Do not dispose. The graphic is to be left
                                in place.
                            2 - Restore to background color. The area used by the
                                graphic must be restored to the background color.
                            3 - Restore to previous. The decoder is required to
                                restore the area overwritten by the graphic with
                                what was there prior to rendering the graphic.

                                Importantly, "previous" means the frame state
                                after the last disposal of method 0, 1, or 2.
                */
                if (currIdx > 0) {
                    if (lastDisposalMethod === 3) {
                        // Restore to previous
                        // If we disposed every frame including first frame up to this point, then we have
                        // no composited frame to restore to. In this case, restore to background instead.
                        if (disposalRestoreFromIdx !== null) {
                        	frame.putImageData(frames[disposalRestoreFromIdx].data, 0, 0);
                        } else {
                        	frame.clearRect(lastImg.leftPos, lastImg.topPos, lastImg.width, lastImg.height);
                        }
                    } else {
                        disposalRestoreFromIdx = currIdx - 1;
                    }

                    if (lastDisposalMethod === 2) {
                        // Restore to background color
                        // Browser implementations historically restore to transparent; we do the same.
                        // http://www.wizards-toolkit.org/discourse-server/viewtopic.php?f=1&t=21172#p86079
                        frame.clearRect(lastImg.leftPos, lastImg.topPos, lastImg.width, lastImg.height);
                    }
                }
                // else, Undefined/Do not dispose.
                // frame contains final pixel data from the last frame; do nothing

                //Get existing pixels for img region after applying disposal method
                var imgData = frame.getImageData(img.leftPos, img.topPos, img.width, img.height);

                //apply color table colors
                img.pixels.forEach(function (pixel, i) {
                    // imgData.data === [R,G,B,A,R,G,B,A,...]
                    if (pixel !== transparency) {
                        imgData.data[i * 4 + 0] = ct[pixel][0];
                        imgData.data[i * 4 + 1] = ct[pixel][1];
                        imgData.data[i * 4 + 2] = ct[pixel][2];
                        imgData.data[i * 4 + 3] = 255; // Opaque.
                    }
                });

                frame.putImageData(imgData, img.leftPos, img.topPos);

                if (!ctx_scaled) {
                    ctx.scale(get_canvas_scale(),get_canvas_scale());
                    ctx_scaled = true;
                }

                // We could use the on-page canvas directly, except that we draw a progress
                // bar for each image chunk (not just the final image).
                if (drawWhileLoading) {
                    ctx.drawImage(tmpCanvas, 0, 0);
                    drawWhileLoading = options.auto_play;
                }

                lastImg = img;
            };

            var player = (function () {
                var i = -1;
                var iterationCount = 0;

                /**
                 * Gets the index of the frame "up next".
                 * @returns {number}
                 */
                var getNextFrameNo = function () {
                    var delta = ( 1 );
                    return (i + delta + frames.length) % frames.length;
                };

                var stepFrame = function (amount) { // XXX: Name is confusing.
                    i = i + amount;

                    putFrame();
                };

                var step = (function () {
                    var stepping = false;

                    var completeLoop = function () {
                        if (onEndListener !== null)
                            onEndListener(gif);
                        iterationCount++;

                        if (overrideLoopMode !== false || iterationCount < 0) {
                            doStep();
                        } else {
                            stepping = false;
                            playing = false;
                        }
                    };

                    var doStep = function () {
                        stepping = playing;
                        if (!stepping) return;

                        stepFrame(1);
                        var delay = frames[i].delay * 10;
                        if (!delay) delay = 100; // FIXME: Should this even default at all? What should it be?

                        var nextFrameNo = getNextFrameNo();
                        if (nextFrameNo === 0) {
                            delay += loopDelay;
                            setTimeout(completeLoop, delay);
                        } else {
                            setTimeout(doStep, delay);
                        }
                    };

                    return function () {
                        if (!stepping) setTimeout(doStep, 0);
                    };
                }());

                var putFrame = function () {
                    var offset;
                    i = parseInt(i, 10);

                    if (i > frames.length - 1){
                        i = 0;
                    }

                    if (i < 0){
                        i = 0;
                    }

                    offset = frameOffsets[i];

                    tmpCanvas.getContext("2d").putImageData(frames[i].data, offset.x, offset.y);
                    ctx.globalCompositeOperation = "copy";
                    ctx.drawImage(tmpCanvas, 0, 0);
                };

                var play = function () {
                    playing = true;
                    step();
                };

                var pause = function () {
                    playing = false;
                };


                return {
                    init: function () {
                        if (loadError) return;

                        if ( ! (options.c_w && options.c_h) ) {
                            ctx.scale(get_canvas_scale(),get_canvas_scale());
                        }

                        if (options.auto_play) {
                            step();
                        }
                        else {
                            i = 0;
                            putFrame();
                        }
                    },
                    step: step,
                    play: play,
                    pause: pause,
                    playing: playing,
                    move_relative: stepFrame,
                    current_frame: function() { return i; },
                    length: function() { return frames.length },
                    move_to: function ( frame_idx ) {
                        i = frame_idx;
                        putFrame();
                    }
                }
            }());

            var doDecodeProgress = function (draw) {
                doShowProgress(stream.pos, stream.data.length, draw);
            };

            var doNothing = function () {};
            /**
             * @param{boolean=} draw Whether to draw progress bar or not; this is not idempotent because of translucency.
             *                       Note that this means that the text will be unsynchronized with the progress bar on non-frames;
             *                       but those are typically so small (GCE etc.) that it doesn't really matter. TODO: Do this properly.
             */
            var withProgress = function (fn, draw) {
                return function (block) {
                    fn(block);
                    doDecodeProgress(draw);
                };
            };


            var handler = {
                hdr: withProgress(doHdr),
                gce: withProgress(doGCE),
                com: withProgress(doNothing),
                // I guess that's all for now.
                app: {
                    // TODO: Is there much point in actually supporting iterations?
                    NETSCAPE: withProgress(doNothing)
                },
                img: withProgress(doImg, true),
                eof: function (block) {
                    //toolbar.style.display = '';
                    pushFrame();
                    doDecodeProgress(false);
                    if ( ! (options.c_w && options.c_h) ) {
                        canvas.width = hdr.width * get_canvas_scale();
                        canvas.height = hdr.height * get_canvas_scale();
                    }
                    player.init();
                    loading = false;
                    if (load_callback) {
                        load_callback(gif);
                    }

                }
            };

            var init = function () {
                var parent = gif.parentNode;

                var div = document.createElement('div');
                canvas = document.createElement('canvas');
                ctx = canvas.getContext('2d');
                toolbar = document.createElement('div');

                tmpCanvas = document.createElement('canvas');

                div.width = canvas.width = gif.width;
                div.height = canvas.height = gif.height;
                toolbar.style.minWidth = gif.width + 'px';

                div.className = 'jsgif';
                toolbar.className = 'jsgif_toolbar';
                div.appendChild(canvas);
                div.appendChild(toolbar);

                parent.insertBefore(div, gif);
                parent.removeChild(gif);

                if (options.c_w && options.c_h) setSizes(options.c_w, options.c_h);
                initialized=true;
            };

            var get_canvas_scale = function() {
                var scale;
                if (options.max_width && hdr && hdr.width > options.max_width) {
                    scale = options.max_width / hdr.width;
                }
                else {
                    scale = 1;
                }
                return scale;
            };

            var canvas, ctx, toolbar, tmpCanvas;
            var initialized = false;
            var load_callback = false;

            var load_setup = function(callback) {
                if (loading) return false;
                if (callback) load_callback = callback;
                else load_callback = false;

                loading = true;
                frames = [];
                clear();
                disposalRestoreFromIdx = null;
                lastDisposalMethod = null;
                frame = null;
                lastImg = null;

                return true;
            };

            var calculateDuration = function() {
                return frames.reduce(function(duration, frame) {
                    return duration + frame.delay;
                }, 0);
            };

            return {
                // play controls
                play: player.play,
                pause: player.pause,
                move_relative: player.move_relative,
                move_to: player.move_to,

                // getters for instance vars
                get_playing      : function() { return playing },
                get_canvas       : function() { return canvas },
                get_canvas_scale : function() { return get_canvas_scale() },
                get_loading      : function() { return loading },
                get_auto_play    : function() { return options.auto_play },
                get_length       : function() { return player.length() },
                get_frames       : function() { return frames },
                get_duration     : function() { return calculateDuration() },
                get_duration_ms  : function() { return calculateDuration() * 10 },
                get_current_frame: function() { return player.current_frame() },
                load_url: function(src,callback){
                    if (!load_setup(callback)) return;

                    var h = new XMLHttpRequest();
                    // new browsers (XMLHttpRequest2-compliant)
                    h.open('GET', src, true);

                    if ('overrideMimeType' in h) {
                        h.overrideMimeType('text/plain; charset=x-user-defined');
                    }

                    // old browsers (XMLHttpRequest-compliant)
                    else if ('responseType' in h) {
                        h.responseType = 'arraybuffer';
                    }

                    // IE9 (Microsoft.XMLHTTP-compliant)
                    else {
                        h.setRequestHeader('Accept-Charset', 'x-user-defined');
                    }

                    h.onloadstart = function() {
                        // Wait until connection is opened to replace the gif element with a canvas to avoid a blank img
                        if (!initialized) init();
                    };
                    h.onload = function(e) {
                        if (this.status != 200) {
                            doLoadError('xhr - response');
                        }
                        // emulating response field for IE9
                        if (!('response' in this)) {
                            this.response = new VBArray(this.responseText).toArray().map(String.fromCharCode).join('');
                        }
                        var data = this.response;
                        if (data.toString().indexOf("ArrayBuffer") > 0) {
                            data = new Uint8Array(data);
                        }

                        stream = new Stream(data);
                        setTimeout(doParse, 0);
                    };
                    h.onprogress = function (e) {
                        if (e.lengthComputable) doShowProgress(e.loaded, e.total, true);
                    };
                    h.onerror = function() { doLoadError('xhr'); };
                    h.send();
                },
                load: function (callback) {
                    this.load_url(gif.getAttribute('rel:animated_src') || gif.src,callback);
                },
                load_raw: function(arr, callback) {
                    if (!load_setup(callback)) return;
                    if (!initialized) init();
                    stream = new Stream(arr);
                    setTimeout(doParse, 0);
                },
                set_frame_offset: setFrameOffset
            };
        };

        return SuperGif;
    }));
    });

    function GifBillboard(options){
        this._canvas = undefined;
        this._options = options;
        var that = this;
        var url = options.url;
        this._billboards = new Cesium.BillboardCollection();
        this._billboard = this._billboards.add({
            position : new Cesium.Cartesian3(0.0, 0.0, 0.0),
            disableDepthTestDistance: Number.POSITIVE_INFINITY
        });

        var div = document.createElement('div');
        var img = document.createElement('img');
        img.setAttribute('rel:animated_src', url);
        img.setAttribute('rel:auto_play', '1');
        div.appendChild(img);
        var rub = new libgif({ gif: img });
        rub.load_url(url,function(){
            that._canvas = rub.get_canvas();
            that._billboard.setImage('1',that._canvas);
        });
        this._div = div;
        this._gif = rub;
        this._currentFrame = 0;
        this._created = false;
    }
    Object.defineProperties(GifBillboard.prototype, {
        canvas: {
            get: function () {
                return this._canvas;
            },
        },
        billboard: {
            get: function () {
                return this._billboard;
            },
        },
        billboards: {
            get: function () {
                return this._billboards;
            },
        }
    });

    GifBillboard.prototype.update = function (frameState) {
        if(!Cesium.defined(this._canvas)){
            return;
        }


        if(frameState.passes.render){
            this._billboards.update(frameState);
        }

        if(this._currentFrame !== this._gif.get_current_frame()){
            this._currentFrame = this._gif.get_current_frame();
            this._billboards.textureAtlas.texture.copyFrom(this._canvas);
        }
    };

    function GifPrimitive(options){
        this._canvas = undefined;

        var that = this;
        var url = options.url;
        var div = document.createElement('div');
        var img = document.createElement('img');
        img.setAttribute('rel:animated_src', url);
        img.setAttribute('rel:auto_play', '1');
        div.appendChild(img);
        var rub = new libgif({ gif: img });
        rub.load_url(url,function(){
            that._canvas = rub.get_canvas();
        });
        this._div = div;
        this._gif = rub;
        this._currentFrame = 0;
        this._options = options;
        var fs = "czm_material czm_getMaterial(czm_materialInput materialInput) { \n" +
          "    czm_material material = czm_getDefaultMaterial(materialInput); \n" +
          "    vec2 st = materialInput.st; \n" +
          "    vec4 color = texture2D(image, st); \n" +
          "    color = czm_gammaCorrect(color); \n" +
          "    material.diffuse = color.rgb; \n" +
          "    material.alpha = color.a; \n" +
          "    material.shininess = 8.0; \n" + // Sharpen highlight
          "    return material; \n" +
          "} \n";
        this._fs = Cesium.defaultValue(options.fragmentShaderSource,fs);
        this._primitive = undefined;
        this._appearance = options.appearance;
        this._dirty = false;
        this._show = true;
    }

    Object.defineProperties(GifPrimitive.prototype, {
        canvas: {
            get: function () {
                return this._canvas;
            },
        },
        appearance: {
            get: function () {
                return this._appearance;
            },
        },
        show: {
            get: function () {
                return this._show;
            },
            set: function (value) {
                this._show = value;
            }
        }
    });

    GifPrimitive.prototype.updateGeometry = function (options) {
        this._options = options;
        this._dirty = true;
    };

    GifPrimitive.prototype.update = function (frameState) {
        if(!Cesium.defined(this._canvas) || !this._show){
            return;
        }

        if(this._dirty || !Cesium.defined(this._primitive)){
            this._dirty = false;
            this._primitive = new Cesium.Primitive(this._options);
            this._primitive.appearance = this._appearance;
        }

        if(!Cesium.defined(this._texture)){
            this._createTexture(frameState.context);
        }

        if(frameState.passes.render){
            this._primitive.update(frameState);
        }

        if(this._currentFrame !== this._gif.get_current_frame()){
            this._currentFrame = this._gif.get_current_frame();
            this._texture.copyFrom(this._canvas);
        }
    };

    GifPrimitive.prototype._createTexture = function (context) {
        var sampler = new Cesium.Sampler({
            wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
            wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
            minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
            magnificationFilter: Cesium.TextureMagnificationFilter.LINEAR
        });

        this._texture = new Cesium.Texture({
            context: context,
            source: this._canvas,
            sampler: sampler,
        });

        var _uniforms = {
            image: this._texture,
        };
        
        if(Cesium.defined(this._options.uniforms)){
            Object.assign(_uniforms,this._options.uniforms);
        }

        this._appearance.material = new Cesium.Material({
            fabric: {
                uniforms: _uniforms,
                source: this._fs
            },
        });
    };

    GifPrimitive.prototype.isDestroyed = function () {
        return false;
    };

    GifPrimitive.prototype.destroy = function() {
        this._primitive = this._primitive && this._primitive.destroy();
        this._texture = this._texture && this._texture.destroy();
        this._div.remove();
        if(Cesium.defined(this._canvas)){
            this._canvas.remove();
        }
        this._canvas = this._div = undefined;
        return Cesium.destroyObject(this);
    };

    function GifPolyline(options){
        this._options = options;
        this._primitive = undefined;
        this._dirty = true;
        this._appearance = new Cesium.PolylineMaterialAppearance();
    }

    Object.defineProperties(GifPolyline.prototype, {
        show: {
            get: function () {
                return this._primitive || this._primitive.show;
            },
            set: function (value) {
                if(Cesium.defined(this._primitive)) {
                    this._primitive.show = value;
                }
            }
        },
    });

    GifPolyline.prototype.updateGeometry = function (options) {
        if(Cesium.defined(options.width)){
            this._options.width = options.width;
            this._dirty = true;
        }
        if(Cesium.defined(options.positions)){
            this._options.positions = options.positions;
            this._dirty = true;
        }
    };

    GifPolyline.prototype.update = function (frameState) {
        if(this._dirty){
            this._dirty = false;

            var geometry = new Cesium.PolylineGeometry({
                positions : this._options.positions,
                width : this._options.width,
                vertexFormat : Cesium.PolylineMaterialAppearance.POSITION_AND_ST
            });
            
            var geometryInstances = [];
            geometryInstances.push(new Cesium.GeometryInstance({
              geometry: geometry
            }));
            
            var options = {
                geometryInstances: geometryInstances
            };

            if(Cesium.defined(this._primitive)){
                this._primitive.updateGeometry(options);
            } else {
                options.url = this._options.url;
                this._primitive = new GifPrimitive(Object.assign(this._options,options));
            }
        }

        this._primitive.update(frameState);
    };


    GifPolyline.prototype.isDestroyed = function () {
        return false;
    };

    GifPolyline.prototype.destroy = function() {
        this._primitive = this._primitive && this._primitive.destroy();
        return Cesium.destroyObject(this);
    };

    var VERSION = '1.8.44';

    exports.ApngPrimitive = ApngPrimitive;
    exports.CanvasPrimitive = CanvasPrimitive;
    exports.CesiumNavigation = CesiumNavigation;
    exports.CloudImageryLayer = CloudImageryLayer;
    exports.CommonLayers = CommonLayers;
    exports.CommonPickHandler = CommonPickHandler;
    exports.Config = Config;
    exports.CoordTransfer = CoordTransfer;
    exports.CustomImageryProvider = CustomImageryProvider;
    exports.CustomPrimitive = CustomPrimitive;
    exports.DataProcess = DataProcess;
    exports.DetectiveLineLayer = DetectiveLineLayer;
    exports.Directory = Directory;
    exports.DistanceLegendViewModel = DistanceLegendViewModel;
    exports.DrawLineHandler = DrawLineHandler;
    exports.DrawPolygonalLineHandler = DrawPolygonalLineHandler;
    exports.DrawRectHandler = DrawRectHandler;
    exports.EarthPin = EarthPin;
    exports.EarthPinCollection = EarthPinCollection;
    exports.EditableCircle = EditableCircle;
    exports.EditableHandler = EditableHandler;
    exports.EditablePoint = EditablePoint;
    exports.FlyHandler = FlyHandler;
    exports.FrameListener = FrameListener;
    exports.FrameListenerManager = FrameListenerManager;
    exports.GeoTerrainProvider = GeoTerrainProvider;
    exports.GifBillboard = GifBillboard;
    exports.GifPolyline = GifPolyline;
    exports.GifPrimitive = GifPrimitive;
    exports.HandlerManager = HandlerManager;
    exports.HeatMapLayer = HeatMapLayer;
    exports.InternalHandler = InternalHandler;
    exports.KmlDataSource = KmlDataSource;
    exports.KnockoutHammerBinding = KnockoutHammerBinding;
    exports.KnockoutMarkdownBinding = KnockoutMarkdownBinding;
    exports.KrigingLayer = KrigingLayer;
    exports.LayerManager = LayerManager;
    exports.MapBoxWind = MapBoxWind;
    exports.Material = Material;
    exports.MousePicker = MousePicker;
    exports.NavigationControl = NavigationControl;
    exports.NavigationViewModel = NavigationViewModel;
    exports.Overlay = Overlay;
    exports.ParticleSystem = ParticleSystem;
    exports.ParticlesComputing = ParticlesComputing;
    exports.ParticlesRendering = ParticlesRendering;
    exports.PipeLayer = PipeLayer;
    exports.PntsPrimitiveCollection = PntsPrimitiveCollection;
    exports.PointDataSource = PointDataSource;
    exports.PointLayer = PointLayer;
    exports.Popup = Popup;
    exports.ProcessTileFeatures = ProcessTileFeatures;
    exports.ResetViewNavigationControl = ResetViewNavigationControl;
    exports.Sampler = Sampler;
    exports.SimpleDrawFrustum = SimpleDrawFrustum;
    exports.SimpleDrawPrimitive = SimpleDrawPrimitive;
    exports.Texture = Texture;
    exports.ThunderLayer = ThunderLayer;
    exports.TimeSampleArray = TimeSampleArray;
    exports.TimeSystem = TimeSystem;
    exports.Tooltip = Tooltip;
    exports.Travel360 = Travel360;
    exports.TyphoonLayer = TyphoonLayer;
    exports.UserInterfaceControl = UserInterfaceControl;
    exports.Util = Util;
    exports.Utils = Utils;
    exports.VERSION = VERSION;
    exports.ViewPoint = ViewPoint;
    exports.ViewportQuad = ViewportQuad;
    exports.VolumeImageryLayer = VolumeImageryLayer;
    exports.We = We;
    exports.WeatherAxes = WeatherAxes;
    exports.WeatherData = WeatherData;
    exports.WeatherLengthWay = WeatherLengthWay;
    exports.WeatherLengthWayInEcharts = WeatherLengthWayInEcharts;
    exports.WeatherLengthWayXYZ = WeatherLengthWayXYZ;
    exports.WeatherSystem = WeatherSystem;
    exports.WeatherVolume = WeatherVolume;
    exports.WeatherVolumeAxes = WeatherVolumeAxes;
    exports.WeatherVolumeAxesWall = WeatherVolumeAxesWall;
    exports.WeatherVolumeAxesWall_depracate = WeatherVolumeAxesWall$1;
    exports.WeatherVolumeBox = WeatherVolumeBox;
    exports.WeatherVolumeClipHandler = WeatherVolumeClipHandler;
    exports.WeatherVolumeCone = WeatherVolumeCone;
    exports.WeatherVolumeConeGeometry = WeatherVolumeConeGeometry;
    exports.WeatherVolumeConeGeometryLibrary = WeatherVolumeConeGeometryLibrary;
    exports.WeatherVolumeGrid = WeatherVolumeGrid;
    exports.WeatherVolumeGrid_depracate = WeatherVolumeGrid$1;
    exports.WeatherVolumeHierarchy = WeatherVolumeHierarchy;
    exports.WeatherVolumeInner = WeatherVolumeInner;
    exports.WeatherVolumeLibrary = WeatherVolumeLibrary;
    exports.WeatherVolumeManager = WeatherVolumeManager;
    exports.WeatherVolumePickHandler = WeatherVolumePickHandler;
    exports.WeatherVolumeRectangle = WeatherVolumeRectangle;
    exports.WeatherVolumeSchedule = WeatherVolumeSchedule;
    exports.WeatherVolumeState = WeatherVolumeState;
    exports.WeatherVolumeStateMVVM = WeatherVolumeStateMVVM;
    exports.WeatherVolumeSurface = WeatherVolumeSurface;
    exports.WeatherVolumeTransfunctions = WeatherVolumeTransfunctions;
    exports.WeatherVolumeWall = WeatherVolumeWall;
    exports.WeatherVolumeWallAxisGeometry = WeatherVolumeWallAxisGeometry;
    exports.WebGLGlobeDataSource = WebGLGlobeDataSource;
    exports.WindImageryLayer = WindImageryLayer;
    exports.Windy = Windy;
    exports.ZoomNavigationControl = ZoomNavigationControl;
    exports._shadersVolumeBoxFS = VolumeBoxFS;
    exports._shadersVolumeBoxVS = VolumeBoxVS;
    exports._shadersVolumeConeMaterial = VolumeConeMaterial;
    exports._shadersVolumeConeScanMaterial = VolumeConeScanMaterial;
    exports._shadersVolumeConeScanVS = VolumeConeScanVS;
    exports._shadersVolumeConeVS = VolumeConeVS;
    exports._shadersVolumeSurfaceMaterial = VolumeSurfaceMaterial;
    exports._shadersVolumeWallMaterial = VolumeWallMaterial;
    exports._shadersdraw_frag = drawFS;
    exports._shadersdraw_vert = drawVS;
    exports._shadersfullscreen = fullscreenVS;
    exports._shadersgetWind = getWindFS;
    exports._shaderspostProcessingPosition = postProcessingPositionFS;
    exports._shaderspostProcessingSpeed = postProcessingSpeedFS;
    exports._shadersquad_vert = quad_vert;
    exports._shadersscreenDraw = screenDrawFS;
    exports._shadersscreen_frag = screen_frag;
    exports._shaderssegmentDrawFS = segmentDrawFS;
    exports._shaderssegmentDrawVS = segmentDrawVS;
    exports._shaderstrailDraw = trailDrawFS;
    exports._shadersupdatePosition = updatePositionFS;
    exports._shadersupdateSpeed = updateSpeedFS;
    exports._shadersupdate_frag = update_frag;
    exports.createFragmentFromTemplate = createFragmentFromTemplate;
    exports.loadView = loadView;
    exports.registerKnockoutBindings = registerKnockoutBindings;
    exports.svgCompassGyro = svgCompassGyro;
    exports.svgCompassOuterRing = svgCompassOuterRing;
    exports.svgCompassRotationMarker = svgCompassRotationMarker;
    exports.svgReset = svgReset;
    exports.viewerCesiumNavigationMixin = viewerCesiumNavigationMixin;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
